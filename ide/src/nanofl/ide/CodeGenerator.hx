package nanofl.ide;

import haxe.io.Path;
import nanofl.engine.elements.Element;
import nanofl.engine.elements.Instance;
import nanofl.engine.elements.TextElement;
import nanofl.ide.libraryitems.IIdeInstancableItem;
import nanofl.ide.libraryitems.MovieClipItem;
import nanofl.ide.library.IdeLibrary;
import nanofl.ide.libraryitems.SoundItem;
import nanofl.ide.sys.Folders;
import nanofl.ide.sys.FileSystem;
using stdlib.Lambda;
using stdlib.StringTools;

@:rtti
class CodeGenerator extends InjectContainer
{
	@inject var fileSystem : FileSystem;
	@inject var folders : Folders;

    var library : IdeLibrary;

    function new(library:IdeLibrary)
    {
        super();
        this.library = library;
    }
	
	public static function generate(library:IdeLibrary, destTsFilePath:String)
	{
        new CodeGenerator(library).generateInner(destTsFilePath);
    }

	function generateInner(destTsFilePath:String)
	{
        var instancableItems = library.getInstancableItemsAsIde().filter(x -> x.linkedClass != "");
        
		fileSystem.createDirectory(Path.directory(destTsFilePath));
        fileSystem.saveContent
        (
            destTsFilePath,
            "// This file is autogenerated by NanoFL\n\n"
            + "/// <reference types='nanofl-ts' />\n\n"
            + "export namespace base\n"
            + "{\n"
            + instancableItems.map(x -> getMovieClipClass(x)).join("\n")
            + "}\n\n"
            + getSoundsClass(library.getSoundsAsIde())
        );
	}
	
	function getMovieClipClass(item:IIdeInstancableItem) : String
	{
        var klass = splitFullClassName(item.linkedClass);
        
        var text = "";
        if (klass.pack != "") text += "declare namespace " + klass.pack + " {\n";
        text += "\texport class " + klass.name + " extends " + item.getDisplayObjectClassName() + "\n";
        text += "\t{\n";
        text += "\t\tconstructor() {\n";
        text += "\t\t\tsuper(nanofl.Player.library.getItem(\"" + item.namePath + "\"));\n";
        text += "\t\t}\n";
        text += getInstanceChildByNameClassDeclaration(item);
        text += "\t}\n";

        // var classFile = baseDir + "/src/" + item.linkedClass.replace(".", "/") + ".hx";
        // if (!fileSystem.exists(classFile))
        // {
        //     fileSystem.saveContent
        //     (
        //         classFile,
        //         (klass.pack != "" ? "package " + klass.pack + ";\n\n" : "") +
        //         movieClipTemplate
        //             .replace("{className}", klass.name)
        //             .replace("{baseClassName}", "base." + item.linkedClass)
        //     );
        // }

        return text;
	}
	
	function getInstanceChildByNameClassDeclaration(item:IIdeInstancableItem) : String
	{
        var r = "";

		if (Std.isOfType(item, MovieClipItem))
		{
            for (element in MovieClipItemTools.getElements((cast item : MovieClipItem)))
            {
                var k = getNamedElementClass(element);
                if (k != null)
                {
                    r += "\t\tget " + k.name + "() { return this.getChildByName(\"" + k.name + "\") as " + k.klass + " }\n";
                }
            }
		}
		
		return r;
	}
	
	function getNamedElementClass(element:Element) : { name:String, klass:String }
	{
		if (Std.isOfType(element, TextElement))
		{
			var elem : TextElement = cast element;
			if (!elem.name.isNullOrEmpty())
			{
				return { name:elem.name, klass:"nanofl.TextField" };
			}
		}
		else
		if (Std.isOfType(element, Instance))
		{
			var elem : Instance = cast element;
			if (!elem.name.isNullOrEmpty())
			{
				if (elem.symbol.linkedClass.isNullOrEmpty())
				{
					return { name:elem.name, klass:elem.symbol.getDisplayObjectClassName() };
				}
				
				return { name:elem.name, klass:elem.symbol.linkedClass };
			}
		}
		
		return null;
	}
	
	function getSoundsClass(sounds:Array<SoundItem>) : String
	{
        sounds = sounds.filter(x -> !StringTools.isNullOrEmpty(x.linkage));

		var text = "";
		text += "export class Sounds\n";
		text += "{\n";
		
		for (sound in sounds)
		{
			text += "\tstatic " + sound.linkage + "(?options:createjs.SoundOptions) : createjs.AbstractSoundInstance { return createjs.Sound.play(\"" + sound.linkage + "\", options) }\n";
		}
		
		text += "}\n";

		return text;
	}
	
	function splitFullClassName(fullClassName:String) : { pack:String, name:String }
	{
		var n = fullClassName.lastIndexOf(".");
		return
		{
			pack: n >= 0 ? fullClassName.substring(0, n) : "",
			name: n >= 0 ? fullClassName.substring(n + 1) : fullClassName
		};
	}
	
	static function log(v:Dynamic, ?infos:haxe.PosInfos)
	{
		//trace(Reflect.isFunction(v) ? v() : v, infos);
	}
}
