window.THREE = window.THREE || {};
window.THREE_addons_GLTFLoader = window.THREE_addons_GLTFLoader || {};

/******/ (() => { // webpackBootstrap
/******/ 	var __webpack_modules__ = ({

/***/ 792:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

// Generated by Haxe 4.3.3
(function ($hx_exports, $global) { "use strict";
$hx_exports["nanofl"] = $hx_exports["nanofl"] || {};
$hx_exports["nanofl"]["engine"] = $hx_exports["nanofl"]["engine"] || {};
$hx_exports["nanofl"]["engine"]["plugins"] = $hx_exports["nanofl"]["engine"]["plugins"] || {};
var $estr = function() { return js_Boot.__string_rec(this,''); },$hxEnums = $hxEnums || {},$_;
class EReg {
	constructor(r,opt) {
		this.r = new RegExp(r,opt.split("u").join(""));
	}
	match(s) {
		if(this.r.global) {
			this.r.lastIndex = 0;
		}
		this.r.m = this.r.exec(s);
		this.r.s = s;
		return this.r.m != null;
	}
	matched(n) {
		if(this.r.m != null && n >= 0 && n < this.r.m.length) {
			return this.r.m[n];
		} else {
			throw haxe_Exception.thrown("EReg::matched");
		}
	}
	matchedPos() {
		if(this.r.m == null) {
			throw haxe_Exception.thrown("No string matched");
		}
		return { pos : this.r.m.index, len : this.r.m[0].length};
	}
	matchSub(s,pos,len) {
		if(len == null) {
			len = -1;
		}
		if(this.r.global) {
			this.r.lastIndex = pos;
			this.r.m = this.r.exec(len < 0 ? s : HxOverrides.substr(s,0,pos + len));
			let b = this.r.m != null;
			if(b) {
				this.r.s = s;
			}
			return b;
		} else {
			let b = this.match(len < 0 ? HxOverrides.substr(s,pos,null) : HxOverrides.substr(s,pos,len));
			if(b) {
				this.r.s = s;
				this.r.m.index += pos;
			}
			return b;
		}
	}
}
EReg.__name__ = "EReg";
Object.assign(EReg.prototype, {
	__class__: EReg
});
class HxOverrides {
	static cca(s,index) {
		let x = s.charCodeAt(index);
		if(x != x) {
			return undefined;
		}
		return x;
	}
	static substr(s,pos,len) {
		if(len == null) {
			len = s.length;
		} else if(len < 0) {
			if(pos == 0) {
				len = s.length + len;
			} else {
				return "";
			}
		}
		return s.substr(pos,len);
	}
	static remove(a,obj) {
		let i = a.indexOf(obj);
		if(i == -1) {
			return false;
		}
		a.splice(i,1);
		return true;
	}
	static now() {
		return Date.now();
	}
}
HxOverrides.__name__ = "HxOverrides";
class Lambda {
	static array(it) {
		let a = [];
		let i = $getIterator(it);
		while(i.hasNext()) {
			let i1 = i.next();
			a.push(i1);
		}
		return a;
	}
	static exists(it,f) {
		let x = $getIterator(it);
		while(x.hasNext()) {
			let x1 = x.next();
			if(f(x1)) {
				return true;
			}
		}
		return false;
	}
	static foreach(it,f) {
		let x = $getIterator(it);
		while(x.hasNext()) {
			let x1 = x.next();
			if(!f(x1)) {
				return false;
			}
		}
		return true;
	}
}
Lambda.__name__ = "Lambda";
Math.__name__ = "Math";
class Reflect {
	static field(o,field) {
		try {
			return o[field];
		} catch( _g ) {
			return null;
		}
	}
	static fields(o) {
		let a = [];
		if(o != null) {
			let hasOwnProperty = Object.prototype.hasOwnProperty;
			for( var f in o ) {
			if(f != "__id__" && f != "hx__closures__" && hasOwnProperty.call(o,f)) {
				a.push(f);
			}
			}
		}
		return a;
	}
	static isFunction(f) {
		if(typeof(f) == "function") {
			return !(f.__name__ || f.__ename__);
		} else {
			return false;
		}
	}
	static compare(a,b) {
		if(a == b) {
			return 0;
		} else if(a > b) {
			return 1;
		} else {
			return -1;
		}
	}
	static deleteField(o,field) {
		if(!Object.prototype.hasOwnProperty.call(o,field)) {
			return false;
		}
		delete(o[field]);
		return true;
	}
	static copy(o) {
		if(o == null) {
			return null;
		}
		let o2 = { };
		let _g = 0;
		let _g1 = Reflect.fields(o);
		while(_g < _g1.length) {
			let f = _g1[_g];
			++_g;
			o2[f] = Reflect.field(o,f);
		}
		return o2;
	}
}
Reflect.__name__ = "Reflect";
class Std {
	static string(s) {
		return js_Boot.__string_rec(s,"");
	}
	static parseInt(x) {
		let v = parseInt(x);
		if(isNaN(v)) {
			return null;
		}
		return v;
	}
}
Std.__name__ = "Std";
class StringBuf {
	constructor() {
		this.b = "";
	}
}
StringBuf.__name__ = "StringBuf";
Object.assign(StringBuf.prototype, {
	__class__: StringBuf
});
class StringTools {
	static isSpace(s,pos) {
		let c = HxOverrides.cca(s,pos);
		if(!(c > 8 && c < 14)) {
			return c == 32;
		} else {
			return true;
		}
	}
	static ltrim(s) {
		let l = s.length;
		let r = 0;
		while(r < l && StringTools.isSpace(s,r)) ++r;
		if(r > 0) {
			return HxOverrides.substr(s,r,l - r);
		} else {
			return s;
		}
	}
	static rtrim(s) {
		let l = s.length;
		let r = 0;
		while(r < l && StringTools.isSpace(s,l - r - 1)) ++r;
		if(r > 0) {
			return HxOverrides.substr(s,0,l - r);
		} else {
			return s;
		}
	}
	static trim(s) {
		return StringTools.ltrim(StringTools.rtrim(s));
	}
	static rpad(s,c,l) {
		if(c.length <= 0) {
			return s;
		}
		let buf_b = "";
		buf_b += s == null ? "null" : "" + s;
		while(buf_b.length < l) buf_b += c == null ? "null" : "" + c;
		return buf_b;
	}
	static replace(s,sub,by) {
		return s.split(sub).join(by);
	}
	static hex(n,digits) {
		let s = "";
		let hexChars = "0123456789ABCDEF";
		do {
			s = hexChars.charAt(n & 15) + s;
			n >>>= 4;
		} while(n > 0);
		if(digits != null) {
			while(s.length < digits) s = "0" + s;
		}
		return s;
	}
}
StringTools.__name__ = "StringTools";
var ValueType = $hxEnums["ValueType"] = { __ename__:"ValueType",__constructs__:null
	,TNull: {_hx_name:"TNull",_hx_index:0,__enum__:"ValueType",toString:$estr}
	,TInt: {_hx_name:"TInt",_hx_index:1,__enum__:"ValueType",toString:$estr}
	,TFloat: {_hx_name:"TFloat",_hx_index:2,__enum__:"ValueType",toString:$estr}
	,TBool: {_hx_name:"TBool",_hx_index:3,__enum__:"ValueType",toString:$estr}
	,TObject: {_hx_name:"TObject",_hx_index:4,__enum__:"ValueType",toString:$estr}
	,TFunction: {_hx_name:"TFunction",_hx_index:5,__enum__:"ValueType",toString:$estr}
	,TClass: ($_=function(c) { return {_hx_index:6,c:c,__enum__:"ValueType",toString:$estr}; },$_._hx_name="TClass",$_.__params__ = ["c"],$_)
	,TEnum: ($_=function(e) { return {_hx_index:7,e:e,__enum__:"ValueType",toString:$estr}; },$_._hx_name="TEnum",$_.__params__ = ["e"],$_)
	,TUnknown: {_hx_name:"TUnknown",_hx_index:8,__enum__:"ValueType",toString:$estr}
};
ValueType.__constructs__ = [ValueType.TNull,ValueType.TInt,ValueType.TFloat,ValueType.TBool,ValueType.TObject,ValueType.TFunction,ValueType.TClass,ValueType.TEnum,ValueType.TUnknown];
class Type {
	static createEnum(e,constr,params) {
		let f = Reflect.field(e,constr);
		if(f == null) {
			throw haxe_Exception.thrown("No such constructor " + constr);
		}
		if(Reflect.isFunction(f)) {
			if(params == null) {
				throw haxe_Exception.thrown("Constructor " + constr + " need parameters");
			}
			return f.apply(e,params);
		}
		if(params != null && params.length != 0) {
			throw haxe_Exception.thrown("Constructor " + constr + " does not need parameters");
		}
		return f;
	}
	static typeof(v) {
		switch(typeof(v)) {
		case "boolean":
			return ValueType.TBool;
		case "function":
			if(v.__name__ || v.__ename__) {
				return ValueType.TObject;
			}
			return ValueType.TFunction;
		case "number":
			if(Math.ceil(v) == v % 2147483648.0) {
				return ValueType.TInt;
			}
			return ValueType.TFloat;
		case "object":
			if(v == null) {
				return ValueType.TNull;
			}
			let e = v.__enum__;
			if(e != null) {
				return ValueType.TEnum($hxEnums[e]);
			}
			let c = js_Boot.getClass(v);
			if(c != null) {
				return ValueType.TClass(c);
			}
			return ValueType.TObject;
		case "string":
			return ValueType.TClass(String);
		case "undefined":
			return ValueType.TNull;
		default:
			return ValueType.TUnknown;
		}
	}
	static enumParameters(e) {
		let enm = $hxEnums[e.__enum__];
		let params = enm.__constructs__[e._hx_index].__params__;
		if(params != null) {
			let _g = [];
			let _g1 = 0;
			while(_g1 < params.length) {
				let p = params[_g1];
				++_g1;
				_g.push(e[p]);
			}
			return _g;
		} else {
			return [];
		}
	}
}
Type.__name__ = "Type";
class datatools_ArrayRO {
	static filterByType(this1,klass) {
		let _g = [];
		let _g1 = 0;
		let _g2 = this1;
		while(_g1 < _g2.length) {
			let v = _g2[_g1];
			++_g1;
			if(js_Boot.__instanceof(v,klass)) {
				_g.push(v);
			}
		}
		return _g;
	}
}
class datatools_ArrayTools {
	static equ(a,b) {
		if(a.length != b.length) {
			return false;
		}
		let _g = 0;
		let _g1 = a.length;
		while(_g < _g1) {
			let i = _g++;
			if(a[i] == null && b[i] != null) {
				return false;
			}
			if(a[i] != null && b[i] == null) {
				return false;
			}
			if(a[i] != null && !a[i].equ(b[i])) {
				return false;
			}
		}
		return true;
	}
	static clone(array) {
		let r = [];
		let _g = 0;
		let _g1 = array;
		while(_g < _g1.length) {
			let item = _g1[_g];
			++_g;
			r.push(item.clone());
		}
		return r;
	}
	static swap(arr,i,j) {
		let z = arr[i];
		arr[i] = arr[j];
		arr[j] = z;
	}
	static equFast(a,b) {
		if(a.length != b.length) {
			return false;
		}
		let _g = 0;
		let _g1 = a.length;
		while(_g < _g1) {
			let i = _g++;
			if(a[i] != b[i]) {
				return false;
			}
		}
		return true;
	}
}
datatools_ArrayTools.__name__ = "datatools.ArrayTools";
class datatools_MapTools {
	static equFast(a,b) {
		return datatools_MapTools.equCustom(a,b,function(e1,e2) {
			return e1 == e2;
		});
	}
	static equCustom(a,b,cmp) {
		let keysA = [];
		let k = a.keys();
		while(k.hasNext()) {
			let k1 = k.next();
			keysA.push(k1);
		}
		let keysB = [];
		let k1 = b.keys();
		while(k1.hasNext()) {
			let k = k1.next();
			keysB.push(k);
		}
		if(keysA.length != keysB.length) {
			return false;
		}
		keysA.sort(Reflect.compare);
		keysB.sort(Reflect.compare);
		if(!datatools_ArrayTools.equFast(keysA,keysB)) {
			return false;
		}
		let _g = 0;
		while(_g < keysA.length) {
			let key = keysA[_g];
			++_g;
			if(!cmp(a.get(key),b.get(key))) {
				return false;
			}
		}
		return true;
	}
	static fromObject(obj) {
		let r = new haxe_ds_StringMap();
		let _g = 0;
		let _g1 = Reflect.fields(obj);
		while(_g < _g1.length) {
			let k = _g1[_g];
			++_g;
			r.h[k] = Reflect.field(obj,k);
		}
		return r;
	}
}
datatools_MapTools.__name__ = "datatools.MapTools";
class datatools_NullTools {
	static clone(v) {
		if(v != null) {
			return v.clone();
		} else {
			return null;
		}
	}
	static equ(a,b) {
		if(!(a == null && b == null)) {
			if(a != null && b != null) {
				return a.equ(b);
			} else {
				return false;
			}
		} else {
			return true;
		}
	}
}
datatools_NullTools.__name__ = "datatools.NullTools";
var haxe_StackItem = $hxEnums["haxe.StackItem"] = { __ename__:"haxe.StackItem",__constructs__:null
	,CFunction: {_hx_name:"CFunction",_hx_index:0,__enum__:"haxe.StackItem",toString:$estr}
	,Module: ($_=function(m) { return {_hx_index:1,m:m,__enum__:"haxe.StackItem",toString:$estr}; },$_._hx_name="Module",$_.__params__ = ["m"],$_)
	,FilePos: ($_=function(s,file,line,column) { return {_hx_index:2,s:s,file:file,line:line,column:column,__enum__:"haxe.StackItem",toString:$estr}; },$_._hx_name="FilePos",$_.__params__ = ["s","file","line","column"],$_)
	,Method: ($_=function(classname,method) { return {_hx_index:3,classname:classname,method:method,__enum__:"haxe.StackItem",toString:$estr}; },$_._hx_name="Method",$_.__params__ = ["classname","method"],$_)
	,LocalFunction: ($_=function(v) { return {_hx_index:4,v:v,__enum__:"haxe.StackItem",toString:$estr}; },$_._hx_name="LocalFunction",$_.__params__ = ["v"],$_)
};
haxe_StackItem.__constructs__ = [haxe_StackItem.CFunction,haxe_StackItem.Module,haxe_StackItem.FilePos,haxe_StackItem.Method,haxe_StackItem.LocalFunction];
class haxe_CallStack {
	static callStack() {
		return haxe_NativeStackTrace.toHaxe(haxe_NativeStackTrace.callStack());
	}
	static toString(stack) {
		let b = new StringBuf();
		let _g = 0;
		let _g1 = stack;
		while(_g < _g1.length) {
			let s = _g1[_g];
			++_g;
			b.b += "\nCalled from ";
			haxe_CallStack.itemToString(b,s);
		}
		return b.b;
	}
	static itemToString(b,s) {
		switch(s._hx_index) {
		case 0:
			b.b += "a C function";
			break;
		case 1:
			let m = s.m;
			b.b += "module ";
			b.b += m == null ? "null" : "" + m;
			break;
		case 2:
			let s1 = s.s;
			let file = s.file;
			let line = s.line;
			let col = s.column;
			if(s1 != null) {
				haxe_CallStack.itemToString(b,s1);
				b.b += " (";
			}
			b.b += file == null ? "null" : "" + file;
			b.b += " line ";
			b.b += line == null ? "null" : "" + line;
			if(col != null) {
				b.b += " column ";
				b.b += col == null ? "null" : "" + col;
			}
			if(s1 != null) {
				b.b += ")";
			}
			break;
		case 3:
			let cname = s.classname;
			let meth = s.method;
			b.b += Std.string(cname == null ? "<unknown>" : cname);
			b.b += ".";
			b.b += meth == null ? "null" : "" + meth;
			break;
		case 4:
			let n = s.v;
			b.b += "local function #";
			b.b += n == null ? "null" : "" + n;
			break;
		}
	}
}
class haxe_IMap {
}
haxe_IMap.__name__ = "haxe.IMap";
haxe_IMap.__isInterface__ = true;
Object.assign(haxe_IMap.prototype, {
	__class__: haxe_IMap
});
class haxe_Exception extends Error {
	constructor(message,previous,native) {
		super(message);
		this.message = message;
		this.__previousException = previous;
		this.__nativeException = native != null ? native : this;
	}
	toString() {
		return this.get_message();
	}
	get_message() {
		return this.message;
	}
	get_native() {
		return this.__nativeException;
	}
	static thrown(value) {
		if(((value) instanceof haxe_Exception)) {
			return value.get_native();
		} else if(((value) instanceof Error)) {
			return value;
		} else {
			let e = new haxe_ValueException(value);
			return e;
		}
	}
}
haxe_Exception.__name__ = "haxe.Exception";
haxe_Exception.__super__ = Error;
Object.assign(haxe_Exception.prototype, {
	__class__: haxe_Exception
});
class haxe_NativeStackTrace {
	static callStack() {
		let e = new Error("");
		let stack = haxe_NativeStackTrace.tryHaxeStack(e);
		if(typeof(stack) == "undefined") {
			try {
				throw e;
			} catch( _g ) {
			}
			stack = e.stack;
		}
		return haxe_NativeStackTrace.normalize(stack,2);
	}
	static toHaxe(s,skip) {
		if(skip == null) {
			skip = 0;
		}
		if(s == null) {
			return [];
		} else if(typeof(s) == "string") {
			let stack = s.split("\n");
			if(stack[0] == "Error") {
				stack.shift();
			}
			let m = [];
			let _g = 0;
			let _g1 = stack.length;
			while(_g < _g1) {
				let i = _g++;
				if(skip > i) {
					continue;
				}
				let line = stack[i];
				let matched = line.match(/^    at ([$A-Za-z0-9_. ]+) \(([^)]+):([0-9]+):([0-9]+)\)$/);
				if(matched != null) {
					let path = matched[1].split(".");
					if(path[0] == "$hxClasses") {
						path.shift();
					}
					let meth = path.pop();
					let file = matched[2];
					let line = Std.parseInt(matched[3]);
					let column = Std.parseInt(matched[4]);
					m.push(haxe_StackItem.FilePos(meth == "Anonymous function" ? haxe_StackItem.LocalFunction() : meth == "Global code" ? null : haxe_StackItem.Method(path.join("."),meth),file,line,column));
				} else {
					m.push(haxe_StackItem.Module(StringTools.trim(line)));
				}
			}
			return m;
		} else if(skip > 0 && Array.isArray(s)) {
			return s.slice(skip);
		} else {
			return s;
		}
	}
	static tryHaxeStack(e) {
		if(e == null) {
			return [];
		}
		let oldValue = Error.prepareStackTrace;
		Error.prepareStackTrace = haxe_NativeStackTrace.prepareHxStackTrace;
		let stack = e.stack;
		Error.prepareStackTrace = oldValue;
		return stack;
	}
	static prepareHxStackTrace(e,callsites) {
		let stack = [];
		let _g = 0;
		while(_g < callsites.length) {
			let site = callsites[_g];
			++_g;
			if(haxe_NativeStackTrace.wrapCallSite != null) {
				site = haxe_NativeStackTrace.wrapCallSite(site);
			}
			let method = null;
			let fullName = site.getFunctionName();
			if(fullName != null) {
				let idx = fullName.lastIndexOf(".");
				if(idx >= 0) {
					let className = fullName.substring(0,idx);
					let methodName = fullName.substring(idx + 1);
					method = haxe_StackItem.Method(className,methodName);
				} else {
					method = haxe_StackItem.Method(null,fullName);
				}
			}
			let fileName = site.getFileName();
			let fileAddr = fileName == null ? -1 : fileName.indexOf("file:");
			if(haxe_NativeStackTrace.wrapCallSite != null && fileAddr > 0) {
				fileName = fileName.substring(fileAddr + 6);
			}
			stack.push(haxe_StackItem.FilePos(method,fileName,site.getLineNumber(),site.getColumnNumber()));
		}
		return stack;
	}
	static normalize(stack,skipItems) {
		if(skipItems == null) {
			skipItems = 0;
		}
		if(Array.isArray(stack) && skipItems > 0) {
			return stack.slice(skipItems);
		} else if(typeof(stack) == "string") {
			switch(stack.substring(0,6)) {
			case "Error\n":case "Error:":
				++skipItems;
				break;
			default:
			}
			return haxe_NativeStackTrace.skipLines(stack,skipItems);
		} else {
			return stack;
		}
	}
	static skipLines(stack,skip,pos) {
		if(pos == null) {
			pos = 0;
		}
		if(skip > 0) {
			pos = stack.indexOf("\n",pos);
			if(pos < 0) {
				return "";
			} else {
				return haxe_NativeStackTrace.skipLines(stack,--skip,pos + 1);
			}
		} else {
			return stack.substring(pos);
		}
	}
}
haxe_NativeStackTrace.__name__ = "haxe.NativeStackTrace";
class haxe_Serializer {
	constructor() {
		this.buf = new StringBuf();
		this.cache = [];
		this.useCache = haxe_Serializer.USE_CACHE;
		this.useEnumIndex = haxe_Serializer.USE_ENUM_INDEX;
		this.shash = new haxe_ds_StringMap();
		this.scount = 0;
	}
	serializeString(s) {
		let x = this.shash.h[s];
		if(x != null) {
			this.buf.b += "R";
			this.buf.b += x == null ? "null" : "" + x;
			return;
		}
		this.shash.h[s] = this.scount++;
		this.buf.b += "y";
		s = encodeURIComponent(s);
		this.buf.b += Std.string(s.length);
		this.buf.b += ":";
		this.buf.b += s == null ? "null" : "" + s;
	}
	serializeRef(v) {
		let vt = typeof(v);
		let _g = 0;
		let _g1 = this.cache.length;
		while(_g < _g1) {
			let i = _g++;
			let ci = this.cache[i];
			if(typeof(ci) == vt && ci == v) {
				this.buf.b += "r";
				this.buf.b += i == null ? "null" : "" + i;
				return true;
			}
		}
		this.cache.push(v);
		return false;
	}
	serializeFields(v) {
		let _g = 0;
		let _g1 = Reflect.fields(v);
		while(_g < _g1.length) {
			let f = _g1[_g];
			++_g;
			this.serializeString(f);
			this.serialize(Reflect.field(v,f));
		}
		this.buf.b += "g";
	}
	serialize(v) {
		let _g = Type.typeof(v);
		switch(_g._hx_index) {
		case 0:
			this.buf.b += "n";
			break;
		case 1:
			let v1 = v;
			if(v1 == 0) {
				this.buf.b += "z";
				return;
			}
			this.buf.b += "i";
			this.buf.b += v1 == null ? "null" : "" + v1;
			break;
		case 2:
			let v2 = v;
			if(isNaN(v2)) {
				this.buf.b += "k";
			} else if(!isFinite(v2)) {
				this.buf.b += v2 < 0 ? "m" : "p";
			} else {
				this.buf.b += "d";
				this.buf.b += v2 == null ? "null" : "" + v2;
			}
			break;
		case 3:
			this.buf.b += v ? "t" : "f";
			break;
		case 4:
			if(js_Boot.__instanceof(v,Class)) {
				let className = v.__name__;
				this.buf.b += "A";
				this.serializeString(className);
			} else if(js_Boot.__instanceof(v,Enum)) {
				this.buf.b += "B";
				this.serializeString(v.__ename__);
			} else {
				if(this.useCache && this.serializeRef(v)) {
					return;
				}
				this.buf.b += "o";
				this.serializeFields(v);
			}
			break;
		case 5:
			throw haxe_Exception.thrown("Cannot serialize function");
		case 6:
			let c = _g.c;
			if(c == String) {
				this.serializeString(v);
				return;
			}
			if(this.useCache && this.serializeRef(v)) {
				return;
			}
			switch(c) {
			case Array:
				let ucount = 0;
				this.buf.b += "a";
				let l = v["length"];
				let _g1 = 0;
				let _g2 = l;
				while(_g1 < _g2) {
					let i = _g1++;
					if(v[i] == null) {
						++ucount;
					} else {
						if(ucount > 0) {
							if(ucount == 1) {
								this.buf.b += "n";
							} else {
								this.buf.b += "u";
								this.buf.b += ucount == null ? "null" : "" + ucount;
							}
							ucount = 0;
						}
						this.serialize(v[i]);
					}
				}
				if(ucount > 0) {
					if(ucount == 1) {
						this.buf.b += "n";
					} else {
						this.buf.b += "u";
						this.buf.b += ucount == null ? "null" : "" + ucount;
					}
				}
				this.buf.b += "h";
				break;
			case Date:
				let d = v;
				this.buf.b += "v";
				this.buf.b += Std.string(d.getTime());
				break;
			case haxe_ds_IntMap:
				this.buf.b += "q";
				let v3 = v;
				let k = v3.keys();
				while(k.hasNext()) {
					let k1 = k.next();
					this.buf.b += ":";
					this.buf.b += k1 == null ? "null" : "" + k1;
					this.serialize(v3.h[k1]);
				}
				this.buf.b += "h";
				break;
			case haxe_ds_List:
				this.buf.b += "l";
				let v4 = v;
				let _g_head = v4.h;
				while(_g_head != null) {
					let val = _g_head.item;
					_g_head = _g_head.next;
					let i = val;
					this.serialize(i);
				}
				this.buf.b += "h";
				break;
			case haxe_ds_ObjectMap:
				this.buf.b += "M";
				let v5 = v;
				let k1 = v5.keys();
				while(k1.hasNext()) {
					let k = k1.next();
					let id = Reflect.field(k,"__id__");
					Reflect.deleteField(k,"__id__");
					this.serialize(k);
					k["__id__"] = id;
					this.serialize(v5.h[k.__id__]);
				}
				this.buf.b += "h";
				break;
			case haxe_ds_StringMap:
				this.buf.b += "b";
				let v6 = v;
				let h = v6.h;
				let _g_h = h;
				let _g_keys = Object.keys(h);
				let _g_length = _g_keys.length;
				let _g_current = 0;
				while(_g_current < _g_length) {
					let k = _g_keys[_g_current++];
					this.serializeString(k);
					this.serialize(v6.h[k]);
				}
				this.buf.b += "h";
				break;
			case haxe_io_Bytes:
				let v7 = v;
				this.buf.b += "s";
				this.buf.b += Std.string(Math.ceil(v7.length * 8 / 6));
				this.buf.b += ":";
				let i = 0;
				let max = v7.length - 2;
				let b64 = haxe_Serializer.BASE64_CODES;
				if(b64 == null) {
					b64 = new Array(haxe_Serializer.BASE64.length);
					let _g = 0;
					let _g1 = haxe_Serializer.BASE64.length;
					while(_g < _g1) {
						let i = _g++;
						b64[i] = HxOverrides.cca(haxe_Serializer.BASE64,i);
					}
					haxe_Serializer.BASE64_CODES = b64;
				}
				while(i < max) {
					let b1 = v7.b[i++];
					let b2 = v7.b[i++];
					let b3 = v7.b[i++];
					this.buf.b += String.fromCodePoint(b64[b1 >> 2]);
					this.buf.b += String.fromCodePoint(b64[(b1 << 4 | b2 >> 4) & 63]);
					this.buf.b += String.fromCodePoint(b64[(b2 << 2 | b3 >> 6) & 63]);
					this.buf.b += String.fromCodePoint(b64[b3 & 63]);
				}
				if(i == max) {
					let b1 = v7.b[i++];
					let b2 = v7.b[i++];
					this.buf.b += String.fromCodePoint(b64[b1 >> 2]);
					this.buf.b += String.fromCodePoint(b64[(b1 << 4 | b2 >> 4) & 63]);
					this.buf.b += String.fromCodePoint(b64[b2 << 2 & 63]);
				} else if(i == max + 1) {
					let b1 = v7.b[i++];
					this.buf.b += String.fromCodePoint(b64[b1 >> 2]);
					this.buf.b += String.fromCodePoint(b64[b1 << 4 & 63]);
				}
				break;
			default:
				if(this.useCache) {
					this.cache.pop();
				}
				if(v.hxSerialize != null) {
					this.buf.b += "C";
					this.serializeString(c.__name__);
					if(this.useCache) {
						this.cache.push(v);
					}
					v.hxSerialize(this);
					this.buf.b += "g";
				} else {
					this.buf.b += "c";
					this.serializeString(c.__name__);
					if(this.useCache) {
						this.cache.push(v);
					}
					this.serializeFields(v);
				}
			}
			break;
		case 7:
			let e = _g.e;
			if(this.useCache) {
				if(this.serializeRef(v)) {
					return;
				}
				this.cache.pop();
			}
			this.buf.b += Std.string(this.useEnumIndex ? "j" : "w");
			this.serializeString(e.__ename__);
			if(this.useEnumIndex) {
				this.buf.b += ":";
				this.buf.b += Std.string(v._hx_index);
			} else {
				let e = v;
				this.serializeString($hxEnums[e.__enum__].__constructs__[e._hx_index]._hx_name);
			}
			this.buf.b += ":";
			let params = Type.enumParameters(v);
			this.buf.b += Std.string(params.length);
			let _g3 = 0;
			while(_g3 < params.length) {
				let p = params[_g3];
				++_g3;
				this.serialize(p);
			}
			if(this.useCache) {
				this.cache.push(v);
			}
			break;
		default:
			throw haxe_Exception.thrown("Cannot serialize " + Std.string(v));
		}
	}
}
haxe_Serializer.__name__ = "haxe.Serializer";
Object.assign(haxe_Serializer.prototype, {
	__class__: haxe_Serializer
});
class haxe_Timer {
	constructor(time_ms) {
		let me = this;
		this.id = setInterval(function() {
			me.run();
		},time_ms);
	}
	stop() {
		if(this.id == null) {
			return;
		}
		clearInterval(this.id);
		this.id = null;
	}
	run() {
	}
	static delay(f,time_ms) {
		let t = new haxe_Timer(time_ms);
		t.run = function() {
			t.stop();
			f();
		};
		return t;
	}
}
haxe_Timer.__name__ = "haxe.Timer";
Object.assign(haxe_Timer.prototype, {
	__class__: haxe_Timer
});
class haxe_Unserializer {
}
haxe_Unserializer.__name__ = "haxe.Unserializer";
class haxe_ValueException extends haxe_Exception {
	constructor(value,previous,native) {
		super(String(value),previous,native);
		this.value = value;
	}
}
haxe_ValueException.__name__ = "haxe.ValueException";
haxe_ValueException.__super__ = haxe_Exception;
Object.assign(haxe_ValueException.prototype, {
	__class__: haxe_ValueException
});
class haxe_ds_IntMap {
	constructor() {
		this.h = { };
	}
	get(key) {
		return this.h[key];
	}
	keys() {
		let a = [];
		for( var key in this.h ) if(this.h.hasOwnProperty(key)) a.push(+key);
		return new haxe_iterators_ArrayIterator(a);
	}
}
haxe_ds_IntMap.__name__ = "haxe.ds.IntMap";
haxe_ds_IntMap.__interfaces__ = [haxe_IMap];
Object.assign(haxe_ds_IntMap.prototype, {
	__class__: haxe_ds_IntMap
});
class haxe_ds_List {
	constructor() {
		this.length = 0;
	}
}
haxe_ds_List.__name__ = "haxe.ds.List";
Object.assign(haxe_ds_List.prototype, {
	__class__: haxe_ds_List
});
class haxe_ds__$List_ListNode {
	constructor(item,next) {
		this.item = item;
		this.next = next;
	}
}
haxe_ds__$List_ListNode.__name__ = "haxe.ds._List.ListNode";
Object.assign(haxe_ds__$List_ListNode.prototype, {
	__class__: haxe_ds__$List_ListNode
});
class haxe_ds_ObjectMap {
	constructor() {
		this.h = { __keys__ : { }};
	}
	set(key,value) {
		let id = key.__id__;
		if(id == null) {
			id = (key.__id__ = $global.$haxeUID++);
		}
		this.h[id] = value;
		this.h.__keys__[id] = key;
	}
	get(key) {
		return this.h[key.__id__];
	}
	remove(key) {
		let id = key.__id__;
		if(this.h.__keys__[id] == null) {
			return false;
		}
		delete(this.h[id]);
		delete(this.h.__keys__[id]);
		return true;
	}
	keys() {
		let a = [];
		for( var key in this.h.__keys__ ) {
		if(this.h.hasOwnProperty(key)) {
			a.push(this.h.__keys__[key]);
		}
		}
		return new haxe_iterators_ArrayIterator(a);
	}
	iterator() {
		return { ref : this.h, it : this.keys(), hasNext : function() {
			return this.it.hasNext();
		}, next : function() {
			let i = this.it.next();
			return this.ref[i.__id__];
		}};
	}
}
haxe_ds_ObjectMap.__name__ = "haxe.ds.ObjectMap";
haxe_ds_ObjectMap.__interfaces__ = [haxe_IMap];
Object.assign(haxe_ds_ObjectMap.prototype, {
	__class__: haxe_ds_ObjectMap
});
class haxe_ds_StringMap {
	constructor() {
		this.h = Object.create(null);
	}
	get(key) {
		return this.h[key];
	}
	keys() {
		return new haxe_ds__$StringMap_StringMapKeyIterator(this.h);
	}
	iterator() {
		return new haxe_ds__$StringMap_StringMapValueIterator(this.h);
	}
}
haxe_ds_StringMap.__name__ = "haxe.ds.StringMap";
haxe_ds_StringMap.__interfaces__ = [haxe_IMap];
Object.assign(haxe_ds_StringMap.prototype, {
	__class__: haxe_ds_StringMap
});
class haxe_ds__$StringMap_StringMapKeyIterator {
	constructor(h) {
		this.h = h;
		this.keys = Object.keys(h);
		this.length = this.keys.length;
		this.current = 0;
	}
	hasNext() {
		return this.current < this.length;
	}
	next() {
		return this.keys[this.current++];
	}
}
haxe_ds__$StringMap_StringMapKeyIterator.__name__ = "haxe.ds._StringMap.StringMapKeyIterator";
Object.assign(haxe_ds__$StringMap_StringMapKeyIterator.prototype, {
	__class__: haxe_ds__$StringMap_StringMapKeyIterator
});
class haxe_ds__$StringMap_StringMapValueIterator {
	constructor(h) {
		this.h = h;
		this.keys = Object.keys(h);
		this.length = this.keys.length;
		this.current = 0;
	}
	hasNext() {
		return this.current < this.length;
	}
	next() {
		return this.h[this.keys[this.current++]];
	}
}
haxe_ds__$StringMap_StringMapValueIterator.__name__ = "haxe.ds._StringMap.StringMapValueIterator";
Object.assign(haxe_ds__$StringMap_StringMapValueIterator.prototype, {
	__class__: haxe_ds__$StringMap_StringMapValueIterator
});
class haxe_io_Bytes {
	constructor(data) {
		this.length = data.byteLength;
		this.b = new Uint8Array(data);
		this.b.bufferValue = data;
		data.hxBytes = this;
		data.bytes = this.b;
	}
}
haxe_io_Bytes.__name__ = "haxe.io.Bytes";
Object.assign(haxe_io_Bytes.prototype, {
	__class__: haxe_io_Bytes
});
class haxe_io_Path {
	constructor(path) {
		switch(path) {
		case ".":case "..":
			this.dir = path;
			this.file = "";
			return;
		}
		let c1 = path.lastIndexOf("/");
		let c2 = path.lastIndexOf("\\");
		if(c1 < c2) {
			this.dir = HxOverrides.substr(path,0,c2);
			path = HxOverrides.substr(path,c2 + 1,null);
			this.backslash = true;
		} else if(c2 < c1) {
			this.dir = HxOverrides.substr(path,0,c1);
			path = HxOverrides.substr(path,c1 + 1,null);
		} else {
			this.dir = null;
		}
		let cp = path.lastIndexOf(".");
		if(cp != -1) {
			this.ext = HxOverrides.substr(path,cp + 1,null);
			this.file = HxOverrides.substr(path,0,cp);
		} else {
			this.ext = null;
			this.file = path;
		}
	}
	toString() {
		return (this.dir == null ? "" : this.dir + (this.backslash ? "\\" : "/")) + this.file + (this.ext == null ? "" : "." + this.ext);
	}
	static withoutExtension(path) {
		let s = new haxe_io_Path(path);
		s.ext = null;
		return s.toString();
	}
	static withoutDirectory(path) {
		let s = new haxe_io_Path(path);
		s.dir = null;
		return s.toString();
	}
}
haxe_io_Path.__name__ = "haxe.io.Path";
Object.assign(haxe_io_Path.prototype, {
	__class__: haxe_io_Path
});
class haxe_iterators_ArrayIterator {
	constructor(array) {
		this.current = 0;
		this.array = array;
	}
	hasNext() {
		return this.current < this.array.length;
	}
	next() {
		return this.array[this.current++];
	}
}
haxe_iterators_ArrayIterator.__name__ = "haxe.iterators.ArrayIterator";
Object.assign(haxe_iterators_ArrayIterator.prototype, {
	__class__: haxe_iterators_ArrayIterator
});
class js_Boot {
	static getClass(o) {
		if(o == null) {
			return null;
		} else if(((o) instanceof Array)) {
			return Array;
		} else {
			let cl = o.__class__;
			if(cl != null) {
				return cl;
			}
			let name = js_Boot.__nativeClassName(o);
			if(name != null) {
				return js_Boot.__resolveNativeClass(name);
			}
			return null;
		}
	}
	static __string_rec(o,s) {
		if(o == null) {
			return "null";
		}
		if(s.length >= 5) {
			return "<...>";
		}
		let t = typeof(o);
		if(t == "function" && (o.__name__ || o.__ename__)) {
			t = "object";
		}
		switch(t) {
		case "function":
			return "<function>";
		case "object":
			if(o.__enum__) {
				let e = $hxEnums[o.__enum__];
				let con = e.__constructs__[o._hx_index];
				let n = con._hx_name;
				if(con.__params__) {
					s = s + "\t";
					return n + "(" + ((function($this) {
						var $r;
						let _g = [];
						{
							let _g1 = 0;
							let _g2 = con.__params__;
							while(true) {
								if(!(_g1 < _g2.length)) {
									break;
								}
								let p = _g2[_g1];
								_g1 = _g1 + 1;
								_g.push(js_Boot.__string_rec(o[p],s));
							}
						}
						$r = _g;
						return $r;
					}(this))).join(",") + ")";
				} else {
					return n;
				}
			}
			if(((o) instanceof Array)) {
				let str = "[";
				s += "\t";
				let _g = 0;
				let _g1 = o.length;
				while(_g < _g1) {
					let i = _g++;
					str += (i > 0 ? "," : "") + js_Boot.__string_rec(o[i],s);
				}
				str += "]";
				return str;
			}
			let tostr;
			try {
				tostr = o.toString;
			} catch( _g ) {
				return "???";
			}
			if(tostr != null && tostr != Object.toString && typeof(tostr) == "function") {
				let s2 = o.toString();
				if(s2 != "[object Object]") {
					return s2;
				}
			}
			let str = "{\n";
			s += "\t";
			let hasp = o.hasOwnProperty != null;
			let k = null;
			for( k in o ) {
			if(hasp && !o.hasOwnProperty(k)) {
				continue;
			}
			if(k == "prototype" || k == "__class__" || k == "__super__" || k == "__interfaces__" || k == "__properties__") {
				continue;
			}
			if(str.length != 2) {
				str += ", \n";
			}
			str += s + k + " : " + js_Boot.__string_rec(o[k],s);
			}
			s = s.substring(1);
			str += "\n" + s + "}";
			return str;
		case "string":
			return o;
		default:
			return String(o);
		}
	}
	static __interfLoop(cc,cl) {
		if(cc == null) {
			return false;
		}
		if(cc == cl) {
			return true;
		}
		let intf = cc.__interfaces__;
		if(intf != null && (cc.__super__ == null || cc.__super__.__interfaces__ != intf)) {
			let _g = 0;
			let _g1 = intf.length;
			while(_g < _g1) {
				let i = _g++;
				let i1 = intf[i];
				if(i1 == cl || js_Boot.__interfLoop(i1,cl)) {
					return true;
				}
			}
		}
		return js_Boot.__interfLoop(cc.__super__,cl);
	}
	static __instanceof(o,cl) {
		if(cl == null) {
			return false;
		}
		switch(cl) {
		case Array:
			return ((o) instanceof Array);
		case Bool:
			return typeof(o) == "boolean";
		case Dynamic:
			return o != null;
		case Float:
			return typeof(o) == "number";
		case Int:
			if(typeof(o) == "number") {
				return ((o | 0) === o);
			} else {
				return false;
			}
			break;
		case String:
			return typeof(o) == "string";
		default:
			if(o != null) {
				if(typeof(cl) == "function") {
					if(js_Boot.__downcastCheck(o,cl)) {
						return true;
					}
				} else if(typeof(cl) == "object" && js_Boot.__isNativeObj(cl)) {
					if(((o) instanceof cl)) {
						return true;
					}
				}
			} else {
				return false;
			}
			if(cl == Class ? o.__name__ != null : false) {
				return true;
			}
			if(cl == Enum ? o.__ename__ != null : false) {
				return true;
			}
			return o.__enum__ != null ? $hxEnums[o.__enum__] == cl : false;
		}
	}
	static __downcastCheck(o,cl) {
		if(!((o) instanceof cl)) {
			if(cl.__isInterface__) {
				return js_Boot.__interfLoop(js_Boot.getClass(o),cl);
			} else {
				return false;
			}
		} else {
			return true;
		}
	}
	static __implements(o,iface) {
		return js_Boot.__interfLoop(js_Boot.getClass(o),iface);
	}
	static __cast(o,t) {
		if(o == null || js_Boot.__instanceof(o,t)) {
			return o;
		} else {
			throw haxe_Exception.thrown("Cannot cast " + Std.string(o) + " to " + Std.string(t));
		}
	}
	static __nativeClassName(o) {
		let name = js_Boot.__toStr.call(o).slice(8,-1);
		if(name == "Object" || name == "Function" || name == "Math" || name == "JSON") {
			return null;
		}
		return name;
	}
	static __isNativeObj(o) {
		return js_Boot.__nativeClassName(o) != null;
	}
	static __resolveNativeClass(name) {
		return $global[name];
	}
}
js_Boot.__name__ = "js.Boot";
var GLTFLoader = (__webpack_require__(676).GLTFLoader);
var THREE_Color = (__webpack_require__(800).Color);
var THREE_PerspectiveCamera = (__webpack_require__(800).PerspectiveCamera);
var THREE_AmbientLight = (__webpack_require__(800).AmbientLight);
var THREE_DirectionalLight = (__webpack_require__(800).DirectionalLight);
var THREE_Euler = (__webpack_require__(800).Euler);
var THREE_Vector3 = (__webpack_require__(800).Vector3);
var THREE_Group = (__webpack_require__(800).Group);
var THREE_WebGLRenderer = (__webpack_require__(800).WebGLRenderer);
var THREE_Scene = (__webpack_require__(800).Scene);
class nanofl_IEventHandlers {
}
nanofl_IEventHandlers.__name__ = "nanofl.IEventHandlers";
nanofl_IEventHandlers.__isInterface__ = true;
class nanofl_Bitmap extends createjs.Bitmap {
	constructor(symbol) {
		super(null);
		this.symbol = symbol;
		symbol.updateDisplayObject(this,null);
	}
	clone(recursive) {
		return this._cloneProps(new nanofl_Bitmap(this.symbol));
	}
	toString() {
		return this.symbol.toString();
	}
	onEnterFrame() {
	}
	onMouseDown(e) {
	}
	onMouseMove(e) {
	}
	onMouseUp(e) {
	}
}
$hx_exports["nanofl"]["Bitmap"] = nanofl_Bitmap;
nanofl_Bitmap.__name__ = "nanofl.Bitmap";
nanofl_Bitmap.__interfaces__ = [nanofl_IEventHandlers];
nanofl_Bitmap.__super__ = createjs.Bitmap;
Object.assign(nanofl_Bitmap.prototype, {
	__class__: nanofl_Bitmap
});
class nanofl_MovieClip extends createjs.Container {
	constructor(symbol,initFrameIndex,childFrameIndexes) {
		super();
		stdlib_Debug.assert(((symbol) instanceof nanofl_engine_libraryitems_MovieClipItem),null,{ fileName : "engine/nanofl/MovieClip.hx", lineNumber : 29, className : "nanofl.MovieClip", methodName : "new"});
		this.layerOfChild = new haxe_ds_ObjectMap();
		this.symbol = symbol;
		let tmp = initFrameIndex;
		this.currentFrame = tmp != null ? tmp : 0;
		symbol.updateDisplayObject(this,childFrameIndexes);
		this.paused = !symbol.autoPlay;
		this.loop = symbol.loop;
	}
	addChildToLayer(child,layerIndex) {
		this.layerOfChild.set(child,layerIndex);
		let _g = 0;
		let _g1 = this.children.length;
		while(_g < _g1) {
			let i = _g++;
			if(this.layerOfChild.h[this.children[i].__id__] < layerIndex) {
				return this.addChildAt(child,i);
			}
		}
		return this.addChild(child);
	}
	removeAllChildren() {
		super.removeAllChildren();
		this.layerOfChild = new haxe_ds_ObjectMap();
	}
	removeChild(child) {
		this.layerOfChild.remove(child);
		return super.removeChild(child);
	}
	removeChildAt(index) {
		this.layerOfChild.remove(this.children[index]);
		return super.removeChildAt(index);
	}
	play() {
		this.paused = false;
	}
	stop() {
		this.paused = true;
	}
	gotoAndStop(labelOrIndex) {
		this.gotoFrame(labelOrIndex);
		this.stop();
	}
	gotoAndPlay(labelOrIndex) {
		this.gotoFrame(labelOrIndex);
		this.play();
	}
	getTotalFrames() {
		return this.symbol.getTotalFrames();
	}
	maskChild(child) {
		let n = this.layerOfChild.h[child.__id__];
		if(n != null) {
			let parentLayerIndex = this.symbol.get_layers()[n].parentIndex;
			if(parentLayerIndex != null && this.symbol.get_layers()[parentLayerIndex].type == nanofl_engine_LayerType.mask) {
				let mask = new createjs.Container();
				let _g = 0;
				let _g1 = this.getLayerChildren(parentLayerIndex);
				while(_g < _g1.length) {
					let obj = _g1[_g];
					++_g;
					let clonedObj = obj.clone(true);
					clonedObj.visible = true;
					nanofl_DisplayObjectTools.smartCache(clonedObj);
					mask.addChild(clonedObj);
				}
				return nanofl_MovieClip.applyMask(mask,child);
			}
		}
		return false;
	}
	uncacheChild(child) {
		child.uncache();
		if(nanofl_DisplayObjectTools.autoHitArea) {
			child.hitArea = null;
		}
		let layerIndex = this.layerOfChild.h[child.__id__];
		if(layerIndex != null && this.symbol.get_layers()[layerIndex].type == nanofl_engine_LayerType.mask) {
			let _g = 0;
			let _g1 = this.children;
			while(_g < _g1.length) {
				let c = _g1[_g];
				++_g;
				let n = this.layerOfChild.h[c.__id__];
				if(n != null && this.symbol.get_layers()[n].parentIndex == layerIndex) {
					c.uncache();
					if(nanofl_DisplayObjectTools.autoHitArea) {
						c.hitArea = null;
					}
				}
			}
		}
	}
	getLayerChildren(layerIndex) {
		let r = [];
		let _g = 0;
		let _g1 = this.children;
		while(_g < _g1.length) {
			let child = _g1[_g];
			++_g;
			if(this.layerOfChild.h[child.__id__] == layerIndex) {
				r.push(child);
			}
		}
		return r;
	}
	gotoFrame(labelOrIndex) {
		let frameIndex = this.getFrameIndexByLabel(labelOrIndex);
		if(this.currentFrame == frameIndex) {
			return null;
		}
		let movieClipChanged = false;
		let createdDisplayObjects = [];
		let keepedChildMovieClips = [];
		let _g = 0;
		let _g1 = this.symbol.get_layers().length;
		while(_g < _g1) {
			let i = _g++;
			let layerChanged = false;
			let layer = this.symbol.get_layers()[i];
			let oldFrame = layer.getFrame(this.currentFrame);
			let newFrame = layer.getFrame(frameIndex);
			if(oldFrame != null && newFrame != null && oldFrame.keyFrame == newFrame.keyFrame) {
				if(newFrame.keyFrame.hasMotionTween()) {
					let tweenedElements = layer.getTweenedElements(frameIndex);
					let layerChildren = this.getLayerChildren(i);
					stdlib_Debug.assert(tweenedElements.length == layerChildren.length,"tweenedElements.length=" + tweenedElements.length + " != layerChildren.length=" + layerChildren.length,{ fileName : "engine/nanofl/MovieClip.hx", lineNumber : 225, className : "nanofl.MovieClip", methodName : "gotoFrame"});
					let _g = 0;
					let _g1 = tweenedElements.length;
					while(_g < _g1) {
						let i = _g++;
						tweenedElements[i].current.updateDisplayObject(layerChildren[i],null);
						layerChildren[i].visible = layer.type == nanofl_engine_LayerType.normal;
						if(((tweenedElements[i].current) instanceof nanofl_MovieClip) || ((tweenedElements[i].current) instanceof createjs.Sprite)) {
							keepedChildMovieClips.push(tweenedElements[i].current);
						}
					}
					layerChanged = true;
				}
			} else if(oldFrame != null || newFrame != null) {
				if(oldFrame != null) {
					let j = 0;
					while(j < this.children.length) if(this.layerOfChild.h[this.children[j].__id__] == i) {
						this.removeChildAt(j);
					} else {
						++j;
					}
				}
				if(newFrame != null) {
					let _g = 0;
					let _g1 = layer.getTweenedElements(frameIndex);
					while(_g < _g1.length) {
						let tweenedElement = _g1[_g];
						++_g;
						let obj = tweenedElement.current.createDisplayObject(null);
						obj.visible = layer.type == nanofl_engine_LayerType.normal;
						this.addChildToLayer(obj,i);
						createdDisplayObjects.push(obj);
					}
				}
				layerChanged = true;
			}
			if(layerChanged) {
				movieClipChanged = true;
				if(layer.type == nanofl_engine_LayerType.mask) {
					let _g = 0;
					let _g1 = this.symbol.get_layers().length;
					while(_g < _g1) {
						let j = _g++;
						if(this.symbol.get_layers()[j].parentIndex == i) {
							let _g = 0;
							let _g1 = this.getLayerChildren(j);
							while(_g < _g1.length) {
								let child = _g1[_g];
								++_g;
								child.uncache();
							}
						}
					}
				}
			}
		}
		if(movieClipChanged) {
			nanofl_DisplayObjectTools.smartUncache(this);
		}
		this.currentFrame = frameIndex;
		let _g2 = 0;
		while(_g2 < createdDisplayObjects.length) {
			let obj = createdDisplayObjects[_g2];
			++_g2;
			nanofl_DisplayObjectTools.callMethod(obj,"init");
		}
		return keepedChildMovieClips;
	}
	getFrameIndexByLabel(labelOrIndex) {
		if(typeof(labelOrIndex) == "number" && ((labelOrIndex | 0) === labelOrIndex)) {
			return labelOrIndex;
		}
		let _g = 0;
		let _g1 = this.symbol.get_layers();
		while(_g < _g1.length) {
			let layer = _g1[_g];
			++_g;
			let _g2 = 0;
			let _g3 = layer._keyFrames;
			while(_g2 < _g3.length) {
				let keyFrame = _g3[_g2];
				++_g2;
				if(keyFrame.label == labelOrIndex) {
					return keyFrame.getIndex();
				}
			}
		}
		return null;
	}
	advance() {
		let childrenToAdvance = null;
		if(!this.paused) {
			let childrenToAdvance1;
			if(this.loop) {
				childrenToAdvance1 = (this.currentFrame + 1) % this.getTotalFrames();
			} else {
				let a = this.currentFrame + 1;
				let b = this.getTotalFrames() - 1;
				childrenToAdvance1 = a < b ? a : b;
			}
			childrenToAdvance = this.gotoFrame(childrenToAdvance1);
		}
		if(childrenToAdvance == null) {
			let _g = 0;
			let _g1 = this.children;
			while(_g < _g1.length) {
				let child = _g1[_g];
				++_g;
				if(((child) instanceof nanofl_MovieClip)) {
					child.advance();
				} else if(((child) instanceof createjs.Sprite)) {
					child.advance();
				}
			}
		} else {
			let _g = 0;
			while(_g < childrenToAdvance.length) {
				let child = childrenToAdvance[_g];
				++_g;
				child.advance();
			}
		}
	}
	clone(recursive) {
		return this._cloneProps(new nanofl_MovieClip(this.symbol,this.currentFrame,null));
	}
	toString() {
		return this.symbol.toString();
	}
	onEnterFrame() {
	}
	onMouseDown(e) {
	}
	onMouseMove(e) {
	}
	onMouseUp(e) {
	}
	static applyMask(mask,obj) {
		let objBounds = nanofl_DisplayObjectTools.getOuterBounds(obj);
		if(objBounds == null || objBounds.width == 0 || objBounds.height == 0) {
			return false;
		}
		mask = mask.clone(true);
		mask.transformMatrix = obj.getMatrix().invert();
		mask.visible = true;
		let maskContainer = new createjs.Container();
		maskContainer.addChild(mask);
		let maskContainerBounds = nanofl_DisplayObjectTools.getOuterBounds(maskContainer);
		if(maskContainerBounds == null || maskContainerBounds.width == 0 || maskContainerBounds.height == 0) {
			obj.visible = false;
			return false;
		}
		nanofl_DisplayObjectTools.smartCache(mask);
		if(((obj) instanceof createjs.Container)) {
			let _g = 0;
			let _g1 = obj.children;
			while(_g < _g1.length) {
				let child = _g1[_g];
				++_g;
				nanofl_DisplayObjectTools.smartCache(child);
			}
		}
		let intersection = maskContainerBounds.intersection(objBounds);
		if(intersection == null || intersection.width == 0 || intersection.height == 0) {
			obj.visible = false;
			return false;
		}
		let union = objBounds.union(intersection);
		maskContainer.cache(union.x,union.y,union.width,union.height);
		let objBounds2 = nanofl_DisplayObjectTools.getOuterBounds(obj,true);
		obj.cache(objBounds2.x,objBounds2.y,objBounds2.width,objBounds2.height);
		new createjs.AlphaMaskFilter(maskContainer.cacheCanvas).applyFilter(obj.cacheCanvas.getContext("2d",null),0,0,objBounds.width | 0,objBounds.height | 0);
		return true;
	}
}
$hx_exports["nanofl"]["MovieClip"] = nanofl_MovieClip;
nanofl_MovieClip.__name__ = "nanofl.MovieClip";
nanofl_MovieClip.__interfaces__ = [nanofl_IEventHandlers];
nanofl_MovieClip.__super__ = createjs.Container;
Object.assign(nanofl_MovieClip.prototype, {
	__class__: nanofl_MovieClip
});
class nanofl_Button extends nanofl_MovieClip {
	constructor(symbol) {
		super(symbol,0,null);
		this.stop();
		if(this.getTotalFrames() >= 4) {
			let hitSymbol = js_Boot.__cast(symbol.duplicate("__nanofl_temp") , nanofl_engine_libraryitems_MovieClipItem);
			hitSymbol.likeButton = false;
			hitSymbol.linkedClass = "";
			this.hitArea = hitSymbol.createDisplayObject(3,null);
			hitSymbol.remove();
		}
		this.cursor = "pointer";
	}
	onMouseDown(e) {
		if(this.getTotalFrames() >= 3 && this.currentFrame != 2) {
			if((this.hitArea != null ? this.hitArea : this).hitTest(e.localX,e.localY)) {
				this.gotoAndStop(2);
			}
		}
	}
	onMouseMove(e) {
		if(this.getTotalFrames() >= 2 && this.currentFrame != 2) {
			this.gotoAndStop((this.hitArea != null ? this.hitArea : this).hitTest(e.localX,e.localY) ? 1 : 0);
		}
	}
	onMouseUp(e) {
		if(this.getTotalFrames() > 0 && this.currentFrame != 0) {
			this.gotoAndStop(0);
		}
	}
}
$hx_exports["nanofl"]["Button"] = nanofl_Button;
nanofl_Button.__name__ = "nanofl.Button";
nanofl_Button.__super__ = nanofl_MovieClip;
Object.assign(nanofl_Button.prototype, {
	__class__: nanofl_Button
});
class nanofl_DisplayObjectTools {
	static smartCache(obj) {
		if(obj.visible && obj.cacheCanvas == null) {
			if(((obj) instanceof createjs.Container) && !((obj) instanceof nanofl_SolidContainer)) {
				let _g = 0;
				let _g1 = obj.children;
				while(_g < _g1.length) {
					let child = _g1[_g];
					++_g;
					nanofl_DisplayObjectTools.smartCache(child);
				}
			}
			if(obj.parent == null || !((obj.parent) instanceof nanofl_MovieClip) || !obj.parent.maskChild(obj)) {
				if(obj.filters != null && obj.filters.length > 0) {
					let bounds = nanofl_DisplayObjectTools.getInnerBounds(obj);
					if(bounds != null && bounds.width > 0 && bounds.height > 0) {
						obj.cache(bounds.x,bounds.y,bounds.width,bounds.height);
						if(nanofl_DisplayObjectTools.autoHitArea) {
							let hitArea = new createjs.Container();
							let hitBmp = new createjs.Bitmap(obj.cacheCanvas);
							hitBmp.x = obj.bitmapCache.offX + obj.bitmapCache._filterOffX;
							hitBmp.y = obj.bitmapCache.offY + obj.bitmapCache._filterOffY;
							hitArea.addChild(hitBmp);
							obj.hitArea = hitArea;
						}
					}
				}
			}
		}
	}
	static smartUncache(obj) {
		let inspiredByChild = null;
		while(obj != null) {
			obj.uncache();
			if(nanofl_DisplayObjectTools.autoHitArea) {
				obj.hitArea = null;
			}
			if(((obj) instanceof nanofl_MovieClip) && inspiredByChild != null) {
				obj.uncacheChild(inspiredByChild);
			}
			inspiredByChild = obj;
			obj = obj.parent;
		}
	}
	static getOuterBounds(obj,ignoreSelf) {
		if(ignoreSelf == null) {
			ignoreSelf = false;
		}
		let r = null;
		if(((obj) instanceof createjs.Container) && !((obj) instanceof nanofl_SolidContainer)) {
			let _g = 0;
			let _g1 = obj.children;
			while(_g < _g1.length) {
				let child = _g1[_g];
				++_g;
				let b = nanofl_engine_geom_BoundsTools.transform(nanofl_DisplayObjectTools.getOuterBounds(child),child.getMatrix());
				if(b != null) {
					if(r != null) {
						r = r.union(b);
					} else {
						r = b;
					}
				}
			}
		} else {
			r = nanofl_DisplayObjectTools.getInnerBounds(obj);
		}
		if(r == null) {
			return null;
		}
		if(!ignoreSelf && obj.filters != null) {
			let _g = 0;
			let _g1 = obj.filters;
			while(_g < _g1.length) {
				let f = _g1[_g];
				++_g;
				f.getBounds(r);
			}
		}
		return r;
	}
	static getInnerBounds(obj) {
		let r = null;
		if(((obj) instanceof createjs.Container) && !((obj) instanceof nanofl_SolidContainer)) {
			let _g = 0;
			let _g1 = obj.children;
			while(_g < _g1.length) {
				let child = _g1[_g];
				++_g;
				let b = nanofl_engine_geom_BoundsTools.transform(nanofl_DisplayObjectTools.getInnerBounds(child),child.getMatrix());
				if(b != null) {
					if(r != null) {
						r = r.union(b);
					} else {
						r = b;
					}
				}
			}
			if(r == null) {
				return null;
			}
		} else {
			if(obj.cacheCanvas == null) {
				r = obj.getBounds();
			} else {
				let savedCacheCanvas = obj.cacheCanvas;
				obj.cacheCanvas = null;
				r = obj.getBounds();
				obj.cacheCanvas = savedCacheCanvas;
			}
			if(r == null) {
				return null;
			}
			r = r.clone();
		}
		return r;
	}
	static callMethod(parent,name) {
		if(((parent) instanceof createjs.Container)) {
			let _g = 0;
			let _g1 = parent.children;
			while(_g < _g1.length) {
				let child = _g1[_g];
				++_g;
				nanofl_DisplayObjectTools.callMethod(child,name);
			}
		}
		let method = Reflect.field(parent,name);
		if(Reflect.isFunction(method)) {
			method.apply(parent,[]);
		}
	}
	static dispatchMouseEvent(parent,name,e) {
		if(((parent) instanceof createjs.Container)) {
			let children = parent.children.slice();
			children.reverse();
			let _g = 0;
			while(_g < children.length) {
				let child = children[_g];
				++_g;
				if(child.parent != null) {
					nanofl_DisplayObjectTools.dispatchMouseEvent(child,name,e);
				}
				if(e.canceled) {
					return;
				}
			}
		}
		if(parent.parent != null) {
			let method = Reflect.field(parent,name);
			if(Reflect.isFunction(method)) {
				e._target = parent;
				method.apply(parent,[e]);
			}
		}
	}
	static smartHitTest(obj,x,y,minAlpha) {
		if(minAlpha == null) {
			minAlpha = 1;
		}
		if(obj.cacheCanvas == null) {
			return obj.hitTest(x,y);
		} else {
			if(x < obj.bitmapCache.offX || y < obj.bitmapCache.offY || x > obj.bitmapCache.offX + obj.bitmapCache.width || y > obj.bitmapCache.offY + obj.bitmapCache.height) {
				return false;
			}
			x = Math.round((x - obj.bitmapCache.offX - obj.bitmapCache._filterOffX) * obj.bitmapCache.scale);
			y = Math.round((y - obj.bitmapCache.offY - obj.bitmapCache._filterOffY) * obj.bitmapCache.scale);
			let alpha = obj.cacheCanvas.getContext("2d",null).getImageData(x,y,1,1).data[3];
			return alpha >= minAlpha;
		}
	}
	static dump(obj,level) {
		if(level == null) {
			level = 0;
		}
		let s = StringTools.rpad("","\t",level);
		if(((obj) instanceof nanofl_MovieClip)) {
			s += "MovieClip(" + obj.symbol.namePath + ")";
		} else if(((obj) instanceof nanofl_Mesh)) {
			s += "Mesh(" + obj.symbol.namePath + ")";
		} else if(((obj) instanceof nanofl_TextField)) {
			s += "TextField";
		} else if(((obj) instanceof nanofl_Bitmap)) {
			s += "Bitmap(" + obj.symbol.namePath + ")";
		} else if(((obj) instanceof createjs.Container)) {
			s += "Container";
		} else if(((obj) instanceof createjs.Shape)) {
			s += "Shape";
		} else {
			s += "Unknow";
		}
		if(obj.cacheCanvas != null) {
			s += " cached";
		}
		if(obj._bounds != null) {
			s += " fixed";
		}
		s += " bounds(" + nanofl_DisplayObjectTools.rectToString(obj.getBounds()) + ")";
		s += " outers(" + nanofl_DisplayObjectTools.rectToString(nanofl_DisplayObjectTools.getOuterBounds(obj)) + ")";
		if(((obj) instanceof nanofl_TextField)) {
			s += " '" + StringTools.replace(StringTools.replace(obj.text,"\r"," "),"\n"," ") + "'";
		}
		console.log("engine/nanofl/DisplayObjectTools.hx:239:",s);
		if(((obj) instanceof createjs.Container) && !((obj) instanceof nanofl_SolidContainer)) {
			let _g = 0;
			let _g1 = obj.children;
			while(_g < _g1.length) {
				let child = _g1[_g];
				++_g;
				nanofl_DisplayObjectTools.dump(child,level + 1);
			}
		}
	}
	static rectToString(rect) {
		if(rect == null) {
			return "null";
		}
		return rect.x + "," + rect.y + " " + rect.width + " x " + rect.height;
	}
}
$hx_exports["nanofl"]["DisplayObjectTools"] = nanofl_DisplayObjectTools;
nanofl_DisplayObjectTools.__name__ = "nanofl.DisplayObjectTools";
class nanofl_SolidContainer extends createjs.Container {
	constructor() {
		super();
	}
}
nanofl_SolidContainer.__name__ = "nanofl.SolidContainer";
nanofl_SolidContainer.__super__ = createjs.Container;
Object.assign(nanofl_SolidContainer.prototype, {
	__class__: nanofl_SolidContainer
});
class nanofl_Mesh extends nanofl_SolidContainer {
	constructor(symbol) {
		super();
		this.rotationX = 0.0;
		this.rotationY = 0.0;
		this.rotationZ = 0.0;
		this.camera = new THREE_PerspectiveCamera(70,1,0,1e7);
		this.autoCamera = true;
		this.ambientLight = new THREE_AmbientLight(14737632);
		this.directionalLight = new THREE_DirectionalLight(8421504,1);
		this.symbol = symbol;
		let d = symbol.renderAreaSize >> 1;
		if(symbol.renderAreaSize % 2 != 0) {
			++d;
		}
		this.setBounds(-d,-d,d,d);
		symbol.updateDisplayObject(this,null);
	}
	clone(recursive) {
		return this._cloneProps(new nanofl_Mesh(this.symbol));
	}
	toString() {
		return this.symbol.toString();
	}
	draw(ctx,ignoreCache) {
		this.update();
		return super.draw(ctx,ignoreCache);
	}
	update() {
		this.removeAllChildren();
		let bitmap = new createjs.Bitmap(this.symbol.get_renderer().domElement);
		this.addChild(bitmap);
		bitmap.x = bitmap.y = -this.symbol.renderAreaSize / 2;
		this.group.setRotationFromEuler(new THREE_Euler(this.rotationX * nanofl_Mesh.DEG_TO_RAD,this.rotationY * nanofl_Mesh.DEG_TO_RAD,this.rotationZ * nanofl_Mesh.DEG_TO_RAD));
		this.group.updateMatrix();
		let posZ = this.symbol.boundingRadius / Math.sin(this.camera.fov / 2 * nanofl_Mesh.DEG_TO_RAD);
		if(this.directionalLight != null) {
			this.directionalLight.position.x = 0.0;
			this.directionalLight.position.y = 0.0;
			this.directionalLight.position.z = -posZ;
			this.directionalLight.position.applyEuler(new THREE_Euler(this.directionalLight.rotation.x,this.directionalLight.rotation.y));
		}
		if(this.autoCamera) {
			this.camera.position.z = -posZ;
			this.camera.lookAt(new THREE_Vector3(0,0,0));
			this.camera.near = posZ - this.symbol.boundingRadius;
			this.camera.far = posZ + this.symbol.boundingRadius;
			this.camera.updateProjectionMatrix();
			this.camera.updateMatrix();
		}
		if(this.ambientLight != null) {
			this.scene.add(this.ambientLight);
		}
		if(this.directionalLight != null) {
			this.scene.add(this.directionalLight);
		}
		this.symbol.get_renderer().render(this.scene,this.camera);
	}
	onEnterFrame() {
	}
	onMouseDown(e) {
	}
	onMouseMove(e) {
	}
	onMouseUp(e) {
	}
}
$hx_exports["nanofl"]["Mesh"] = nanofl_Mesh;
nanofl_Mesh.__name__ = "nanofl.Mesh";
nanofl_Mesh.__interfaces__ = [nanofl_IEventHandlers];
nanofl_Mesh.__super__ = nanofl_SolidContainer;
Object.assign(nanofl_Mesh.prototype, {
	__class__: nanofl_Mesh
});
class nanofl_MouseEvent {
	constructor(stageX,stageY) {
		this.canceled = false;
		let _gthis = this;
		Object.defineProperty(this,"localX",{ get : function() {
			return _gthis.get_localX();
		}});
		Object.defineProperty(this,"localY",{ get : function() {
			return _gthis.get_localY();
		}});
		this.stageX = stageX;
		this.stageY = stageY;
	}
	get_localX() {
		if(typeof(this._local) == "undefined") {
			this._local = this._target.globalToLocal(this.stageX,this.stageY);
		}
		return this._local.x;
	}
	get_localY() {
		if(typeof(this._local) == "undefined") {
			this._local = this._target.globalToLocal(this.stageX,this.stageY);
		}
		return this._local.y;
	}
}
nanofl_MouseEvent.__name__ = "nanofl.MouseEvent";
Object.assign(nanofl_MouseEvent.prototype, {
	__class__: nanofl_MouseEvent
});
class nanofl_Player {
	static init(args) {
		if(args.container == null) {
			throw new Error("Player.init: argument `container` must be specified.");
		}
		if(args.libraryData == null) {
			throw new Error("Player.init: argument `libraryData` must be specified.");
		}
		if(args.scaleMode == null) {
			args.scaleMode = "custom";
		}
		if(args.framerate == null) {
			args.framerate = 24;
		}
		nanofl_Player.container = args.container;
		nanofl_Player.library = nanofl_engine_Library.loadFromJson("library",args.libraryData);
		args.container.innerHTML = "";
		let canvas = window.document.createElement("canvas");
		canvas.style.position = "absolute";
		args.container.appendChild(canvas);
		return nanofl_engine_TextureAtlasTools.resolveImages(args.textureAtlasesData).then(function(_) {
			if(args.textureAtlasesData != null) {
				let _g = 0;
				let _g1 = args.textureAtlasesData;
				while(_g < _g1.length) {
					let textureAtlasData = _g1[_g];
					++_g;
					let _g2 = 0;
					let _g3 = Reflect.fields(textureAtlasData);
					while(_g2 < _g3.length) {
						let namePath = _g3[_g2];
						++_g2;
						nanofl_Player.spriteSheets[namePath] = new createjs.SpriteSheet(Reflect.field(textureAtlasData,namePath));
					}
				}
			}
			return nanofl_Player.library.preload().then(function(_) {
				nanofl_Player.stage = new nanofl_Stage(canvas);
				if(args.scaleMode != nanofl_engine_ScaleMode.custom) {
					let originalWidth = args.container.offsetWidth;
					let originalHeight = args.container.offsetHeight;
					window.addEventListener("resize",function() {
						nanofl_Player.resize(args.scaleMode,originalWidth,originalHeight);
					});
					nanofl_Player.resize(args.scaleMode,originalWidth,originalHeight);
				}
				nanofl_Player.stage.addChild(nanofl_Player.scene = nanofl_Player.library.getSceneInstance().createDisplayObject(null));
				nanofl_DisplayObjectTools.callMethod(nanofl_Player.scene,"init");
				nanofl_DisplayObjectTools.callMethod(nanofl_Player.scene,"onEnterFrame");
				nanofl_Player.stage.update();
				createjs.Ticker.framerate = args.framerate;
				createjs.Ticker.addEventListener("tick",function() {
					nanofl_Player.scene.advance();
					nanofl_DisplayObjectTools.callMethod(nanofl_Player.scene,"onEnterFrame");
					nanofl_Player.stage.update();
				});
				return null;
			});
		});
	}
	static resize(scaleMode,originalWidth,originalHeight) {
		let tmp = Std.string(window.innerWidth);
		window.document.body.style.width = tmp + "px";
		let tmp1 = Std.string(window.innerHeight);
		window.document.body.style.height = tmp1 + "px";
		let kx;
		let ky;
		switch(scaleMode) {
		case nanofl_engine_ScaleMode.fill:
			ky = Math.max(window.innerWidth / originalWidth,window.innerHeight / originalHeight);
			kx = ky;
			break;
		case nanofl_engine_ScaleMode.fit:
			ky = Math.min(window.innerWidth / originalWidth,window.innerHeight / originalHeight);
			kx = ky;
			break;
		case nanofl_engine_ScaleMode.stretch:
			kx = window.innerWidth / originalWidth;
			ky = window.innerHeight / originalHeight;
			break;
		default:
			ky = 1;
			kx = ky;
		}
		let w = Math.round(originalWidth * kx);
		let h = Math.round(originalHeight * ky);
		nanofl_Player.container.style.width = w + "px";
		nanofl_Player.container.style.height = h + "px";
		let _g = 0;
		let _g1 = nanofl_Player.container.children;
		while(_g < _g1.length) {
			let node = _g1[_g];
			++_g;
			if(node.tagName.toUpperCase() == "CANVAS") {
				node.width = w;
				node.height = h;
			}
		}
		let tmp2 = Math.round((window.innerWidth - nanofl_Player.container.offsetWidth) / 2);
		nanofl_Player.container.style.left = tmp2 + "px";
		let tmp3 = Math.round((window.innerHeight - nanofl_Player.container.offsetHeight) / 2);
		nanofl_Player.container.style.top = tmp3 + "px";
		nanofl_Player.stage.scaleX = kx;
		nanofl_Player.stage.scaleY = ky;
	}
}
$hx_exports["nanofl"]["Player"] = nanofl_Player;
nanofl_Player.__name__ = "nanofl.Player";
class nanofl_SeamlessSoundLoop {
	constructor(audio) {
		this.n = 1;
		if(audio.duration == null || audio.duration == 0) {
			return;
		}
		if(nanofl_SeamlessSoundLoop.delay == null) {
			nanofl_SeamlessSoundLoop.delay = this.detectDelay();
		}
		this.sounds = [audio,audio.cloneNode()];
		this.switchSound();
	}
	stop() {
		if(this.sounds[0] != null) {
			this.sounds[0].pause();
			this.sounds[0] = null;
			this.sounds[1].pause();
			this.sounds[1] = null;
			this.timer.stop();
		}
	}
	switchSound() {
		this.n = this.n == 1 ? 0 : 1;
		if(this.sounds[this.n] != null) {
			this.sounds[this.n].play();
			this.timer = haxe_Timer.delay($bind(this,this.switchSound),Math.round(this.sounds[0].duration));
		}
	}
	detectDelay() {
		let $window = window;
		let document = window.document;
		if($window.mozInnerScreenX != null && new EReg("firefox","i").match($global.navigator.userAgent)) {
			return -25;
		}
		if(document.all) {
			return -30;
		}
		if($window.chrome) {
			return -25;
		}
		if(new EReg("safari","i").match($global.navigator.userAgent) && $window.getComputedStyle && !$window.globalStorage) {
			return -30;
		}
		return 0;
	}
}
$hx_exports["nanofl"]["SeamlessSoundLoop"] = nanofl_SeamlessSoundLoop;
nanofl_SeamlessSoundLoop.__name__ = "nanofl.SeamlessSoundLoop";
Object.assign(nanofl_SeamlessSoundLoop.prototype, {
	__class__: nanofl_SeamlessSoundLoop
});
class nanofl_SpriteButton extends createjs.Sprite {
	constructor(spriteSheet) {
		super(spriteSheet);
		this.stop();
		if(spriteSheet.getNumFrames() >= 4) {
			this.hitArea = spriteSheet.getFrame(3);
		}
		this.cursor = "pointer";
	}
	onMouseDown(e) {
		if(this.spriteSheet.getNumFrames() >= 3 && this.currentFrame != 2) {
			if((this.hitArea != null ? this.hitArea : this).hitTest(e.localX,e.localY)) {
				this.gotoAndStop(2);
			}
		}
	}
	onMouseMove(e) {
		if(this.spriteSheet.getNumFrames() >= 2 && this.currentFrame != 2) {
			this.gotoAndStop((this.hitArea != null ? this.hitArea : this).hitTest(e.localX,e.localY) ? 1 : 0);
		}
	}
	onMouseUp(e) {
		if(this.spriteSheet.getNumFrames() > 0 && this.currentFrame != 0) {
			this.gotoAndStop(0);
		}
	}
	stageMouseEventProxy(f,e) {
		let t = e.currentTarget;
		e.currentTarget = this;
		f(e);
		e.currentTarget = t;
	}
}
$hx_exports["nanofl"]["SpriteButton"] = nanofl_SpriteButton;
nanofl_SpriteButton.__name__ = "nanofl.SpriteButton";
nanofl_SpriteButton.__super__ = createjs.Sprite;
Object.assign(nanofl_SpriteButton.prototype, {
	__class__: nanofl_SpriteButton
});
class nanofl_Stage extends createjs.Stage {
	constructor(canvas) {
		super(canvas);
		this.tickOnUpdate = false;
		this.enableMouseOver(10);
		let _gthis = this;
		this.addEventListener("stagemousedown",function(e) {
			nanofl_DisplayObjectTools.dispatchMouseEvent(_gthis,"onMouseDown",new nanofl_MouseEvent(e.stageX,e.stageY));
		},null);
		this.addEventListener("stagemousemove",function(e) {
			nanofl_DisplayObjectTools.dispatchMouseEvent(_gthis,"onMouseMove",new nanofl_MouseEvent(e.stageX,e.stageY));
		},null);
		this.addEventListener("stagemouseup",function(e) {
			nanofl_DisplayObjectTools.dispatchMouseEvent(_gthis,"onMouseUp",new nanofl_MouseEvent(e.stageX,e.stageY));
		},null);
	}
	update(params) {
		nanofl_DisplayObjectTools.smartCache(this);
		super.update(params);
	}
}
$hx_exports["nanofl"]["Stage"] = nanofl_Stage;
nanofl_Stage.__name__ = "nanofl.Stage";
nanofl_Stage.__super__ = createjs.Stage;
Object.assign(nanofl_Stage.prototype, {
	__class__: nanofl_Stage
});
class nanofl_TextField extends nanofl_SolidContainer {
	constructor(width,height,selectable,border,dashedBorder,textRuns,newTextFormat) {
		if(dashedBorder == null) {
			dashedBorder = false;
		}
		if(border == null) {
			border = false;
		}
		if(selectable == null) {
			selectable = false;
		}
		if(height == null) {
			height = 0.0;
		}
		if(width == null) {
			width = 0.0;
		}
		super();
		let _gthis = this;
		Object.defineProperty(this,"minWidth",{ get : function() {
			return _gthis.get_minWidth();
		}});
		Object.defineProperty(this,"minHeight",{ get : function() {
			return _gthis.get_minHeight();
		}});
		Object.defineProperty(this,"width",{ get : function() {
			return _gthis.get_width();
		}, set : function(v) {
			_gthis.set_width(v);
		}});
		Object.defineProperty(this,"height",{ get : function() {
			return _gthis.get_height();
		}, set : function(v) {
			_gthis.set_height(v);
		}});
		Object.defineProperty(this,"border",{ get : function() {
			return _gthis.get_border();
		}, set : function(v) {
			_gthis.set_border(v);
		}});
		Object.defineProperty(this,"dashedBorder",{ get : function() {
			return _gthis.get_dashedBorder();
		}, set : function(v) {
			_gthis.set_dashedBorder(v);
		}});
		Object.defineProperty(this,"newTextFormat",{ get : function() {
			return _gthis.get_newTextFormat();
		}, set : function(v) {
			_gthis.set_newTextFormat(v);
		}});
		Object.defineProperty(this,"text",{ get : function() {
			return _gthis.get_text();
		}, set : function(v) {
			_gthis.set_text(v);
		}});
		this._border = false;
		this._dashedBorder = false;
		this.width = width;
		this.height = height;
		this.selectable = selectable;
		this.border = border;
		this.dashedBorder = dashedBorder;
		this.textRuns = textRuns != null ? textRuns : [];
		this._newTextFormat = newTextFormat;
		this.resize = new stdlib_Event(this);
		this.change = new stdlib_Event(this);
		let _g = 0;
		let _g1 = this.textRuns;
		while(_g < _g1.length) {
			let textRun = _g1[_g];
			++_g;
			textRun.characters = StringTools.replace(StringTools.replace(textRun.characters,"\r\n","\n"),"\r","\n");
		}
		this.textLines = [];
		this.addChild(this.globalBackground = new createjs.Shape());
		this.addChild(this.background = new createjs.Shape());
		this.addChild(this.textsContainer = new createjs.Container());
		this.addChild(this.borders = new createjs.Shape());
		this.addChild(this.caret = new createjs.Shape());
		this.hitBox = new createjs.Shape();
		this.optionsChanged();
	}
	get_minWidth() {
		this.update();
		return this._minWidth;
	}
	get_minHeight() {
		this.update();
		return this._minHeight;
	}
	get_width() {
		return this._width;
	}
	set_width(v) {
		if(this._width != v) {
			this._width = v;
			this.needUpdate = true;
		}
		return v;
	}
	get_height() {
		return this._height;
	}
	set_height(v) {
		if(this._height != v) {
			this._height = v;
			this.needUpdate = true;
		}
		return v;
	}
	get_border() {
		return this._border;
	}
	set_border(v) {
		if(this._border != v) {
			this._border = v;
			this.optionsChanged();
		}
		return v;
	}
	get_dashedBorder() {
		return this._dashedBorder;
	}
	set_dashedBorder(v) {
		if(this._dashedBorder != v) {
			this._dashedBorder = v;
			this.optionsChanged();
		}
		return v;
	}
	get_newTextFormat() {
		if(this._newTextFormat != null) {
			return this._newTextFormat;
		} else {
			return this._newTextFormat = new nanofl_TextRun();
		}
	}
	set_newTextFormat(format) {
		stdlib_Debug.assert(format != null,"TextField.newTextFormat must not be null." + haxe_CallStack.toString(haxe_CallStack.callStack()),{ fileName : "engine/nanofl/TextField.hx", lineNumber : 109, className : "nanofl.TextField", methodName : "set_newTextFormat"});
		return this._newTextFormat = format;
	}
	get_text() {
		let _this = this.textRuns;
		let result = new Array(_this.length);
		let _g = 0;
		let _g1 = _this.length;
		while(_g < _g1) {
			let i = _g++;
			result[i] = _this[i].characters;
		}
		return result.join("");
	}
	set_text(v) {
		let format = this.textRuns.length > 0 ? this.textRuns[this.textRuns.length - 1] : this.newTextFormat;
		this.textRuns.splice(0,this.textRuns.length);
		this.textRuns.push(format.duplicate(v));
		return v;
	}
	getSplittedByPosition(runs,position,textToInsert) {
		if(textToInsert == null) {
			textToInsert = "";
		}
		let r = [];
		if(position > 0) {
			let charIndex = 0;
			let _g = 0;
			while(_g < runs.length) {
				let run = runs[_g];
				++_g;
				let len = run.characters.length;
				if(position > charIndex && position < charIndex + len) {
					r.push(run.duplicate(HxOverrides.substr(run.characters,0,position - charIndex)));
					if(textToInsert.length > 0) {
						r.push(run.duplicate(textToInsert));
					}
					r.push(run.duplicate(HxOverrides.substr(run.characters,position - charIndex,len - (position - charIndex))));
					len += textToInsert.length;
				} else {
					r.push(run.clone());
					if(position == charIndex + len) {
						if(textToInsert.length > 0) {
							r.push(run.duplicate(textToInsert));
							len += textToInsert.length;
						}
					}
				}
				charIndex += len;
			}
		} else {
			if(textToInsert.length > 0) {
				r.push(runs.length > 0 ? runs[0].duplicate(textToInsert) : this.newTextFormat.duplicate(textToInsert));
			}
			let _g = 0;
			while(_g < runs.length) {
				let run = runs[_g];
				++_g;
				r.push(run);
			}
		}
		return r;
	}
	getSplittedToLines(runs) {
		let runLines = [];
		let runLine = [];
		let _g = 0;
		while(_g < runs.length) {
			let run = runs[_g];
			++_g;
			let lines = run.characters.split("\n");
			if(lines.length == 1) {
				if(run.characters != "") {
					runLine.push(run);
				}
			} else {
				let _g = 0;
				let _g1 = lines.length;
				while(_g < _g1) {
					let i = _g++;
					if(lines[i] != "") {
						runLine.push(run.duplicate(lines[i]));
					}
					if(i < lines.length - 1) {
						runLine.push(run.duplicate(" "));
						runLines.push(runLine);
						runLine = [];
					}
				}
			}
		}
		if(runLine.length == 0) {
			runLine.push(runs.length > 0 ? runs[runs.length - 1].duplicate(" ") : this.newTextFormat.duplicate(" "));
		}
		runLines.push(runLine);
		return runLines;
	}
	getTextLines() {
		let runs = this.textRuns.slice();
		if(this.selectable && !this.dashedBorder) {
			runs = this.getSplittedByPosition(runs,0);
		}
		let lines = this.getSplittedToLines(runs);
		let r = [];
		let charIndex = 0;
		let _g = 0;
		let _g1 = lines.length;
		while(_g < _g1) {
			let i = _g++;
			let runsLine = [];
			let _g1 = 0;
			let _g2 = lines[i];
			while(_g1 < _g2.length) {
				let run = _g2[_g1];
				++_g1;
				if(run.kerning) {
					runsLine.push(run);
				} else {
					let _g_offset = 0;
					let _g_s = run.characters;
					while(_g_offset < _g_s.length) {
						let c = _g_s.charCodeAt(_g_offset++);
						runsLine.push(run.duplicate(String.fromCodePoint(c)));
					}
				}
			}
			let lineWidth = 0.0;
			let lineMinY = 1.0e10;
			let lineMaxY = -1.0e10;
			let lineSpacing = null;
			let chunks = [];
			let _g3 = 0;
			let _g4 = runsLine.length;
			while(_g3 < _g4) {
				let j = _g3++;
				let run = runsLine[j];
				let selected = this.selectable && !this.dashedBorder && charIndex >= 0 && charIndex < 0;
				let text = this.createFirstText(run,selected);
				let bounds = text.getBounds();
				let fontHeight = nanofl_TextField.measureFontHeight(run.family,run.style,run.size);
				let fontBaselineCoef = nanofl_TextField.measureFontBaselineCoef(run.family,run.style);
				stdlib_Debug.assert(run.letterSpacing != null,null,{ fileName : "engine/nanofl/TextField.hx", lineNumber : 311, className : "nanofl.TextField", methodName : "getTextLines"});
				text.setBounds(bounds.x,-fontHeight * fontBaselineCoef,bounds.width + (!run.kerning ? run.letterSpacing : 0),fontHeight);
				bounds = text.getBounds();
				if(i == lines.length - 1 || j < runsLine.length - 1) {
					lineWidth += bounds.width;
				}
				lineMinY = Math.min(lineMinY,bounds.y);
				lineMaxY = Math.max(lineMaxY,bounds.y + bounds.height);
				stdlib_Debug.assert(run.lineSpacing != null,null,{ fileName : "engine/nanofl/TextField.hx", lineNumber : 329, className : "nanofl.TextField", methodName : "getTextLines"});
				lineSpacing = lineSpacing != null ? Math.max(lineSpacing,run.lineSpacing) : run.lineSpacing;
				chunks.push({ text : text, textSecond : this.createSecondText(run,selected), charIndex : charIndex, bounds : bounds, backgroundColor : !selected ? run.backgroundColor : "darkblue", format : run});
				charIndex += run.characters.length;
			}
			r.push({ chunks : chunks, width : lineWidth, minY : lineMinY, maxY : lineMaxY, align : StringTools.trim(runsLine[0].align).toLowerCase(), spacing : lineSpacing - 2});
		}
		return r;
	}
	update() {
		if(!this.needUpdate && !this.isTextChanged()) {
			return;
		}
		this.needUpdate = false;
		nanofl_TextRun.optimize(this.textRuns);
		let _this = this.textRuns;
		let result = new Array(_this.length);
		let _g = 0;
		let _g1 = _this.length;
		while(_g < _g1) {
			let i = _g++;
			result[i] = _this[i].clone();
		}
		this.textRunsOnLastUpdate = result;
		this.globalBackground.visible = false;
		this.borders.visible = false;
		let sizeChanged = false;
		this.textLines = this.getTextLines();
		this._minWidth = 0.0;
		this._minHeight = nanofl_TextField.PADDING * 2;
		let _g2 = 0;
		let _g3 = this.textLines;
		while(_g2 < _g3.length) {
			let line = _g3[_g2];
			++_g2;
			this._minWidth = Math.max(this._minWidth,line.width + nanofl_TextField.PADDING * 2);
			if(this._minWidth > this.width) {
				switch(line.align) {
				case "center":
					this.x -= (line.width - (this.width - nanofl_TextField.PADDING * 2)) / 2;
					break;
				case "right":
					this.x -= line.width - (this.width - nanofl_TextField.PADDING * 2);
					break;
				}
				this.width = line.width + nanofl_TextField.PADDING * 2;
				sizeChanged = true;
			}
			this._minHeight += line.maxY - line.minY + line.spacing;
		}
		if(this.textLines.length > 0) {
			this._minHeight -= this.textLines[this.textLines.length - 1].spacing;
		}
		if(this._minHeight > this.height) {
			this.height = this._minHeight;
			sizeChanged = true;
		}
		this.textsContainer.removeAllChildren();
		this.background.graphics.clear();
		let innerY = nanofl_TextField.PADDING;
		let _g4 = 0;
		let _g5 = this.textLines.length;
		while(_g4 < _g5) {
			let i = _g4++;
			let line = this.textLines[i];
			let innerX;
			switch(line.align) {
			case "center":
				innerX = (this.width - nanofl_TextField.PADDING * 2 - line.width) / 2.0;
				break;
			case "right":
				innerX = this.width - nanofl_TextField.PADDING * 2 - line.width;
				break;
			default:
				innerX = 0.0;
			}
			let innerX1 = nanofl_TextField.PADDING + innerX;
			let _g = 0;
			let _g1 = line.chunks;
			while(_g < _g1.length) {
				let t = _g1[_g];
				++_g;
				if(t.textSecond != null) {
					this.textsContainer.addChild(t.textSecond);
				}
				this.textsContainer.addChild(t.text);
				t.text.x = innerX1;
				t.text.y = innerY - line.minY;
				if(t.backgroundColor != null) {
					this.background.graphics.beginFill(t.backgroundColor).rect(t.text.x + t.bounds.x,t.text.y + line.minY,t.bounds.width,line.maxY - line.minY).endFill();
				}
				if(t.textSecond != null) {
					t.textSecond.x = t.text.x;
					t.textSecond.y = t.text.y;
				}
				innerX1 += t.bounds.width;
			}
			innerY += line.maxY - line.minY + line.spacing;
		}
		if(this.border || this.dashedBorder) {
			let pt0 = this.localToGlobal(0,0);
			pt0 = this.globalToLocal(Math.round(pt0.x) + 0.5,Math.round(pt0.y) + 0.5);
			let pt1 = this.localToGlobal(this.width,this.height);
			pt1 = this.globalToLocal(Math.round(pt1.x) + 0.5,Math.round(pt1.y) + 0.5);
			if(this.border) {
				this.globalBackground.visible = true;
				this.globalBackground.graphics.clear().beginFill("#FFFFFF").rect(pt0.x,pt0.y,pt1.x - pt0.x,pt1.y - pt0.y).endFill();
			}
			this.drawBorders(pt0,pt1);
		}
		if(sizeChanged) {
			this.resize.call({ width : this.width, height : this.height});
		}
		this.updateHitArea();
		this.setBounds(0,0,this.width,this.height);
	}
	draw(ctx,ignoreCache) {
		this.update();
		return super.draw(ctx,ignoreCache);
	}
	drawBorders(pt0,pt1) {
		if(this.border) {
			this.borders.visible = true;
			this.borders.graphics.clear().setStrokeStyle(1.0,null,null,null,true).beginStroke("#000000").rect(pt0.x,pt0.y,pt1.x - pt0.x,pt1.y - pt0.y).endStroke();
		} else if(this.dashedBorder) {
			this.borders.visible = true;
			let dashPt0 = this.globalToLocal(0,0);
			let dashPt1 = this.globalToLocal(2,2);
			let dashLen = (Math.abs(dashPt1.x - dashPt0.x) + Math.abs(dashPt1.y - dashPt0.y)) / 2;
			nanofl_engine_DrawTools.drawDashedRect(this.borders.graphics.clear().setStrokeStyle(1.0,null,null,null,true),pt0.x,pt0.y,pt1.x,pt1.y,"#000000","#FFFFFF",dashLen);
		}
	}
	updateHitArea() {
		this.hitBox.graphics.clear().beginFill("#000000").rect(0,0,this.width,this.height).endFill();
	}
	optionsChanged() {
		this.hitArea = this.hitBox;
		this.needUpdate = true;
	}
	updateStage() {
		this.update();
		if(this.stage != null) {
			this.stage.update();
		}
	}
	isTextChanged() {
		if(this.textRunsOnLastUpdate.length != this.textRuns.length) {
			return true;
		}
		let _g = 0;
		let _g1 = this.textRuns.length;
		while(_g < _g1) {
			let i = _g++;
			if(!this.textRunsOnLastUpdate[i].equ(this.textRuns[i])) {
				return true;
			}
		}
		return false;
	}
	createFirstText(run,selected) {
		if(!selected && run.isStroked()) {
			return run.createText(run.strokeColor,run.strokeSize);
		} else {
			return run.createText(!selected ? run.fillColor : "white");
		}
	}
	createSecondText(run,selected) {
		if(!selected && run.isFilled() && run.isStroked()) {
			return run.createText();
		} else {
			return null;
		}
	}
	clone(recursive) {
		let tmp = this;
		let tmp1 = this.width;
		let tmp2 = this.height;
		let tmp3 = this.selectable;
		let tmp4 = this.border;
		let tmp5 = this.dashedBorder;
		let tmp6;
		if(recursive) {
			let _this = this.textRuns;
			let result = new Array(_this.length);
			let _g = 0;
			let _g1 = _this.length;
			while(_g < _g1) {
				let i = _g++;
				result[i] = _this[i].clone();
			}
			tmp6 = result;
		} else {
			tmp6 = this.textRuns;
		}
		let tmp7 = recursive && this.newTextFormat != null ? this.newTextFormat.clone() : this.newTextFormat;
		return tmp._cloneProps(new nanofl_TextField(tmp1,tmp2,tmp3,tmp4,tmp5,tmp6,tmp7));
	}
	hxUnserialize(s) {
		let _gthis = this;
		Object.defineProperty(this,"minWidth",{ get : function() {
			return _gthis.get_minWidth();
		}});
		Object.defineProperty(this,"minHeight",{ get : function() {
			return _gthis.get_minHeight();
		}});
		Object.defineProperty(this,"width",{ get : function() {
			return _gthis.get_width();
		}, set : function(v) {
			_gthis.set_width(v);
		}});
		Object.defineProperty(this,"height",{ get : function() {
			return _gthis.get_height();
		}, set : function(v) {
			_gthis.set_height(v);
		}});
		Object.defineProperty(this,"border",{ get : function() {
			return _gthis.get_border();
		}, set : function(v) {
			_gthis.set_border(v);
		}});
		Object.defineProperty(this,"dashedBorder",{ get : function() {
			return _gthis.get_dashedBorder();
		}, set : function(v) {
			_gthis.set_dashedBorder(v);
		}});
		Object.defineProperty(this,"newTextFormat",{ get : function() {
			return _gthis.get_newTextFormat();
		}, set : function(v) {
			_gthis.set_newTextFormat(v);
		}});
		Object.defineProperty(this,"text",{ get : function() {
			return _gthis.get_text();
		}, set : function(v) {
			_gthis.set_text(v);
		}});
		s.unserializeObject(this);
	}
	hxSerialize(s) {
		s.serializeFields(this);
	}
	static measureFontHeight(family,style,size) {
		let key = family + "|" + style + "|" + size;
		if(Object.prototype.hasOwnProperty.call(nanofl_TextField.fontHeightCache.h,key)) {
			return nanofl_TextField.fontHeightCache.h[key];
		}
		let div = window.document.createElement("div");
		div.innerHTML = "Mp";
		div.style.position = "absolute";
		div.style.top = "0";
		div.style.left = "0";
		div.style.fontFamily = family;
		div.style.fontWeight = style.indexOf("bold") >= 0 ? "bold" : "normal";
		div.style.fontStyle = style.indexOf("italic") >= 0 ? "italic" : "normal";
		div.style.fontSize = size + "px";
		div.style.lineHeight = "normal";
		if(window.document.body == null) {
			window.document.body = window.document.querySelector("body");
		}
		window.document.body.appendChild(div);
		let r = div.offsetHeight;
		window.document.body.removeChild(div);
		nanofl_TextField.fontHeightCache.h[key] = r;
		return r;
	}
	static measureFontBaselineCoef(family,style) {
		let key = family + "|" + style;
		if(Object.prototype.hasOwnProperty.call(nanofl_TextField.fontBaselineCoefCache.h,key)) {
			return nanofl_TextField.fontBaselineCoefCache.h[key];
		}
		let container = window.document.createElement("div");
		container.style.height = "100px";
		container.style.position = "absolute";
		container.style.top = "0";
		container.style.left = "0";
		let letter = window.document.createElement("span");
		letter.style.fontFamily = family;
		letter.style.fontWeight = style.indexOf("bold") >= 0 ? "bold" : "normal";
		letter.style.fontStyle = style.indexOf("italic") >= 0 ? "italic" : "normal";
		letter.style.fontSize = "100px";
		letter.style.lineHeight = "0";
		letter.innerHTML = "A";
		let strut = window.document.createElement("span");
		strut.style.fontFamily = family;
		strut.style.fontWeight = style.indexOf("bold") >= 0 ? "bold" : "normal";
		strut.style.fontStyle = style.indexOf("italic") >= 0 ? "italic" : "normal";
		strut.style.fontSize = "999px";
		strut.style.lineHeight = "normal";
		strut.style.display = "inline-block";
		strut.style.height = "100px";
		strut.innerHTML = "";
		container.appendChild(letter);
		container.appendChild(strut);
		window.document.body.appendChild(container);
		let r = 1 - (letter.offsetTop + letter.offsetHeight - container.offsetHeight - container.offsetTop) / 100;
		container.remove();
		nanofl_TextField.fontBaselineCoefCache.h[key] = r;
		return r;
	}
	static log(v,infos) {
	}
}
$hx_exports["nanofl"]["TextField"] = nanofl_TextField;
nanofl_TextField.__name__ = "nanofl.TextField";
nanofl_TextField.__super__ = nanofl_SolidContainer;
Object.assign(nanofl_TextField.prototype, {
	__class__: nanofl_TextField
});
class nanofl_TextRun {
	constructor(characters,fillColor,size) {
		if(size == null) {
			size = 12.0;
		}
		if(fillColor == null) {
			fillColor = "#000000";
		}
		if(characters == null) {
			characters = "";
		}
		this.lineSpacing = 2.0;
		this.letterSpacing = 0.0;
		this.kerning = true;
		this.strokeColor = "#000000";
		this.strokeSize = 0.0;
		this.align = "left";
		this.style = "";
		this.family = "Times";
		this.characters = characters;
		this.fillColor = fillColor;
		this.size = size;
	}
	getFontString() {
		return StringTools.trim((this.style != null ? this.style : "") + " " + (this.size != null ? this.size + "px" : "") + " " + (this.family != null && this.family != "" ? this.family : "serif"));
	}
	clone() {
		return this.duplicate();
	}
	duplicate(characters) {
		let r = nanofl_TextRun.create(characters != null ? characters : this.characters,this.fillColor,this.family,this.style,this.size,this.align,this.strokeSize,this.strokeColor,this.kerning,this.letterSpacing,this.lineSpacing);
		r.backgroundColor = this.backgroundColor;
		return r;
	}
	equ(textRun) {
		if(this.characters == textRun.characters) {
			return this.equFormat(textRun);
		} else {
			return false;
		}
	}
	createText(color,outline) {
		let r = new createjs.Text(this.characters,this.getFontString(),color != null ? color : this.fillColor);
		if(outline != null) {
			r.outline = outline;
		}
		r.textBaseline = "alphabetic";
		r.textAlign = "left";
		return r;
	}
	isFilled() {
		return !this.isEmptyColor(this.fillColor);
	}
	isStroked() {
		if(this.strokeSize != null && this.strokeSize != 0) {
			return !this.isEmptyColor(this.strokeColor);
		} else {
			return false;
		}
	}
	isEmptyColor(s) {
		if(!(s == null || s == "" || s == "transparent" || s == "none")) {
			return new EReg("^\\s*rgba\\s*\\(\\s*\\d+\\s*,\\s*\\d+\\s*,\\s*\\d+\\s*,\\s*0(?:\\.0)?\\s*\\)$","i").match(s);
		} else {
			return true;
		}
	}
	equFormat(format) {
		if(this.fillColor == format.fillColor && this.family == format.family && this.style == format.style && this.size == format.size && this.align == format.align && this.strokeSize == format.strokeSize && this.strokeColor == format.strokeColor && this.kerning == format.kerning && this.letterSpacing == format.letterSpacing) {
			return this.lineSpacing == format.lineSpacing;
		} else {
			return false;
		}
	}
	static create(characters,fillColor,family,style,size,align,strokeSize,strokeColor,kerning,letterSpacing,lineSpacing) {
		let r = new nanofl_TextRun();
		r.characters = characters;
		r.fillColor = fillColor;
		r.family = family;
		r.style = style;
		r.size = size;
		r.align = align;
		r.strokeSize = strokeSize;
		r.strokeColor = strokeColor;
		r.kerning = kerning;
		r.letterSpacing = letterSpacing;
		r.lineSpacing = lineSpacing;
		return r;
	}
	static optimize(textRuns) {
		let i = 0;
		while(i < textRuns.length - 1) if(textRuns[i].equFormat(textRuns[i + 1])) {
			textRuns[i].characters += textRuns[i + 1].characters;
			textRuns.splice(i + 1,1);
		} else {
			++i;
		}
		return textRuns;
	}
}
$hx_exports["nanofl"]["TextRun"] = nanofl_TextRun;
nanofl_TextRun.__name__ = "nanofl.TextRun";
Object.assign(nanofl_TextRun.prototype, {
	__class__: nanofl_TextRun
});
class nanofl_engine_ColorTools {
	static parse(s) {
		nanofl_engine_ColorTools.log("parse color " + s,{ fileName : "engine/nanofl/engine/ColorTools.hx", lineNumber : 45, className : "nanofl.engine.ColorTools", methodName : "parse"});
		let r = -1;
		let g = -1;
		let b = -1;
		let a = 1.0;
		s = StringTools.replace(s," ","");
		if(Object.prototype.hasOwnProperty.call(nanofl_engine_ColorTools.colors,s.toLowerCase())) {
			s = Reflect.field(nanofl_engine_ColorTools.colors,s.toLowerCase());
		}
		let reRGB = new EReg("^rgb\\(([0-9]+),([0-9]+),([0-9]+)\\)$","i");
		let reRGBA = new EReg("^rgba\\(([0-9]+),([0-9]+),([0-9]+),([0-9.e+-]+)\\)$","i");
		if(new EReg("^#?[0-9A-F]{6}$","i").match(s)) {
			if(s.startsWith("#")) {
				s = HxOverrides.substr(s,1,null);
			}
			r = Std.parseInt("0x" + HxOverrides.substr(s,0,2));
			g = Std.parseInt("0x" + HxOverrides.substr(s,2,2));
			b = Std.parseInt("0x" + HxOverrides.substr(s,4,2));
		} else if(new EReg("^#?[0-9A-F]{3}$","i").match(s)) {
			if(s.startsWith("#")) {
				s = HxOverrides.substr(s,1,null);
			}
			r = Std.parseInt("0x" + HxOverrides.substr(s,0,1) + HxOverrides.substr(s,0,1));
			g = Std.parseInt("0x" + HxOverrides.substr(s,1,1) + HxOverrides.substr(s,1,1));
			b = Std.parseInt("0x" + HxOverrides.substr(s,2,1) + HxOverrides.substr(s,2,1));
		} else if(reRGB.match(s)) {
			r = Std.parseInt(reRGB.matched(1));
			g = Std.parseInt(reRGB.matched(2));
			b = Std.parseInt(reRGB.matched(3));
		} else if(reRGBA.match(s)) {
			r = Std.parseInt(reRGBA.matched(1));
			g = Std.parseInt(reRGBA.matched(2));
			b = Std.parseInt(reRGBA.matched(3));
			a = parseFloat(reRGBA.matched(4));
		}
		if(r >= 0 && g >= 0 && b >= 0) {
			return { r : r, g : g, b : b, a : a};
		}
		return null;
	}
	static joinStringAndAlpha(color,alpha) {
		let rgba = nanofl_engine_ColorTools.parse(color);
		if(rgba != null) {
			if(alpha != null) {
				rgba.a = alpha;
			}
			return nanofl_engine_ColorTools.rgbaToString(rgba);
		}
		return null;
	}
	static stringToNumber(color,defValue) {
		let rgba = nanofl_engine_ColorTools.parse(color);
		if(rgba != null) {
			return nanofl_engine_ColorTools.rgbaToNumber(rgba);
		} else {
			return defValue;
		}
	}
	static rgbaToString(rgba) {
		if(rgba.a == null || rgba.a == 1.0) {
			return "#" + StringTools.hex(rgba.r,2) + StringTools.hex(rgba.g,2) + StringTools.hex(rgba.b,2);
		} else {
			return "rgba(" + rgba.r + "," + rgba.g + "," + rgba.b + "," + rgba.a + ")";
		}
	}
	static rgbaToNumber(rgba) {
		if(rgba.a == null || rgba.a == 1.0) {
			return rgba.r << 16 | rgba.g << 8 | rgba.b;
		} else {
			return Math.round(rgba.a * 255) << 24 | rgba.r << 16 | rgba.g << 8 | rgba.b;
		}
	}
	static rgbToHsl(rgb) {
		let r = rgb.r / 255;
		let g = rgb.g / 255;
		let b = rgb.b / 255;
		let max = Math.max(r,Math.max(g,b));
		let min = Math.min(r,Math.min(g,b));
		let h;
		let s;
		let l = (max + min) / 2;
		if(max == min) {
			s = 0.0;
			h = s;
		} else {
			let d = max - min;
			s = l > 0.5 ? d / (2 - max - min) : d / (max + min);
			if(max == r) {
				h = (g - b) / d + (g < b ? 6 : 0);
			} else if(max == g) {
				h = (b - r) / d + 2;
			} else {
				h = (r - g) / d + 4;
			}
			h /= 6;
		}
		return { h : h, s : s, l : l};
	}
	static hslToRgb(hsl) {
		let r;
		let g;
		let b;
		if(hsl.s == 0.0) {
			b = hsl.l;
			g = b;
			r = g;
		} else {
			let hue2rgb = function(p,q,t) {
				if(t < 0) {
					++t;
				}
				if(t > 1) {
					--t;
				}
				if(t < 0.16666666666666666) {
					return p + (q - p) * 6 * t;
				}
				if(t < 0.5) {
					return q;
				}
				if(t < 0.66666666666666663) {
					return p + (q - p) * (0.66666666666666663 - t) * 6;
				}
				return p;
			};
			let q = hsl.l < 0.5 ? hsl.l * (1 + hsl.s) : hsl.l + hsl.s - hsl.l * hsl.s;
			let p = 2 * hsl.l - q;
			r = hue2rgb(p,q,hsl.h + 0.33333333333333331);
			g = hue2rgb(p,q,hsl.h);
			b = hue2rgb(p,q,hsl.h - 0.33333333333333331);
		}
		return { r : r * 255 | 0, g : g * 255 | 0, b : b * 255 | 0};
	}
	static rgbToHsv(rgb) {
		let r = rgb.r / 255;
		let g = rgb.g / 255;
		let b = rgb.b / 255;
		let max = Math.max(r,Math.max(g,b));
		let min = Math.min(r,Math.min(g,b));
		let h;
		let v = max;
		let d = max - min;
		let s = max == 0 ? 0 : d / max;
		if(max == min) {
			h = 0;
		} else {
			if(max == r) {
				h = (g - b) / d + (g < b ? 6 : 0);
			} else if(max == g) {
				h = (b - r) / d + 2;
			} else {
				h = (r - g) / d + 4;
			}
			h /= 6;
		}
		return { h : h, s : s, v : v};
	}
	static hsvToRgb(hsv) {
		let r;
		let g;
		let b;
		let i = Math.floor(hsv.h * 6);
		let f = hsv.h * 6 - i;
		let p = hsv.v * (1 - hsv.s);
		let q = hsv.v * (1 - f * hsv.s);
		let t = hsv.v * (1 - (1 - f) * hsv.s);
		switch(i % 6) {
		case 0:
			r = hsv.v;
			g = t;
			b = p;
			break;
		case 1:
			r = q;
			g = hsv.v;
			b = p;
			break;
		case 2:
			r = p;
			g = hsv.v;
			b = t;
			break;
		case 3:
			r = p;
			g = q;
			b = hsv.v;
			break;
		case 4:
			r = t;
			g = p;
			b = hsv.v;
			break;
		default:
			r = hsv.v;
			g = p;
			b = q;
		}
		return { r : r * 255 | 0, g : g * 255 | 0, b : b * 255 | 0};
	}
	static tweenRgba(start,finish,t) {
		let r = nanofl_engine_ColorTools.hslToRgb(nanofl_engine_ColorTools.tweenHsl(nanofl_engine_ColorTools.rgbToHsl(start),nanofl_engine_ColorTools.rgbToHsl(finish),t));
		if(start.a != null || finish.a != null) {
			let a1 = start.a != null ? start.a : 1.0;
			let a2 = finish.a != null ? finish.a : 1.0;
			r.a = a1 + (a2 - a1) * t;
		}
		return r;
	}
	static tweenHsl(start,finish,t) {
		return { h : start.h + (finish.h - start.h) * t, s : start.s + (finish.s - start.s) * t, l : start.l + (finish.l - start.l) * t};
	}
	static normalize(s) {
		if(s == null) {
			return null;
		}
		if(s == "") {
			return "";
		}
		return nanofl_engine_ColorTools.rgbaToString(nanofl_engine_ColorTools.parse(s));
	}
	static getTweened(start,k,finish) {
		let rgbaStart = nanofl_engine_ColorTools.parse(start);
		let rgbaFinish = nanofl_engine_ColorTools.parse(finish);
		return nanofl_engine_ColorTools.rgbaToString({ r : rgbaStart.r + Math.round((rgbaFinish.r - rgbaStart.r) * k), g : rgbaStart.g + Math.round((rgbaFinish.g - rgbaStart.g) * k), b : rgbaStart.b + Math.round((rgbaFinish.b - rgbaStart.b) * k), a : rgbaStart.a + (rgbaFinish.a - rgbaStart.a) * k});
	}
	static log(v,infos) {
	}
}
$hx_exports["nanofl"]["engine"]["ColorTools"] = nanofl_engine_ColorTools;
nanofl_engine_ColorTools.__name__ = "nanofl.engine.ColorTools";
class nanofl_engine_Console {
	constructor() {
	}
	error(v) {
		$global.console.error(v);
	}
}
nanofl_engine_Console.__name__ = "nanofl.engine.Console";
Object.assign(nanofl_engine_Console.prototype, {
	__class__: nanofl_engine_Console
});
class nanofl_engine_CustomPropertiesTools {
	static equ(params1,params2) {
		let fields1 = Reflect.fields(params1);
		let fields2 = Reflect.fields(params2);
		if(fields1.length != fields2.length) {
			return false;
		}
		fields1.sort(Reflect.compare);
		fields2.sort(Reflect.compare);
		let _g = 0;
		let _g1 = fields1.length;
		while(_g < _g1) {
			let i = _g++;
			if(fields1[i] != fields2[i]) {
				return false;
			}
			if(Reflect.field(params1,fields1[i]) != Reflect.field(params2,fields1[i])) {
				return false;
			}
		}
		return true;
	}
	static tween(start,t,finish,properties) {
		if(t == 0.0 || properties == null) {
			return;
		}
		let _g = 0;
		while(_g < properties.length) {
			let p = properties[_g];
			++_g;
			if(p.type == "delimiter" || p.type == "info") {
				continue;
			}
			let startV = Reflect.field(start,p.name);
			let finishV = finish != null ? Reflect.field(finish,p.name) : p.neutralValue != null ? p.neutralValue : startV;
			switch(p.type.toLowerCase()) {
			case "color":
				start[p.name] = nanofl_engine_ColorTools.rgbaToString(nanofl_engine_ColorTools.tweenRgba(nanofl_engine_ColorTools.parse(startV),nanofl_engine_ColorTools.parse(finishV),t));
				break;
			case "float":case "int":
				start[p.name] = startV + (finishV - startV) * t;
				break;
			default:
				start[p.name] = startV;
			}
		}
	}
	static fix(params,properties) {
		if(properties == null) {
			return params;
		}
		let _g = 0;
		while(_g < properties.length) {
			let p = properties[_g];
			++_g;
			if(p.type == "delimiter" || p.type == "info") {
				continue;
			}
			let v = Reflect.field(params,p.name);
			if(v == null) {
				params[p.name] = p.defaultValue;
			} else {
				switch(p.type) {
				case "bool":
					params[p.name] = typeof(v) == "string" ? stdlib_Std.bool(v) : v;
					break;
				case "float":
					params[p.name] = typeof(v) == "string" ? stdlib_Std.parseFloat(v) : v;
					break;
				case "int":
					params[p.name] = typeof(v) == "string" ? stdlib_Std.parseInt(v) : v;
					break;
				default:
					params[p.name] = v;
				}
			}
		}
		return params;
	}
	static resetToNeutral(params,properties) {
		let _g = 0;
		while(_g < properties.length) {
			let p = properties[_g];
			++_g;
			if(p.type == "delimiter" || p.type == "info") {
				continue;
			}
			if(p.neutralValue != null) {
				params[p.name] = p.neutralValue;
			}
		}
	}
}
nanofl_engine_CustomPropertiesTools.__name__ = "nanofl.engine.CustomPropertiesTools";
class nanofl_engine_Debug {
}
nanofl_engine_Debug.__name__ = "nanofl.engine.Debug";
class nanofl_engine_DrawTools {
	static drawDashedLine(g,x1,y1,x2,y2,color1,color2,dashLen) {
		if(dashLen == null) {
			dashLen = 2.0;
		}
		let dX = x2 - x1;
		let dY = y2 - y1;
		let dashes = Math.floor(Math.sqrt(dX * dX + dY * dY) / dashLen);
		let dashX = dX / dashes;
		let dashY = dY / dashes;
		g.beginStroke(color1);
		let x = x1;
		let y = y1;
		g.moveTo(x,y);
		let q = 0;
		while(q++ < dashes) {
			x += dashX;
			y += dashY;
			if(q % 2 == 0) {
				g.moveTo(x,y);
			} else {
				g.lineTo(x,y);
			}
		}
		if(q % 2 == 0) {
			g.moveTo(x2,y2);
		} else {
			g.lineTo(x2,y2);
		}
		g.endStroke();
		if(color2 != null) {
			g.beginStroke(color2);
			x = x1 + dashX;
			y = y1 + dashY;
			g.moveTo(x,y);
			q = 1;
			while(q++ < dashes) {
				x += dashX;
				y += dashY;
				if(q % 2 == 1) {
					g.moveTo(x,y);
				} else {
					g.lineTo(x,y);
				}
			}
			if(q % 2 == 1) {
				g.moveTo(x2,y2);
			} else {
				g.lineTo(x2,y2);
			}
			g.endStroke();
		}
		return g;
	}
	static drawDashedRect(g,x1,y1,x2,y2,color1,color2,dashLen) {
		if(dashLen == null) {
			dashLen = 2.0;
		}
		nanofl_engine_DrawTools.drawDashedLine(g,x1,y1,x2,y1,color1,color2,dashLen);
		nanofl_engine_DrawTools.drawDashedLine(g,x2,y1,x2,y2,color1,color2,dashLen);
		nanofl_engine_DrawTools.drawDashedLine(g,x2,y2,x1,y2,color1,color2,dashLen);
		nanofl_engine_DrawTools.drawDashedLine(g,x1,y2,x1,y1,color1,color2,dashLen);
		return g;
	}
}
nanofl_engine_DrawTools.__name__ = "nanofl.engine.DrawTools";
class nanofl_engine_Ease {
	static get(amount) {
		if(amount < -1) {
			amount = -1;
		} else if(amount > 1) {
			amount = 1;
		}
		return function(t) {
			if(amount == 0) {
				return t;
			}
			if(amount < 0) {
				return t * (t * -amount + 1 + amount);
			}
			return t * ((2 - t) * amount + (1 - amount));
		};
	}
}
nanofl_engine_Ease.__name__ = "nanofl.engine.Ease";
var nanofl_engine_ElementType = $hxEnums["nanofl.engine.ElementType"] = { __ename__:"nanofl.engine.ElementType",__constructs__:null
	,shape: {_hx_name:"shape",_hx_index:0,__enum__:"nanofl.engine.ElementType",toString:$estr}
	,instance: {_hx_name:"instance",_hx_index:1,__enum__:"nanofl.engine.ElementType",toString:$estr}
	,group: {_hx_name:"group",_hx_index:2,__enum__:"nanofl.engine.ElementType",toString:$estr}
	,text: {_hx_name:"text",_hx_index:3,__enum__:"nanofl.engine.ElementType",toString:$estr}
};
nanofl_engine_ElementType.__constructs__ = [nanofl_engine_ElementType.shape,nanofl_engine_ElementType.instance,nanofl_engine_ElementType.group,nanofl_engine_ElementType.text];
class nanofl_engine_FilterDef {
	constructor(name,params) {
		stdlib_Debug.assert(params != null,null,{ fileName : "engine/nanofl/engine/FilterDef.hx", lineNumber : 30, className : "nanofl.engine.FilterDef", methodName : "new"});
		this.name = name;
		this._params = params;
	}
	get_params() {
		if(this.isParamsFixed || !Object.prototype.hasOwnProperty.call(nanofl_engine_plugins_FilterPlugins.plugins.h,this.name)) {
			return this._params;
		}
		this.isParamsFixed = true;
		return nanofl_engine_CustomPropertiesTools.fix(this._params,this.getProperties());
	}
	equ(filter) {
		if(filter.name == this.name) {
			return nanofl_engine_CustomPropertiesTools.equ(filter.get_params(),this.get_params());
		} else {
			return false;
		}
	}
	clone() {
		let r = new nanofl_engine_FilterDef(this.name,Reflect.copy(this._params));
		r.isParamsFixed = this.isParamsFixed;
		return r;
	}
	tween(t,finish) {
		stdlib_Debug.assert(finish == null || this.name == finish.name,this.name + " != " + finish.name,{ fileName : "engine/nanofl/engine/FilterDef.hx", lineNumber : 120, className : "nanofl.engine.FilterDef", methodName : "tween"});
		if(t == 0.0 || !Object.prototype.hasOwnProperty.call(nanofl_engine_plugins_FilterPlugins.plugins.h,this.name)) {
			return this;
		}
		let plugin = nanofl_engine_plugins_FilterPlugins.plugins.h[this.name];
		nanofl_engine_CustomPropertiesTools.tween(this.get_params(),t,finish != null ? finish.get_params() : null,plugin != null ? plugin.properties : null);
		return this;
	}
	getFilter() {
		if(Object.prototype.hasOwnProperty.call(nanofl_engine_plugins_FilterPlugins.plugins.h,this.name)) {
			return nanofl_engine_plugins_FilterPlugins.plugins.h[this.name].getFilter(this.get_params());
		} else {
			return null;
		}
	}
	getProperties() {
		if(Object.prototype.hasOwnProperty.call(nanofl_engine_plugins_FilterPlugins.plugins.h,this.name)) {
			return nanofl_engine_plugins_FilterPlugins.plugins.h[this.name].properties;
		} else {
			return [];
		}
	}
	resetToNeutral() {
		let plugin = nanofl_engine_plugins_FilterPlugins.plugins.h[this.name];
		if(plugin != null) {
			nanofl_engine_CustomPropertiesTools.resetToNeutral(this.get_params(),plugin.properties);
		}
		return this;
	}
	static loadJson(obj,version) {
		return new nanofl_engine_FilterDef(obj.name,obj.params);
	}
}
nanofl_engine_FilterDef.__name__ = "nanofl.engine.FilterDef";
Object.assign(nanofl_engine_FilterDef.prototype, {
	__class__: nanofl_engine_FilterDef
});
class nanofl_engine_FontVariant {
	constructor(style,weight,locals,urls) {
		if(weight == null) {
			weight = 400;
		}
		if(style == null) {
			style = "normal";
		}
		this.style = style;
		this.weight = weight;
		this.locals = locals != null ? locals : [];
		this.urls = urls != null ? urls : new haxe_ds_StringMap();
	}
	equ(e) {
		if(e.style == this.style && e.weight == this.weight) {
			return datatools_MapTools.equFast(e.urls,this.urls);
		} else {
			return false;
		}
	}
}
nanofl_engine_FontVariant.__name__ = "nanofl.engine.FontVariant";
Object.assign(nanofl_engine_FontVariant.prototype, {
	__class__: nanofl_engine_FontVariant
});
class nanofl_engine_IElementsContainer {
}
nanofl_engine_IElementsContainer.__name__ = "nanofl.engine.IElementsContainer";
nanofl_engine_IElementsContainer.__isInterface__ = true;
Object.assign(nanofl_engine_IElementsContainer.prototype, {
	__class__: nanofl_engine_IElementsContainer
});
class nanofl_engine_movieclip_KeyFrame {
	constructor(label,duration,motionTween,elements) {
		if(duration == null) {
			duration = 1;
		}
		if(label == null) {
			label = "";
		}
		this.label = label;
		this.duration = duration;
		this._elements = elements != null ? elements : [];
		let _g = 0;
		let _g1 = this.get_elements();
		while(_g < _g1.length) {
			let element = _g1[_g];
			++_g;
			element.parent = this;
		}
		if(motionTween != null) {
			this.motionTween = motionTween;
			motionTween.keyFrame = this;
		}
	}
	get_elements() {
		return this._elements;
	}
	getNextKeyFrame() {
		return this.layer._keyFrames[this.getKeyIndex() + 1];
	}
	getKeyIndex() {
		return this.layer._keyFrames.indexOf(this);
	}
	addElement(element,index) {
		if(index == null) {
			this._elements.push(element);
		} else {
			this._elements.splice(index,0,element);
		}
		element.parent = this;
	}
	removeElementAt(n) {
		this._elements.splice(n,1);
	}
	removeElement(element) {
		let n = this.get_elements().indexOf(element);
		if(n >= 0) {
			this.removeElementAt(n);
		}
	}
	getTweenedElements(frameSubIndex) {
		if(this.motionTween != null && frameSubIndex != 0) {
			return this.motionTween.apply(frameSubIndex);
		} else {
			let _this = this.get_elements();
			let result = new Array(_this.length);
			let _g = 0;
			let _g1 = _this.length;
			while(_g < _g1) {
				let i = _g++;
				let x = _this[i];
				result[i] = new nanofl_engine_movieclip_TweenedElement(x,x);
			}
			return result;
		}
	}
	setLibrary(library) {
		let _g = 0;
		let _g1 = this.get_elements();
		while(_g < _g1.length) {
			let element = _g1[_g];
			++_g;
			element.setLibrary(library);
		}
	}
	toString() {
		return (this.layer != null ? this.layer.toString() + " / " : "") + "frame";
	}
	getIndex() {
		let r = 0;
		let _g = 0;
		let _g1 = this.getKeyIndex();
		while(_g < _g1) {
			let i = _g++;
			r += this.layer._keyFrames[i].duration;
		}
		return r;
	}
	clone() {
		return this.duplicate();
	}
	hasMotionTween() {
		return this.motionTween != null;
	}
	getGuideLine() {
		return new nanofl_engine_movieclip_GuideLine(this.getShape(false));
	}
	getShape(createIfNotExist) {
		if(this.get_elements().length > 0 && ((this.get_elements()[0]) instanceof nanofl_engine_elements_ShapeElement)) {
			return this.get_elements()[0];
		}
		if(createIfNotExist) {
			let shape = new nanofl_engine_elements_ShapeElement();
			this.addElement(shape,0);
			return shape;
		}
		return null;
	}
	duplicate(label,duration,elements) {
		return new nanofl_engine_movieclip_KeyFrame(label != null ? label : this.label,duration != null ? duration : this.duration,this.motionTween != null ? this.motionTween.clone() : null,elements != null ? datatools_ArrayTools.clone(elements) : datatools_ArrayTools.clone(this._elements));
	}
	equ(keyFrame) {
		if(keyFrame.label != this.label) {
			return false;
		}
		if(keyFrame.duration != this.duration) {
			return false;
		}
		if(keyFrame.motionTween == null && this.motionTween != null) {
			return false;
		}
		if(keyFrame.motionTween != null && this.motionTween == null) {
			return false;
		}
		if(keyFrame.motionTween != null && this.motionTween != null && !keyFrame.motionTween.equ(this.motionTween)) {
			return false;
		}
		if(!datatools_ArrayTools.equ(this.getElementsWithoutEmptyShapes(keyFrame._elements),this.getElementsWithoutEmptyShapes(this._elements))) {
			return false;
		}
		return true;
	}
	getElementsWithoutEmptyShapes(elements) {
		let _g = [];
		let _g1 = 0;
		let _g2 = elements;
		while(_g1 < _g2.length) {
			let v = _g2[_g1];
			++_g1;
			if(!((v) instanceof nanofl_engine_elements_ShapeElement) || !v.isEmpty()) {
				_g.push(v);
			}
		}
		return _g;
	}
	static parseJson(obj,version) {
		return new nanofl_engine_movieclip_KeyFrame(obj.label,obj.duration,nanofl_engine_movieclip_MotionTween.loadJson(obj.motionTween),nanofl_engine_elements_Elements.parseJson(obj.elements,version));
	}
}
nanofl_engine_movieclip_KeyFrame.__name__ = "nanofl.engine.movieclip.KeyFrame";
nanofl_engine_movieclip_KeyFrame.__interfaces__ = [nanofl_engine_IElementsContainer];
Object.assign(nanofl_engine_movieclip_KeyFrame.prototype, {
	__class__: nanofl_engine_movieclip_KeyFrame
});
class nanofl_engine_GroupKeyFrame extends nanofl_engine_movieclip_KeyFrame {
	constructor(group) {
		super(null,null,null,group._elements);
		this.group = group;
		let _g = 0;
		let _g1 = this.get_elements();
		while(_g < _g1.length) {
			let element = _g1[_g];
			++_g;
			element.parent = group;
		}
	}
	addElement(element,index) {
		super.addElement(element,index);
		element.parent = this.group;
	}
	duplicate(label,duration,elements) {
		return stdlib_Debug.methodNotSupported(this,{ fileName : "engine/nanofl/engine/GroupKeyFrame.hx", lineNumber : 24, className : "nanofl.engine.GroupKeyFrame", methodName : "duplicate"});
	}
}
nanofl_engine_GroupKeyFrame.__name__ = "nanofl.engine.GroupKeyFrame";
nanofl_engine_GroupKeyFrame.__super__ = nanofl_engine_movieclip_KeyFrame;
Object.assign(nanofl_engine_GroupKeyFrame.prototype, {
	__class__: nanofl_engine_GroupKeyFrame
});
class nanofl_engine_IFramedItem {
}
nanofl_engine_IFramedItem.__name__ = "nanofl.engine.IFramedItem";
nanofl_engine_IFramedItem.__isInterface__ = true;
class nanofl_engine_ILayersContainer {
}
nanofl_engine_ILayersContainer.__name__ = "nanofl.engine.ILayersContainer";
nanofl_engine_ILayersContainer.__isInterface__ = true;
Object.assign(nanofl_engine_ILayersContainer.prototype, {
	__class__: nanofl_engine_ILayersContainer
});
class nanofl_engine_ILibraryItem {
}
nanofl_engine_ILibraryItem.__name__ = "nanofl.engine.ILibraryItem";
nanofl_engine_ILibraryItem.__isInterface__ = true;
Object.assign(nanofl_engine_ILibraryItem.prototype, {
	__class__: nanofl_engine_ILibraryItem
});
class nanofl_engine_IMotionTween {
}
nanofl_engine_IMotionTween.__name__ = "nanofl.engine.IMotionTween";
nanofl_engine_IMotionTween.__isInterface__ = true;
Object.assign(nanofl_engine_IMotionTween.prototype, {
	__class__: nanofl_engine_IMotionTween
});
class nanofl_engine_IPathElement {
}
nanofl_engine_IPathElement.__name__ = "nanofl.engine.IPathElement";
nanofl_engine_IPathElement.__isInterface__ = true;
nanofl_engine_IPathElement.__interfaces__ = [nanofl_engine_ILayersContainer];
class nanofl_engine_ISelectable {
}
nanofl_engine_ISelectable.__name__ = "nanofl.engine.ISelectable";
nanofl_engine_ISelectable.__isInterface__ = true;
class nanofl_engine_ISpriteSheetableItem {
}
nanofl_engine_ISpriteSheetableItem.__name__ = "nanofl.engine.ISpriteSheetableItem";
nanofl_engine_ISpriteSheetableItem.__isInterface__ = true;
class nanofl_engine_ITextureItem {
}
nanofl_engine_ITextureItem.__name__ = "nanofl.engine.ITextureItem";
nanofl_engine_ITextureItem.__isInterface__ = true;
Object.assign(nanofl_engine_ITextureItem.prototype, {
	__class__: nanofl_engine_ITextureItem
});
class nanofl_engine_ITimeline {
}
nanofl_engine_ITimeline.__name__ = "nanofl.engine.ITimeline";
nanofl_engine_ITimeline.__isInterface__ = true;
var nanofl_engine_LayerType = $hxEnums["nanofl.engine.LayerType"] = { __ename__:"nanofl.engine.LayerType",__constructs__:null
	,normal: {_hx_name:"normal",_hx_index:0,__enum__:"nanofl.engine.LayerType",toString:$estr}
	,mask: {_hx_name:"mask",_hx_index:1,__enum__:"nanofl.engine.LayerType",toString:$estr}
	,folder: {_hx_name:"folder",_hx_index:2,__enum__:"nanofl.engine.LayerType",toString:$estr}
	,guide: {_hx_name:"guide",_hx_index:3,__enum__:"nanofl.engine.LayerType",toString:$estr}
};
nanofl_engine_LayerType.__constructs__ = [nanofl_engine_LayerType.normal,nanofl_engine_LayerType.mask,nanofl_engine_LayerType.folder,nanofl_engine_LayerType.guide];
class nanofl_engine_LayersTools {
	static addLayer(obj,layer) {
		layer.layersContainer = obj;
		obj._layers.push(layer);
	}
	static addLayersBlock(obj,layersToAdd,index) {
		if(index == null || index < 0 || index > obj._layers.length) {
			index = obj._layers.length;
		}
		let _g = 0;
		let _g1 = obj._layers;
		while(_g < _g1.length) {
			let layer = _g1[_g];
			++_g;
			if(layer.parentIndex != null && layer.parentIndex >= index) {
				layer.parentIndex += layersToAdd.length;
			}
		}
		let n = index;
		let _g2 = 0;
		while(_g2 < layersToAdd.length) {
			let layer = layersToAdd[_g2];
			++_g2;
			layer.layersContainer = obj;
			if(layer.parentIndex != null) {
				layer.parentIndex += index;
			}
			obj._layers.splice(n,0,layer);
			++n;
		}
	}
	static getTotalFrames(obj) {
		let r = 0;
		let _g = 0;
		let _g1 = obj.get_layers();
		while(_g < _g1.length) {
			let layer = _g1[_g];
			++_g;
			let b = layer.getTotalFrames();
			if(r <= b) {
				r = b;
			}
		}
		return r;
	}
}
nanofl_engine_LayersTools.__name__ = "nanofl.engine.LayersTools";
class nanofl_engine_Library {
	constructor(libraryDir,items) {
		this.items = new haxe_ds_StringMap();
		this.libraryDir = libraryDir;
		if(items != null) {
			let _g = 0;
			let _g1 = items;
			while(_g < _g1.length) {
				let item = _g1[_g];
				++_g;
				this.addItem(item);
			}
		}
	}
	addItem(item) {
		item.setLibrary(this);
		this.items.h[item.namePath] = item;
		this.ensureFolderOfItemExists(item.namePath);
	}
	removeItem(namePath) {
		let _g = 0;
		let _g1 = this.getItemsInFolder(namePath);
		while(_g < _g1.length) {
			let item = _g1[_g];
			++_g;
			this.removeItemInner(item.namePath);
		}
		this.removeItemInner(namePath);
	}
	removeItemInner(namePath) {
		let itemToRemove = this.getItem(namePath);
		let _this = this.items;
		if(Object.prototype.hasOwnProperty.call(_this.h,namePath)) {
			delete(_this.h[namePath]);
		}
		if(((itemToRemove) instanceof nanofl_engine_libraryitems_InstancableItem)) {
			let instances = [];
			let h = this.items.h;
			let item_h = h;
			let item_keys = Object.keys(h);
			let item_length = item_keys.length;
			let item_current = 0;
			while(item_current < item_length) {
				let item = item_h[item_keys[item_current++]];
				if(((item) instanceof nanofl_engine_libraryitems_MovieClipItem)) {
					nanofl_engine_MovieClipItemTools.iterateInstances(item,true,null,function(instance,_) {
						if(instance.namePath == namePath) {
							instances.push(instance);
						}
					});
				}
			}
			let _g = 0;
			while(_g < instances.length) {
				let instance = instances[_g];
				++_g;
				instance.parent.removeElement(instance);
			}
		}
	}
	getItem(namePath) {
		stdlib_Debug.assert(namePath != null,null,{ fileName : "engine/nanofl/engine/Library.hx", lineNumber : 73, className : "nanofl.engine.Library", methodName : "getItem"});
		stdlib_Debug.assert(namePath != "",null,{ fileName : "engine/nanofl/engine/Library.hx", lineNumber : 74, className : "nanofl.engine.Library", methodName : "getItem"});
		let r = this.items.h[namePath];
		if(r != null) {
			return r;
		}
		$global.console.warn("Symbol '" + namePath + "' is not found.");
		return this.createItemOnItemNotFound(namePath);
	}
	getItems(includeScene) {
		let namePaths = stdlib_LambdaIterator.array(new haxe_ds__$StringMap_StringMapKeyIterator(this.items.h));
		if(!includeScene) {
			let _g = [];
			let _g1 = 0;
			let _g2 = namePaths;
			while(_g1 < _g2.length) {
				let v = _g2[_g1];
				++_g1;
				if(v != nanofl_engine_Library.SCENE_NAME_PATH) {
					_g.push(v);
				}
			}
			namePaths = _g;
		}
		namePaths.sort(function(a,b) {
			return Reflect.compare(a.toLowerCase(),b.toLowerCase());
		});
		let _gthis = this;
		let result = new Array(namePaths.length);
		let _g = 0;
		let _g1 = namePaths.length;
		while(_g < _g1) {
			let i = _g++;
			result[i] = _gthis.items.h[namePaths[i]];
		}
		return result;
	}
	hasItem(namePath) {
		return Object.prototype.hasOwnProperty.call(this.items.h,namePath);
	}
	realUrl(url) {
		if(url.indexOf("//") >= 0) {
			return url;
		}
		return this.libraryDir + "/" + url;
	}
	preload() {
		let r = Promise.resolve();
		let h = this.items.h;
		let item_h = h;
		let item_keys = Object.keys(h);
		let item_length = item_keys.length;
		let item_current = 0;
		while(item_current < item_length) {
			let item = item_h[item_keys[item_current++]];
			r = r.then(function(_) {
				return item.preload();
			});
		}
		return r;
	}
	ensureFolderOfItemExists(namePath) {
		let parts = namePath.split("/");
		let _g = 1;
		let _g1 = parts.length;
		while(_g < _g1) {
			let i = _g++;
			let folder = parts.slice(0,i).join("/");
			if(!this.hasItem(folder)) {
				this.addItem(new nanofl_engine_libraryitems_FolderItem(folder));
			}
		}
	}
	createItemOnItemNotFound(namePath) {
		return nanofl_engine_libraryitems_MovieClipItem.createWithFrame(namePath,[new nanofl_engine_elements_TextElement("",0,0,false,true,[new nanofl_TextRun("Symbol '" + namePath + "' is not found.")])],"temp");
	}
	getItemsInFolder(folderNamePath) {
		if(((this.items.h[folderNamePath]) instanceof nanofl_engine_libraryitems_FolderItem)) {
			let _g = [];
			let _g1 = 0;
			let _g2 = this.getItems();
			while(_g1 < _g2.length) {
				let v = _g2[_g1];
				++_g1;
				if(v.namePath.startsWith(folderNamePath + "/")) {
					_g.push(v);
				}
			}
			return _g;
		}
		return [];
	}
	getSceneItem() {
		return js_Boot.__cast(this.items.h[nanofl_engine_Library.SCENE_NAME_PATH] , nanofl_engine_libraryitems_MovieClipItem);
	}
	getSceneInstance() {
		return this.getSceneItem().newInstance();
	}
	static loadFromJson(libraryDir,obj) {
		let _this = Reflect.fields(obj);
		let result = new Array(_this.length);
		let _g = 0;
		let _g1 = _this.length;
		while(_g < _g1) {
			let i = _g++;
			let namePath = _this[i];
			result[i] = nanofl_engine_libraryitems_LibraryItem.loadFromJson(namePath,Reflect.field(obj,namePath));
		}
		let items = result;
		return new nanofl_engine_Library(libraryDir,items);
	}
}
nanofl_engine_Library.__name__ = "nanofl.engine.Library";
Object.assign(nanofl_engine_Library.prototype, {
	__class__: nanofl_engine_Library
});
var nanofl_engine_LibraryItemType = $hxEnums["nanofl.engine.LibraryItemType"] = { __ename__:"nanofl.engine.LibraryItemType",__constructs__:null
	,bitmap: {_hx_name:"bitmap",_hx_index:0,__enum__:"nanofl.engine.LibraryItemType",toString:$estr}
	,folder: {_hx_name:"folder",_hx_index:1,__enum__:"nanofl.engine.LibraryItemType",toString:$estr}
	,font: {_hx_name:"font",_hx_index:2,__enum__:"nanofl.engine.LibraryItemType",toString:$estr}
	,mesh: {_hx_name:"mesh",_hx_index:3,__enum__:"nanofl.engine.LibraryItemType",toString:$estr}
	,movieclip: {_hx_name:"movieclip",_hx_index:4,__enum__:"nanofl.engine.LibraryItemType",toString:$estr}
	,sound: {_hx_name:"sound",_hx_index:5,__enum__:"nanofl.engine.LibraryItemType",toString:$estr}
};
nanofl_engine_LibraryItemType.__constructs__ = [nanofl_engine_LibraryItemType.bitmap,nanofl_engine_LibraryItemType.folder,nanofl_engine_LibraryItemType.font,nanofl_engine_LibraryItemType.mesh,nanofl_engine_LibraryItemType.movieclip,nanofl_engine_LibraryItemType.sound];
class nanofl_engine_Loader {
	static image(url) {
		return new Promise(function(resolve,reject) {
			let image = new Image();
			image.onload = function(_) {
				resolve(image);
			};
			image.onerror = function(_) {
				nanofl_engine_Debug.console.error("Failed to load '" + url + "'.");
				image.src = "data:image/gif;base64,R0lGODlhAQABAIAAAP///wAAACwAAAAAAQABAAACAkQBADs=";
				reject(new Error("Failed to load '" + url + "'."));
			};
			image.src = url;
		});
	}
	static file(url) {
		return new Promise(function(resolve,reject) {
			let xmlhttp = new XMLHttpRequest();
			xmlhttp.responseType = "text";
			xmlhttp.onreadystatechange = function() {
				if(xmlhttp.readyState == 4) {
					if(xmlhttp.status == 200) {
						resolve(xmlhttp.responseText);
					} else {
						nanofl_engine_Debug.console.error(new Error("Failed to load '" + url + "': " + xmlhttp.status + " / " + xmlhttp.statusText + "."));
						reject(new Error("Failed to load '" + url + "': " + xmlhttp.status + " / " + xmlhttp.statusText + "."));
					}
				}
			};
			xmlhttp.open("GET",url,true);
			xmlhttp.send();
		});
	}
	static javaScript(url) {
		return new Promise(function(resolve,reject) {
			let elem = window.document.createElement("script");
			elem.type = "text/javascript";
			elem.async = true;
			elem.src = url;
			elem.addEventListener("load",function(_) {
				elem.remove();
				resolve(null);
			});
			elem.addEventListener("error",function(e) {
				elem.remove();
				nanofl_engine_Debug.console.error(new Error("Failed to load '" + url + "'."));
				reject(new Error("Failed to load '" + url + "'."));
			});
			window.document.head.appendChild(elem);
		});
	}
}
nanofl_engine_Loader.__name__ = "nanofl.engine.Loader";
class nanofl_engine_MeshParams {
	constructor() {
		this.directionalLightRotationY = 0.0;
		this.directionalLightRotationX = 0.0;
		this.directionalLightColor = "#808080";
		this.ambientLightColor = "#E0E0E0";
		this.cameraFov = 70;
		this.rotationY = 0.0;
		this.rotationX = 0.0;
	}
	equ(obj) {
		if(obj.rotationX == this.rotationX && obj.rotationY == this.rotationY && obj.cameraFov == this.cameraFov && obj.ambientLightColor == this.ambientLightColor && obj.directionalLightColor == this.directionalLightColor && obj.directionalLightRotationX == this.directionalLightRotationX) {
			return obj.directionalLightRotationY == this.directionalLightRotationY;
		} else {
			return false;
		}
	}
	clone() {
		let r = new nanofl_engine_MeshParams();
		r.rotationX = this.rotationX;
		r.rotationY = this.rotationY;
		r.cameraFov = this.cameraFov;
		r.ambientLightColor = this.ambientLightColor;
		r.directionalLightColor = this.directionalLightColor;
		r.directionalLightRotationX = this.directionalLightRotationX;
		r.directionalLightRotationY = this.directionalLightRotationY;
		return r;
	}
	applyToMesh(mesh) {
		mesh.rotationX = this.rotationX;
		mesh.rotationY = this.rotationY;
		mesh.camera.fov = this.cameraFov;
		let tmp = nanofl_engine_ColorTools.stringToNumber(this.ambientLightColor);
		mesh.ambientLight.color = new THREE_Color(tmp);
		let tmp1 = nanofl_engine_ColorTools.stringToNumber(this.directionalLightColor);
		mesh.directionalLight.color = new THREE_Color(tmp1);
		mesh.directionalLight.setRotationFromEuler(new THREE_Euler(this.directionalLightRotationX * Math.PI / 180,this.directionalLightRotationY * Math.PI / 180));
	}
	static loadJson(obj) {
		let r = new nanofl_engine_MeshParams();
		let tmp = obj.rotationX;
		r.rotationX = tmp != null ? tmp : r.rotationX;
		let tmp1 = obj.rotationY;
		r.rotationY = tmp1 != null ? tmp1 : r.rotationY;
		let tmp2 = obj.cameraFov;
		r.cameraFov = tmp2 != null ? tmp2 : r.cameraFov;
		let tmp3 = obj.ambientLightColor;
		r.ambientLightColor = tmp3 != null ? tmp3 : r.ambientLightColor;
		let tmp4 = obj.directionalLightColor;
		r.directionalLightColor = tmp4 != null ? tmp4 : r.directionalLightColor;
		let tmp5 = obj.directionalLightRotationX;
		r.directionalLightRotationX = tmp5 != null ? tmp5 : r.directionalLightRotationX;
		let tmp6 = obj.directionalLightRotationY;
		r.directionalLightRotationY = tmp6 != null ? tmp6 : r.directionalLightRotationY;
		return r;
	}
}
nanofl_engine_MeshParams.__name__ = "nanofl.engine.MeshParams";
Object.assign(nanofl_engine_MeshParams.prototype, {
	__class__: nanofl_engine_MeshParams
});
class nanofl_engine_MovieClipItemTools {
	static iterateInstances(item,allFrames,insideMask,callb) {
		if(insideMask == null) {
			insideMask = false;
		}
		nanofl_engine_MovieClipItemTools.iterateElements(item,allFrames,insideMask,function(element,e) {
			if(((element) instanceof nanofl_engine_elements_Instance)) {
				callb(element,e);
			}
		});
	}
	static iterateElements(item,allFrames,insideMask,callb) {
		if(insideMask == null) {
			insideMask = false;
		}
		let _g = 0;
		let _g1 = item.get_layers().length;
		while(_g < _g1) {
			let layerIndex = _g++;
			let layer = item.get_layers()[layerIndex];
			if(layer._keyFrames.length > 0) {
				let localInsideMask = insideMask || layer.type == nanofl_engine_LayerType.mask;
				let _g = 0;
				let _g1 = allFrames ? layer._keyFrames.length : 1;
				while(_g < _g1) {
					let keyFrameIndex = _g++;
					let keyFrame = layer._keyFrames[keyFrameIndex];
					let _g1 = 0;
					let _g2 = nanofl_engine_elements_Elements.expandGroups(keyFrame.get_elements());
					while(_g1 < _g2.length) {
						let element = _g2[_g1];
						++_g1;
						callb(element,{ keyFrameIndex : keyFrameIndex, layerIndex : layerIndex, insideMask : localInsideMask});
					}
				}
			}
		}
	}
}
nanofl_engine_MovieClipItemTools.__name__ = "nanofl.engine.MovieClipItemTools";
class nanofl_engine_ScaleMode {
}
nanofl_engine_ScaleMode.__name__ = "nanofl.engine.ScaleMode";
class nanofl_engine_SerializationAsJsTools {
	static load(library,namePath,removeAfterLoad) {
		return nanofl_engine_Loader.javaScript(library.realUrl(namePath + ".js")).then(function(_) {
			if(!window.nanofl) {
				throw new Error("Global `nanofl` is not found.");
			}
			if(!window.nanofl.libraryFiles) {
				throw new Error("Global `nanofl.libraryFiles` is not found.");
			}
			let libraryFiles = window.nanofl.libraryFiles;
			let r = libraryFiles[namePath];
			if(typeof(r) == "undefined") {
				throw new Error("Global `nanofl.libraryFiles[\"" + namePath + "\"]` is not found.");
			}
			if(removeAfterLoad) {
				Reflect.deleteField(libraryFiles,namePath);
			}
			return r;
		});
	}
}
nanofl_engine_SerializationAsJsTools.__name__ = "nanofl.engine.SerializationAsJsTools";
class nanofl_engine_TextureAtlasTools {
	static getSpriteSheet(item) {
		if(item.textureAtlas != null && item.textureAtlas != "" && Object.prototype.hasOwnProperty.call(nanofl_Player.spriteSheets,item.namePath)) {
			return Reflect.field(nanofl_Player.spriteSheets,item.namePath);
		} else {
			return null;
		}
	}
	static resolveImages(textureAtlasesData) {
		if(textureAtlasesData == null) {
			return Promise.resolve(null);
		}
		let urlToImageStruct = new haxe_ds_StringMap();
		let _g = 0;
		while(_g < textureAtlasesData.length) {
			let textureAtlasData = textureAtlasesData[_g];
			++_g;
			let _g1 = 0;
			let _g2 = Reflect.fields(textureAtlasData);
			while(_g1 < _g2.length) {
				let namePath = _g2[_g1];
				++_g1;
				let spriteSheetData = Reflect.field(textureAtlasData,namePath);
				let _g = 0;
				let _g3 = spriteSheetData.images;
				while(_g < _g3.length) {
					let url = _g3[_g];
					++_g;
					if(typeof(url) == "string" && !Object.prototype.hasOwnProperty.call(urlToImageStruct.h,url)) {
						let value = nanofl_engine_TextureAtlasTools.resolveImage(url);
						urlToImageStruct.h[url] = value;
					}
				}
			}
		}
		return Promise.all(Lambda.array(urlToImageStruct)).then(function(data) {
			let urlToImage = stdlib_LambdaArray.toMapOneInner(data,function(x) {
				return x.url;
			},function(x) {
				return x.image;
			});
			let _g = 0;
			while(_g < textureAtlasesData.length) {
				let textureAtlasData = textureAtlasesData[_g];
				++_g;
				let _g1 = 0;
				let _g2 = Reflect.fields(textureAtlasData);
				while(_g1 < _g2.length) {
					let namePath = _g2[_g1];
					++_g1;
					let spriteSheetData = Reflect.field(textureAtlasData,namePath);
					let _this = spriteSheetData.images;
					let result = new Array(_this.length);
					let _g = 0;
					let _g3 = _this.length;
					while(_g < _g3) {
						let i = _g++;
						let x = _this[i];
						let tmp = urlToImage.get(x);
						result[i] = tmp != null ? tmp : x;
					}
					spriteSheetData.images = result;
				}
			}
			return null;
		});
	}
	static resolveImage(url) {
		return nanofl_engine_Loader.javaScript(url).then(function(_) {
			let name = haxe_io_Path.withoutDirectory(haxe_io_Path.withoutExtension(url));
			let pngDataAsBase64 = window.nanofl.textureAtlasImageFiles[name + ".png"];
			window.nanofl.textureAtlasImageFiles[name + ".png"] = null;
			return nanofl_engine_Loader.image("data:image/png;base64," + pngDataAsBase64).then(function(image) {
				return { url : url, image : image};
			});
		});
	}
}
nanofl_engine_TextureAtlasTools.__name__ = "nanofl.engine.TextureAtlasTools";
class nanofl_engine_coloreffects_ColorEffect {
	static loadJson(obj) {
		let _g = obj != null ? obj.type : null;
		if(_g == null) {
			return null;
		} else {
			switch(_g) {
			case "advanced":
				return nanofl_engine_coloreffects_ColorEffectAdvanced.loadJson(obj);
			case "alpha":
				return nanofl_engine_coloreffects_ColorEffectAlpha.loadJson(obj);
			case "brightness":
				return nanofl_engine_coloreffects_ColorEffectBrightness.loadJson(obj);
			case "tint":
				return nanofl_engine_coloreffects_ColorEffectTint.loadJson(obj);
			default:
				return null;
			}
		}
	}
}
nanofl_engine_coloreffects_ColorEffect.__name__ = "nanofl.engine.coloreffects.ColorEffect";
Object.assign(nanofl_engine_coloreffects_ColorEffect.prototype, {
	__class__: nanofl_engine_coloreffects_ColorEffect
});
class nanofl_engine_coloreffects_ColorEffectAdvanced extends nanofl_engine_coloreffects_ColorEffect {
	constructor(alphaMultiplier,redMultiplier,greenMultiplier,blueMultiplier,alphaOffset,redOffset,greenOffset,blueOffset) {
		super();
		this.alphaMultiplier = alphaMultiplier;
		this.redMultiplier = redMultiplier;
		this.greenMultiplier = greenMultiplier;
		this.blueMultiplier = blueMultiplier;
		this.alphaOffset = alphaOffset;
		this.redOffset = redOffset;
		this.greenOffset = greenOffset;
		this.blueOffset = blueOffset;
	}
	apply(obj) {
		if(obj.filters == null) {
			obj.filters = [];
		}
		obj.filters.push(new createjs.ColorFilter(this.redMultiplier,this.greenMultiplier,this.blueMultiplier,this.alphaMultiplier,this.redOffset,this.greenOffset,this.blueOffset,this.alphaOffset));
	}
	clone() {
		return new nanofl_engine_coloreffects_ColorEffectAdvanced(this.alphaMultiplier,this.redMultiplier,this.greenMultiplier,this.blueMultiplier,this.alphaOffset,this.redOffset,this.greenOffset,this.blueOffset);
	}
	getNeutralClone() {
		return new nanofl_engine_coloreffects_ColorEffectAdvanced(1,1,1,1,0,0,0,0);
	}
	getTweened(k,finish) {
		stdlib_Debug.assert(((finish) instanceof nanofl_engine_coloreffects_ColorEffectAdvanced),null,{ fileName : "engine/nanofl/engine/coloreffects/ColorEffectAdvanced.hx", lineNumber : 128, className : "nanofl.engine.coloreffects.ColorEffectAdvanced", methodName : "getTweened"});
		return new nanofl_engine_coloreffects_ColorEffectAdvanced(this.alphaMultiplier + (finish.alphaMultiplier - this.alphaMultiplier) * k,this.redMultiplier + (finish.redMultiplier - this.redMultiplier) * k,this.greenMultiplier + (finish.greenMultiplier - this.greenMultiplier) * k,this.blueMultiplier + (finish.blueMultiplier - this.blueMultiplier) * k,this.alphaOffset + (finish.alphaOffset - this.alphaOffset) * k,this.redOffset + (finish.redOffset - this.redOffset) * k,this.greenOffset + (finish.greenOffset - this.greenOffset) * k,this.blueOffset + (finish.blueOffset - this.blueOffset) * k);
	}
	equ(c) {
		if(((c) instanceof nanofl_engine_coloreffects_ColorEffectAdvanced) && this.redMultiplier == c.redMultiplier && this.greenMultiplier == c.greenMultiplier && this.blueMultiplier == c.blueMultiplier && this.alphaMultiplier == c.alphaMultiplier && this.redOffset == c.redOffset && this.greenOffset == c.greenOffset && this.blueOffset == c.blueOffset) {
			return this.alphaOffset == c.alphaOffset;
		} else {
			return false;
		}
	}
	static loadJson(obj) {
		let tmp = obj.alphaMultiplier;
		let tmp1 = obj.redMultiplier;
		let tmp2 = obj.greenMultiplier;
		let tmp3 = obj.blueMultiplier;
		let tmp4 = obj.alphaOffset;
		let tmp5 = obj.redOffset;
		let tmp6 = obj.greenOffset;
		let tmp7 = obj.blueOffset;
		return new nanofl_engine_coloreffects_ColorEffectAdvanced(tmp != null ? tmp : 1.0,tmp1 != null ? tmp1 : 1.0,tmp2 != null ? tmp2 : 1.0,tmp3 != null ? tmp3 : 1.0,tmp4 != null ? tmp4 : 0.0,tmp5 != null ? tmp5 : 0.0,tmp6 != null ? tmp6 : 0.0,tmp7 != null ? tmp7 : 0.0);
	}
}
nanofl_engine_coloreffects_ColorEffectAdvanced.__name__ = "nanofl.engine.coloreffects.ColorEffectAdvanced";
nanofl_engine_coloreffects_ColorEffectAdvanced.__super__ = nanofl_engine_coloreffects_ColorEffect;
Object.assign(nanofl_engine_coloreffects_ColorEffectAdvanced.prototype, {
	__class__: nanofl_engine_coloreffects_ColorEffectAdvanced
});
class nanofl_engine_coloreffects_ColorEffectAlpha extends nanofl_engine_coloreffects_ColorEffect {
	constructor(value) {
		super();
		this.value = value;
	}
	apply(obj) {
		obj.alpha = this.value;
	}
	clone() {
		return new nanofl_engine_coloreffects_ColorEffectAlpha(this.value);
	}
	getNeutralClone() {
		return new nanofl_engine_coloreffects_ColorEffectAlpha(1);
	}
	getTweened(k,finish) {
		return new nanofl_engine_coloreffects_ColorEffectAlpha(this.value + ((js_Boot.__cast(finish , nanofl_engine_coloreffects_ColorEffectAlpha)).value - this.value) * k);
	}
	equ(c) {
		if(((c) instanceof nanofl_engine_coloreffects_ColorEffectAlpha)) {
			return this.value == c.value;
		} else {
			return false;
		}
	}
	static loadJson(obj) {
		let tmp = obj.value;
		return new nanofl_engine_coloreffects_ColorEffectAlpha(tmp != null ? tmp : 1.0);
	}
}
nanofl_engine_coloreffects_ColorEffectAlpha.__name__ = "nanofl.engine.coloreffects.ColorEffectAlpha";
nanofl_engine_coloreffects_ColorEffectAlpha.__super__ = nanofl_engine_coloreffects_ColorEffect;
Object.assign(nanofl_engine_coloreffects_ColorEffectAlpha.prototype, {
	__class__: nanofl_engine_coloreffects_ColorEffectAlpha
});
class nanofl_engine_coloreffects_ColorEffectBrightness extends nanofl_engine_coloreffects_ColorEffect {
	constructor(value) {
		super();
		this.value = value;
	}
	apply(obj) {
		if(obj.filters == null) {
			obj.filters = [];
		}
		if(this.value > 0) {
			obj.filters.push(new createjs.ColorFilter(1,1,1,1,this.value * 255,this.value * 255,this.value * 255,0));
		} else if(this.value < 0) {
			obj.filters.push(new createjs.ColorFilter(1 + this.value,1 + this.value,1 + this.value,1,0,0,0,0));
		}
	}
	clone() {
		return new nanofl_engine_coloreffects_ColorEffectBrightness(this.value);
	}
	getNeutralClone() {
		return new nanofl_engine_coloreffects_ColorEffectBrightness(0);
	}
	getTweened(k,finish) {
		return new nanofl_engine_coloreffects_ColorEffectBrightness(this.value + ((js_Boot.__cast(finish , nanofl_engine_coloreffects_ColorEffectBrightness)).value - this.value) * k);
	}
	equ(c) {
		if(((c) instanceof nanofl_engine_coloreffects_ColorEffectBrightness)) {
			return this.value == c.value;
		} else {
			return false;
		}
	}
	static loadJson(obj) {
		let tmp = obj.value;
		return new nanofl_engine_coloreffects_ColorEffectBrightness(tmp != null ? tmp : 0.0);
	}
}
nanofl_engine_coloreffects_ColorEffectBrightness.__name__ = "nanofl.engine.coloreffects.ColorEffectBrightness";
nanofl_engine_coloreffects_ColorEffectBrightness.__super__ = nanofl_engine_coloreffects_ColorEffect;
Object.assign(nanofl_engine_coloreffects_ColorEffectBrightness.prototype, {
	__class__: nanofl_engine_coloreffects_ColorEffectBrightness
});
class nanofl_engine_coloreffects_ColorEffectDouble extends nanofl_engine_coloreffects_ColorEffect {
	constructor(effect0,effect1) {
		super();
		this.effect0 = effect0;
		this.effect1 = effect1;
	}
	apply(obj) {
		this.effect0.apply(obj);
		this.effect1.apply(obj);
	}
	equ(c) {
		if(((c) instanceof nanofl_engine_coloreffects_ColorEffectDouble) && this.effect0.equ(c.effect0)) {
			return this.effect1.equ(c.effect1);
		} else {
			return false;
		}
	}
	clone() {
		return new nanofl_engine_coloreffects_ColorEffectDouble(this.effect0.clone(),this.effect1.clone());
	}
	getNeutralClone() {
		return new nanofl_engine_coloreffects_ColorEffectDouble(this.effect0.getNeutralClone(),this.effect1.getNeutralClone());
	}
	getTweened(k,finish) {
		return new nanofl_engine_coloreffects_ColorEffectDouble(this.effect0.getTweened(k,finish.effect0),this.effect1.getTweened(k,finish.effect1));
	}
}
nanofl_engine_coloreffects_ColorEffectDouble.__name__ = "nanofl.engine.coloreffects.ColorEffectDouble";
nanofl_engine_coloreffects_ColorEffectDouble.__super__ = nanofl_engine_coloreffects_ColorEffect;
Object.assign(nanofl_engine_coloreffects_ColorEffectDouble.prototype, {
	__class__: nanofl_engine_coloreffects_ColorEffectDouble
});
class nanofl_engine_coloreffects_ColorEffectTint extends nanofl_engine_coloreffects_ColorEffect {
	constructor(color,multiplier) {
		super();
		this.color = color;
		this.multiplier = multiplier;
	}
	apply(obj) {
		let rgb = nanofl_engine_ColorTools.parse(this.color);
		if(obj.filters == null) {
			obj.filters = [];
		}
		obj.filters.push(new createjs.ColorFilter(1 - this.multiplier,1 - this.multiplier,1 - this.multiplier,1,rgb.r * this.multiplier,rgb.g * this.multiplier,rgb.b * this.multiplier,0));
	}
	clone() {
		return new nanofl_engine_coloreffects_ColorEffectTint(this.color,this.multiplier);
	}
	getNeutralClone() {
		return new nanofl_engine_coloreffects_ColorEffectTint(this.color,0);
	}
	getTweened(k,finish) {
		return new nanofl_engine_coloreffects_ColorEffectTint(nanofl_engine_ColorTools.getTweened(this.color,k,(js_Boot.__cast(finish , nanofl_engine_coloreffects_ColorEffectTint)).color),this.multiplier + ((js_Boot.__cast(finish , nanofl_engine_coloreffects_ColorEffectTint)).multiplier - this.multiplier) * k);
	}
	equ(c) {
		if(((c) instanceof nanofl_engine_coloreffects_ColorEffectTint) && this.color == c.color) {
			return this.multiplier == c.multiplier;
		} else {
			return false;
		}
	}
	static loadJson(obj) {
		let tmp = obj.multiplier;
		return new nanofl_engine_coloreffects_ColorEffectTint(obj.color,tmp != null ? tmp : 1.0);
	}
}
nanofl_engine_coloreffects_ColorEffectTint.__name__ = "nanofl.engine.coloreffects.ColorEffectTint";
nanofl_engine_coloreffects_ColorEffectTint.__super__ = nanofl_engine_coloreffects_ColorEffect;
Object.assign(nanofl_engine_coloreffects_ColorEffectTint.prototype, {
	__class__: nanofl_engine_coloreffects_ColorEffectTint
});
class nanofl_engine_elements_Element {
	constructor() {
		if(nanofl_engine_elements_Element._hx_skip_constructor) {
			return;
		}
		this._hx_constructor();
	}
	_hx_constructor() {
		this.regY = 0.0;
		this.regX = 0.0;
		this.matrix = new nanofl_engine_geom_Matrix();
		this.visible = true;
	}
	setLibrary(library) {
	}
	toString() {
		let c = js_Boot.getClass(this);
		let className = c.__name__;
		className = HxOverrides.substr(className,className.lastIndexOf(".") + 1,null);
		let parents = this.parent != null ? this.parent.toString() : "";
		if(parents.endsWith(" / layer / frame")) {
			parents = parents.substring(0,parents.length - " / layer / frame".length);
		}
		return (parents != "" ? parents + " / " : "") + className;
	}
	loadPropertiesJson(obj,version) {
		this.matrix = nanofl_engine_geom_Matrix.loadJson(obj);
		let tmp = obj.regX;
		this.regX = tmp != null ? tmp : 0.0;
		let tmp1 = obj.regY;
		this.regY = tmp1 != null ? tmp1 : 0.0;
		return true;
	}
	copyBaseProperties(obj) {
		obj.parent = this.parent;
		obj.visible = this.visible;
		obj.matrix = this.matrix.clone();
		obj.regX = this.regX;
		obj.regY = this.regY;
	}
	updateDisplayObjectProperties(dispObj) {
		dispObj.visible = this.visible;
		dispObj.set(this.matrix.decompose());
		dispObj.filters = [];
		dispObj.setBounds(null,null,null,null);
		dispObj.uncache();
	}
	equ(element) {
		if(js_Boot.getClass(element) != js_Boot.getClass(this)) {
			return false;
		}
		if(element.visible != this.visible) {
			return false;
		}
		if(!element.matrix.equ(this.matrix)) {
			return false;
		}
		if(element.regX != this.regX) {
			return false;
		}
		if(element.regY != this.regY) {
			return false;
		}
		return true;
	}
	static parseJson(obj,version) {
		let element;
		switch(Type.createEnum(nanofl_engine_ElementType,obj.type,null)._hx_index) {
		case 0:
			element = new nanofl_engine_elements_ShapeElement();
			break;
		case 1:
			element = new nanofl_engine_elements_Instance(null);
			break;
		case 2:
			element = new nanofl_engine_elements_GroupElement([]);
			break;
		case 3:
			element = new nanofl_engine_elements_TextElement(null,null,null,null,null,null);
			break;
		}
		if(element != null) {
			element.visible = true;
			if(!element.loadPropertiesJson(obj,version)) {
				return null;
			}
			stdlib_Debug.assert(element.matrix != null,null,{ fileName : "engine/nanofl/engine/elements/Element.hx", lineNumber : 96, className : "nanofl.engine.elements.Element", methodName : "parseJson"});
		}
		return element;
	}
}
nanofl_engine_elements_Element.__name__ = "nanofl.engine.elements.Element";
Object.assign(nanofl_engine_elements_Element.prototype, {
	__class__: nanofl_engine_elements_Element
});
class nanofl_engine_elements_Elements {
	static parseJson(obj,version) {
		let elements = [];
		let _g = 0;
		while(_g < obj.length) {
			let itemObj = obj[_g];
			++_g;
			let element = nanofl_engine_elements_Element.parseJson(itemObj,version);
			if(element != null) {
				elements.push(element);
			}
		}
		return elements;
	}
	static expandGroups(elements) {
		let r = [];
		let _g = 0;
		let _g1 = elements;
		while(_g < _g1.length) {
			let element = _g1[_g];
			++_g;
			if(((element) instanceof nanofl_engine_elements_GroupElement)) {
				r = r.concat(nanofl_engine_elements_Elements.expandGroups(element.getChildren()));
			} else {
				r.push(element);
			}
		}
		return r;
	}
}
nanofl_engine_elements_Elements.__name__ = "nanofl.engine.elements.Elements";
class nanofl_engine_elements_GroupElement extends nanofl_engine_elements_Element {
	constructor(elements) {
		nanofl_engine_elements_Element._hx_skip_constructor = true;
		super();
		nanofl_engine_elements_Element._hx_skip_constructor = false;
		this._hx_constructor(elements);
	}
	_hx_constructor(elements) {
		this.name = "";
		super._hx_constructor();
		this._elements = elements != null ? elements : [];
		let _g = 0;
		let _g1 = this.get_elements();
		while(_g < _g1.length) {
			let element = _g1[_g];
			++_g;
			element.parent = this;
		}
	}
	get_elements() {
		return this._elements;
	}
	get_layers() {
		if(this._layers == null) {
			let layer = new nanofl_engine_movieclip_Layer("auto");
			layer.layersContainer = this;
			layer.addKeyFrame(new nanofl_engine_GroupKeyFrame(this));
			this._layers = [layer];
		}
		return this._layers;
	}
	removeElementAt(n) {
		this._elements.splice(n,1);
	}
	removeElement(element) {
		let n = this.get_elements().indexOf(element);
		if(n >= 0) {
			this.removeElementAt(n);
		}
	}
	loadPropertiesJson(obj,version) {
		if(!super.loadPropertiesJson(obj,version)) {
			return false;
		}
		let tmp = obj.name;
		this.name = tmp != null ? tmp : "";
		this._elements = nanofl_engine_elements_Elements.parseJson(obj.elements,version);
		return this.get_elements().length > 0;
	}
	clone() {
		let obj = new nanofl_engine_elements_GroupElement(datatools_ArrayTools.clone(this._elements));
		this.copyBaseProperties(obj);
		obj.name = this.name;
		return obj;
	}
	setLibrary(library) {
		let _g = 0;
		let _g1 = this.get_elements();
		while(_g < _g1.length) {
			let element = _g1[_g];
			++_g;
			element.setLibrary(library);
		}
	}
	getChildren() {
		return this.get_elements();
	}
	createDisplayObject(frameIndexes) {
		return this.updateDisplayObject(new createjs.Container(),frameIndexes);
	}
	updateDisplayObject(dispObj,frameIndexes) {
		stdlib_Debug.assert(((dispObj) instanceof createjs.Container),this.toString(),{ fileName : "engine/nanofl/engine/elements/GroupElement.hx", lineNumber : 140, className : "nanofl.engine.elements.GroupElement", methodName : "updateDisplayObject"});
		stdlib_Debug.assert(this.get_elements().length > 0,this.toString(),{ fileName : "engine/nanofl/engine/elements/GroupElement.hx", lineNumber : 141, className : "nanofl.engine.elements.GroupElement", methodName : "updateDisplayObject"});
		if(frameIndexes != null && frameIndexes.length > 0 && frameIndexes[0].element == this) {
			frameIndexes = frameIndexes.slice(1);
		} else {
			frameIndexes = null;
		}
		this.updateDisplayObjectProperties(dispObj);
		let container = dispObj;
		container.removeAllChildren();
		let topElement = null;
		let _g = 0;
		let _g1 = this.get_elements();
		while(_g < _g1.length) {
			let element = _g1[_g];
			++_g;
			if(frameIndexes == null || frameIndexes.length == 0 || frameIndexes[0].element != element) {
				container.addChild(element.createDisplayObject(frameIndexes));
			} else if(frameIndexes != null && frameIndexes.length != 0 && frameIndexes[0].element == element) {
				topElement = element;
			}
		}
		if(topElement != null) {
			container.addChild(topElement.createDisplayObject(frameIndexes));
		}
		return container;
	}
	equ(element) {
		if(!super.equ(element)) {
			return false;
		}
		if(element.name != this.name) {
			return false;
		}
		if(!datatools_ArrayTools.equ(element._elements,this._elements)) {
			return false;
		}
		return true;
	}
}
nanofl_engine_elements_GroupElement.__name__ = "nanofl.engine.elements.GroupElement";
nanofl_engine_elements_GroupElement.__interfaces__ = [nanofl_engine_IElementsContainer,nanofl_engine_IPathElement];
nanofl_engine_elements_GroupElement.__super__ = nanofl_engine_elements_Element;
Object.assign(nanofl_engine_elements_GroupElement.prototype, {
	__class__: nanofl_engine_elements_GroupElement
});
class nanofl_engine_elements_Instance extends nanofl_engine_elements_Element {
	constructor(namePath,name,colorEffect,filters,blendMode,meshParams) {
		super();
		this.namePath = namePath;
		this.name = name;
		this.colorEffect = colorEffect;
		let tmp = filters;
		this.filters = tmp != null ? tmp : [];
		let tmp1 = blendMode;
		this.blendMode = tmp1 != null ? tmp1 : "normal";
		let tmp2 = meshParams;
		this.meshParams = tmp2 != null ? tmp2 : new nanofl_engine_MeshParams();
	}
	get_symbol() {
		return js_Boot.__cast(this.library.getItem(this.namePath) , nanofl_engine_libraryitems_InstancableItem);
	}
	loadPropertiesJson(obj,version) {
		if(!super.loadPropertiesJson(obj,version)) {
			return false;
		}
		this.namePath = obj.libraryItem;
		stdlib_Debug.assert(this.namePath != null,null,{ fileName : "engine/nanofl/engine/elements/Instance.hx", lineNumber : 74, className : "nanofl.engine.elements.Instance", methodName : "loadPropertiesJson"});
		stdlib_Debug.assert(this.namePath != "",null,{ fileName : "engine/nanofl/engine/elements/Instance.hx", lineNumber : 75, className : "nanofl.engine.elements.Instance", methodName : "loadPropertiesJson"});
		let tmp = obj.name;
		this.name = tmp != null ? tmp : "";
		this.colorEffect = nanofl_engine_coloreffects_ColorEffect.loadJson(obj.colorEffect);
		let tmp1 = obj.filters;
		let _this = tmp1 != null ? tmp1 : [];
		let result = new Array(_this.length);
		let _g = 0;
		let _g1 = _this.length;
		while(_g < _g1) {
			let i = _g++;
			result[i] = nanofl_engine_FilterDef.loadJson(_this[i],version);
		}
		this.filters = result;
		let tmp2 = obj.blendMode;
		this.blendMode = tmp2 != null ? tmp2 : "normal";
		this.meshParams = obj.meshParams != null ? nanofl_engine_MeshParams.loadJson(obj.meshParams) : null;
		return true;
	}
	clone() {
		let obj = new nanofl_engine_elements_Instance(this.namePath,this.name,datatools_NullTools.clone(this.colorEffect),datatools_ArrayTools.clone(this.filters),this.blendMode,datatools_NullTools.clone(this.meshParams));
		obj.library = this.library;
		this.copyBaseProperties(obj);
		return obj;
	}
	toString() {
		return (this.parent != null ? this.parent.toString() + " / " : "") + "Instance(" + this.namePath + ")";
	}
	get_layers() {
		if(js_Boot.__implements(this.get_symbol(),nanofl_engine_ILayersContainer)) {
			return this.get_symbol().get_layers();
		} else {
			return null;
		}
	}
	createDisplayObject(frameIndexes) {
		let initFrameIndex = 0;
		if(frameIndexes != null && frameIndexes.length > 0 && frameIndexes[0].element == this) {
			initFrameIndex = frameIndexes[0].frameIndex;
			frameIndexes = frameIndexes.slice(1);
		} else {
			frameIndexes = null;
		}
		let dispObj = this.get_symbol().createDisplayObject(initFrameIndex,frameIndexes);
		this.updateDisplayObjectProperties(dispObj);
		this.updateDisplayObjectInstanceProperties(dispObj);
		return dispObj;
	}
	updateDisplayObject(dispObj,frameIndexes) {
		this.updateDisplayObjectProperties(dispObj);
		this.get_symbol().updateDisplayObject(dispObj,frameIndexes);
		this.updateDisplayObjectInstanceProperties(dispObj);
		return dispObj;
	}
	updateDisplayObjectInstanceProperties(dispObj) {
		if(dispObj.filters == null) {
			dispObj.filters = [];
		}
		dispObj.alpha = 1.0;
		if(this.colorEffect != null) {
			this.colorEffect.apply(dispObj);
		}
		let _g = 0;
		let _g1 = this.filters;
		while(_g < _g1.length) {
			let filter = _g1[_g];
			++_g;
			let f = filter.getFilter();
			if(f != null) {
				dispObj.filters.push(f);
			}
		}
		if(this.name != "") {
			dispObj.name = this.name;
		}
		dispObj.compositeOperation = this.blendMode;
		if(this.meshParams != null && ((dispObj) instanceof nanofl_Mesh)) {
			this.meshParams.applyToMesh(dispObj);
		}
	}
	setLibrary(library) {
		this.library = library;
	}
	equ(element) {
		if(!super.equ(element)) {
			return false;
		}
		if(element.namePath != this.namePath) {
			return false;
		}
		if(element.name != this.name) {
			return false;
		}
		if(!datatools_NullTools.equ(element.colorEffect,this.colorEffect)) {
			return false;
		}
		if(!datatools_ArrayTools.equ(element.filters,this.filters)) {
			return false;
		}
		if(element.blendMode != this.blendMode) {
			return false;
		}
		if(!datatools_NullTools.equ(element.meshParams,this.meshParams)) {
			return false;
		}
		return true;
	}
	getFilters() {
		return this.filters;
	}
	setFilters(filters) {
		this.filters = filters;
	}
}
nanofl_engine_elements_Instance.__name__ = "nanofl.engine.elements.Instance";
nanofl_engine_elements_Instance.__interfaces__ = [nanofl_engine_IPathElement];
nanofl_engine_elements_Instance.__super__ = nanofl_engine_elements_Element;
Object.assign(nanofl_engine_elements_Instance.prototype, {
	__class__: nanofl_engine_elements_Instance
});
class nanofl_engine_elements_ShapeElement extends nanofl_engine_elements_Element {
	constructor(edges,polygons,isNormalize) {
		if(isNormalize == null) {
			isNormalize = true;
		}
		super();
		this.edges = edges != null ? edges : [];
		this.polygons = polygons != null ? polygons : [];
		if(isNormalize) {
			this.normalize();
		}
	}
	loadPropertiesJson(obj,version) {
		if(!super.loadPropertiesJson(obj,version)) {
			return false;
		}
		let fills = [];
		let strokes = [];
		let _g = 0;
		let tmp = obj.fills;
		let _g1 = tmp != null ? tmp : [];
		while(_g < _g1.length) {
			let fillObj = _g1[_g];
			++_g;
			let tmp = fillObj.type;
			switch(tmp != null ? tmp : "solid") {
			case "bitmap":
				fills.push(nanofl_engine_fills_BitmapFill.loadJson(fillObj,version));
				break;
			case "linear":
				fills.push(nanofl_engine_fills_LinearFill.loadJson(fillObj,version));
				break;
			case "radial":
				fills.push(nanofl_engine_fills_RadialFill.loadJson(fillObj,version));
				break;
			case "solid":
				fills.push(nanofl_engine_fills_SolidFill.loadJson(fillObj,version));
				break;
			default:
				nanofl_engine_elements_ShapeElement.log(function() {
					return "Unknow fill type '" + Std.string(fillObj.type) + "'.";
				},{ fileName : "engine/nanofl/engine/elements/ShapeElement.hx", lineNumber : 109, className : "nanofl.engine.elements.ShapeElement", methodName : "loadPropertiesJson"});
			}
		}
		let _g2 = 0;
		let tmp1 = obj.strokes;
		let _g3 = tmp1 != null ? tmp1 : [];
		while(_g2 < _g3.length) {
			let strokeObj = _g3[_g2];
			++_g2;
			strokes.push(nanofl_engine_strokes_BaseStroke.loadJson(strokeObj,version));
		}
		if(obj.figure != null) {
			this.edges = nanofl_engine_geom_StrokeEdges.loadJson(obj.figure.edges,strokes,version);
			let _this = obj.figure.polygons;
			let result = new Array(_this.length);
			let _g = 0;
			let _g1 = _this.length;
			while(_g < _g1) {
				let i = _g++;
				result[i] = nanofl_engine_geom_Polygon.loadJson(_this[i],fills,version);
			}
			this.polygons = result;
		}
		this.ensureNoTransform();
		return true;
	}
	ensureNoTransform() {
		this.transform(this.matrix);
		this.matrix.tx = 0;
		this.matrix.ty = 0;
		this.matrix.a = 1;
		this.matrix.b = 0;
		this.matrix.c = 0;
		this.matrix.d = 1;
	}
	draw(g,scaleSelection) {
		let _g = 0;
		let _g1 = this.polygons;
		while(_g < _g1.length) {
			let p = _g1[_g];
			++_g;
			p.draw(g,scaleSelection);
		}
		nanofl_engine_geom_StrokeEdges.drawSorted(this.edges,g,scaleSelection);
	}
	createDisplayObject(frameIndexes) {
		return this.updateDisplayObject(new createjs.Shape(),null);
	}
	updateDisplayObject(dispObj,frameIndexes) {
		stdlib_Debug.assert(((dispObj) instanceof createjs.Shape),null,{ fileName : "engine/nanofl/engine/elements/ShapeElement.hx", lineNumber : 241, className : "nanofl.engine.elements.ShapeElement", methodName : "updateDisplayObject"});
		this.updateDisplayObjectProperties(dispObj);
		let shape = dispObj;
		shape.graphics.clear();
		let m = dispObj.getConcatenatedMatrix().invert();
		this.draw(shape.graphics,(m.a + m.d) / 2);
		if(!this.isEmpty()) {
			let b = this.getBounds();
			shape.setBounds(b.minX,b.minY,b.maxX - b.minX,b.maxY - b.minY);
		}
		return shape;
	}
	clone() {
		let obj = new nanofl_engine_elements_ShapeElement(datatools_ArrayTools.clone(this.edges),datatools_ArrayTools.clone(this.polygons));
		this.copyBaseProperties(obj);
		return obj;
	}
	isEmpty() {
		if(this.edges.length == 0) {
			return this.polygons.length == 0;
		} else {
			return false;
		}
	}
	getNearestStrokeEdge(pt) {
		let r = { edge : null, dist : 1e100, point : null, t : 0.0};
		let _g = 0;
		let _g1 = this.edges;
		while(_g < _g1.length) {
			let edge = _g1[_g];
			++_g;
			let pointAndT = new nanofl_engine_geom_Edge(edge.x1,edge.y1,edge.x2,edge.y2,edge.x3,edge.y3).getNearestPoint(pt.x,pt.y);
			let b = pointAndT.point;
			let dist = nanofl_engine_geom_PointTools.getDist(pt.x,pt.y,b.x,b.y);
			if(dist < r.dist) {
				r.edge = edge;
				r.dist = dist;
				r.point = pointAndT.point;
				r.t = pointAndT.t;
			}
		}
		if(r.edge != null) {
			return r;
		} else {
			return null;
		}
	}
	getBounds(bounds,useStrokeThickness) {
		if(useStrokeThickness == null) {
			useStrokeThickness = true;
		}
		if(this.edges.length > 0 || this.polygons.length > 0) {
			if(bounds == null) {
				bounds = { minX : 1e100, minY : 1e100, maxX : -1e100, maxY : -1e100};
			}
			if(useStrokeThickness) {
				nanofl_engine_geom_StrokeEdges.getBounds(this.edges,bounds);
			} else {
				nanofl_engine_geom_Edges.getBounds(this.edges,bounds);
			}
			let _g = 0;
			let _g1 = this.polygons;
			while(_g < _g1.length) {
				let polygon = _g1[_g];
				++_g;
				polygon.getBounds(bounds);
			}
		}
		return bounds;
	}
	transform(m,applyToStrokeAndFill) {
		if(applyToStrokeAndFill == null) {
			applyToStrokeAndFill = true;
		}
		if(m.isIdentity()) {
			return;
		}
		let _g = 0;
		let _g1 = this.edges;
		while(_g < _g1.length) {
			let edge = _g1[_g];
			++_g;
			edge.transform(m,applyToStrokeAndFill);
		}
		let _g2 = 0;
		let _g3 = this.polygons;
		while(_g2 < _g3.length) {
			let polygon = _g3[_g2];
			++_g2;
			polygon.transform(m,applyToStrokeAndFill);
		}
		this.normalize();
	}
	normalize() {
		nanofl_engine_geom_Edges.normalize(this.edges);
		nanofl_engine_geom_Polygons.normalize(this.polygons);
	}
	setLibrary(library) {
		let _g = 0;
		let _g1 = this.edges;
		while(_g < _g1.length) {
			let edge = _g1[_g];
			++_g;
			edge.stroke.setLibrary(library);
		}
		let _g2 = 0;
		let _g3 = this.polygons;
		while(_g2 < _g3.length) {
			let polygon = _g3[_g2];
			++_g2;
			polygon.fill.setLibrary(library);
		}
	}
	equ(element) {
		if(!super.equ(element)) {
			return false;
		}
		if(!datatools_ArrayTools.equ(element.edges,this.edges)) {
			return false;
		}
		if(!datatools_ArrayTools.equ(element.polygons,this.polygons)) {
			return false;
		}
		return true;
	}
	toString() {
		return (this.parent != null ? this.parent.toString() + " / " : "") + "Shape";
	}
	static log(v,infos) {
	}
}
nanofl_engine_elements_ShapeElement.__name__ = "nanofl.engine.elements.ShapeElement";
nanofl_engine_elements_ShapeElement.__super__ = nanofl_engine_elements_Element;
Object.assign(nanofl_engine_elements_ShapeElement.prototype, {
	__class__: nanofl_engine_elements_ShapeElement
});
class nanofl_engine_elements_TextElement extends nanofl_engine_elements_Element {
	constructor(name,width,height,selectable,border,textRuns,newTextFormat) {
		super();
		this.name = name;
		this.width = width;
		this.height = height;
		this.selectable = selectable;
		this.border = border;
		this.textRuns = textRuns;
		this.newTextFormat = newTextFormat != null ? newTextFormat : new nanofl_TextRun();
	}
	loadPropertiesJson(obj,version) {
		if(!super.loadPropertiesJson(obj,version)) {
			return false;
		}
		let tmp = obj.name;
		this.name = tmp != null ? tmp : "";
		let tmp1 = obj.width;
		this.width = tmp1 != null ? tmp1 : 0.0;
		let tmp2 = obj.height;
		this.height = tmp2 != null ? tmp2 : 0.0;
		let tmp3 = obj.selectable;
		this.selectable = tmp3 != null && tmp3;
		let tmp4 = obj.border;
		this.border = tmp4 != null && tmp4;
		let _gthis = this;
		let _this = obj.textRuns;
		let result = new Array(_this.length);
		let _g = 0;
		let _g1 = _this.length;
		while(_g < _g1) {
			let i = _g++;
			result[i] = _gthis.loadTextRunJson(_this[i]);
		}
		let _g2 = [];
		let _g3 = 0;
		let _g4 = result;
		while(_g3 < _g4.length) {
			let v = _g4[_g3];
			++_g3;
			if(!stdlib_StringTools.isNullOrEmpty(v.characters)) {
				_g2.push(v);
			}
		}
		this.textRuns = _g2;
		this.newTextFormat = this.loadTextRunJson(obj.newTextFormat);
		return true;
	}
	loadTextRunJson(obj) {
		let tmp = obj.fillColor;
		let tmp1 = obj.family;
		let tmp2 = obj.style;
		let tmp3 = obj.size;
		let tmp4 = obj.align;
		let tmp5 = obj.strokeSize;
		let tmp6 = obj.strokeColor;
		let tmp7 = obj.kerning;
		let tmp8 = obj.letterSpacing;
		let tmp9 = obj.lineSpacing;
		return nanofl_TextRun.create(obj.characters,tmp != null ? tmp : "#000000",tmp1 != null ? tmp1 : "Times",tmp2 != null ? tmp2 : "",tmp3 != null ? tmp3 : 12.0,tmp4 != null ? tmp4 : "left",tmp5 != null ? tmp5 : 0.0,tmp6 != null ? tmp6 : "#000000",tmp7 != null ? tmp7 : true,tmp8 != null ? tmp8 : 0.0,tmp9 != null ? tmp9 : 2.0);
	}
	createDisplayObject(frameIndexes) {
		let dispObj = new nanofl_TextField();
		this.updateDisplayObject(dispObj,null);
		if(this.name != "") {
			dispObj.name = this.name;
		}
		return dispObj;
	}
	updateDisplayObject(dispObj,frameIndexes) {
		stdlib_Debug.assert(((dispObj) instanceof nanofl_TextField),null,{ fileName : "engine/nanofl/engine/elements/TextElement.hx", lineNumber : 212, className : "nanofl.engine.elements.TextElement", methodName : "updateDisplayObject"});
		this.updateDisplayObjectProperties(dispObj);
		let tf = dispObj;
		tf.width = this.width;
		tf.height = this.height;
		tf.selectable = this.selectable;
		tf.border = this.border;
		tf.textRuns = datatools_ArrayTools.clone(this.textRuns);
		tf.newTextFormat = this.newTextFormat;
		tf.setBounds(0.5,0.5,this.width,this.height);
		return tf;
	}
	equ(element) {
		if(!super.equ(element)) {
			return false;
		}
		if(element.name != this.name) {
			return false;
		}
		if(element.width != this.width) {
			return false;
		}
		if(element.height != this.height) {
			return false;
		}
		if(element.selectable != this.selectable) {
			return false;
		}
		if(element.border != this.border) {
			return false;
		}
		if(!datatools_ArrayTools.equ(element.textRuns,this.textRuns)) {
			return false;
		}
		if(!element.newTextFormat.equ(this.newTextFormat)) {
			return false;
		}
		return true;
	}
	clone() {
		let obj = new nanofl_engine_elements_TextElement(this.name,this.width,this.height,this.selectable,this.border,datatools_ArrayTools.clone(this.textRuns),this.newTextFormat.clone());
		this.copyBaseProperties(obj);
		return obj;
	}
}
nanofl_engine_elements_TextElement.__name__ = "nanofl.engine.elements.TextElement";
nanofl_engine_elements_TextElement.__super__ = nanofl_engine_elements_Element;
Object.assign(nanofl_engine_elements_TextElement.prototype, {
	__class__: nanofl_engine_elements_TextElement
});
class nanofl_engine_fills_BaseFill {
}
nanofl_engine_fills_BaseFill.__name__ = "nanofl.engine.fills.BaseFill";
class nanofl_engine_fills_IFill {
}
nanofl_engine_fills_IFill.__name__ = "nanofl.engine.fills.IFill";
nanofl_engine_fills_IFill.__isInterface__ = true;
Object.assign(nanofl_engine_fills_IFill.prototype, {
	__class__: nanofl_engine_fills_IFill
});
class nanofl_engine_fills_BitmapFill extends nanofl_engine_fills_BaseFill {
	constructor(bitmapPath,repeat,matrix) {
		super();
		this.bitmapPath = bitmapPath;
		this.repeat = repeat;
		this.matrix = matrix;
	}
	clone() {
		let r = new nanofl_engine_fills_BitmapFill(this.bitmapPath,this.repeat,this.matrix.clone());
		r.library = this.library;
		return r;
	}
	begin(g) {
		if(this.library.hasItem(this.bitmapPath)) {
			let image = (js_Boot.__cast(this.library.getItem(this.bitmapPath) , nanofl_engine_libraryitems_BitmapItem)).image;
			g.beginBitmapFill(image,this.repeat,this.matrix.toNative());
		} else {
			g.beginFill("rgba(0,0,0,0)");
		}
	}
	equ(e) {
		if(e == this) {
			return true;
		}
		if(((e) instanceof nanofl_engine_fills_BitmapFill)) {
			let ee = e;
			if(ee.bitmapPath == this.bitmapPath && ee.matrix.equ(this.matrix)) {
				return ee.repeat == this.repeat;
			} else {
				return false;
			}
		}
		return false;
	}
	setLibrary(library) {
		this.library = library;
	}
	getTransformed(m) {
		let r = this.clone();
		r.matrix.prependMatrix(m);
		return r;
	}
	static loadJson(obj,version) {
		let tmp = obj.repeat;
		return new nanofl_engine_fills_BitmapFill(obj.bitmapPath,tmp != null ? tmp : "repeat",nanofl_engine_geom_Matrix.loadJson(obj));
	}
}
nanofl_engine_fills_BitmapFill.__name__ = "nanofl.engine.fills.BitmapFill";
nanofl_engine_fills_BitmapFill.__interfaces__ = [nanofl_engine_fills_IFill];
nanofl_engine_fills_BitmapFill.__super__ = nanofl_engine_fills_BaseFill;
Object.assign(nanofl_engine_fills_BitmapFill.prototype, {
	__class__: nanofl_engine_fills_BitmapFill
});
class nanofl_engine_fills_LinearFill extends nanofl_engine_fills_BaseFill {
	constructor(colors,ratios,x0,y0,x1,y1) {
		super();
		this.colors = colors;
		this.ratios = ratios;
		this.x0 = x0;
		this.y0 = y0;
		this.x1 = x1;
		this.y1 = y1;
	}
	clone() {
		return new nanofl_engine_fills_LinearFill(this.colors.slice(),this.ratios.slice(),this.x0,this.y0,this.x1,this.y1);
	}
	begin(g) {
		g.beginLinearGradientFill(this.colors,this.ratios,this.x0,this.y0,this.x1,this.y1);
	}
	equ(e) {
		if(e == this) {
			return true;
		}
		if(((e) instanceof nanofl_engine_fills_LinearFill)) {
			let ee = e;
			if(this.arrEqu(ee.colors,this.colors) && this.arrEqu(ee.ratios,this.ratios) && ee.x0 == this.x0 && ee.y0 == this.y0 && ee.x1 == this.x1) {
				return ee.y1 == this.y1;
			} else {
				return false;
			}
		}
		return false;
	}
	arrEqu(a,b) {
		if(a.length != b.length) {
			return false;
		}
		let _g = 0;
		let _g1 = a.length;
		while(_g < _g1) {
			let i = _g++;
			if(a[i] != b[i]) {
				return false;
			}
		}
		return true;
	}
	setLibrary(library) {
	}
	getTransformed(m) {
		let r = this.clone();
		let p0 = m.transformPoint(this.x0,this.y0);
		r.x0 = p0.x;
		r.y0 = p0.y;
		let p1 = m.transformPoint(this.x1,this.y1);
		r.x1 = p1.x;
		r.y1 = p1.y;
		return r;
	}
	static loadJson(obj,version) {
		let tmp = obj.colors;
		let tmp1 = obj.ratios;
		let tmp2 = obj.x0;
		let tmp3 = obj.y0;
		let tmp4 = obj.x1;
		let tmp5 = obj.y1;
		return new nanofl_engine_fills_LinearFill(tmp != null ? tmp : [],tmp1 != null ? tmp1 : [0.0],tmp2 != null ? tmp2 : 0.0,tmp3 != null ? tmp3 : 0.0,tmp4 != null ? tmp4 : 0.0,tmp5 != null ? tmp5 : 0.0);
	}
}
nanofl_engine_fills_LinearFill.__name__ = "nanofl.engine.fills.LinearFill";
nanofl_engine_fills_LinearFill.__interfaces__ = [nanofl_engine_fills_IFill];
nanofl_engine_fills_LinearFill.__super__ = nanofl_engine_fills_BaseFill;
Object.assign(nanofl_engine_fills_LinearFill.prototype, {
	__class__: nanofl_engine_fills_LinearFill
});
class nanofl_engine_fills_RadialFill extends nanofl_engine_fills_BaseFill {
	constructor(colors,ratios,cx,cy,r,fx,fy) {
		super();
		this.colors = colors;
		this.ratios = ratios;
		this.cx = cx;
		this.cy = cy;
		this.r = r;
		this.fx = fx;
		this.fy = fy;
	}
	clone() {
		return new nanofl_engine_fills_RadialFill(this.colors.slice(),this.ratios.slice(),this.cx,this.cy,this.r,this.fx,this.fy);
	}
	begin(g) {
		g.beginRadialGradientFill(this.colors,this.ratios,this.fx,this.fy,0,this.cx,this.cy,this.r);
	}
	equ(e) {
		if(e == this) {
			return true;
		}
		if(((e) instanceof nanofl_engine_fills_RadialFill)) {
			let ee = e;
			if(this.arrEqu(ee.colors,this.colors) && this.arrEqu(ee.ratios,this.ratios) && ee.cx == this.cx && ee.cy == this.cy && ee.r == this.r && ee.fx == this.fx) {
				return ee.fy == this.fy;
			} else {
				return false;
			}
		}
		return false;
	}
	arrEqu(a,b) {
		if(a.length != b.length) {
			return false;
		}
		let _g = 0;
		let _g1 = a.length;
		while(_g < _g1) {
			let i = _g++;
			if(a[i] != b[i]) {
				return false;
			}
		}
		return true;
	}
	setLibrary(library) {
	}
	getTransformed(m) {
		let fill = this.clone();
		let c = m.transformPoint(this.cx,this.cy);
		fill.cx = c.x;
		fill.cy = c.y;
		let f = m.transformPoint(this.fx,this.fy);
		fill.fx = f.x;
		fill.fy = f.y;
		fill.r *= m.getAverageScale();
		return fill;
	}
	static loadJson(obj,version) {
		let tmp = obj.cx;
		let cx = tmp != null ? tmp : 0.0;
		let tmp1 = obj.cy;
		let cy = tmp1 != null ? tmp1 : 0.0;
		let tmp2 = obj.colors;
		let tmp3 = obj.ratios;
		let tmp4 = obj.r;
		let tmp5 = obj.fx;
		let tmp6 = obj.fy;
		return new nanofl_engine_fills_RadialFill(tmp2 != null ? tmp2 : [],tmp3 != null ? tmp3 : [0.0],cx,cy,tmp4 != null ? tmp4 : 0.0,tmp5 != null ? tmp5 : cx,tmp6 != null ? tmp6 : cy);
	}
}
nanofl_engine_fills_RadialFill.__name__ = "nanofl.engine.fills.RadialFill";
nanofl_engine_fills_RadialFill.__interfaces__ = [nanofl_engine_fills_IFill];
nanofl_engine_fills_RadialFill.__super__ = nanofl_engine_fills_BaseFill;
Object.assign(nanofl_engine_fills_RadialFill.prototype, {
	__class__: nanofl_engine_fills_RadialFill
});
class nanofl_engine_fills_SolidFill extends nanofl_engine_fills_BaseFill {
	constructor(color) {
		super();
		this.color = color;
	}
	clone() {
		return new nanofl_engine_fills_SolidFill(this.color);
	}
	setLibrary(library) {
	}
	getTransformed(m) {
		return this;
	}
	begin(g) {
		g.beginFill(this.color);
	}
	equ(e) {
		if(e == this) {
			return true;
		}
		if(((e) instanceof nanofl_engine_fills_SolidFill)) {
			let ee = e;
			return ee.color == this.color;
		}
		return false;
	}
	static loadJson(obj,version) {
		let tmp = obj.color;
		return new nanofl_engine_fills_SolidFill(tmp != null ? tmp : "#000000");
	}
}
nanofl_engine_fills_SolidFill.__name__ = "nanofl.engine.fills.SolidFill";
nanofl_engine_fills_SolidFill.__interfaces__ = [nanofl_engine_fills_IFill];
nanofl_engine_fills_SolidFill.__super__ = nanofl_engine_fills_BaseFill;
Object.assign(nanofl_engine_fills_SolidFill.prototype, {
	__class__: nanofl_engine_fills_SolidFill
});
class nanofl_engine_geom_BezierCurve {
	constructor(x1,y1,x2,y2,x3,y3) {
		this.p1 = { x : x1, y : y1};
		this.p2 = { x : x2, y : y2};
		this.p3 = { x : x3, y : y3};
	}
	getNearestPoint(x,y) {
		let Ax = this.p2.x - this.p1.x;
		let Ay = this.p2.y - this.p1.y;
		let Bx = this.p1.x - 2 * this.p2.x + this.p3.x;
		let By = this.p1.y - 2 * this.p2.y + this.p3.y;
		let dx = this.p1.x - x;
		let dy = this.p1.y - y;
		let sol = nanofl_engine_geom_Equation.solveCube(Bx * Bx + By * By,3 * (Ax * Bx + Ay * By),2 * (Ax * Ax + Ay * Ay) + dx * Bx + dy * By,dx * Ax + dy * Ay);
		let d1 = nanofl_engine_geom_PointTools.getSqrDist(x,y,this.p1.x,this.p1.y);
		let d3 = nanofl_engine_geom_PointTools.getSqrDist(x,y,this.p3.x,this.p3.y);
		if(sol.length > 0) {
			let tMin = null;
			let distMin = 1.0e100;
			let pointMin = null;
			let _g = 0;
			while(_g < sol.length) {
				let t = sol[_g];
				++_g;
				if(t >= 0 && t <= 1) {
					let pt = this.getPoint(t);
					let dist = nanofl_engine_geom_PointTools.getSqrDist(x,y,pt.x,pt.y);
					if(dist < distMin) {
						tMin = t;
						distMin = dist;
						pointMin = pt;
					}
				}
			}
			if(tMin != null && distMin < d1 && distMin < d3) {
				let nor = { x : Ay + tMin * By, y : -(Ax + tMin * Bx)};
				nanofl_engine_geom_PointTools.normalize(nor);
				let dist = Math.sqrt(distMin);
				let orientedDist = dist;
				if((x - pointMin.x) * nor.x + (y - pointMin.y) * nor.y < 0) {
					nor.x *= -1;
					nor.y *= -1;
					orientedDist *= -1;
				}
				return { t : tMin, point : pointMin, nor : nor, dist : dist, orientedDist : orientedDist};
			}
		}
		if(d1 < d3) {
			let dist = Math.sqrt(d1);
			return { t : 0, point : nanofl_engine_geom_PointTools.clone(this.p1), nor : nanofl_engine_geom_PointTools.normalize({ x : x - this.p1.x, y : y - this.p1.y}), dist : dist, orientedDist : dist};
		} else {
			let dist = Math.sqrt(d3);
			return { t : 1, point : nanofl_engine_geom_PointTools.clone(this.p3), nor : nanofl_engine_geom_PointTools.normalize({ x : x - this.p3.x, y : y - this.p3.y}), dist : dist, orientedDist : dist};
		}
	}
	getPoint(t) {
		if(t == 0) {
			return nanofl_engine_geom_PointTools.clone(this.p1);
		}
		if(t == 1) {
			return nanofl_engine_geom_PointTools.clone(this.p3);
		}
		let z = 1 - t;
		let a = z * z;
		let b = 2 * t * z;
		let c = t * t;
		return { x : a * this.p1.x + b * this.p2.x + c * this.p3.x, y : a * this.p1.y + b * this.p2.y + c * this.p3.y};
	}
	getBounds() {
		let r = { minX : Math.min(this.p1.x,Math.min(this.p2.x,this.p3.x)), maxX : Math.max(this.p1.x,Math.max(this.p2.x,this.p3.x)), minY : Math.min(this.p1.y,Math.min(this.p2.y,this.p3.y)), maxY : Math.max(this.p1.y,Math.max(this.p2.y,this.p3.y))};
		let Ax = this.p2.x - this.p1.x;
		let Ay = this.p2.y - this.p1.y;
		let Bx = this.p1.x - 2 * this.p2.x + this.p3.x;
		let By = this.p1.y - 2 * this.p2.y + this.p3.y;
		if(Math.abs(Bx) > 1e-10 && (r.minX == this.p2.x || r.maxX == this.p2.x)) {
			let u = -Ax / Bx;
			u = (1 - u) * (1 - u) * this.p1.x + 2 * u * (1 - u) * this.p2.x + u * u * this.p3.x;
			if(r.minX == this.p2.x) {
				r.minX = u;
			} else {
				r.maxX = u;
			}
		}
		if(Math.abs(By) > 1e-10 && (r.minY == this.p2.y || r.maxY == this.p2.y)) {
			let u = -Ay / By;
			u = (1 - u) * (1 - u) * this.p1.y + 2 * u * (1 - u) * this.p2.y + u * u * this.p3.y;
			if(r.minY == this.p2.y) {
				r.minY = u;
			} else {
				r.maxY = u;
			}
		}
		return r;
	}
	isDegenerated() {
		if(nanofl_engine_geom_PointTools.equ(this.p1,this.p2)) {
			return nanofl_engine_geom_PointTools.equ(this.p2,this.p3);
		} else {
			return false;
		}
	}
	getFirstPart(t) {
		let m = this.getPoint(t);
		return new nanofl_engine_geom_BezierCurve(this.p1.x,this.p1.y,this.p1.x + t * (this.p2.x - this.p1.x),this.p1.y + t * (this.p2.y - this.p1.y),m.x,m.y);
	}
	getLength() {
		let Ax = this.p2.x - this.p1.x;
		let Ay = this.p2.y - this.p1.y;
		let Bx = this.p1.x - 2 * this.p2.x + this.p3.x;
		let By = this.p1.y - 2 * this.p2.y + this.p3.y;
		let ax2 = 2 * Ax;
		let ay2 = 2 * Ay;
		let a = 4 * (Bx * Bx + By * By);
		let b = 4 * (Bx * ax2 + By * ay2);
		let c = ax2 * ax2 + ay2 * ay2;
		let z1 = 2 * Math.sqrt(a + b + c);
		let z2 = Math.sqrt(a);
		let z3 = 2 * a * z2;
		let z4 = 2 * Math.sqrt(c);
		let z5 = b / z2;
		return (z3 * z1 + z2 * b * (z1 - z4) + (4 * c * a - b * b) * Math.log((2 * z2 + z5 + z1) / (z5 + z4))) / (4 * z3);
	}
	getTangent(t) {
		let Cx = (this.p2.x - this.p1.x) * t + this.p1.x;
		let Cy = (this.p2.y - this.p1.y) * t + this.p1.y;
		let Dx = (this.p3.x - this.p2.x) * t + this.p2.x;
		let Dy = (this.p3.y - this.p2.y) * t + this.p2.y;
		return Math.atan2(Dy - Cy,Dx - Cx);
	}
	getMonotoneT(k) {
		if(k == 0) {
			return 0;
		}
		if(k == 1) {
			return 1;
		}
		let eps = 0.005;
		let need = this.getLength() * k;
		let t = 0.5;
		let d = 0.5;
		while(true) {
			let part = this.getFirstPart(t);
			let len = part.getLength();
			if(Math.abs(need - len) < eps) {
				return t;
			}
			d /= 2;
			if(need < len) {
				t -= d;
			} else {
				t += d;
			}
		}
	}
}
nanofl_engine_geom_BezierCurve.__name__ = "nanofl.engine.geom.BezierCurve";
Object.assign(nanofl_engine_geom_BezierCurve.prototype, {
	__class__: nanofl_engine_geom_BezierCurve
});
class nanofl_engine_geom_BoundsTools {
	static extend(bounds,b) {
		bounds.minX = Math.min(bounds.minX,b.minX);
		bounds.minY = Math.min(bounds.minY,b.minY);
		bounds.maxX = Math.max(bounds.maxX,b.maxX);
		bounds.maxY = Math.max(bounds.maxY,b.maxY);
		return bounds;
	}
	static clone(bounds) {
		if(bounds == null) {
			return null;
		}
		return { minX : bounds.minX, minY : bounds.minY, maxX : bounds.maxX, maxY : bounds.maxY};
	}
	static transform(bounds,matrix) {
		if(bounds == null) {
			return null;
		}
		let x_a = bounds.width * matrix.a;
		let x_b = bounds.width * matrix.b;
		let y_c = bounds.height * matrix.c;
		let y_d = bounds.height * matrix.d;
		let tx = matrix.tx + (bounds.x * matrix.a + bounds.y * matrix.c);
		let ty = matrix.ty + (bounds.x * matrix.b + bounds.y * matrix.d);
		let minX = tx;
		let minY = ty;
		let maxX = tx;
		let maxY = ty;
		let x = x_a + tx;
		if(x < minX) {
			minX = x;
		} else if(x > maxX) {
			maxX = x;
		}
		x = x_a + y_c + tx;
		if(x < minX) {
			minX = x;
		} else if(x > maxX) {
			maxX = x;
		}
		x = y_c + tx;
		if(x < minX) {
			minX = x;
		} else if(x > maxX) {
			maxX = x;
		}
		let y = x_b + ty;
		if(y < minY) {
			minY = y;
		} else if(y > maxY) {
			maxY = y;
		}
		y = x_b + y_d + ty;
		if(y < minY) {
			minY = y;
		} else if(y > maxY) {
			maxY = y;
		}
		y = y_d + ty;
		if(y < minY) {
			minY = y;
		} else if(y > maxY) {
			maxY = y;
		}
		bounds.x = minX;
		bounds.y = minY;
		bounds.width = maxX - minX;
		bounds.height = maxY - minY;
		return bounds;
	}
}
nanofl_engine_geom_BoundsTools.__name__ = "nanofl.engine.geom.BoundsTools";
class nanofl_engine_geom_Contour {
	constructor(edges) {
		this.edges = edges;
	}
	draw(g) {
		nanofl_engine_geom_Edges.draw(this.edges,g,false);
	}
	clone() {
		return new nanofl_engine_geom_Contour(datatools_ArrayTools.clone(this.edges));
	}
	normalize() {
		nanofl_engine_geom_Edges.roundPoints(this.edges);
		nanofl_engine_geom_Edges.removeDegenerated(this.edges,true);
		let i = 0;
		while(i < this.edges.length) {
			let a = this.edges[i];
			let b = this.edges[(i + 1) % this.edges.length];
			if(a.x1 == b.x3 && a.y1 == b.y3 && (a.isStraight() && b.isStraight() || a.x2 == b.x2 && a.y2 == b.y2)) {
				if(i + 1 < this.edges.length) {
					this.edges.splice(i,2);
				} else {
					this.edges.splice(i,1);
					this.edges.splice(0,1);
					--i;
				}
			} else {
				++i;
			}
		}
	}
	equ(c) {
		return nanofl_engine_geom_Edges.equIgnoreOrder(this.edges,c.edges);
	}
}
nanofl_engine_geom_Contour.__name__ = "nanofl.engine.geom.Contour";
Object.assign(nanofl_engine_geom_Contour.prototype, {
	__class__: nanofl_engine_geom_Contour
});
class nanofl_engine_geom_Edge {
	constructor(x1,y1,x2,y2,x3,y3) {
		stdlib_Debug.assert(!isNaN(x1),null,{ fileName : "engine/nanofl/engine/geom/Edge.hx", lineNumber : 30, className : "nanofl.engine.geom.Edge", methodName : "new"});
		stdlib_Debug.assert(!isNaN(y1),null,{ fileName : "engine/nanofl/engine/geom/Edge.hx", lineNumber : 31, className : "nanofl.engine.geom.Edge", methodName : "new"});
		stdlib_Debug.assert(!isNaN(x2),null,{ fileName : "engine/nanofl/engine/geom/Edge.hx", lineNumber : 32, className : "nanofl.engine.geom.Edge", methodName : "new"});
		stdlib_Debug.assert(!isNaN(y2),null,{ fileName : "engine/nanofl/engine/geom/Edge.hx", lineNumber : 33, className : "nanofl.engine.geom.Edge", methodName : "new"});
		this.x1 = x1;
		this.y1 = y1;
		if(x3 == null) {
			this.x2 = (x1 + x2) / 2;
			this.y2 = (y1 + y2) / 2;
			this.x3 = x2;
			this.y3 = y2;
		} else {
			this.x2 = x2;
			this.y2 = y2;
			this.x3 = x3;
			this.y3 = y3;
		}
	}
	isStraight() {
		let pt = this.asStraightLine().getOrthogonalRayIntersection(this.x2,this.y2).point;
		return nanofl_engine_geom_PointTools.getSqrDist(pt.x,pt.y,this.x2,this.y2) < nanofl_engine_geom_Edge.GAP * nanofl_engine_geom_Edge.GAP;
	}
	drawTo(g) {
		if(this.isStraight()) {
			g.lineTo(this.x3,this.y3);
		} else {
			g.curveTo(this.x2,this.y2,this.x3,this.y3);
		}
	}
	equ(e) {
		if(e.x2 == this.x2 && e.y2 == this.y2) {
			if(!(e.x1 == this.x1 && e.y1 == this.y1 && e.x3 == this.x3 && e.y3 == this.y3)) {
				if(e.x1 == this.x3 && e.y1 == this.y3 && e.x3 == this.x1) {
					return e.y3 == this.y1;
				} else {
					return false;
				}
			} else {
				return true;
			}
		} else {
			return false;
		}
	}
	getNearestPoint(x,y) {
		let r = this.isStraight() ? this.asStraightLine().getNearestPoint(x,y) : this.asBezierCurve().getNearestPoint(x,y);
		stdlib_Debug.assert(r.point != null,this.toString() + "; x = " + x + ", y = " + y,{ fileName : "engine/nanofl/engine/geom/Edge.hx", lineNumber : 134, className : "nanofl.engine.geom.Edge", methodName : "getNearestPoint"});
		let f = r.point.x;
		stdlib_Debug.assert(!isNaN(f),this.toString() + "; x = " + x + ", y = " + y,{ fileName : "engine/nanofl/engine/geom/Edge.hx", lineNumber : 135, className : "nanofl.engine.geom.Edge", methodName : "getNearestPoint"});
		let f1 = r.point.y;
		stdlib_Debug.assert(!isNaN(f1),this.toString() + "; x = " + x + ", y = " + y,{ fileName : "engine/nanofl/engine/geom/Edge.hx", lineNumber : 136, className : "nanofl.engine.geom.Edge", methodName : "getNearestPoint"});
		let f2 = r.t;
		stdlib_Debug.assert(!isNaN(f2),this.toString() + "; x = " + x + ", y = " + y,{ fileName : "engine/nanofl/engine/geom/Edge.hx", lineNumber : 137, className : "nanofl.engine.geom.Edge", methodName : "getNearestPoint"});
		return r;
	}
	reverse() {
		let z = this.x1;
		this.x1 = this.x3;
		this.x3 = z;
		z = this.y1;
		this.y1 = this.y3;
		this.y3 = z;
		return this;
	}
	getBounds(bounds) {
		if(bounds == null) {
			return nanofl_engine_geom_BoundsTools.clone(this.getBoundsRO());
		} else {
			return nanofl_engine_geom_BoundsTools.extend(bounds,this.getBoundsRO());
		}
	}
	getBoundsRO() {
		if(this.cachedBounds == null || !this.cachedBoundsEdge.equ(this)) {
			this.cachedBounds = this.isStraight() ? this.asStraightLine().getBounds() : this.asBezierCurve().getBounds();
			this.cachedBoundsEdge = this.clone();
		}
		return this.cachedBounds;
	}
	toString() {
		if(this.isStraight()) {
			return "new Edge(" + this.x1 + "," + this.y1 + ", " + this.x3 + "," + this.y3 + ")";
		} else {
			return "new Edge(" + this.x1 + "," + this.y1 + ", " + this.x2 + "," + this.y2 + ", " + this.x3 + "," + this.y3 + ")";
		}
	}
	transform(m,applyToStroke) {
		if(applyToStroke == null) {
			applyToStroke = true;
		}
		let straight = this.isStraight();
		let p1 = m.transformPoint(this.x1,this.y1);
		this.x1 = nanofl_engine_geom_PointTools.roundGap(p1.x);
		this.y1 = nanofl_engine_geom_PointTools.roundGap(p1.y);
		let p3 = m.transformPoint(this.x3,this.y3);
		this.x3 = nanofl_engine_geom_PointTools.roundGap(p3.x);
		this.y3 = nanofl_engine_geom_PointTools.roundGap(p3.y);
		if(straight) {
			this.x2 = (this.x1 + this.x3) / 2;
			this.y2 = (this.y1 + this.y3) / 2;
		} else {
			let p2 = m.transformPoint(this.x2,this.y2);
			this.x2 = nanofl_engine_geom_PointTools.roundGap(p2.x);
			this.y2 = nanofl_engine_geom_PointTools.roundGap(p2.y);
		}
	}
	asStraightLine() {
		return new nanofl_engine_geom_StraightLine(this.x1,this.y1,this.x3,this.y3);
	}
	asBezierCurve() {
		return new nanofl_engine_geom_BezierCurve(this.x1,this.y1,this.x2,this.y2,this.x3,this.y3);
	}
	clone() {
		return new nanofl_engine_geom_Edge(this.x1,this.y1,this.x2,this.y2,this.x3,this.y3);
	}
	indexIn(edges) {
		let _g = 0;
		let _g1 = edges.length;
		while(_g < _g1) {
			let i = _g++;
			if(this.equ(edges[i])) {
				return i;
			}
		}
		return -1;
	}
	isDegenerated() {
		if(this.x1 == this.x2 && this.x2 == this.x3 && this.y1 == this.y2) {
			return this.y2 == this.y3;
		} else {
			return false;
		}
	}
	roundPoints() {
		let straight = this.isStraight();
		this.x1 = nanofl_engine_geom_PointTools.roundGap(this.x1);
		this.y1 = nanofl_engine_geom_PointTools.roundGap(this.y1);
		this.x3 = nanofl_engine_geom_PointTools.roundGap(this.x3);
		this.y3 = nanofl_engine_geom_PointTools.roundGap(this.y3);
		if(straight) {
			this.x2 = (this.x1 + this.x3) / 2;
			this.y2 = (this.y1 + this.y3) / 2;
		} else {
			this.x2 = nanofl_engine_geom_PointTools.roundGap(this.x2);
			this.y2 = nanofl_engine_geom_PointTools.roundGap(this.y2);
			if(this.isStraight()) {
				this.x2 = (this.x1 + this.x3) / 2;
				this.y2 = (this.y1 + this.y3) / 2;
			}
		}
	}
	getLength() {
		if(this.isStraight()) {
			return this.asStraightLine().getLength();
		} else {
			return this.asBezierCurve().getLength();
		}
	}
	getPart(t) {
		if(this.isStraight()) {
			return nanofl_engine_geom_Edge.fromStraightLine(this.asStraightLine().getFirstPart(t));
		} else {
			return nanofl_engine_geom_Edge.fromBezierCurve(this.asBezierCurve().getFirstPart(t));
		}
	}
	getPoint(t) {
		if(this.isStraight()) {
			return this.asStraightLine().getPoint(t);
		} else {
			return this.asBezierCurve().getPoint(t);
		}
	}
	getTangent(t) {
		if(this.isStraight()) {
			return this.asStraightLine().getTangent(t);
		} else {
			return this.asBezierCurve().getTangent(t);
		}
	}
	getMonotoneT(k) {
		if(this.isStraight()) {
			return k;
		} else {
			return this.asBezierCurve().getMonotoneT(k);
		}
	}
	static fromStraightLine(line) {
		return new nanofl_engine_geom_Edge(line.x1,line.y1,line.x2,line.y2);
	}
	static fromBezierCurve(curve) {
		return new nanofl_engine_geom_Edge(curve.p1.x,curve.p1.y,curve.p2.x,curve.p2.y,curve.p3.x,curve.p3.y);
	}
}
nanofl_engine_geom_Edge.__name__ = "nanofl.engine.geom.Edge";
Object.assign(nanofl_engine_geom_Edge.prototype, {
	__class__: nanofl_engine_geom_Edge
});
class nanofl_engine_geom_Edges {
	static removeDublicates(edges) {
		let i = 0;
		while(i < edges.length) {
			let j = i + 1;
			while(j < edges.length) if(edges[i].equ(edges[j])) {
				edges.splice(j,1);
			} else {
				++j;
			}
			++i;
		}
	}
	static draw(edges,g,fixLineJoinsInClosedContours) {
		let x = 1e100;
		let y = 1e100;
		let startEdge = null;
		let _g = 0;
		while(_g < edges.length) {
			let e = edges[_g];
			++_g;
			if(e.x1 != x || e.y1 != y) {
				if(fixLineJoinsInClosedContours && startEdge != null) {
					if(startEdge.x1 == x && startEdge.y1 == y) {
						startEdge.drawTo(g);
					}
				}
				startEdge = e;
				g.moveTo(e.x1,e.y1);
			}
			e.drawTo(g);
			x = e.x3;
			y = e.y3;
		}
		if(fixLineJoinsInClosedContours && startEdge != null) {
			if(startEdge.x1 == x && startEdge.y1 == y) {
				startEdge.drawTo(g);
			}
		}
	}
	static getBounds(edges,bounds) {
		if(edges.length > 0) {
			if(bounds == null) {
				bounds = { minX : 1e100, minY : 1e100, maxX : -1e100, maxY : -1e100};
			}
			let _g = 0;
			while(_g < edges.length) {
				let e = edges[_g];
				++_g;
				e.getBounds(bounds);
			}
			return bounds;
		}
		return bounds;
	}
	static load(s) {
		let r = [];
		let x = 0.0;
		let y = 0.0;
		let i = 0;
		while(i < s.length) {
			let c = s.charAt(i);
			++i;
			if(c == "M") {
				if(!nanofl_engine_geom_Edges.reFloat2.matchSub(s,i)) {
					throw haxe_Exception.thrown("Cannot parse " + HxOverrides.substr(s,i,20) + "'.");
				}
				x = parseFloat(nanofl_engine_geom_Edges.reFloat2.matched(1));
				y = parseFloat(nanofl_engine_geom_Edges.reFloat2.matched(2));
				i += nanofl_engine_geom_Edges.reFloat2.matchedPos().len;
			} else if(c == "L") {
				if(!nanofl_engine_geom_Edges.reFloat2.matchSub(s,i)) {
					throw haxe_Exception.thrown("Cannot parse " + HxOverrides.substr(s,i,20) + "'.");
				}
				let newX = parseFloat(nanofl_engine_geom_Edges.reFloat2.matched(1));
				let newY = parseFloat(nanofl_engine_geom_Edges.reFloat2.matched(2));
				r.push(new nanofl_engine_geom_Edge(x,y,newX,newY));
				x = newX;
				y = newY;
				i += nanofl_engine_geom_Edges.reFloat2.matchedPos().len;
			} else if(c == "C") {
				if(!nanofl_engine_geom_Edges.reFloat4.matchSub(s,i)) {
					throw haxe_Exception.thrown("Cannot parse " + HxOverrides.substr(s,i,20) + "'.");
				}
				let newX = parseFloat(nanofl_engine_geom_Edges.reFloat4.matched(3));
				let newY = parseFloat(nanofl_engine_geom_Edges.reFloat4.matched(4));
				r.push(new nanofl_engine_geom_Edge(x,y,parseFloat(nanofl_engine_geom_Edges.reFloat4.matched(1)),parseFloat(nanofl_engine_geom_Edges.reFloat4.matched(2)),newX,newY));
				x = newX;
				y = newY;
				i += nanofl_engine_geom_Edges.reFloat4.matchedPos().len;
			} else {
				throw haxe_Exception.thrown("Unexpected command '" + c + "'.");
			}
		}
		return r;
	}
	static normalize(edges) {
		nanofl_engine_geom_Edges.roundPoints(edges);
		nanofl_engine_geom_Edges.removeDegenerated(edges);
		nanofl_engine_geom_Edges.removeDublicates(edges);
		return edges;
	}
	static roundPoints(edges) {
		let _g = 0;
		while(_g < edges.length) {
			let edge = edges[_g];
			++_g;
			edge.roundPoints();
		}
		return edges;
	}
	static removeDegenerated(edges,removeAlsoCurvesWithStartAndEndEquals) {
		if(removeAlsoCurvesWithStartAndEndEquals == null) {
			removeAlsoCurvesWithStartAndEndEquals = false;
		}
		if(removeAlsoCurvesWithStartAndEndEquals) {
			let i = 0;
			while(i < edges.length) {
				let edge = edges[i];
				if(edge.x1 == edge.x3 && edge.y1 == edge.y3) {
					edges.splice(i,1);
				} else {
					++i;
				}
			}
		} else {
			let i = 0;
			while(i < edges.length) if(edges[i].isDegenerated()) {
				edges.splice(i,1);
			} else {
				++i;
			}
		}
		return edges;
	}
	static equIgnoreOrder(edgesA,edgesB) {
		if(edgesA.length != edgesB.length) {
			return false;
		}
		let _g = 0;
		while(_g < edgesA.length) {
			let edgeA = edgesA[_g];
			++_g;
			if(edgeA.indexIn(edgesB) < 0) {
				return false;
			}
		}
		return true;
	}
}
nanofl_engine_geom_Edges.__name__ = "nanofl.engine.geom.Edges";
class nanofl_engine_geom_Equation {
	static solveCube(a,b,c,d) {
		if(Math.abs(a) < 1e-10) {
			return nanofl_engine_geom_Equation.solveQuadratic(b,c,d);
		}
		let z = a;
		a = b / z;
		b = c / z;
		c = d / z;
		let p = b - a * a / 3;
		let q = a * (2 * a * a - 9 * b) / 27 + c;
		let p3 = p * p * p;
		let D = q * q + 4 * p3 / 27;
		let offset = -a / 3;
		if(D > 1e-10) {
			z = Math.sqrt(D);
			let u = (-q + z) / 2;
			let v = (-q - z) / 2;
			u = u >= 0 ? Math.pow(u,0.33333333333333331) : -Math.pow(-u,0.33333333333333331);
			v = v >= 0 ? Math.pow(v,0.33333333333333331) : -Math.pow(-v,0.33333333333333331);
			return [u + v + offset];
		} else if(D < -1e-010) {
			let u = 2 * Math.sqrt(-p / 3);
			let v = Math.acos(-Math.sqrt(-27 / p3) * q / 2) / 3;
			return [u * Math.cos(v) + offset,u * Math.cos(v + 2 * Math.PI / 3) + offset,u * Math.cos(v + 4 * Math.PI / 3) + offset];
		} else {
			let u = q < 0 ? Math.pow(-q / 2,0.33333333333333331) : -Math.pow(q / 2,0.33333333333333331);
			return [2 * u + offset,-u + offset];
		}
	}
	static solveQuadratic(a,b,c) {
		if(Math.abs(a) <= 1e-10) {
			if(Math.abs(b) > 1e-10) {
				return [-c / b];
			} else {
				return [];
			}
		}
		let D = b * b - 4 * a * c;
		if(D > 1e-10) {
			D = Math.sqrt(D);
			return [(-b - D) / (2 * a),(-b + D) / (2 * a)];
		}
		if(D > -1e-010) {
			return [-b / (2 * a)];
		}
		return [];
	}
}
nanofl_engine_geom_Equation.__name__ = "nanofl.engine.geom.Equation";
class nanofl_engine_geom_Matrix {
	constructor(a,b,c,d,tx,ty) {
		if(ty == null) {
			ty = 0.0;
		}
		if(tx == null) {
			tx = 0.0;
		}
		if(d == null) {
			d = 1.0;
		}
		if(c == null) {
			c = 0.0;
		}
		if(b == null) {
			b = 0.0;
		}
		if(a == null) {
			a = 1.0;
		}
		this.a = a;
		this.b = b;
		this.c = c;
		this.d = d;
		this.tx = tx;
		this.ty = ty;
	}
	decompose() {
		let r = { };
		r.x = this.tx;
		r.y = this.ty;
		r.scaleX = Math.sqrt(this.a * this.a + this.b * this.b);
		r.scaleY = Math.sqrt(this.c * this.c + this.d * this.d);
		let skewX = Math.atan2(-this.c,this.d);
		let skewY = Math.atan2(this.b,this.a);
		if(skewX == skewY) {
			r.rotation = skewY * 180 / Math.PI;
			if(this.a < 0 && this.d >= 0) {
				r.rotation += r.rotation <= 0 ? 180 : -180;
			}
			r.skewX = r.skewY = 0;
		} else {
			r.rotation = 0;
			r.skewX = skewX * 180 / Math.PI;
			r.skewY = skewY * 180 / Math.PI;
		}
		return r;
	}
	setMatrix(m) {
		this.a = m.a;
		this.b = m.b;
		this.c = m.c;
		this.d = m.d;
		this.tx = m.tx;
		this.ty = m.ty;
		return this;
	}
	isIdentity() {
		if(this.a == 1.0 && this.b == 0.0 && this.c == 0.0 && this.d == 1.0 && this.tx == 0.0) {
			return this.ty == 0.0;
		} else {
			return false;
		}
	}
	transformPoint(x,y) {
		return { x : x * this.a + y * this.c + this.tx, y : x * this.b + y * this.d + this.ty};
	}
	clone() {
		return new nanofl_engine_geom_Matrix(this.a,this.b,this.c,this.d,this.tx,this.ty);
	}
	equ(m) {
		if(m.a == this.a && m.b == this.b && m.c == this.c && m.d == this.d && m.tx == this.tx) {
			return m.ty == this.ty;
		} else {
			return false;
		}
	}
	setTransform(x,y,scaleX,scaleY,rotation,skewX,skewY,regX,regY) {
		return this.setMatrix(new nanofl_engine_geom_Matrix().appendTransform(x,y,scaleX,scaleY,rotation,skewX,skewY,regX,regY));
	}
	prependMatrix(m) {
		return this.prepend(m.a,m.b,m.c,m.d,m.tx,m.ty);
	}
	append(a,b,c,d,tx,ty) {
		let a1 = this.a;
		let b1 = this.b;
		let c1 = this.c;
		let d1 = this.d;
		this.a = a * a1 + b * c1;
		this.b = a * b1 + b * d1;
		this.c = c * a1 + d * c1;
		this.d = c * b1 + d * d1;
		this.tx = tx * a1 + ty * c1 + this.tx;
		this.ty = tx * b1 + ty * d1 + this.ty;
		return this;
	}
	prepend(a,b,c,d,tx,ty) {
		let tx1 = this.tx;
		if(a != 1 || b != 0 || c != 0 || d != 1) {
			let a1 = this.a;
			let c1 = this.c;
			this.a = a1 * a + this.b * c;
			this.b = a1 * b + this.b * d;
			this.c = c1 * a + this.d * c;
			this.d = c1 * b + this.d * d;
		}
		this.tx = tx1 * a + this.ty * c + tx;
		this.ty = tx1 * b + this.ty * d + ty;
		return this;
	}
	appendTransform(x,y,scaleX,scaleY,rotation,skewX,skewY,regX,regY) {
		if(regY == null) {
			regY = 0.0;
		}
		if(regX == null) {
			regX = 0.0;
		}
		if(skewY == null) {
			skewY = 0.0;
		}
		if(skewX == null) {
			skewX = 0.0;
		}
		if(rotation == null) {
			rotation = 0.0;
		}
		if(scaleY == null) {
			scaleY = 1.0;
		}
		if(scaleX == null) {
			scaleX = 1.0;
		}
		let sin;
		let cos;
		if(rotation % 360 != 0) {
			let r = rotation * nanofl_engine_geom_Matrix.DEG_TO_RAD;
			cos = Math.cos(r);
			sin = Math.sin(r);
		} else {
			cos = 1;
			sin = 0;
		}
		if(skewX != 0 || skewY != 0) {
			skewX *= nanofl_engine_geom_Matrix.DEG_TO_RAD;
			skewY *= nanofl_engine_geom_Matrix.DEG_TO_RAD;
			this.append(Math.cos(skewY),Math.sin(skewY),-Math.sin(skewX),Math.cos(skewX),x,y);
			this.append(cos * scaleX,sin * scaleX,-sin * scaleY,cos * scaleY,0,0);
		} else {
			this.append(cos * scaleX,sin * scaleX,-sin * scaleY,cos * scaleY,x,y);
		}
		if(regX != 0 || regY != 0) {
			this.tx -= regX * this.a + regY * this.c;
			this.ty -= regX * this.b + regY * this.d;
		}
		return this;
	}
	getAverageScale() {
		return (Math.sqrt(this.a * this.a + this.c * this.c) + Math.sqrt(this.b * this.b + this.d * this.d)) / 2;
	}
	toNative() {
		return new createjs.Matrix2D(this.a,this.b,this.c,this.d,this.tx,this.ty);
	}
	static loadJson(obj) {
		if(obj.matrix != null) {
			let tmp = obj.x;
			let tmp1 = obj.y;
			return new nanofl_engine_geom_Matrix(obj.matrix[0],obj.matrix[1],obj.matrix[2],obj.matrix[3],tmp != null ? tmp : 0.0,tmp1 != null ? tmp1 : 0.0);
		} else {
			let tmp = obj.x;
			let tmp1 = obj.y;
			return new nanofl_engine_geom_Matrix(1.0,0.0,0.0,1.0,tmp != null ? tmp : 0.0,tmp1 != null ? tmp1 : 0.0);
		}
	}
}
nanofl_engine_geom_Matrix.__name__ = "nanofl.engine.geom.Matrix";
Object.assign(nanofl_engine_geom_Matrix.prototype, {
	__class__: nanofl_engine_geom_Matrix
});
class nanofl_engine_geom_PointTools {
	static normalize(pt) {
		let len = nanofl_engine_geom_PointTools.getLength(pt);
		if(len != 0) {
			pt.x /= len;
			pt.y /= len;
		}
		return pt;
	}
	static getLength(pt) {
		return Math.sqrt(pt.x * pt.x + pt.y * pt.y);
	}
	static getDist(x1,y1,x2,y2) {
		let dx = x2 - x1;
		let dy = y2 - y1;
		return Math.sqrt(dx * dx + dy * dy);
	}
	static getSqrDist(x1,y1,x2,y2) {
		let dx = x2 - x1;
		let dy = y2 - y1;
		return dx * dx + dy * dy;
	}
	static equ(pt1,pt2) {
		if(pt1.x == pt2.x) {
			return pt1.y == pt2.y;
		} else {
			return false;
		}
	}
	static clone(pt) {
		return { x : pt.x, y : pt.y};
	}
	static roundGap(n) {
		return Math.round(n * 100) / 100;
	}
	static toString(pt) {
		if(pt != null) {
			return pt.x + "," + pt.y;
		} else {
			return "null";
		}
	}
}
nanofl_engine_geom_PointTools.__name__ = "nanofl.engine.geom.PointTools";
class nanofl_engine_geom_Polygon {
	constructor(fill,contours,selected) {
		if(selected == null) {
			selected = false;
		}
		this.fill = fill;
		this.contours = contours != null ? contours : [];
		this.set_selected(selected);
	}
	get_selected() {
		return this.selected;
	}
	set_selected(v) {
		return this.selected = v;
	}
	draw(g,scaleSelection) {
		this.fill.begin(g);
		let _g = 0;
		let _g1 = this.contours;
		while(_g < _g1.length) {
			let contour = _g1[_g];
			++_g;
			contour.draw(g);
		}
		g.endFill();
	}
	getBounds(bounds) {
		if(this.contours.length > 0) {
			if(bounds == null) {
				bounds = { minX : 1e10, minY : 1e10, maxX : -1e10, maxY : -1e10};
			}
			let _g = 0;
			let _g1 = this.contours;
			while(_g < _g1.length) {
				let contour = _g1[_g];
				++_g;
				nanofl_engine_geom_Edges.getBounds(contour.edges,bounds);
			}
			return bounds;
		}
		if(bounds != null) {
			return bounds;
		} else {
			return { minX : 0.0, minY : 0.0, maxX : 0.0, maxY : 0.0};
		}
	}
	transform(m,applyToFill) {
		if(applyToFill == null) {
			applyToFill = true;
		}
		let _g = 0;
		let _g1 = this.contours;
		while(_g < _g1.length) {
			let contour = _g1[_g];
			++_g;
			let _g2 = 0;
			let _g3 = contour.edges;
			while(_g2 < _g3.length) {
				let edge = _g3[_g2];
				++_g2;
				edge.transform(m);
			}
		}
		if(applyToFill && this.fill != null) {
			this.fill = this.fill.getTransformed(m);
		}
	}
	clone() {
		return new nanofl_engine_geom_Polygon(this.fill.clone(),datatools_ArrayTools.clone(this.contours),this.get_selected());
	}
	equ(p) {
		if(p.contours.length != this.contours.length) {
			return false;
		}
		return Lambda.foreach(this.contours,function(a) {
			return Lambda.exists(p.contours,function(b) {
				return a.equ(b);
			});
		});
	}
	normalize() {
		let i = 0;
		while(i < this.contours.length) {
			this.contours[i].normalize();
			if(this.contours[i].edges.length <= 1) {
				this.contours.splice(i,1);
			} else {
				++i;
			}
		}
	}
	static loadJson(obj,fills,version) {
		let tmp = obj.fillIndex;
		let fillIndex = (tmp != null ? tmp : -1) | 0;
		stdlib_Debug.assert(fillIndex != null,null,{ fileName : "engine/nanofl/engine/geom/Polygon.hx", lineNumber : 65, className : "nanofl.engine.geom.Polygon", methodName : "loadJson"});
		stdlib_Debug.assert(fillIndex >= 0,null,{ fileName : "engine/nanofl/engine/geom/Polygon.hx", lineNumber : 66, className : "nanofl.engine.geom.Polygon", methodName : "loadJson"});
		stdlib_Debug.assert(fillIndex < fills.length,null,{ fileName : "engine/nanofl/engine/geom/Polygon.hx", lineNumber : 67, className : "nanofl.engine.geom.Polygon", methodName : "loadJson"});
		let contours = [];
		let i = 0;
		while(i < obj.contours.length) contours.push(new nanofl_engine_geom_Contour(nanofl_engine_geom_Edges.load(obj.contours[i++].edges)));
		return new nanofl_engine_geom_Polygon(fills[fillIndex],contours);
	}
}
nanofl_engine_geom_Polygon.__name__ = "nanofl.engine.geom.Polygon";
nanofl_engine_geom_Polygon.__interfaces__ = [nanofl_engine_ISelectable];
Object.assign(nanofl_engine_geom_Polygon.prototype, {
	__class__: nanofl_engine_geom_Polygon
});
class nanofl_engine_geom_Polygons {
	static removeDublicates(polygons) {
		let i = 0;
		while(i < polygons.length) {
			let j = i + 1;
			while(j < polygons.length) if(polygons[i].equ(polygons[j])) {
				polygons[i].fill = polygons[j].fill;
				polygons.splice(j,1);
			} else {
				++j;
			}
			++i;
		}
	}
	static hasDublicates(polygons) {
		let _g = 0;
		let _g1 = polygons.length;
		while(_g < _g1) {
			let i = _g++;
			let _g1 = i + 1;
			let _g2 = polygons.length;
			while(_g1 < _g2) {
				let j = _g1++;
				if(polygons[i].equ(polygons[j])) {
					return true;
				}
			}
		}
		return false;
	}
	static normalize(polygons) {
		let i = 0;
		while(i < polygons.length) {
			polygons[i].normalize();
			if(polygons[i].contours.length == 0) {
				polygons.splice(i,1);
			} else {
				++i;
			}
		}
		nanofl_engine_geom_Polygons.log("normalize > removeDublicates vvvvvvvvvvv",{ fileName : "engine/nanofl/engine/geom/Polygons.hx", lineNumber : 199, className : "nanofl.engine.geom.Polygons", methodName : "normalize"});
		nanofl_engine_geom_Polygons.removeDublicates(polygons);
		nanofl_engine_geom_Polygons.log("normalize > removeDublicates ^^^^^^^^^^^",{ fileName : "engine/nanofl/engine/geom/Polygons.hx", lineNumber : 201, className : "nanofl.engine.geom.Polygons", methodName : "normalize"});
		if(nanofl_engine_geom_Polygons.hasDublicates(polygons)) {
			console.log("engine/nanofl/engine/geom/Polygons.hx:203:","normalize > DUPS DETECTED!!!!!!!");
		}
	}
	static log(v,infos) {
	}
}
nanofl_engine_geom_Polygons.__name__ = "nanofl.engine.geom.Polygons";
class nanofl_engine_geom_StraightLine {
	constructor(x1,y1,x2,y2) {
		this.x1 = x1;
		this.y1 = y1;
		this.x2 = x2;
		this.y2 = y2;
	}
	getBounds() {
		return { minX : Math.min(this.x1,this.x2), maxX : Math.max(this.x1,this.x2), minY : Math.min(this.y1,this.y2), maxY : Math.max(this.y1,this.y2)};
	}
	getNearestPoint(x,y) {
		let dx = this.x2 - this.x1;
		let dy = this.y2 - this.y1;
		if(dx == 0 && dy == 0) {
			return { t : 0, point : { x : this.x1, y : this.y1}};
		}
		let t = Math.min(1,Math.max(0,((x - this.x1) * dx + (y - this.y1) * dy) / (dx * dx + dy * dy)));
		if(t == 1) {
			return { t : 1, point : { x : this.x2, y : this.y2}};
		}
		return { t : t, point : { x : this.x1 + t * dx, y : this.y1 + t * dy}};
	}
	getOrthogonalRayIntersection(x,y) {
		let dx = this.x2 - this.x1;
		let dy = this.y2 - this.y1;
		if(dx == 0 && dy == 0) {
			return { t : 0, point : { x : this.x1, y : this.y1}};
		}
		let t = ((x - this.x1) * dx + (y - this.y1) * dy) / (dx * dx + dy * dy);
		if(t == 1) {
			return { t : 1, point : { x : this.x2, y : this.y2}};
		}
		return { t : t, point : { x : this.x1 + t * dx, y : this.y1 + t * dy}};
	}
	getLength() {
		return nanofl_engine_geom_PointTools.getDist(this.x1,this.y1,this.x2,this.y2);
	}
	isDegenerated() {
		if(this.x1 == this.x2) {
			return this.y1 == this.y2;
		} else {
			return false;
		}
	}
	getFirstPart(t) {
		return new nanofl_engine_geom_StraightLine(this.x1,this.y1,this.x1 + (this.x2 - this.x1) * t,this.y1 + (this.y2 - this.y1) * t);
	}
	getPoint(t) {
		return { x : this.x1 + (this.x2 - this.x1) * t, y : this.y1 + (this.y2 - this.y1) * t};
	}
	getTangent(t) {
		return Math.atan2(this.y2 - this.y1,this.x2 - this.x1);
	}
}
nanofl_engine_geom_StraightLine.__name__ = "nanofl.engine.geom.StraightLine";
Object.assign(nanofl_engine_geom_StraightLine.prototype, {
	__class__: nanofl_engine_geom_StraightLine
});
class nanofl_engine_geom_StrokeEdge extends nanofl_engine_geom_Edge {
	constructor(x1,y1,x2,y2,x3,y3,stroke,selected) {
		if(selected == null) {
			selected = false;
		}
		super(x1,y1,x2,y2,x3,y3);
		this.stroke = stroke;
		this.set_selected(selected);
	}
	get_selected() {
		return this.selected;
	}
	set_selected(v) {
		return this.selected = v;
	}
	transform(m,applyToStrokeThickness) {
		if(applyToStrokeThickness == null) {
			applyToStrokeThickness = true;
		}
		super.transform(m);
		if(this.stroke != null) {
			this.stroke = this.stroke.getTransformed(m,applyToStrokeThickness);
		}
	}
	clone() {
		return new nanofl_engine_geom_StrokeEdge(this.x1,this.y1,this.x2,this.y2,this.x3,this.y3,this.stroke.clone(),this.get_selected());
	}
	toString() {
		if(this.isStraight()) {
			return "new StrokeEdge(" + this.x1 + "," + this.y1 + ", " + this.x3 + "," + this.y3 + ", " + Std.string(this.stroke) + ", " + Std.string(this.get_selected()) + ")";
		} else {
			return "new StrokeEdge(" + this.x1 + "," + this.y1 + ", " + this.x2 + "," + this.y2 + ", " + this.x3 + "," + this.y3 + ", " + Std.string(this.stroke) + ", " + Std.string(this.get_selected()) + ")";
		}
	}
	static fromEdge(edge,stroke,selected) {
		if(selected == null) {
			selected = false;
		}
		return new nanofl_engine_geom_StrokeEdge(edge.x1,edge.y1,edge.x2,edge.y2,edge.x3,edge.y3,stroke,selected);
	}
}
nanofl_engine_geom_StrokeEdge.__name__ = "nanofl.engine.geom.StrokeEdge";
nanofl_engine_geom_StrokeEdge.__interfaces__ = [nanofl_engine_ISelectable];
nanofl_engine_geom_StrokeEdge.__super__ = nanofl_engine_geom_Edge;
Object.assign(nanofl_engine_geom_StrokeEdge.prototype, {
	__class__: nanofl_engine_geom_StrokeEdge
});
class nanofl_engine_geom_StrokeEdges {
	static loadJson(objs,strokes,version) {
		let r = [];
		let _g = 0;
		while(_g < objs.length) {
			let obj = objs[_g];
			++_g;
			let tmp = obj.strokeIndex;
			let strokeIndex = tmp != null ? tmp : -1;
			stdlib_Debug.assert(strokeIndex >= 0,null,{ fileName : "engine/nanofl/engine/geom/StrokeEdges.hx", lineNumber : 44, className : "nanofl.engine.geom.StrokeEdges", methodName : "loadJson"});
			stdlib_Debug.assert(strokeIndex < strokes.length,null,{ fileName : "engine/nanofl/engine/geom/StrokeEdges.hx", lineNumber : 45, className : "nanofl.engine.geom.StrokeEdges", methodName : "loadJson"});
			let edges = nanofl_engine_geom_Edges.load(obj.edges);
			let result = new Array(edges.length);
			let _g1 = 0;
			let _g2 = edges.length;
			while(_g1 < _g2) {
				let i = _g1++;
				result[i] = nanofl_engine_geom_StrokeEdge.fromEdge(edges[i],strokes[strokeIndex]);
			}
			stdlib_LambdaArray.addRange(r,result);
		}
		return r;
	}
	static getBounds(edges,bounds) {
		if(edges.length > 0) {
			if(bounds == null) {
				bounds = { minX : 1e100, minY : 1e100, maxX : -1e100, maxY : -1e100};
			}
			let _g = 0;
			while(_g < edges.length) {
				let e = edges[_g];
				++_g;
				let b = e.getBounds();
				let r = e.stroke.thickness / 2;
				bounds.minX = Math.min(bounds.minX,b.minX - r);
				bounds.minY = Math.min(bounds.minY,b.minY - r);
				bounds.maxX = Math.max(bounds.maxX,b.maxX + r);
				bounds.maxY = Math.max(bounds.maxY,b.maxY + r);
			}
		}
		return bounds;
	}
	static drawSorted(edges,g,scaleSelection) {
		nanofl_engine_geom_StrokeEdges.sort(edges);
		let i = 0;
		while(i < edges.length) {
			let j = i + 1;
			while(j < edges.length && edges[i].stroke.equ(edges[j].stroke)) ++j;
			edges[i].stroke.begin(g);
			nanofl_engine_geom_Edges.draw(edges.slice(i,j),g,true);
			g.endStroke();
			i = j;
		}
	}
	static sort(edges) {
		let i = 1;
		while(i < edges.length) {
			while(i < edges.length && edges[i - 1].stroke.equ(edges[i].stroke)) ++i;
			let _g = i;
			let _g1 = edges.length;
			while(_g < _g1) {
				let j = _g++;
				if(edges[i].stroke.equ(edges[j].stroke)) {
					let z = edges[i];
					edges[i] = edges[j];
					edges[j] = z;
					++i;
				}
			}
			++i;
		}
		let i1 = 0;
		while(i1 < edges.length) {
			let j = i1 + 1;
			while(j < edges.length && edges[i1].stroke.equ(edges[j].stroke)) ++j;
			nanofl_engine_geom_StrokeEdges.sortToProduceSequences(edges,i1,j);
			i1 = j;
		}
	}
	static sortToProduceSequences(edges,from,to) {
		let lastSorted = from;
		let i = lastSorted + 1;
		while(i < to) if(lastSorted + 1 < to && edges[lastSorted].x3 == edges[i].x1 && edges[lastSorted].y3 == edges[i].y1) {
			datatools_ArrayTools.swap(edges,lastSorted + 1,i);
			++lastSorted;
			i = lastSorted + 1;
		} else if(lastSorted + 1 < to && edges[lastSorted].x3 == edges[i].x3 && edges[lastSorted].y3 == edges[i].y3) {
			edges[i].reverse();
			datatools_ArrayTools.swap(edges,lastSorted + 1,i);
			++lastSorted;
			i = lastSorted + 1;
		} else if(edges[from].x1 == edges[i].x3 && edges[from].y1 == edges[i].y3) {
			let z = edges[i];
			let k = i;
			while(k > from) {
				edges[k] = edges[k - 1];
				--k;
			}
			edges[from] = z;
			++lastSorted;
			i = lastSorted + 1;
		} else if(edges[i].x1 == edges[from].x1 && edges[i].y1 == edges[from].y1) {
			edges[i].reverse();
			let z = edges[i];
			let k = i;
			while(k > from) {
				edges[k] = edges[k - 1];
				--k;
			}
			edges[from] = z;
			++lastSorted;
			i = lastSorted + 1;
		} else {
			++i;
		}
		if(lastSorted + 2 < to) {
			nanofl_engine_geom_StrokeEdges.sortToProduceSequences(edges,lastSorted + 1,to);
		}
	}
}
nanofl_engine_geom_StrokeEdges.__name__ = "nanofl.engine.geom.StrokeEdges";
class nanofl_engine_libraryitems_LibraryItem {
	constructor(namePath) {
		if(nanofl_engine_libraryitems_LibraryItem._hx_skip_constructor) {
			return;
		}
		this._hx_constructor(namePath);
	}
	_hx_constructor(namePath) {
		this.namePath = namePath;
	}
	copyBaseProperties(obj) {
		obj.library = this.library;
		obj.namePath = this.namePath;
	}
	setLibrary(library) {
		this.library = library;
	}
	duplicate(newNamePath) {
		let item = this.clone();
		item.namePath = newNamePath;
		if(this.library != null) {
			this.library.addItem(item);
		}
		return item;
	}
	remove() {
		if(this.library != null) {
			this.library.removeItem(this.namePath);
		}
	}
	equ(item) {
		return this.namePath == item.namePath;
	}
	static loadFromJson(namePath,obj) {
		let item;
		switch(Type.createEnum(nanofl_engine_LibraryItemType,obj.type,null)._hx_index) {
		case 0:
			item = new nanofl_engine_libraryitems_BitmapItem(namePath,null);
			break;
		case 1:
			item = null;
			break;
		case 2:
			item = new nanofl_engine_libraryitems_FontItem(namePath);
			break;
		case 3:
			item = new nanofl_engine_libraryitems_MeshItem(namePath,null,null);
			break;
		case 4:
			item = new nanofl_engine_libraryitems_MovieClipItem(namePath);
			break;
		case 5:
			item = new nanofl_engine_libraryitems_SoundItem(namePath,null);
			break;
		}
		if(item == null) {
			return null;
		}
		item.loadPropertiesJson(obj);
		return item;
	}
}
nanofl_engine_libraryitems_LibraryItem.__name__ = "nanofl.engine.libraryitems.LibraryItem";
nanofl_engine_libraryitems_LibraryItem.__interfaces__ = [nanofl_engine_ILibraryItem];
Object.assign(nanofl_engine_libraryitems_LibraryItem.prototype, {
	__class__: nanofl_engine_libraryitems_LibraryItem
});
class nanofl_engine_libraryitems_InstancableItem extends nanofl_engine_libraryitems_LibraryItem {
	constructor(namePath) {
		if(nanofl_engine_libraryitems_LibraryItem._hx_skip_constructor) {
			super();
			return;
		}
		nanofl_engine_libraryitems_LibraryItem._hx_skip_constructor = true;
		super();
		nanofl_engine_libraryitems_LibraryItem._hx_skip_constructor = false;
		this._hx_constructor(namePath);
	}
	_hx_constructor(namePath) {
		this.linkedClass = "";
		super._hx_constructor(namePath);
	}
	copyBaseProperties(obj) {
		super.copyBaseProperties(obj);
		obj.linkedClass = this.linkedClass;
	}
	newInstance() {
		stdlib_Debug.assert(this.library != null,"You must add symbol '" + this.namePath + "' to library before newInstance() call.",{ fileName : "engine/nanofl/engine/libraryitems/InstancableItem.hx", lineNumber : 30, className : "nanofl.engine.libraryitems.InstancableItem", methodName : "newInstance"});
		let r = new nanofl_engine_elements_Instance(this.namePath);
		r.setLibrary(this.library);
		return r;
	}
	createDisplayObject(initFrameIndex,childFrameIndexes) {
		if(this.linkedClass != "") {
			let klass = window[this.linkedClass];
			if(klass != null) {
				return new klass(this);
			}
			console.log("engine/nanofl/engine/libraryitems/InstancableItem.hx:46:","Linkage class '" + this.linkedClass + "' is not found.");
		}
		return null;
	}
	equ(item) {
		if(((item) instanceof nanofl_engine_libraryitems_InstancableItem)) {
			return false;
		}
		if(!super.equ(item)) {
			return false;
		}
		return this.linkedClass == item.linkedClass;
	}
	loadPropertiesJson(obj) {
		let tmp = obj.linkedClass;
		this.linkedClass = tmp != null ? tmp : "";
	}
}
nanofl_engine_libraryitems_InstancableItem.__name__ = "nanofl.engine.libraryitems.InstancableItem";
nanofl_engine_libraryitems_InstancableItem.__super__ = nanofl_engine_libraryitems_LibraryItem;
Object.assign(nanofl_engine_libraryitems_InstancableItem.prototype, {
	__class__: nanofl_engine_libraryitems_InstancableItem
});
class nanofl_engine_libraryitems_BitmapItem extends nanofl_engine_libraryitems_InstancableItem {
	constructor(namePath,ext) {
		super(namePath);
		this.ext = ext;
	}
	get_type() {
		return nanofl_engine_LibraryItemType.bitmap;
	}
	clone() {
		let obj = new nanofl_engine_libraryitems_BitmapItem(this.namePath,this.ext);
		obj.ext = this.ext;
		obj.textureAtlas = this.textureAtlas;
		obj.image = this.image;
		this.copyBaseProperties(obj);
		return obj;
	}
	preload() {
		stdlib_Debug.assert(this.library != null,"You need to add item '" + this.namePath + "' to the library before preload call.",{ fileName : "engine/nanofl/engine/libraryitems/BitmapItem.hx", lineNumber : 51, className : "nanofl.engine.libraryitems.BitmapItem", methodName : "preload"});
		if(nanofl_engine_TextureAtlasTools.getSpriteSheet(this) == null) {
			return this.preloadInner();
		} else {
			return Promise.resolve(null);
		}
	}
	preloadInner() {
		if(this.textureAtlas != null && this.textureAtlas != "") {
			return Promise.resolve(null);
		}
		let _gthis = this;
		if(this.ext == "js") {
			return nanofl_engine_SerializationAsJsTools.load(this.library,this.namePath,true).then(function(dataUri) {
				return _gthis.loadImageFromDataUri(dataUri);
			});
		} else {
			return nanofl_engine_Loader.image(this.library.realUrl(this.namePath + "." + this.ext)).then(function(img) {
				_gthis.image = img;
				return null;
			});
		}
	}
	loadImageFromDataUri(dataUri) {
		let _gthis = this;
		return new Promise(function(resolve,reject) {
			let tmp = window.document.createElement("img");
			_gthis.image = tmp;
			_gthis.image.onload = function() {
				resolve(null);
			};
			_gthis.image.onerror = function(e) {
				reject(e);
			};
			_gthis.image.src = dataUri;
		});
	}
	createDisplayObject(initFrameIndex,childFrameIndexes) {
		let r = super.createDisplayObject(initFrameIndex,childFrameIndexes);
		if(r == null) {
			let spriteSheet = nanofl_engine_TextureAtlasTools.getSpriteSheet(this);
			r = spriteSheet == null ? new nanofl_Bitmap(this) : new createjs.Sprite(spriteSheet);
		}
		r.setBounds(0,0,this.image.width,this.image.height);
		return r;
	}
	updateDisplayObject(dispObj,childFrameIndexes) {
		stdlib_Debug.assert(((dispObj) instanceof createjs.Bitmap),null,{ fileName : "engine/nanofl/engine/libraryitems/BitmapItem.hx", lineNumber : 100, className : "nanofl.engine.libraryitems.BitmapItem", methodName : "updateDisplayObject"});
		dispObj.image = this.image;
		dispObj.setBounds(0,0,this.image.width,this.image.height);
	}
	equ(item) {
		if(!((item) instanceof nanofl_engine_libraryitems_BitmapItem)) {
			return false;
		}
		if(!super.equ(item)) {
			return false;
		}
		if(item.ext != this.ext) {
			return false;
		}
		if(item.textureAtlas != this.textureAtlas) {
			return false;
		}
		return true;
	}
	loadPropertiesJson(obj) {
		if(obj.type != this.get_type()) {
			throw new Error("Type of item must be '" + Std.string(this.get_type()) + "', but '" + Std.string(obj.type) + "' found.");
		}
		super.loadPropertiesJson(obj);
		let tmp = obj.ext;
		this.ext = tmp != null ? tmp : null;
		let tmp1 = obj.textureAtlas;
		this.textureAtlas = tmp1 != null ? tmp1 : null;
	}
	toString() {
		return "BitmapItem(" + this.namePath + ")";
	}
}
nanofl_engine_libraryitems_BitmapItem.__name__ = "nanofl.engine.libraryitems.BitmapItem";
nanofl_engine_libraryitems_BitmapItem.__interfaces__ = [nanofl_engine_ITextureItem];
nanofl_engine_libraryitems_BitmapItem.__super__ = nanofl_engine_libraryitems_InstancableItem;
Object.assign(nanofl_engine_libraryitems_BitmapItem.prototype, {
	__class__: nanofl_engine_libraryitems_BitmapItem
});
class nanofl_engine_libraryitems_FolderItem extends nanofl_engine_libraryitems_LibraryItem {
	constructor(namePath) {
		nanofl_engine_libraryitems_LibraryItem._hx_skip_constructor = true;
		super();
		nanofl_engine_libraryitems_LibraryItem._hx_skip_constructor = false;
		this._hx_constructor(namePath);
	}
	_hx_constructor(namePath) {
		this.opened = false;
		super._hx_constructor(namePath);
	}
	clone() {
		let obj = new nanofl_engine_libraryitems_FolderItem(this.namePath);
		obj.opened = this.opened;
		this.copyBaseProperties(obj);
		return obj;
	}
	equ(item) {
		if(!((item) instanceof nanofl_engine_libraryitems_FolderItem)) {
			return false;
		}
		if(!super.equ(item)) {
			return false;
		}
		return true;
	}
	preload() {
		return Promise.resolve();
	}
	loadPropertiesJson(obj) {
	}
	toString() {
		return "FolderItem(" + this.namePath + ")";
	}
}
nanofl_engine_libraryitems_FolderItem.__name__ = "nanofl.engine.libraryitems.FolderItem";
nanofl_engine_libraryitems_FolderItem.__super__ = nanofl_engine_libraryitems_LibraryItem;
Object.assign(nanofl_engine_libraryitems_FolderItem.prototype, {
	__class__: nanofl_engine_libraryitems_FolderItem
});
class nanofl_engine_libraryitems_FontItem extends nanofl_engine_libraryitems_LibraryItem {
	constructor(namePath,variants) {
		super(namePath);
		let tmp = variants;
		this.variants = tmp != null ? tmp : [];
	}
	get_type() {
		return nanofl_engine_LibraryItemType.font;
	}
	clone() {
		let obj = new nanofl_engine_libraryitems_FontItem(this.namePath,this.variants.slice());
		this.copyBaseProperties(obj);
		return obj;
	}
	preload() {
		stdlib_Debug.assert(this.library != null,"You need to add item '" + this.namePath + "' to the library before preload call.",{ fileName : "engine/nanofl/engine/libraryitems/FontItem.hx", lineNumber : 49, className : "nanofl.engine.libraryitems.FontItem", methodName : "preload"});
		let family = haxe_io_Path.withoutDirectory(this.namePath);
		let r = Promise.resolve();
		let _gthis = this;
		let _g = 0;
		let _g1 = this.variants;
		while(_g < _g1.length) {
			let variant = _g1[_g];
			++_g;
			r = r.then(function(_) {
				return _gthis.getExistsSupportedFormat(variant).then(function(format) {
					if(format != null) {
						let font = new FontFace(family,"url(" + variant.urls.h[format] + ") format(\"" + format + "\")",{ style : variant.style, weight : Std.string(variant.weight)});
						return new Promise(function(resolve,reject) {
							font.load().then(function(font) {
								window.document.fonts.add(font);
								resolve(null);
							},function(e) {
								console.log("engine/nanofl/engine/libraryitems/FontItem.hx:77:","Font '" + family + "' loading error ('" + variant.urls.h[format] + "'):");
								console.log("engine/nanofl/engine/libraryitems/FontItem.hx:78:",e);
								resolve(null);
							});
						});
					} else {
						console.log("engine/nanofl/engine/libraryitems/FontItem.hx:86:","Can't found suitable font file format ('" + family + " " + variant.style + " " + variant.weight + "').");
						return null;
					}
				});
			});
		}
		return r;
	}
	getExistsSupportedFormat(variant) {
		return new Promise(function(resolve,reject) {
			if(Object.prototype.hasOwnProperty.call(variant.urls.h,"woff2")) {
				resolve("woff2");
			} else if(Object.prototype.hasOwnProperty.call(variant.urls.h,"woff")) {
				resolve("woff");
			} else if(Object.prototype.hasOwnProperty.call(variant.urls.h,"truetype")) {
				resolve("truetype");
			} else if(Object.prototype.hasOwnProperty.call(variant.urls.h,"svg")) {
				resolve("svg");
			} else if(Object.prototype.hasOwnProperty.call(variant.urls.h,"eot")) {
				resolve("eot");
			} else {
				resolve(null);
			}
		});
	}
	equ(item) {
		if(!((item) instanceof nanofl_engine_libraryitems_FontItem)) {
			return false;
		}
		if(!super.equ(item)) {
			return false;
		}
		if(!datatools_ArrayTools.equ(item.variants,this.variants)) {
			return false;
		}
		return true;
	}
	loadPropertiesJson(obj) {
		if(obj.type != this.get_type()) {
			throw new Error("Type of item must be '" + Std.string(this.get_type()) + "', but '" + Std.string(obj.type) + "' found.");
		}
		let _this = obj.variants;
		let result = new Array(_this.length);
		let _g = 0;
		let _g1 = _this.length;
		while(_g < _g1) {
			let i = _g++;
			let x = _this[i];
			result[i] = new nanofl_engine_FontVariant(x.style,x.weight,x.locals,datatools_MapTools.fromObject(x.files));
		}
		this.variants = result;
	}
	toString() {
		return "FontItem(" + this.namePath + ")";
	}
}
nanofl_engine_libraryitems_FontItem.__name__ = "nanofl.engine.libraryitems.FontItem";
nanofl_engine_libraryitems_FontItem.__super__ = nanofl_engine_libraryitems_LibraryItem;
Object.assign(nanofl_engine_libraryitems_FontItem.prototype, {
	__class__: nanofl_engine_libraryitems_FontItem
});
class nanofl_engine_libraryitems_MeshItem extends nanofl_engine_libraryitems_InstancableItem {
	constructor(namePath,ext,originalExt) {
		nanofl_engine_libraryitems_LibraryItem._hx_skip_constructor = true;
		super();
		nanofl_engine_libraryitems_LibraryItem._hx_skip_constructor = false;
		this._hx_constructor(namePath,ext,originalExt);
	}
	_hx_constructor(namePath,ext,originalExt) {
		this.textureFiles = [];
		this.loadLights = false;
		this.renderAreaSize = 256;
		super._hx_constructor(namePath);
		this.ext = ext;
		this.originalExt = originalExt;
	}
	get_type() {
		return nanofl_engine_LibraryItemType.mesh;
	}
	clone() {
		let obj = new nanofl_engine_libraryitems_MeshItem(this.namePath,this.ext,this.originalExt);
		obj.textureAtlas = this.textureAtlas;
		obj.renderAreaSize = this.renderAreaSize;
		obj.loadLights = this.loadLights;
		obj.scene = this.scene != null ? this.scene.clone(true) : null;
		obj.boundingRadius = this.boundingRadius;
		obj.textureFiles = this.textureFiles;
		this.copyBaseProperties(obj);
		return obj;
	}
	preload() {
		stdlib_Debug.assert(this.library != null,"You need to add item '" + this.namePath + "' to the library before preload call.",{ fileName : "engine/nanofl/engine/libraryitems/MeshItem.hx", lineNumber : 75, className : "nanofl.engine.libraryitems.MeshItem", methodName : "preload"});
		let spriteSheet = nanofl_engine_TextureAtlasTools.getSpriteSheet(this);
		if(spriteSheet == null) {
			return this.preloadInner();
		} else {
			return Promise.resolve(null);
		}
	}
	preloadInner() {
		if(this.textureAtlas != null && this.textureAtlas != "") {
			return Promise.resolve(null);
		}
		let _gthis = this;
		return nanofl_engine_SerializationAsJsTools.load(this.library,this.namePath,true).then(function(json) {
			return _gthis.processPreloadedJson(json);
		});
	}
	processPreloadedJson(json) {
		nanofl_engine_libraryitems_MeshItem.log("processPreloadedJson",{ fileName : "engine/nanofl/engine/libraryitems/MeshItem.hx", lineNumber : 97, className : "nanofl.engine.libraryitems.MeshItem", methodName : "processPreloadedJson"});
		nanofl_engine_libraryitems_MeshItem.log(json,{ fileName : "engine/nanofl/engine/libraryitems/MeshItem.hx", lineNumber : 98, className : "nanofl.engine.libraryitems.MeshItem", methodName : "processPreloadedJson"});
		let loader = new GLTFLoader();
		let _gthis = this;
		return loader.parseAsync(json,this.library.realUrl("")).then(function(gltf) {
			if(gltf.scene.type == "Scene") {
				_gthis.scene = gltf.scene;
			} else {
				_gthis.scene = new THREE_Scene();
				_gthis.scene.add(gltf.scene);
			}
			_gthis.updateBoundingRadius();
			return null;
		});
	}
	updateBoundingRadius() {
		this.boundingRadius = 0.0;
		let _gthis = this;
		this.scene.traverse(function(object) {
			nanofl_engine_libraryitems_MeshItem.log("MeshItem.updateBoundingRadius object " + object.type + " / " + object.name,{ fileName : "engine/nanofl/engine/libraryitems/MeshItem.hx", lineNumber : 134, className : "nanofl.engine.libraryitems.MeshItem", methodName : "updateBoundingRadius"});
			if(object.type == "Mesh") {
				let mesh = object;
				mesh.updateMatrixWorld(true);
				mesh.geometry.computeBoundingSphere();
				_gthis.boundingRadius = Math.max(_gthis.boundingRadius,mesh.geometry.boundingSphere.radius);
			}
		});
		this.boundingRadius = Math.sqrt(this.boundingRadius);
		nanofl_engine_libraryitems_MeshItem.log("MeshItem.updateBoundingRadius boundingRadius = " + this.boundingRadius,{ fileName : "engine/nanofl/engine/libraryitems/MeshItem.hx", lineNumber : 148, className : "nanofl.engine.libraryitems.MeshItem", methodName : "updateBoundingRadius"});
	}
	createDisplayObject(initFrameIndex,childFrameIndexes) {
		let r = super.createDisplayObject(initFrameIndex,childFrameIndexes);
		if(r == null) {
			let spriteSheet = nanofl_engine_TextureAtlasTools.getSpriteSheet(this);
			r = spriteSheet == null ? new nanofl_Mesh(this) : new createjs.Sprite(spriteSheet);
		}
		return r;
	}
	updateDisplayObject(dispObj,childFrameIndexes) {
		stdlib_Debug.assert(((dispObj) instanceof nanofl_Mesh),null,{ fileName : "engine/nanofl/engine/libraryitems/MeshItem.hx", lineNumber : 170, className : "nanofl.engine.libraryitems.MeshItem", methodName : "updateDisplayObject"});
		let mesh = dispObj;
		mesh.scene = new THREE_Scene();
		mesh.scene.fog = datatools_NullTools.clone(this.scene.fog);
		mesh.scene.add(mesh.group = new THREE_Group());
		let _g = 0;
		let _g1 = this.scene.children;
		while(_g < _g1.length) {
			let object = _g1[_g];
			++_g;
			switch(object.type) {
			case "AmbientLight":case "DirectionalLight":case "HemisphereLight":case "PointLight":case "RectAreaLight":case "SpotLight":
				if(this.loadLights) {
					mesh.group.add(object.clone());
				}
				break;
			default:
				mesh.group.add(object.clone());
			}
		}
		mesh.update();
	}
	get_renderer() {
		if(this._rendererLoadLights != this.loadLights) {
			this._renderer = null;
		}
		if(this._renderer != null) {
			if(!((this._renderer) instanceof THREE_WebGLRenderer)) {
				this._renderer = null;
			}
		}
		if(this._renderer == null) {
			let canvas = window.document.createElement("canvas");
			canvas.width = canvas.height = this.renderAreaSize;
			this._renderer = new THREE_WebGLRenderer({ canvas : canvas, alpha : true});
			this._renderer.setSize(this.renderAreaSize,this.renderAreaSize);
			this._rendererLoadLights = this.loadLights;
		}
		return this._renderer;
	}
	equ(item) {
		if(!((item) instanceof nanofl_engine_libraryitems_MeshItem)) {
			return false;
		}
		if(!super.equ(item)) {
			return false;
		}
		if(item.ext != this.ext) {
			return false;
		}
		if(item.textureAtlas != this.textureAtlas) {
			return false;
		}
		if(item.renderAreaSize != this.renderAreaSize) {
			return false;
		}
		if(item.loadLights != this.loadLights) {
			return false;
		}
		return true;
	}
	loadPropertiesJson(obj) {
		if(obj.type != this.get_type()) {
			throw new Error("Type of item must be '" + Std.string(this.get_type()) + "', but '" + Std.string(obj.type) + "' found.");
		}
		super.loadPropertiesJson(obj);
		let tmp = obj.ext;
		this.ext = tmp != null ? tmp : null;
		let tmp1 = obj.originalExt;
		this.originalExt = tmp1 != null ? tmp1 : null;
		let tmp2 = obj.textureAtlas;
		this.textureAtlas = tmp2 != null ? tmp2 : null;
		let tmp3 = obj.renderAreaSize;
		this.renderAreaSize = tmp3 != null ? tmp3 : 256;
		let tmp4 = obj.loadLights;
		this.loadLights = tmp4 != null && tmp4;
	}
	toString() {
		return "MeshItem(" + this.namePath + ")";
	}
	static log(v,infos) {
	}
}
nanofl_engine_libraryitems_MeshItem.__name__ = "nanofl.engine.libraryitems.MeshItem";
nanofl_engine_libraryitems_MeshItem.__interfaces__ = [nanofl_engine_ITextureItem];
nanofl_engine_libraryitems_MeshItem.__super__ = nanofl_engine_libraryitems_InstancableItem;
Object.assign(nanofl_engine_libraryitems_MeshItem.prototype, {
	__class__: nanofl_engine_libraryitems_MeshItem
});
class nanofl_engine_libraryitems_MovieClipItem extends nanofl_engine_libraryitems_InstancableItem {
	constructor(namePath) {
		nanofl_engine_libraryitems_LibraryItem._hx_skip_constructor = true;
		super();
		nanofl_engine_libraryitems_LibraryItem._hx_skip_constructor = false;
		this._hx_constructor(namePath);
	}
	_hx_constructor(namePath) {
		this.spriteSheet = null;
		this.exportAsSprite = false;
		this.likeButton = false;
		this.loop = true;
		this.autoPlay = true;
		this._layers = [];
		super._hx_constructor(namePath);
	}
	get_type() {
		return nanofl_engine_LibraryItemType.movieclip;
	}
	get_layers() {
		return this._layers;
	}
	addLayer(layer) {
		nanofl_engine_LayersTools.addLayer(this,layer);
	}
	addLayersBlock(layersToAdd,index) {
		nanofl_engine_LayersTools.addLayersBlock(this,layersToAdd,index);
	}
	getTotalFrames() {
		return nanofl_engine_LayersTools.getTotalFrames(this);
	}
	clone() {
		let obj = new nanofl_engine_libraryitems_MovieClipItem(this.namePath);
		this.copyBaseProperties(obj);
		this.copyProperties(obj);
		return obj;
	}
	copyProperties(obj) {
		obj._layers = [];
		let _g = 0;
		let _g1 = this.get_layers();
		while(_g < _g1.length) {
			let layer = _g1[_g];
			++_g;
			obj.addLayer(layer.clone());
		}
		obj.likeButton = this.likeButton;
		obj.autoPlay = this.autoPlay;
		obj.loop = this.loop;
		obj.exportAsSprite = this.exportAsSprite;
		obj.textureAtlas = this.textureAtlas;
	}
	createDisplayObject(initFrameIndex,childFrameIndexes) {
		let r = super.createDisplayObject(initFrameIndex,childFrameIndexes);
		if(r != null) {
			return r;
		}
		let spriteSheet = nanofl_engine_TextureAtlasTools.getSpriteSheet(this);
		if(spriteSheet == null && this.exportAsSprite) {
			spriteSheet = this.asSpriteSheet();
		}
		if(spriteSheet == null) {
			if(!this.likeButton) {
				return new nanofl_MovieClip(this,initFrameIndex,childFrameIndexes);
			} else {
				return new nanofl_Button(this);
			}
		} else if(!this.likeButton) {
			return new createjs.Sprite(spriteSheet,initFrameIndex);
		} else {
			return new nanofl_SpriteButton(spriteSheet);
		}
	}
	updateDisplayObject(dispObj,childFrameIndexes) {
		if(!this.exportAsSprite) {
			nanofl_engine_libraryitems_MovieClipItem.updateDisplayObjectInner(this.get_layers(),dispObj,childFrameIndexes);
		}
	}
	asSpriteSheet() {
		if(this.spriteSheet == null) {
			let builder = new createjs.SpriteSheetBuilder();
			let t = this.exportAsSprite;
			this.exportAsSprite = false;
			let _g = 0;
			let _g1 = this.getTotalFrames();
			while(_g < _g1) {
				let i = _g++;
				let mc = new nanofl_MovieClip(this,i,null);
				builder.addFrame(mc);
			}
			this.exportAsSprite = t;
			this.spriteSheet = builder.build();
		}
		return this.spriteSheet;
	}
	preload() {
		return Promise.resolve(null);
	}
	equ(item) {
		if(item == this) {
			return true;
		}
		if(!((item) instanceof nanofl_engine_libraryitems_MovieClipItem)) {
			return false;
		}
		if(item.namePath != this.namePath) {
			return false;
		}
		let mc = item;
		if(mc.linkedClass != this.linkedClass) {
			return false;
		}
		if(mc.autoPlay != this.autoPlay) {
			return false;
		}
		if(mc.loop != this.loop) {
			return false;
		}
		if(!datatools_ArrayTools.equ(mc._layers,this._layers)) {
			return false;
		}
		if(item.likeButton != this.likeButton) {
			return false;
		}
		if(item.exportAsSprite != this.exportAsSprite) {
			return false;
		}
		if(item.textureAtlas != this.textureAtlas) {
			return false;
		}
		return true;
	}
	setLibrary(library) {
		super.setLibrary(library);
		let _g = 0;
		let _g1 = this.get_layers();
		while(_g < _g1.length) {
			let layer = _g1[_g];
			++_g;
			layer.setLibrary(library);
		}
	}
	loadPropertiesJson(obj) {
		if(obj.type != this.get_type()) {
			throw new Error("Type of item must be '" + Std.string(this.get_type()) + "', but '" + Std.string(obj.type) + "' found.");
		}
		super.loadPropertiesJson(obj);
		this.autoPlay = obj.autoPlay;
		this.loop = obj.loop;
		this.likeButton = obj.likeButton;
		this.exportAsSprite = obj.exportAsSprite;
		this.textureAtlas = obj.textureAtlas;
		let _this = obj.layers;
		let result = new Array(_this.length);
		let _g = 0;
		let _g1 = _this.length;
		while(_g < _g1) {
			let i = _g++;
			let layer = new nanofl_engine_movieclip_Layer("");
			layer.loadPropertiesJson(_this[i],obj.version);
			result[i] = layer;
		}
		this.addLayersBlock(result);
	}
	toString() {
		return "MovieClipItem(" + this.namePath + ")";
	}
	static createWithFrame(namePath,elements,layerName) {
		if(layerName == null) {
			layerName = "Layer 0";
		}
		let item = new nanofl_engine_libraryitems_MovieClipItem(namePath);
		let layer = new nanofl_engine_movieclip_Layer(layerName);
		item.addLayer(layer);
		layer.addKeyFrame(new nanofl_engine_movieclip_KeyFrame(null,null,null,elements));
		return item;
	}
	static updateDisplayObjectInner(layers,dispObj,childFrameIndexes) {
		stdlib_Debug.assert(((dispObj) instanceof nanofl_MovieClip),null,{ fileName : "engine/nanofl/engine/libraryitems/MovieClipItem.hx", lineNumber : 140, className : "nanofl.engine.libraryitems.MovieClipItem", methodName : "updateDisplayObjectInner"});
		let movieClip = dispObj;
		movieClip.removeAllChildren();
		movieClip.alpha = 1.0;
		let topElement = null;
		let topElementLayer = null;
		let i = layers.length - 1;
		while(i >= 0) {
			let _g = 0;
			let _g1 = layers[i].getTweenedElements(movieClip.currentFrame);
			while(_g < _g1.length) {
				let tweenedElement = _g1[_g];
				++_g;
				if(childFrameIndexes == null || childFrameIndexes.length == 0 || childFrameIndexes[0].element != tweenedElement.original) {
					let obj = tweenedElement.current.createDisplayObject(childFrameIndexes);
					obj.visible = layers[i].type == nanofl_engine_LayerType.normal;
					movieClip.addChildToLayer(obj,i);
				} else if(childFrameIndexes != null && childFrameIndexes.length != 0 && childFrameIndexes[0].element == tweenedElement.original) {
					topElement = tweenedElement.current;
					topElementLayer = i;
				}
			}
			--i;
		}
		if(topElement != null) {
			movieClip.addChildToLayer(topElement.createDisplayObject(childFrameIndexes),topElementLayer);
		}
	}
	static loadFromJson(namePath,baseLibraryUrl) {
		return nanofl_engine_Loader.file(baseLibraryUrl + "/" + namePath + ".json").then(function(itemJsonStr) {
			let r = new nanofl_engine_libraryitems_MovieClipItem(namePath);
			r.loadPropertiesJson(JSON.parse(itemJsonStr));
			return r;
		});
	}
}
nanofl_engine_libraryitems_MovieClipItem.__name__ = "nanofl.engine.libraryitems.MovieClipItem";
nanofl_engine_libraryitems_MovieClipItem.__interfaces__ = [nanofl_engine_IFramedItem,nanofl_engine_ISpriteSheetableItem,nanofl_engine_ITextureItem,nanofl_engine_ITimeline,nanofl_engine_ILayersContainer];
nanofl_engine_libraryitems_MovieClipItem.__super__ = nanofl_engine_libraryitems_InstancableItem;
Object.assign(nanofl_engine_libraryitems_MovieClipItem.prototype, {
	__class__: nanofl_engine_libraryitems_MovieClipItem
});
class nanofl_engine_libraryitems_SoundItem extends nanofl_engine_libraryitems_LibraryItem {
	constructor(namePath,ext) {
		nanofl_engine_libraryitems_LibraryItem._hx_skip_constructor = true;
		super();
		nanofl_engine_libraryitems_LibraryItem._hx_skip_constructor = false;
		this._hx_constructor(namePath,ext);
	}
	_hx_constructor(namePath,ext) {
		this.linkage = "";
		super._hx_constructor(namePath);
		this.ext = ext;
	}
	clone() {
		let obj = new nanofl_engine_libraryitems_SoundItem(this.namePath,this.ext);
		obj.linkage = this.linkage;
		this.copyBaseProperties(obj);
		return obj;
	}
	equ(item) {
		if(item.namePath != this.namePath) {
			return false;
		}
		if(!((item) instanceof nanofl_engine_libraryitems_SoundItem)) {
			return false;
		}
		if(item.ext != this.ext) {
			return false;
		}
		if(item.linkage != this.linkage) {
			return false;
		}
		return true;
	}
	preload() {
		stdlib_Debug.assert(this.linkage != null && this.linkage != "",null,{ fileName : "engine/nanofl/engine/libraryitems/SoundItem.hx", lineNumber : 53, className : "nanofl.engine.libraryitems.SoundItem", methodName : "preload"});
		let _gthis = this;
		if(this.ext.toLowerCase() == "js") {
			return nanofl_engine_SerializationAsJsTools.load(this.library,this.namePath,true).then(function(dataUri) {
				return _gthis.preloadInner(dataUri);
			});
		} else {
			return this.preloadInner(this.library.realUrl(this.namePath + "." + this.ext));
		}
	}
	preloadInner(uri) {
		let _gthis = this;
		return new Promise(function(resolve,reject) {
			_gthis.audio = new Audio();
			_gthis.audio.addEventListener("canplay",function() {
				resolve(null);
			});
			_gthis.audio.addEventListener("error",function(e) {
				$global.console.warn("Error loading sound " + _gthis.namePath,e);
				resolve(null);
			});
			_gthis.audio.src = uri;
		});
	}
	play() {
		stdlib_Debug.assert(this.audio != null,null,{ fileName : "engine/nanofl/engine/libraryitems/SoundItem.hx", lineNumber : 78, className : "nanofl.engine.libraryitems.SoundItem", methodName : "play"});
		let r = this.audio.cloneNode();
		r.play();
		return r;
	}
	loadPropertiesJson(obj) {
		let tmp = obj.linkage;
		this.linkage = tmp != null ? tmp : "";
		let tmp1 = obj.ext;
		this.ext = tmp1 != null ? tmp1 : "";
	}
	toString() {
		return "SoundItem(" + this.namePath + ")";
	}
}
nanofl_engine_libraryitems_SoundItem.__name__ = "nanofl.engine.libraryitems.SoundItem";
nanofl_engine_libraryitems_SoundItem.__super__ = nanofl_engine_libraryitems_LibraryItem;
Object.assign(nanofl_engine_libraryitems_SoundItem.prototype, {
	__class__: nanofl_engine_libraryitems_SoundItem
});
class nanofl_engine_movieclip_Guide {
	constructor(guideLine) {
		let tmp = guideLine;
		this.guideLine = tmp != null ? tmp : new nanofl_engine_movieclip_GuideLine();
	}
	get(startProps,finishProps,orientToPath,t) {
		nanofl_engine_movieclip_Guide.log("Guide.getPos: " + startProps.x + ", " + startProps.y + " => " + finishProps.x + ", " + finishProps.y + "; t = " + t,{ fileName : "engine/nanofl/engine/movieclip/Guide.hx", lineNumber : 14, className : "nanofl.engine.movieclip.Guide", methodName : "get"});
		let path = this.guideLine.getPath(startProps,finishProps);
		nanofl_engine_movieclip_Guide.log("path = " + path.join("; "),{ fileName : "engine/nanofl/engine/movieclip/Guide.hx", lineNumber : 17, className : "nanofl.engine.movieclip.Guide", methodName : "get"});
		let result = new Array(path.length);
		let _g = 0;
		let _g1 = path.length;
		while(_g < _g1) {
			let i = _g++;
			result[i] = path[i].getLength();
		}
		let lens = result;
		let sumLen = 0.0;
		let _g2 = 0;
		while(_g2 < lens.length) {
			let len = lens[_g2];
			++_g2;
			sumLen += len;
		}
		if(sumLen == 0.0) {
			return { x : path[0].x1, y : path[0].y1, rotation : startProps.rotation};
		}
		let lenPos = sumLen * t;
		let curLen = 0.0;
		let _g3 = 0;
		let _g4 = path.length;
		while(_g3 < _g4) {
			let i = _g3++;
			if(lens[i] == 0) {
				continue;
			}
			curLen += lens[i];
			if(curLen >= lenPos) {
				let dLen = lenPos - (curLen - lens[i]);
				let subT = dLen / lens[i];
				let point = path[i].getMonotoneT(subT);
				let point1 = path[i].getPoint(point);
				let rotation;
				if(!orientToPath) {
					rotation = startProps.rotation + (finishProps.rotation - startProps.rotation) * t;
				} else {
					let angleT = path[i].getTangent(subT) * 180 / Math.PI;
					let angleS = path[0].getTangent(0) * 180 / Math.PI;
					let angleF = path[path.length - 1].getTangent(1) * 180 / Math.PI;
					rotation = startProps.rotation + (angleT - angleS) + (finishProps.rotation - angleF - (startProps.rotation - angleS)) * t;
				}
				return { x : point1.x, y : point1.y, rotation : rotation};
			}
		}
		return Reflect.copy(finishProps);
	}
	static log(v,infos) {
	}
}
nanofl_engine_movieclip_Guide.__name__ = "nanofl.engine.movieclip.Guide";
Object.assign(nanofl_engine_movieclip_Guide.prototype, {
	__class__: nanofl_engine_movieclip_Guide
});
class nanofl_engine_movieclip_GuideLine {
	constructor(shape) {
		let tmp = shape;
		this.shape = tmp != null ? tmp : new nanofl_engine_elements_ShapeElement();
		this.vectors = this.shape.edges.slice();
		let _g = 0;
		let _g1 = this.shape.edges;
		while(_g < _g1.length) {
			let edge = _g1[_g];
			++_g;
			this.vectors.push(edge.clone().reverse());
		}
		let _g2 = [];
		let _g3 = 0;
		let _g4 = this.vectors;
		while(_g3 < _g4.length) {
			let v = _g4[_g3];
			++_g3;
			if(v.x1 != v.x3 || v.y1 != v.y3) {
				_g2.push(v);
			}
		}
		this.vectors = _g2;
		this.connections = nanofl_engine_movieclip_GuideLine.getConnectionMatrix(this.vectors);
		this.used = [];
		let _g5 = 0;
		let _g6 = this.shape.edges.length;
		while(_g5 < _g6) {
			let i = _g5++;
			this.used.push(false);
		}
	}
	getPath(startPos,finishPos) {
		let r = this.findPath(startPos,finishPos);
		if(r.length == 0) {
			r.push(new nanofl_engine_geom_Edge(startPos.x,startPos.y,finishPos.x,finishPos.y));
		}
		return r;
	}
	findPath(startPos,finishPos) {
		if(this.vectors.length == 0) {
			return [];
		}
		let start = this.shape.getNearestStrokeEdge(startPos);
		let end = this.shape.getNearestStrokeEdge(finishPos);
		nanofl_engine_movieclip_GuideLine.log("Guide.findPath " + nanofl_engine_geom_PointTools.toString(startPos) + " (" + start.t + ") => " + nanofl_engine_geom_PointTools.toString(finishPos) + " (" + end.t + ")" + "\tend.edge = " + Std.string(end.edge),{ fileName : "engine/nanofl/engine/movieclip/GuideLine.hx", lineNumber : 75, className : "nanofl.engine.movieclip.GuideLine", methodName : "findPath"});
		let params = { counter : 0, endEdge : end.edge, bestLen : 1.0e100, bestPath : [], path : [], len : 0.0};
		let startEdgeIndex = stdlib_LambdaIterable.findIndex(this.shape.edges,function(e) {
			return e.equ(start.edge);
		});
		stdlib_Debug.assert(startEdgeIndex >= 0,"startEdgeIndex = " + startEdgeIndex,{ fileName : "engine/nanofl/engine/movieclip/GuideLine.hx", lineNumber : 90, className : "nanofl.engine.movieclip.GuideLine", methodName : "findPath"});
		this.findPathInner(params,startEdgeIndex);
		this.findPathInner(params,startEdgeIndex + this.shape.edges.length);
		let _gthis = this;
		let _this = params.bestPath;
		let result = new Array(_this.length);
		let _g = 0;
		let _g1 = _this.length;
		while(_g < _g1) {
			let i = _g++;
			result[i] = _gthis.vectors[_this[i]];
		}
		let path = result;
		if(path.length > 0) {
			let lastI = path.length - 1;
			let firstSameDir = path[0].x3 == start.edge.x3 && path[0].y3 == start.edge.y3;
			let lastSameDir = path[lastI].x1 == end.edge.x1 && path[lastI].y1 == end.edge.y1;
			path[0] = firstSameDir ? path[0].clone().reverse().getPart(1 - start.t).reverse() : path[0] = path[0].getPart(start.t);
			path[lastI] = lastSameDir ? path[lastI].getPart(end.t) : path[lastI].clone().reverse().getPart(1 - end.t).reverse();
		}
		return path;
	}
	findPathInner(params,nextVectorIndex) {
		params.counter++;
		let nextVector = this.vectors[nextVectorIndex];
		let edgesCount = this.vectors.length >> 1;
		params.path.push(nextVectorIndex);
		this.used[nextVectorIndex % edgesCount] = true;
		params.len += nextVector.getLength();
		if(params.len < params.bestLen) {
			if(nextVector.equ(params.endEdge)) {
				params.bestLen = params.len;
				params.bestPath = params.path.slice();
			} else {
				let _g = 0;
				let _g1 = this.vectors.length;
				while(_g < _g1) {
					let i = _g++;
					if(!this.used[i % edgesCount] && this.connections[nextVectorIndex][i]) {
						this.findPathInner(params,i);
					}
				}
			}
		}
		params.len -= nextVector.getLength();
		this.used[nextVectorIndex % edgesCount] = false;
		params.path.pop();
	}
	static getConnectionMatrix(vectors) {
		let r = [];
		let _g = 0;
		while(_g < vectors.length) {
			let a = vectors[_g];
			++_g;
			let line = [];
			let _g1 = 0;
			while(_g1 < vectors.length) {
				let b = vectors[_g1];
				++_g1;
				line.push(a.x3 == b.x1 && a.y3 == b.y1);
			}
			r.push(line);
		}
		return r;
	}
	static log(v,infos) {
	}
}
nanofl_engine_movieclip_GuideLine.__name__ = "nanofl.engine.movieclip.GuideLine";
Object.assign(nanofl_engine_movieclip_GuideLine.prototype, {
	__class__: nanofl_engine_movieclip_GuideLine
});
class nanofl_engine_movieclip_Layer {
	constructor(name,type,visible,locked,parentIndex) {
		if(locked == null) {
			locked = false;
		}
		if(visible == null) {
			visible = true;
		}
		this.name = name;
		this.type = type != null ? type : nanofl_engine_LayerType.normal;
		this.visible = visible;
		this.locked = locked;
		this.parentIndex = parentIndex;
		this._keyFrames = [];
	}
	get_parentLayer() {
		if(this.parentIndex != null) {
			return this.layersContainer.get_layers()[this.parentIndex];
		} else {
			return null;
		}
	}
	getTotalFrames() {
		let r = 0;
		let _g = 0;
		let _g1 = this._keyFrames;
		while(_g < _g1.length) {
			let frame = _g1[_g];
			++_g;
			r += frame.duration;
		}
		return r;
	}
	getFrame(frameIndex) {
		let indexes = this.getFrameIndexes(frameIndex);
		if(indexes != null) {
			return { keyFrame : this._keyFrames[indexes.keyIndex], subIndex : indexes.subIndex};
		} else {
			return null;
		}
	}
	getFrameIndexes(frameIndex) {
		let start = 0;
		let _g = 0;
		let _g1 = this._keyFrames.length;
		while(_g < _g1) {
			let i = _g++;
			if(frameIndex >= start && frameIndex < start + this._keyFrames[i].duration) {
				return { keyIndex : i, subIndex : frameIndex - start};
			}
			start += this._keyFrames[i].duration;
		}
		return null;
	}
	addKeyFrame(keyFrame) {
		this._keyFrames.push(keyFrame);
		keyFrame.layer = this;
	}
	getTweenedElements(frameIndex) {
		let frame = this.getFrame(frameIndex);
		if(frame != null) {
			return frame.keyFrame.getTweenedElements(frame.subIndex);
		}
		return [];
	}
	loadPropertiesJson(obj,version) {
		let tmp = obj.name;
		this.name = tmp != null ? tmp : "";
		let tmp1 = obj.type;
		this.type = Type.createEnum(nanofl_engine_LayerType,tmp1 != null ? tmp1 : "normal",null);
		let tmp2 = obj.visible;
		this.visible = tmp2 != null ? tmp2 : true;
		let tmp3 = obj.locked;
		this.locked = tmp3 != null && tmp3;
		this.parentIndex = obj.parentIndex;
		let _g = 0;
		let _g1 = obj.keyFrames;
		while(_g < _g1.length) {
			let kf = _g1[_g];
			++_g;
			this.addKeyFrame(nanofl_engine_movieclip_KeyFrame.parseJson(kf,version));
		}
	}
	clone() {
		return this.duplicate(this._keyFrames,this.parentIndex);
	}
	duplicate(keyFrames,parentIndex) {
		let r = new nanofl_engine_movieclip_Layer(this.name,this.type,this.visible,this.locked,parentIndex);
		let _g = 0;
		let _g1 = keyFrames;
		while(_g < _g1.length) {
			let keyFrame = _g1[_g];
			++_g;
			r.addKeyFrame(keyFrame.clone());
		}
		return r;
	}
	setLibrary(library) {
		let _g = 0;
		let _g1 = this._keyFrames;
		while(_g < _g1.length) {
			let keyFrame = _g1[_g];
			++_g;
			keyFrame.setLibrary(library);
		}
	}
	equ(layer) {
		if(layer.name != this.name) {
			return false;
		}
		if(layer.type != this.type) {
			return false;
		}
		if(layer.visible != this.visible) {
			return false;
		}
		if(layer.locked != this.locked) {
			return false;
		}
		if(!datatools_ArrayTools.equ(layer._keyFrames,this._keyFrames)) {
			return false;
		}
		return true;
	}
	toString() {
		return (this.layersContainer != null ? this.layersContainer.toString() + " / " : "") + "layer";
	}
}
nanofl_engine_movieclip_Layer.__name__ = "nanofl.engine.movieclip.Layer";
Object.assign(nanofl_engine_movieclip_Layer.prototype, {
	__class__: nanofl_engine_movieclip_Layer
});
class nanofl_engine_movieclip_MotionTween {
	constructor(easing,orientToPath,rotateCount,rotateCountX,rotateCountY,directionalLightRotateCountX,directionalLightRotateCountY) {
		this.easing = easing;
		this.orientToPath = orientToPath;
		this.rotateCount = rotateCount;
		this.rotateCountX = rotateCountX;
		this.rotateCountY = rotateCountY;
		this.directionalLightRotateCountX = directionalLightRotateCountX;
		this.directionalLightRotateCountY = directionalLightRotateCountY;
	}
	getGuideLine(keyFrame,frameSubIndex) {
		if(keyFrame.layer.parentIndex == null) {
			return null;
		}
		let parentLayer = keyFrame.layer.get_parentLayer();
		if(parentLayer.type != nanofl_engine_LayerType.guide) {
			return null;
		}
		let frame = parentLayer.getFrame(keyFrame.getIndex() + frameSubIndex);
		return frame.keyFrame.getGuideLine();
	}
	apply(frameSubIndex) {
		let startElements = this.keyFrame.get_elements();
		let nextKeyFrame = this.keyFrame.getNextKeyFrame();
		let finishElements = nextKeyFrame != null ? nextKeyFrame.get_elements() : null;
		let guideLine = this.getGuideLine(this.keyFrame,frameSubIndex);
		let guide = guideLine != null ? new nanofl_engine_movieclip_Guide(guideLine) : null;
		let t = frameSubIndex / this.keyFrame.duration;
		let r = [];
		if(finishElements != null) {
			let ease = nanofl_engine_Ease.get(this.easing / 100);
			let k = ease(t);
			let instancesMap = this.getInstancesMap(startElements,finishElements);
			let _g = 0;
			let _g1 = startElements;
			while(_g < _g1.length) {
				let startElement = _g1[_g];
				++_g;
				if(((startElement) instanceof nanofl_engine_elements_Instance) && instancesMap.h.__keys__[startElement.__id__] != null) {
					let startInstance = startElement;
					let finishInstance = instancesMap.h[startInstance.__id__];
					let targetInstance = this.getMovedInstance(startInstance,finishInstance,k,guide);
					let _g = [];
					let _g1 = 0;
					let _g2 = startInstance.getFilters();
					while(_g1 < _g2.length) {
						let v = _g2[_g1];
						++_g1;
						if(Object.prototype.hasOwnProperty.call(nanofl_engine_plugins_FilterPlugins.plugins.h,v.name)) {
							_g.push(v);
						}
					}
					let startFilters = _g;
					let _g3 = [];
					let _g4 = 0;
					let _g5 = finishInstance.getFilters();
					while(_g4 < _g5.length) {
						let v = _g5[_g4];
						++_g4;
						if(Object.prototype.hasOwnProperty.call(nanofl_engine_plugins_FilterPlugins.plugins.h,v.name)) {
							_g3.push(v);
						}
					}
					let finishFilters = _g3;
					this.fixFilterSequence(startFilters,finishFilters);
					this.fixFilterSequence(finishFilters,startFilters);
					stdlib_Debug.assert(startFilters.length == finishFilters.length,"startFilters.length = " + startFilters.length + " != finishFilters.length = " + finishFilters.length,{ fileName : "engine/nanofl/engine/movieclip/MotionTween.hx", lineNumber : 92, className : "nanofl.engine.movieclip.MotionTween", methodName : "apply"});
					let i = 0;
					let _g6 = [];
					let _g_current = 0;
					let _g_array = startFilters;
					while(_g_current < _g_array.length) {
						let x = _g_array[_g_current++];
						_g6.push(x.clone().tween(k,finishFilters[i++]));
					}
					targetInstance.setFilters(Lambda.array(_g6));
					r.push(new nanofl_engine_movieclip_TweenedElement(startElement,targetInstance));
				} else {
					r.push(new nanofl_engine_movieclip_TweenedElement(startElement,startElement));
				}
			}
		} else {
			let _g = 0;
			let _g1 = this.keyFrame.get_elements();
			while(_g < _g1.length) {
				let element = _g1[_g];
				++_g;
				r.push(new nanofl_engine_movieclip_TweenedElement(element,element));
			}
		}
		return r;
	}
	fixFilterSequence(src,dst) {
		let _g = 0;
		let _g1 = src.length;
		while(_g < _g1) {
			let i = _g++;
			if(i >= dst.length || dst[i].name != src[i].name) {
				let x = src[i].clone().resetToNeutral();
				dst.splice(i,0,x);
			}
		}
	}
	getInstancesMap(startElements,finishElements) {
		let r = new haxe_ds_ObjectMap();
		if(finishElements != null) {
			let startInstances = datatools_ArrayRO.filterByType(startElements,nanofl_engine_elements_Instance);
			let finishInstances = datatools_ArrayRO.filterByType(finishElements,nanofl_engine_elements_Instance);
			let _g = 0;
			while(_g < startInstances.length) {
				let instance = startInstances[_g];
				++_g;
				let _g1 = 0;
				while(_g1 < finishInstances.length) {
					let nextInstance = finishInstances[_g1];
					++_g1;
					if(nextInstance.namePath == instance.namePath) {
						r.set(instance,nextInstance);
						HxOverrides.remove(finishInstances,nextInstance);
						break;
					}
				}
			}
		}
		return r;
	}
	getMovedInstance(startInstance,finishInstance,k,guide) {
		if(guide == null) {
			guide = new nanofl_engine_movieclip_Guide(null);
		}
		let targetInstance = js_Boot.__cast(startInstance.clone() , nanofl_engine_elements_Instance);
		let startProps = this.translatedMatrixByLocalVector(startInstance.matrix.clone(),startInstance.regX,startInstance.regY).decompose();
		let finishProps = this.translatedMatrixByLocalVector(finishInstance.matrix.clone(),startInstance.regX,startInstance.regY).decompose();
		let props = guide.get(startProps,finishProps,this.orientToPath,k);
		targetInstance.matrix.setTransform(props.x,props.y,startProps.scaleX + (finishProps.scaleX - startProps.scaleX) * k,startProps.scaleY + (finishProps.scaleY - startProps.scaleY) * k,props.rotation + this.rotateCount * 360 * k,startProps.skewX + (finishProps.skewX - startProps.skewX) * k,startProps.skewY + (finishProps.skewY - startProps.skewY) * k);
		this.translatedMatrixByLocalVector(targetInstance.matrix,-startInstance.regX,-startInstance.regY);
		if(((startInstance.get_symbol()) instanceof nanofl_engine_libraryitems_MeshItem) && ((finishInstance.get_symbol()) instanceof nanofl_engine_libraryitems_MeshItem)) {
			targetInstance.meshParams.rotationX += (finishInstance.meshParams.rotationX - startInstance.meshParams.rotationX) * k + this.rotateCountX * 360 * k;
			targetInstance.meshParams.rotationY += (finishInstance.meshParams.rotationY - startInstance.meshParams.rotationY) * k + this.rotateCountY * 360 * k;
			targetInstance.meshParams.cameraFov += Math.round((finishInstance.meshParams.cameraFov - startInstance.meshParams.cameraFov) * k);
			targetInstance.meshParams.ambientLightColor = nanofl_engine_ColorTools.getTweened(startInstance.meshParams.ambientLightColor,k,finishInstance.meshParams.ambientLightColor);
			targetInstance.meshParams.directionalLightColor = nanofl_engine_ColorTools.getTweened(startInstance.meshParams.directionalLightColor,k,finishInstance.meshParams.directionalLightColor);
			targetInstance.meshParams.directionalLightRotationX += (finishInstance.meshParams.directionalLightRotationX - startInstance.meshParams.directionalLightRotationX) * k + this.directionalLightRotateCountX * 360 * k;
			targetInstance.meshParams.directionalLightRotationY += (finishInstance.meshParams.directionalLightRotationY - startInstance.meshParams.directionalLightRotationY) * k + this.directionalLightRotateCountY * 360 * k;
		}
		if(startInstance.colorEffect != null || finishInstance.colorEffect != null) {
			let startCE = startInstance.colorEffect != null ? startInstance.colorEffect : finishInstance.colorEffect.getNeutralClone();
			let finishCE = finishInstance.colorEffect != null ? finishInstance.colorEffect : startInstance.colorEffect.getNeutralClone();
			if(js_Boot.getClass(startCE) == js_Boot.getClass(finishCE)) {
				targetInstance.colorEffect = startCE.getTweened(k,finishCE);
			} else {
				targetInstance.colorEffect = new nanofl_engine_coloreffects_ColorEffectDouble(startCE.getTweened(k,startCE.getNeutralClone()),finishCE.getNeutralClone().getTweened(k,finishCE));
			}
		}
		return targetInstance;
	}
	translatedMatrixByLocalVector(m,dx,dy) {
		let v = m.transformPoint(dx,dy);
		m.tx = v.x;
		m.ty = v.y;
		return m;
	}
	clone() {
		return new nanofl_engine_movieclip_MotionTween(this.easing,this.orientToPath,this.rotateCount,this.rotateCountX,this.rotateCountY,this.directionalLightRotateCountX,this.directionalLightRotateCountY);
	}
	equ(_motionTween) {
		stdlib_Debug.assert(((_motionTween) instanceof nanofl_engine_movieclip_MotionTween),null,{ fileName : "engine/nanofl/engine/movieclip/MotionTween.hx", lineNumber : 303, className : "nanofl.engine.movieclip.MotionTween", methodName : "equ"});
		let motionTween = _motionTween;
		if(motionTween.easing != this.easing) {
			return false;
		}
		if(motionTween.rotateCount != this.rotateCount) {
			return false;
		}
		if(motionTween.orientToPath != this.orientToPath) {
			return false;
		}
		if(motionTween.rotateCountX != this.rotateCountX) {
			return false;
		}
		if(motionTween.rotateCountY != this.rotateCountY) {
			return false;
		}
		if(motionTween.directionalLightRotateCountX != this.directionalLightRotateCountX) {
			return false;
		}
		if(motionTween.directionalLightRotateCountY != this.directionalLightRotateCountY) {
			return false;
		}
		return true;
	}
	static loadJson(obj) {
		if((obj != null ? obj.tweenType : null) != "motion") {
			return null;
		}
		let tmp = obj.motionTweenEasing;
		let tmp1 = obj.motionTweenOrientToPath;
		let tmp2 = obj.motionTweenRotateCount;
		let tmp3 = obj.motionTweenRotateCountX;
		let tmp4 = obj.motionTweenRotateCountY;
		let tmp5 = obj.motionTweenDirectionalLightRotateCountX;
		let tmp6 = obj.motionTweenDirectionalLightRotateCountY;
		return new nanofl_engine_movieclip_MotionTween(tmp != null ? tmp : 0,tmp1 != null && tmp1,tmp2 != null ? tmp2 : 0,tmp3 != null ? tmp3 : 0,tmp4 != null ? tmp4 : 0,tmp5 != null ? tmp5 : 0,tmp6 != null ? tmp6 : 0);
	}
}
nanofl_engine_movieclip_MotionTween.__name__ = "nanofl.engine.movieclip.MotionTween";
nanofl_engine_movieclip_MotionTween.__interfaces__ = [nanofl_engine_IMotionTween];
Object.assign(nanofl_engine_movieclip_MotionTween.prototype, {
	__class__: nanofl_engine_movieclip_MotionTween
});
class nanofl_engine_movieclip_TweenedElement {
	constructor(original,current) {
		this.original = original;
		this.current = current;
	}
}
nanofl_engine_movieclip_TweenedElement.__name__ = "nanofl.engine.movieclip.TweenedElement";
Object.assign(nanofl_engine_movieclip_TweenedElement.prototype, {
	__class__: nanofl_engine_movieclip_TweenedElement
});
class nanofl_engine_plugins_FilterPlugins {
	static register(plugin) {
		nanofl_engine_plugins_FilterPlugins.plugins.h[plugin.name] = plugin;
	}
}
$hx_exports["nanofl"]["engine"]["plugins"]["FilterPlugins"] = nanofl_engine_plugins_FilterPlugins;
nanofl_engine_plugins_FilterPlugins.__name__ = "nanofl.engine.plugins.FilterPlugins";
class nanofl_engine_plugins_IFilterPlugin {
}
$hx_exports["nanofl"]["engine"]["plugins"]["IFilterPlugin"] = nanofl_engine_plugins_IFilterPlugin;
nanofl_engine_plugins_IFilterPlugin.__name__ = "nanofl.engine.plugins.IFilterPlugin";
nanofl_engine_plugins_IFilterPlugin.__isInterface__ = true;
Object.assign(nanofl_engine_plugins_IFilterPlugin.prototype, {
	__class__: nanofl_engine_plugins_IFilterPlugin
});
class nanofl_engine_strokes_BaseStroke {
	constructor(thickness,caps,joints,miterLimit,ignoreScale) {
		if(ignoreScale == null) {
			ignoreScale = false;
		}
		if(miterLimit == null) {
			miterLimit = 3.0;
		}
		if(joints == null) {
			joints = "round";
		}
		if(caps == null) {
			caps = "round";
		}
		if(thickness == null) {
			thickness = 1.0;
		}
		this.thickness = thickness;
		this.caps = caps;
		this.joints = joints;
		this.miterLimit = miterLimit;
		this.ignoreScale = ignoreScale;
	}
	loadBasePropertiesJson(obj) {
		let tmp = obj.thickness;
		this.thickness = tmp != null ? tmp : 1.0;
		let tmp1 = obj.caps;
		this.caps = tmp1 != null ? tmp1 : "round";
		let tmp2 = obj.joints;
		this.joints = tmp2 != null ? tmp2 : "round";
		let tmp3 = obj.miterLimit;
		this.miterLimit = tmp3 != null ? tmp3 : 3.0;
		let tmp4 = obj.ignoreScale;
		this.ignoreScale = tmp4 != null && tmp4;
	}
	setStrokeStyle(g) {
		g.setStrokeStyle(this.thickness,this.caps,this.joints,this.miterLimit,this.ignoreScale);
	}
	clone() {
		let c = js_Boot.getClass(this);
		throw haxe_Exception.thrown("Cloning of " + c.__name__ + " is not supported.");
	}
	equ(e) {
		let ee = e;
		if(ee.thickness == this.thickness && ee.caps == this.caps && ee.joints == this.joints && ee.miterLimit == this.miterLimit) {
			return ee.ignoreScale == this.ignoreScale;
		} else {
			return false;
		}
	}
	setLibrary(library) {
	}
	getTransformed(m,applyToThickness) {
		let r = this.clone();
		if(applyToThickness) {
			r.thickness *= m.getAverageScale();
		}
		return r;
	}
	static loadJson(obj,version) {
		let r;
		switch(obj.type) {
		case "bitmap":
			r = new nanofl_engine_strokes_BitmapStroke();
			break;
		case "linear":
			r = new nanofl_engine_strokes_LinearStroke([],[],0,0,0,0);
			break;
		case "radial":
			r = new nanofl_engine_strokes_RadialStroke([],[],0,0,0,0,0);
			break;
		case "solid":
			r = new nanofl_engine_strokes_SolidStroke();
			break;
		default:
			throw haxe_Exception.thrown("Unknow stroke type '" + obj.type + "'.");
		}
		r.loadPropertiesJson(obj);
		return r;
	}
}
nanofl_engine_strokes_BaseStroke.__name__ = "nanofl.engine.strokes.BaseStroke";
Object.assign(nanofl_engine_strokes_BaseStroke.prototype, {
	__class__: nanofl_engine_strokes_BaseStroke
});
class nanofl_engine_strokes_IStroke {
}
nanofl_engine_strokes_IStroke.__name__ = "nanofl.engine.strokes.IStroke";
nanofl_engine_strokes_IStroke.__isInterface__ = true;
Object.assign(nanofl_engine_strokes_IStroke.prototype, {
	__class__: nanofl_engine_strokes_IStroke
});
class nanofl_engine_strokes_BitmapStroke extends nanofl_engine_strokes_BaseStroke {
	constructor(bitmapPath,repeat,thickness,caps,joints,miterLimit,ignoreScale) {
		if(ignoreScale == null) {
			ignoreScale = false;
		}
		if(miterLimit == null) {
			miterLimit = 3.0;
		}
		if(joints == null) {
			joints = "round";
		}
		if(caps == null) {
			caps = "round";
		}
		if(thickness == null) {
			thickness = 1.0;
		}
		if(repeat == null) {
			repeat = "repeat";
		}
		super(thickness,caps,joints,miterLimit,ignoreScale);
		this.bitmapPath = bitmapPath;
		this.repeat = repeat;
	}
	loadPropertiesJson(obj) {
		this.loadBasePropertiesJson(obj);
		this.bitmapPath = obj.bitmapPath;
		this.repeat = obj.repeat;
	}
	begin(g) {
		if(this.library.hasItem(this.bitmapPath)) {
			let image = (js_Boot.__cast(this.library.getItem(this.bitmapPath) , nanofl_engine_libraryitems_BitmapItem)).image;
			g.beginBitmapStroke(image,this.repeat);
			this.setStrokeStyle(g);
		} else {
			g.beginStroke("rgba(0,0,0,0)");
		}
	}
	clone() {
		let obj = new nanofl_engine_strokes_BitmapStroke(this.bitmapPath,this.repeat,this.thickness,this.caps,this.joints,this.miterLimit,this.ignoreScale);
		obj.library = this.library;
		return obj;
	}
	equ(e) {
		if(e == this) {
			return true;
		}
		if(!((e) instanceof nanofl_engine_strokes_BitmapStroke) || !super.equ(e)) {
			return false;
		}
		let ee = e;
		if(ee.bitmapPath == this.bitmapPath) {
			return ee.repeat == this.repeat;
		} else {
			return false;
		}
	}
	setLibrary(library) {
		this.library = library;
	}
	toString() {
		return "new BitmapStroke(\"" + this.bitmapPath + "\")";
	}
}
nanofl_engine_strokes_BitmapStroke.__name__ = "nanofl.engine.strokes.BitmapStroke";
nanofl_engine_strokes_BitmapStroke.__interfaces__ = [nanofl_engine_strokes_IStroke];
nanofl_engine_strokes_BitmapStroke.__super__ = nanofl_engine_strokes_BaseStroke;
Object.assign(nanofl_engine_strokes_BitmapStroke.prototype, {
	__class__: nanofl_engine_strokes_BitmapStroke
});
class nanofl_engine_strokes_LinearStroke extends nanofl_engine_strokes_BaseStroke {
	constructor(colors,ratios,x0,y0,x1,y1,thickness,caps,joints,miterLimit,ignoreScale) {
		if(ignoreScale == null) {
			ignoreScale = false;
		}
		if(miterLimit == null) {
			miterLimit = 3.0;
		}
		if(joints == null) {
			joints = "round";
		}
		if(caps == null) {
			caps = "round";
		}
		if(thickness == null) {
			thickness = 1.0;
		}
		super(thickness,caps,joints,miterLimit,ignoreScale);
		this.colors = colors;
		this.ratios = ratios;
		this.x0 = x0;
		this.y0 = y0;
		this.x1 = x1;
		this.y1 = y1;
	}
	loadPropertiesJson(obj) {
		this.loadBasePropertiesJson(obj);
		let tmp = obj.colors;
		this.colors = tmp != null ? tmp : [];
		let tmp1 = obj.ratios;
		this.ratios = tmp1 != null ? tmp1 : [0.0];
		let tmp2 = obj.x0;
		this.x0 = tmp2 != null ? tmp2 : 0.0;
		let tmp3 = obj.y0;
		this.y0 = tmp3 != null ? tmp3 : 0.0;
		let tmp4 = obj.x1;
		this.x1 = tmp4 != null ? tmp4 : 0.0;
		let tmp5 = obj.y1;
		this.y1 = tmp5 != null ? tmp5 : 0.0;
	}
	begin(g) {
		g.beginLinearGradientStroke(this.colors,this.ratios,this.x0,this.y0,this.x1,this.y1);
		this.setStrokeStyle(g);
	}
	clone() {
		return new nanofl_engine_strokes_LinearStroke(this.colors,this.ratios,this.x0,this.y0,this.x1,this.y1,this.thickness,this.caps,this.joints,this.miterLimit,this.ignoreScale);
	}
	equ(e) {
		if(e == this) {
			return true;
		}
		if(!((e) instanceof nanofl_engine_strokes_LinearStroke) || !super.equ(e)) {
			return false;
		}
		let ee = e;
		if(this.arrEqu(ee.colors,this.colors) && this.arrEqu(ee.ratios,this.ratios) && ee.x0 == this.x0 && ee.y0 == this.y0 && ee.x1 == this.x1) {
			return ee.y1 == this.y1;
		} else {
			return false;
		}
	}
	getTransformed(m,applyToThickness) {
		let r = super.getTransformed(m,applyToThickness);
		let p0 = m.transformPoint(this.x0,this.y0);
		r.x0 = p0.x;
		r.y0 = p0.y;
		let p1 = m.transformPoint(this.x1,this.y1);
		r.x1 = p1.x;
		r.y1 = p1.y;
		return r;
	}
	toString() {
		let _this = this.colors;
		let result = new Array(_this.length);
		let _g = 0;
		let _g1 = _this.length;
		while(_g < _g1) {
			let i = _g++;
			result[i] = "\"" + _this[i] + "\"";
		}
		return "new LinearStroke(" + Std.string(result) + (", " + Std.string(this.ratios) + ", " + this.x0 + ", " + this.y0 + ", " + this.x1 + ", " + this.y1 + ")");
	}
	arrEqu(a,b) {
		if(a.length != b.length) {
			return false;
		}
		let _g = 0;
		let _g1 = a.length;
		while(_g < _g1) {
			let i = _g++;
			if(a[i] != b[i]) {
				return false;
			}
		}
		return true;
	}
}
nanofl_engine_strokes_LinearStroke.__name__ = "nanofl.engine.strokes.LinearStroke";
nanofl_engine_strokes_LinearStroke.__interfaces__ = [nanofl_engine_strokes_IStroke];
nanofl_engine_strokes_LinearStroke.__super__ = nanofl_engine_strokes_BaseStroke;
Object.assign(nanofl_engine_strokes_LinearStroke.prototype, {
	__class__: nanofl_engine_strokes_LinearStroke
});
class nanofl_engine_strokes_RadialStroke extends nanofl_engine_strokes_BaseStroke {
	constructor(colors,ratios,cx,cy,r,fx,fy,thickness,caps,joints,miterLimit,ignoreScale) {
		if(ignoreScale == null) {
			ignoreScale = false;
		}
		if(miterLimit == null) {
			miterLimit = 3.0;
		}
		if(joints == null) {
			joints = "round";
		}
		if(caps == null) {
			caps = "round";
		}
		if(thickness == null) {
			thickness = 1.0;
		}
		super(thickness,caps,joints,miterLimit,ignoreScale);
		this.colors = colors;
		this.ratios = ratios;
		this.cx = cx;
		this.cy = cy;
		this.r = r;
		this.fx = fx;
		this.fy = fy;
	}
	loadPropertiesJson(obj) {
		this.loadBasePropertiesJson(obj);
		let tmp = obj.colors;
		this.colors = tmp != null ? tmp : [];
		let tmp1 = obj.ratios;
		this.ratios = tmp1 != null ? tmp1 : [0.0];
		let tmp2 = obj.cx;
		this.cx = tmp2 != null ? tmp2 : 0.0;
		let tmp3 = obj.cy;
		this.cy = tmp3 != null ? tmp3 : 0.0;
		let tmp4 = obj.r;
		this.r = tmp4 != null ? tmp4 : 0.0;
		let tmp5 = obj.fx;
		this.fx = tmp5 != null ? tmp5 : this.cx;
		let tmp6 = obj.fy;
		this.fy = tmp6 != null ? tmp6 : this.cy;
	}
	begin(g) {
		g.beginRadialGradientStroke(this.colors,this.ratios,this.fx,this.fy,0,this.cx,this.cy,this.r);
		this.setStrokeStyle(g);
	}
	clone() {
		return new nanofl_engine_strokes_RadialStroke(this.colors,this.ratios,this.cx,this.cy,this.r,this.fx,this.fy,this.thickness,this.caps,this.joints,this.miterLimit,this.ignoreScale);
	}
	equ(e) {
		if(e == this) {
			return true;
		}
		if(!((e) instanceof nanofl_engine_strokes_RadialStroke) || !super.equ(e)) {
			return false;
		}
		let ee = e;
		if(this.arrEqu(ee.colors,this.colors) && this.arrEqu(ee.ratios,this.ratios) && ee.cx == this.cx && ee.cy == this.cy && ee.r == this.r && ee.fx == this.fx) {
			return ee.fy == this.fy;
		} else {
			return false;
		}
	}
	getTransformed(m,applyToThickness) {
		let stroke = super.getTransformed(m,applyToThickness);
		let c = m.transformPoint(this.cx,this.cy);
		stroke.cx = c.x;
		stroke.cy = c.y;
		let f = m.transformPoint(this.fx,this.fy);
		stroke.fx = f.x;
		stroke.fy = f.y;
		stroke.r *= m.getAverageScale();
		return stroke;
	}
	toString() {
		let _this = this.colors;
		let result = new Array(_this.length);
		let _g = 0;
		let _g1 = _this.length;
		while(_g < _g1) {
			let i = _g++;
			result[i] = "\"" + _this[i] + "\"";
		}
		return "new RadialStroke(" + Std.string(result) + (", " + Std.string(this.ratios) + ", " + this.cx + ", " + this.cy + ", " + this.r + ", " + this.fx + ", " + this.fy + ")");
	}
	arrEqu(a,b) {
		if(a.length != b.length) {
			return false;
		}
		let _g = 0;
		let _g1 = a.length;
		while(_g < _g1) {
			let i = _g++;
			if(a[i] != b[i]) {
				return false;
			}
		}
		return true;
	}
}
nanofl_engine_strokes_RadialStroke.__name__ = "nanofl.engine.strokes.RadialStroke";
nanofl_engine_strokes_RadialStroke.__interfaces__ = [nanofl_engine_strokes_IStroke];
nanofl_engine_strokes_RadialStroke.__super__ = nanofl_engine_strokes_BaseStroke;
Object.assign(nanofl_engine_strokes_RadialStroke.prototype, {
	__class__: nanofl_engine_strokes_RadialStroke
});
class nanofl_engine_strokes_SolidStroke extends nanofl_engine_strokes_BaseStroke {
	constructor(color,thickness,caps,joints,miterLimit,ignoreScale) {
		if(ignoreScale == null) {
			ignoreScale = false;
		}
		if(miterLimit == null) {
			miterLimit = 3.0;
		}
		if(joints == null) {
			joints = "round";
		}
		if(caps == null) {
			caps = "round";
		}
		if(thickness == null) {
			thickness = 1.0;
		}
		if(color == null) {
			color = "black";
		}
		super(thickness,caps,joints,miterLimit,ignoreScale);
		this.color = color;
	}
	loadPropertiesJson(obj) {
		this.loadBasePropertiesJson(obj);
		let tmp = obj.color;
		this.color = tmp != null ? tmp : "#000000";
	}
	begin(g) {
		g.beginStroke(this.color);
		this.setStrokeStyle(g);
	}
	clone() {
		return new nanofl_engine_strokes_SolidStroke(this.color,this.thickness,this.caps,this.joints,this.miterLimit,this.ignoreScale);
	}
	equ(e) {
		if(e == this) {
			return true;
		}
		if(!((e) instanceof nanofl_engine_strokes_SolidStroke) || !super.equ(e)) {
			return false;
		}
		let ee = e;
		return ee.color == this.color;
	}
	toString() {
		return "new SolidStroke(\"" + this.color + "\")";
	}
}
nanofl_engine_strokes_SolidStroke.__name__ = "nanofl.engine.strokes.SolidStroke";
nanofl_engine_strokes_SolidStroke.__interfaces__ = [nanofl_engine_strokes_IStroke];
nanofl_engine_strokes_SolidStroke.__super__ = nanofl_engine_strokes_BaseStroke;
Object.assign(nanofl_engine_strokes_SolidStroke.prototype, {
	__class__: nanofl_engine_strokes_SolidStroke
});
class stdlib_Debug {
	static assert(e,message,pos) {
		if(!e) {
			if(message == null) {
				message = "error";
			} else if(Reflect.isFunction(message)) {
				message = message();
			}
			let s = "ASSERT " + Std.string(message) + " in " + pos.fileName + " at line " + pos.lineNumber;
			throw new Error(s);
		}
	}
	static methodNotSupported(_this,pos) {
		let c = js_Boot.getClass(_this);
		throw new haxe_Exception("Method " + pos.methodName + "() is not supported by class " + c.__name__ + ".");
	}
}
stdlib_Debug.__name__ = "stdlib.Debug";
class stdlib_Event {
	constructor(target) {
		this.target = target;
		this.handlers = [];
	}
	call(args) {
		let _g = 0;
		let _g1 = this.handlers;
		while(_g < _g1.length) {
			let handler = _g1[_g];
			++_g;
			handler.apply(null,[this.target,args]);
		}
	}
}
stdlib_Event.__name__ = "stdlib.Event";
Object.assign(stdlib_Event.prototype, {
	__class__: stdlib_Event
});
class stdlib_LambdaArray {
	static addRange(arr,range) {
		let _g = 0;
		while(_g < range.length) {
			let e = range[_g];
			++_g;
			arr.push(e);
		}
	}
	static toMapOneInner(arr,keySelector,valueSelector) {
		let r = new Map();
		let _g = 0;
		while(_g < arr.length) {
			let item = arr[_g];
			++_g;
			r.set(keySelector(item),valueSelector(item));
		}
		return r;
	}
}
stdlib_LambdaArray.__name__ = "stdlib.LambdaArray";
class stdlib_LambdaIterable {
	static findIndex(it,f) {
		let n = 0;
		let x = $getIterator(it);
		while(x.hasNext()) {
			let x1 = x.next();
			if(f(x1)) {
				return n;
			}
			++n;
		}
		return -1;
	}
}
stdlib_LambdaIterable.__name__ = "stdlib.LambdaIterable";
class stdlib_LambdaIterator {
	static array(it) {
		let r = [];
		let e = it;
		while(e.hasNext()) {
			let e1 = e.next();
			r.push(e1);
		}
		return r;
	}
}
stdlib_LambdaIterator.__name__ = "stdlib.LambdaIterator";
class stdlib_Std {
	static parseInt(x,defaultValue) {
		if(x != null) {
			if(new EReg("^\\s*[+-]?\\s*((?:0x[0-9a-fA-F]{1,7})|(?:\\d{1,9}))\\s*$","").match(x)) {
				return Std.parseInt(x);
			} else {
				return defaultValue;
			}
		} else {
			return defaultValue;
		}
	}
	static parseFloat(x,defaultValue) {
		if(x == null) {
			return defaultValue;
		}
		if(new EReg("^\\s*[+-]?\\s*\\d{1,20}(?:[.]\\d+)?(?:e[+-]?\\d{1,20})?\\s*$","").match(x)) {
			let r = parseFloat(x);
			if(!isNaN(r)) {
				return r;
			} else {
				return defaultValue;
			}
		}
		return defaultValue;
	}
	static bool(v) {
		if(v != false && v != null && v != 0 && v != "" && v != "0") {
			if(typeof(v) == "string") {
				if((js_Boot.__cast(v , String)).toLowerCase() != "false" && (js_Boot.__cast(v , String)).toLowerCase() != "off") {
					return (js_Boot.__cast(v , String)).toLowerCase() != "null";
				} else {
					return false;
				}
			} else {
				return true;
			}
		} else {
			return false;
		}
	}
}
stdlib_Std.__name__ = "stdlib.Std";
class stdlib_StringTools {
	static isNullOrEmpty(s) {
		if(s != null) {
			return s == "";
		} else {
			return true;
		}
	}
}
stdlib_StringTools.__name__ = "stdlib.StringTools";
function $getIterator(o) { if( o instanceof Array ) return new haxe_iterators_ArrayIterator(o); else return o.iterator(); }
function $bind(o,m) { if( m == null ) return null; if( m.__id__ == null ) m.__id__ = $global.$haxeUID++; var f; if( o.hx__closures__ == null ) o.hx__closures__ = {}; else f = o.hx__closures__[m.__id__]; if( f == null ) { f = m.bind(o); o.hx__closures__[m.__id__] = f; } return f; }
$global.$haxeUID |= 0;
if(typeof(performance) != "undefined" ? typeof(performance.now) == "function" : false) {
	HxOverrides.now = performance.now.bind(performance);
}
if( String.fromCodePoint == null ) String.fromCodePoint = function(c) { return c < 0x10000 ? String.fromCharCode(c) : String.fromCharCode((c>>10)+0xD7C0)+String.fromCharCode((c&0x3FF)+0xDC00); }
{
	Object.defineProperty(String.prototype,"__class__",{ value : String, enumerable : false, writable : true});
	String.__name__ = "String";
	Array.__name__ = "Array";
	Date.prototype.__class__ = Date;
	Date.__name__ = "Date";
	var Int = { };
	var Dynamic = { };
	var Float = Number;
	var Bool = Boolean;
	var Class = { };
	var Enum = { };
}
js_Boot.__toStr = ({ }).toString;
haxe_Serializer.USE_CACHE = false;
haxe_Serializer.USE_ENUM_INDEX = false;
haxe_Serializer.BASE64 = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789%:";
nanofl_DisplayObjectTools.autoHitArea = false;
nanofl_Mesh.DEG_TO_RAD = Math.PI / 180;
nanofl_Player.spriteSheets = { };
nanofl_TextField.PADDING = 2.0;
nanofl_TextField.fontHeightCache = new haxe_ds_StringMap();
nanofl_TextField.fontBaselineCoefCache = new haxe_ds_StringMap();
nanofl_TextField.editing = false;
nanofl_TextField.selectionStart = 0;
nanofl_TextField.selectionEnd = 0;
nanofl_engine_ColorTools.colors = { "aliceblue" : "#f0f8ff", "antiquewhite" : "#faebd7", "aqua" : "#00ffff", "aquamarine" : "#7fffd4", "azure" : "#f0ffff", "beige" : "#f5f5dc", "bisque" : "#ffe4c4", "black" : "#000000", "blanchedalmond" : "#ffebcd", "blue" : "#0000ff", "blueviolet" : "#8a2be2", "brown" : "#a52a2a", "burlywood" : "#deb887", "cadetblue" : "#5f9ea0", "chartreuse" : "#7fff00", "chocolate" : "#d2691e", "coral" : "#ff7f50", "cornflowerblue" : "#6495ed", "cornsilk" : "#fff8dc", "crimson" : "#dc143c", "cyan" : "#00ffff", "darkblue" : "#00008b", "darkcyan" : "#008b8b", "darkgoldenrod" : "#b8860b", "darkgray" : "#a9a9a9", "darkgreen" : "#006400", "darkkhaki" : "#bdb76b", "darkmagenta" : "#8b008b", "darkolivegreen" : "#556b2f", "darkorange" : "#ff8c00", "darkorchid" : "#9932cc", "darkred" : "#8b0000", "darksalmon" : "#e9967a", "darkseagreen" : "#8fbc8f", "darkslateblue" : "#483d8b", "darkslategray" : "#2f4f4f", "darkturquoise" : "#00ced1", "darkviolet" : "#9400d3", "deeppink" : "#ff1493", "deepskyblue" : "#00bfff", "dimgray" : "#696969", "dodgerblue" : "#1e90ff", "firebrick" : "#b22222", "floralwhite" : "#fffaf0", "forestgreen" : "#228b22", "fuchsia" : "#ff00ff", "gainsboro" : "#dcdcdc", "ghostwhite" : "#f8f8ff", "gold" : "#ffd700", "goldenrod" : "#daa520", "gray" : "#808080", "grey" : "#808080", "green" : "#008000", "greenyellow" : "#adff2f", "honeydew" : "#f0fff0", "hotpink" : "#ff69b4", "indianred " : "#cd5c5c", "indigo" : "#4b0082", "ivory" : "#fffff0", "khaki" : "#f0e68c", "lavender" : "#e6e6fa", "lavenderblush" : "#fff0f5", "lawngreen" : "#7cfc00", "lemonchiffon" : "#fffacd", "lightblue" : "#add8e6", "lightcoral" : "#f08080", "lightcyan" : "#e0ffff", "lightgoldenrodyellow" : "#fafad2", "lightgrey" : "#d3d3d3", "lightgreen" : "#90ee90", "lightpink" : "#ffb6c1", "lightsalmon" : "#ffa07a", "lightseagreen" : "#20b2aa", "lightskyblue" : "#87cefa", "lightslategray" : "#778899", "lightsteelblue" : "#b0c4de", "lightyellow" : "#ffffe0", "lime" : "#00ff00", "limegreen" : "#32cd32", "linen" : "#faf0e6", "magenta" : "#ff00ff", "maroon" : "#800000", "mediumaquamarine" : "#66cdaa", "mediumblue" : "#0000cd", "mediumorchid" : "#ba55d3", "mediumpurple" : "#9370d8", "mediumseagreen" : "#3cb371", "mediumslateblue" : "#7b68ee", "mediumspringgreen" : "#00fa9a", "mediumturquoise" : "#48d1cc", "mediumvioletred" : "#c71585", "midnightblue" : "#191970", "mintcream" : "#f5fffa", "mistyrose" : "#ffe4e1", "moccasin" : "#ffe4b5", "navajowhite" : "#ffdead", "navy" : "#000080", "oldlace" : "#fdf5e6", "olive" : "#808000", "olivedrab" : "#6b8e23", "orange" : "#ffa500", "orangered" : "#ff4500", "orchid" : "#da70d6", "palegoldenrod" : "#eee8aa", "palegreen" : "#98fb98", "paleturquoise" : "#afeeee", "palevioletred" : "#d87093", "papayawhip" : "#ffefd5", "peachpuff" : "#ffdab9", "peru" : "#cd853f", "pink" : "#ffc0cb", "plum" : "#dda0dd", "powderblue" : "#b0e0e6", "purple" : "#800080", "red" : "#ff0000", "rosybrown" : "#bc8f8f", "royalblue" : "#4169e1", "saddlebrown" : "#8b4513", "salmon" : "#fa8072", "sandybrown" : "#f4a460", "seagreen" : "#2e8b57", "seashell" : "#fff5ee", "sienna" : "#a0522d", "silver" : "#c0c0c0", "skyblue" : "#87ceeb", "slateblue" : "#6a5acd", "slategray" : "#708090", "snow" : "#fffafa", "springgreen" : "#00ff7f", "steelblue" : "#4682b4", "tan" : "#d2b48c", "teal" : "#008080", "thistle" : "#d8bfd8", "tomato" : "#ff6347", "turquoise" : "#40e0d0", "violet" : "#ee82ee", "wheat" : "#f5deb3", "white" : "#ffffff", "whitesmoke" : "#f5f5f5", "yellow" : "#ffff00", "yellowgreen" : "#9acd32", "transparent" : "rgba(0,0,0,0)"};
nanofl_engine_Debug.console = new nanofl_engine_Console();
nanofl_engine_Library.SCENE_NAME_PATH = "scene";
nanofl_engine_ScaleMode.fit = "fit";
nanofl_engine_ScaleMode.fill = "fill";
nanofl_engine_ScaleMode.stretch = "stretch";
nanofl_engine_ScaleMode.custom = "custom";
nanofl_engine_elements_Element._hx_skip_constructor = false;
nanofl_engine_geom_Edge.GAP = 0.01;
nanofl_engine_geom_Edges.reFloat2 = new EReg("([-+0-9.]+),([-+0-9.]+)","");
nanofl_engine_geom_Edges.reFloat4 = new EReg("([-+0-9.]+),([-+0-9.]+),([-+0-9.]+),([-+0-9.]+)","");
nanofl_engine_geom_Matrix.DEG_TO_RAD = Math.PI / 180;
nanofl_engine_libraryitems_LibraryItem._hx_skip_constructor = false;
nanofl_engine_plugins_FilterPlugins.plugins = new haxe_ds_StringMap();
})( true ? exports : 0, typeof window != "undefined" ? window : typeof __webpack_require__.g != "undefined" ? __webpack_require__.g : typeof self != "undefined" ? self : this);


/***/ }),

/***/ 800:
/***/ ((module) => {

"use strict";
module.exports = THREE;

/***/ }),

/***/ 676:
/***/ ((module) => {

"use strict";
module.exports = THREE_addons_GLTFLoader;

/***/ })

/******/ 	});
/************************************************************************/
/******/ 	// The module cache
/******/ 	var __webpack_module_cache__ = {};
/******/ 	
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/ 		// Check if module is in cache
/******/ 		var cachedModule = __webpack_module_cache__[moduleId];
/******/ 		if (cachedModule !== undefined) {
/******/ 			return cachedModule.exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = __webpack_module_cache__[moduleId] = {
/******/ 			// no module.id needed
/******/ 			// no module.loaded needed
/******/ 			exports: {}
/******/ 		};
/******/ 	
/******/ 		// Execute the module function
/******/ 		__webpack_modules__[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/ 	
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/ 	
/************************************************************************/
/******/ 	/* webpack/runtime/global */
/******/ 	(() => {
/******/ 		__webpack_require__.g = (function() {
/******/ 			if (typeof globalThis === 'object') return globalThis;
/******/ 			try {
/******/ 				return this || new Function('return this')();
/******/ 			} catch (e) {
/******/ 				if (typeof window === 'object') return window;
/******/ 			}
/******/ 		})();
/******/ 	})();
/******/ 	
/************************************************************************/
/******/ 	
/******/ 	// startup
/******/ 	// Load entry module and return exports
/******/ 	// This entry module is referenced by other modules so it can't be inlined
/******/ 	var __webpack_exports__ = __webpack_require__(792);
/******/ 	var __webpack_export_target__ = (window = typeof window === "undefined" ? {} : window);
/******/ 	for(var i in __webpack_exports__) __webpack_export_target__[i] = __webpack_exports__[i];
/******/ 	if(__webpack_exports__.__esModule) Object.defineProperty(__webpack_export_target__, "__esModule", { value: true });
/******/ 	
/******/ })()
;// Generated by Haxe 4.3.3
(function ($hx_exports, $global) { "use strict";
$hx_exports["createjs"] = $hx_exports["createjs"] || {};
function $extend(from, fields) {
	var proto = Object.create(from);
	for (var name in fields) proto[name] = fields[name];
	if( fields.toString !== Object.prototype.toString ) proto.toString = fields.toString;
	return proto;
}
var AdjustColorFilterPlugin = function() {
	this.properties = [{ type : "int", name : "brightness", label : "Brightness", defaultValue : 0, minValue : -100, maxValue : 100, units : "%"},{ type : "int", name : "contrast", label : "Contrast", defaultValue : 0, minValue : -100, maxValue : 100, units : "%"},{ type : "int", name : "saturation", label : "Saturation", defaultValue : 0, minValue : -100, maxValue : 100, units : "%"},{ type : "int", name : "hue", label : "Hue", defaultValue : 0, minValue : -180, maxValue : 180, units : "deg"}];
	this.label = "Adjust Color";
	this.name = "AdjustColorFilter";
};
AdjustColorFilterPlugin.prototype = {
	getFilter: function(params) {
		return new createjs.ColorMatrixFilter(new createjs.ColorMatrix(Math.round(params.brightness / 100 * 255 * 0.4),params.contrast,params.saturation,params.hue).toArray());
	}
};
var BoxBlurFilterPlugin = function() {
	this.properties = [{ type : "float", name : "blurX", label : "Blur X", defaultValue : 10, neutralValue : 0, units : "px", minValue : 0},{ type : "float", name : "blurY", label : "Blur Y", defaultValue : 10, neutralValue : 0, units : "px", minValue : 0},{ type : "int", name : "quality", label : "Quality", defaultValue : 1, minValue : 1, maxValue : 3}];
	this.label = "Box Blur";
	this.name = "BoxBlurFilter";
};
BoxBlurFilterPlugin.prototype = {
	getFilter: function(params) {
		return new createjs.BlurFilter(params.blurX,params.blurY,params.quality);
	}
};
var DropShadowFilterPlugin = function() {
	this.properties = [{ type : "float", name : "blurX", label : "Blur X", defaultValue : 5, units : "px", minValue : 0},{ type : "float", name : "blurY", label : "Blur Y", defaultValue : 5, units : "px", minValue : 0},{ type : "int", name : "strength", label : "Strength", defaultValue : 100, units : "%", minValue : 0, maxValue : 100},{ type : "int", name : "quality", label : "Quality", defaultValue : 1, minValue : 1, maxValue : 3},{ type : "float", name : "angle", label : "Angle", defaultValue : 45, units : "deg", minValue : 0, maxValue : 360},{ type : "float", name : "distance", label : "Distance", defaultValue : 5, units : "px", minValue : 0},{ type : "bool", name : "knockout", label : "Knockout", defaultValue : false},{ type : "bool", name : "inner", label : "Inner shadow", defaultValue : false},{ type : "bool", name : "hideObject", label : "Hide object", defaultValue : false},{ type : "color", name : "color", label : "Color", defaultValue : "#000000"},{ type : "int", name : "alpha", label : "Alpha", defaultValue : 100, neutralValue : 0, units : "%", minValue : 0, maxValue : 100}];
	this.label = "Drop Shadow";
	this.name = "DropShadowFilter";
};
DropShadowFilterPlugin.prototype = {
	getFilter: function(params) {
		var rgb = nanofl.engine.ColorTools.parse(params.color);
		var color = rgb.r << 16 | rgb.g << 8 | rgb.b;
		return new createjs.DropShadowFilter(params.distance * 2,params.angle,color,params.alpha / 100 * (params.strength / 100),params.blurX * 2,params.blurY * 2,1,params.quality,params.inner,params.knockout,params.hideObject);
	}
};
var GaussianBlurFilterPlugin = function() {
	this.properties = [{ type : "int", name : "radius", label : "Radius", defaultValue : 10, neutralValue : 0, units : "px", minValue : 0}];
	this.label = "Gaussian Blur";
	this.name = "GaussianBlurFilterPlugin";
};
GaussianBlurFilterPlugin.prototype = {
	getFilter: function(params) {
		return new createjs_GaussianBlurFilter(params.radius);
	}
};
var GlowFilterPlugin = function() {
	this.properties = [{ type : "float", name : "blurX", label : "Blur X", defaultValue : 5, units : "px", minValue : 0},{ type : "float", name : "blurY", label : "Blur Y", defaultValue : 5, units : "px", minValue : 0},{ type : "int", name : "strength", label : "Strength", defaultValue : 100, units : "%", minValue : 0, maxValue : 100},{ type : "int", name : "quality", label : "Quality", defaultValue : 1, minValue : 1, maxValue : 3},{ type : "color", name : "color", label : "Color", defaultValue : "#000000"},{ type : "int", name : "alpha", label : "Alpha", defaultValue : 100, neutralValue : 0, units : "%", minValue : 0, maxValue : 100},{ type : "bool", name : "knockout", label : "Knockout", defaultValue : false},{ type : "bool", name : "inner", label : "Inner shadow", defaultValue : false}];
	this.label = "Glow";
	this.name = "GlowFilter";
};
GlowFilterPlugin.prototype = {
	getFilter: function(params) {
		var rgb = nanofl.engine.ColorTools.parse(params.color);
		var color = rgb.r << 16 | rgb.g << 8 | rgb.b;
		return new createjs.GlowFilter(color,params.alpha / 100 * (params.strength / 100),params.blurX * 2,params.blurY * 2,1,params.quality,params.inner,params.knockout);
	}
};
var Main = function() { };
Main.main = function() {
	nanofl.engine.plugins.FilterPlugins.register(new DropShadowFilterPlugin());
	nanofl.engine.plugins.FilterPlugins.register(new BoxBlurFilterPlugin());
	nanofl.engine.plugins.FilterPlugins.register(new GlowFilterPlugin());
	nanofl.engine.plugins.FilterPlugins.register(new AdjustColorFilterPlugin());
	nanofl.engine.plugins.FilterPlugins.register(new GaussianBlurFilterPlugin());
};
var createjs_GaussianBlurFilter = $hx_exports["createjs"]["GaussianBlurFilter"] = function(radius) {
	createjs.Filter.call(this);
	this.usesContext = true;
	this.radius = radius;
};
createjs_GaussianBlurFilter.__super__ = createjs.Filter;
createjs_GaussianBlurFilter.prototype = $extend(createjs.Filter.prototype,{
	applyFilter: function(ctx,x,y,width,height,targetCtx,targetX,targetY) {
		StackBlur.stackBlurCanvasRGBA(ctx.canvas,x,y,width,height,this.radius);
		return true;
	}
	,getBounds: function(rect) {
		if(rect != null) {
			rect.x -= this.radius;
			rect.y -= this.radius;
			rect.width += this.radius * 2;
			rect.height += this.radius * 2;
			return rect;
		}
		return new createjs.Rectangle(-this.radius,-this.radius,this.radius * 2,this.radius * 2);
	}
	,clone: function() {
		return new createjs_GaussianBlurFilter(this.radius);
	}
	,toString: function() {
		return "[GaussianBlurFilter]";
	}
});
var haxe_iterators_ArrayIterator = function(array) {
	this.current = 0;
	this.array = array;
};
haxe_iterators_ArrayIterator.prototype = {
	hasNext: function() {
		return this.current < this.array.length;
	}
	,next: function() {
		return this.array[this.current++];
	}
};
/*

StackBlur - a fast almost Gaussian Blur For Canvas

Version: 	0.5
Author:		Mario Klingemann
Contact: 	mario@quasimondo.com
Website:	http://www.quasimondo.com/StackBlurForCanvas
Twitter:	@quasimondo

In case you find this class useful - especially in commercial projects -
I am not totally unhappy for a small donation to my PayPal account
mario@quasimondo.de

Or support me on flattr: 
https://flattr.com/thing/72791/StackBlur-a-fast-almost-Gaussian-Blur-Effect-for-CanvasJavascript

Copyright (c) 2010 Mario Klingemann

Permission is hereby granted, free of charge, to any person
obtaining a copy of this software and associated documentation
files (the "Software"), to deal in the Software without
restriction, including without limitation the rights to use,
copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the
Software is furnished to do so, subject to the following
conditions:

The above copyright notice and this permission notice shall be
included in all copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES
OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT
HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY,
WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR
OTHER DEALINGS IN THE SOFTWARE.
*/

(function(window) {

var mul_table = [
        512,512,456,512,328,456,335,512,405,328,271,456,388,335,292,512,
        454,405,364,328,298,271,496,456,420,388,360,335,312,292,273,512,
        482,454,428,405,383,364,345,328,312,298,284,271,259,496,475,456,
        437,420,404,388,374,360,347,335,323,312,302,292,282,273,265,512,
        497,482,468,454,441,428,417,405,394,383,373,364,354,345,337,328,
        320,312,305,298,291,284,278,271,265,259,507,496,485,475,465,456,
        446,437,428,420,412,404,396,388,381,374,367,360,354,347,341,335,
        329,323,318,312,307,302,297,292,287,282,278,273,269,265,261,512,
        505,497,489,482,475,468,461,454,447,441,435,428,422,417,411,405,
        399,394,389,383,378,373,368,364,359,354,350,345,341,337,332,328,
        324,320,316,312,309,305,301,298,294,291,287,284,281,278,274,271,
        268,265,262,259,257,507,501,496,491,485,480,475,470,465,460,456,
        451,446,442,437,433,428,424,420,416,412,408,404,400,396,392,388,
        385,381,377,374,370,367,363,360,357,354,350,347,344,341,338,335,
        332,329,326,323,320,318,315,312,310,307,304,302,299,297,294,292,
        289,287,285,282,280,278,275,273,271,269,267,265,263,261,259];
        
   
var shg_table = [
	     9, 11, 12, 13, 13, 14, 14, 15, 15, 15, 15, 16, 16, 16, 16, 17, 
		17, 17, 17, 17, 17, 17, 18, 18, 18, 18, 18, 18, 18, 18, 18, 19, 
		19, 19, 19, 19, 19, 19, 19, 19, 19, 19, 19, 19, 19, 20, 20, 20,
		20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 21,
		21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21,
		21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 22, 22, 22, 22, 22, 22, 
		22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22,
		22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 23, 
		23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23,
		23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23,
		23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 
		23, 23, 23, 23, 23, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 
		24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24,
		24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24,
		24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24,
		24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24 ];

function premultiplyAlpha(imageData)
{
	var pixels = imageData.data;
	var size = imageData.width * imageData.height * 4;
	
	for (var i=0; i<size; i+=4)
	{
		var a = pixels[i+3] / 255;
		pixels[i  ] *= a;
		pixels[i+1] *= a;
		pixels[i+2] *= a;
	}
}

function unpremultiplyAlpha(imageData)
{
	var pixels = imageData.data;
	var size = imageData.width * imageData.height * 4;
	
	for (var i=0; i<size; i+=4)
	{
		var a = pixels[i+3];
		if (a != 0)
		{
			a = 255 / a;
			pixels[i  ] *= a;
			pixels[i+1] *= a;
			pixels[i+2] *= a;
		}
	}
}

function stackBlurCanvasRGBA( canvas, top_x, top_y, width, height, radius )
{
	if ( isNaN(radius) || radius < 1 ) return;
	radius |= 0;
	
	var context = canvas.getContext("2d", { willReadFrequently:true });
	var imageData;
	
	try
	{
	  try
	  {
		imageData = context.getImageData( top_x, top_y, width, height );
	  }
	  catch(e)
	  {
		// NOTE: this part is supposedly only needed if you want to work with local files
		// so it might be okay to remove the whole try/catch block and just use
		// imageData = context.getImageData( top_x, top_y, width, height );
		try
		{
			netscape.security.PrivilegeManager.enablePrivilege("UniversalBrowserRead");
			imageData = context.getImageData( top_x, top_y, width, height );
		}
		catch(e)
		{
			alert("Cannot access local image");
			throw new Error("unable to access local image data: " + e);
			return;
		}
	  }
	}
	catch(e)
	{
	  alert("Cannot access image");
	  throw new Error("unable to access image data: " + e);
	}
	
	premultiplyAlpha(imageData);
	
	var pixels = imageData.data;
	
	var x, y, i, p, yp, yi, yw, r_sum, g_sum, b_sum, a_sum, 
	r_out_sum, g_out_sum, b_out_sum, a_out_sum,
	r_in_sum, g_in_sum, b_in_sum, a_in_sum, 
	pr, pg, pb, pa, rbs;
			
	var div = radius + radius + 1;
	var w4 = width << 2;
	var widthMinus1  = width - 1;
	var heightMinus1 = height - 1;
	var radiusPlus1  = radius + 1;
	var sumFactor = radiusPlus1 * ( radiusPlus1 + 1 ) / 2;
	
	var stackStart = new BlurStack();
	var stack = stackStart;
	for ( i = 1; i < div; i++ )
	{
		stack = stack.next = new BlurStack();
		if ( i == radiusPlus1 ) var stackEnd = stack;
	}
	stack.next = stackStart;
	var stackIn = null;
	var stackOut = null;
	
	yw = yi = 0;
	
	var mul_sum = mul_table[radius];
	var shg_sum = shg_table[radius];
	
	for ( y = 0; y < height; y++ )
	{
		r_in_sum = g_in_sum = b_in_sum = a_in_sum = r_sum = g_sum = b_sum = a_sum = 0;
		
		r_out_sum = radiusPlus1 * ( pr = pixels[yi] );
		g_out_sum = radiusPlus1 * ( pg = pixels[yi+1] );
		b_out_sum = radiusPlus1 * ( pb = pixels[yi+2] );
		a_out_sum = radiusPlus1 * ( pa = pixels[yi+3] );
		
		r_sum += sumFactor * pr;
		g_sum += sumFactor * pg;
		b_sum += sumFactor * pb;
		a_sum += sumFactor * pa;
		
		stack = stackStart;
		
		for( i = 0; i < radiusPlus1; i++ )
		{
			stack.r = pr;
			stack.g = pg;
			stack.b = pb;
			stack.a = pa;
			stack = stack.next;
		}
		
		for( i = 1; i < radiusPlus1; i++ )
		{
			p = yi + (( widthMinus1 < i ? widthMinus1 : i ) << 2 );
			rbs = radiusPlus1 - i;
			r_sum += ( stack.r = ( pr = pixels[p  ])) * rbs;
			g_sum += ( stack.g = ( pg = pixels[p+1])) * rbs;
			b_sum += ( stack.b = ( pb = pixels[p+2])) * rbs;
			a_sum += ( stack.a = ( pa = pixels[p+3])) * rbs;
			
			r_in_sum += pr;
			g_in_sum += pg;
			b_in_sum += pb;
			a_in_sum += pa;
			
			stack = stack.next;
		}
		
		
		stackIn = stackStart;
		stackOut = stackEnd;
		for ( x = 0; x < width; x++ )
		{
			pixels[yi]   = (r_sum * mul_sum) >> shg_sum;
			pixels[yi+1] = (g_sum * mul_sum) >> shg_sum;
			pixels[yi+2] = (b_sum * mul_sum) >> shg_sum;
			pixels[yi+3] = (a_sum * mul_sum) >> shg_sum;
			
			r_sum -= r_out_sum;
			g_sum -= g_out_sum;
			b_sum -= b_out_sum;
			a_sum -= a_out_sum;
			
			r_out_sum -= stackIn.r;
			g_out_sum -= stackIn.g;
			b_out_sum -= stackIn.b;
			a_out_sum -= stackIn.a;
			
			p =  ( yw + ( ( p = x + radius + 1 ) < widthMinus1 ? p : widthMinus1 ) ) << 2;
			
			r_in_sum += ( stackIn.r = pixels[p]);
			g_in_sum += ( stackIn.g = pixels[p+1]);
			b_in_sum += ( stackIn.b = pixels[p+2]);
			a_in_sum += ( stackIn.a = pixels[p+3]);
			
			r_sum += r_in_sum;
			g_sum += g_in_sum;
			b_sum += b_in_sum;
			a_sum += a_in_sum;
			
			stackIn = stackIn.next;
			
			r_out_sum += ( pr = stackOut.r );
			g_out_sum += ( pg = stackOut.g );
			b_out_sum += ( pb = stackOut.b );
			a_out_sum += ( pa = stackOut.a );
			
			r_in_sum -= pr;
			g_in_sum -= pg;
			b_in_sum -= pb;
			a_in_sum -= pa;
			
			stackOut = stackOut.next;
			
			yi += 4;
		}
		yw += width;
	}
	
	for ( x = 0; x < width; x++ )
	{
		g_in_sum = b_in_sum = a_in_sum = r_in_sum = g_sum = b_sum = a_sum = r_sum = 0;
		
		yi = x << 2;
		r_out_sum = radiusPlus1 * ( pr = pixels[yi]);
		g_out_sum = radiusPlus1 * ( pg = pixels[yi+1]);
		b_out_sum = radiusPlus1 * ( pb = pixels[yi+2]);
		a_out_sum = radiusPlus1 * ( pa = pixels[yi+3]);
		
		r_sum += sumFactor * pr;
		g_sum += sumFactor * pg;
		b_sum += sumFactor * pb;
		a_sum += sumFactor * pa;
		
		stack = stackStart;
		
		for( i = 0; i < radiusPlus1; i++ )
		{
			stack.r = pr;
			stack.g = pg;
			stack.b = pb;
			stack.a = pa;
			stack = stack.next;
		}
		
		yp = width;
		
		for( i = 1; i <= radius; i++ )
		{
			yi = ( yp + x ) << 2;
			rbs = radiusPlus1 - i;
			
			r_sum += ( stack.r = ( pr = pixels[yi  ])) * rbs;
			g_sum += ( stack.g = ( pg = pixels[yi+1])) * rbs;
			b_sum += ( stack.b = ( pb = pixels[yi+2])) * rbs;
			a_sum += ( stack.a = ( pa = pixels[yi+3])) * rbs;
		   
			r_in_sum += pr;
			g_in_sum += pg;
			b_in_sum += pb;
			a_in_sum += pa;
			
			stack = stack.next;
		
			if( i < heightMinus1 )
			{
				yp += width;
			}
		}
		
		yi = x;
		stackIn = stackStart;
		stackOut = stackEnd;
		for ( y = 0; y < height; y++ )
		{
			p = yi << 2;
			pixels[p]   = (r_sum * mul_sum) >> shg_sum;
			pixels[p+1] = (g_sum * mul_sum) >> shg_sum;
			pixels[p+2] = (b_sum * mul_sum) >> shg_sum;
			pixels[p+3] = (a_sum * mul_sum) >> shg_sum;
			
			r_sum -= r_out_sum;
			g_sum -= g_out_sum;
			b_sum -= b_out_sum;
			a_sum -= a_out_sum;
		   
			r_out_sum -= stackIn.r;
			g_out_sum -= stackIn.g;
			b_out_sum -= stackIn.b;
			a_out_sum -= stackIn.a;
			
			p = ( x + (( ( p = y + radiusPlus1) < heightMinus1 ? p : heightMinus1 ) * width )) << 2;
			
			r_sum += ( r_in_sum += ( stackIn.r = pixels[p]));
			g_sum += ( g_in_sum += ( stackIn.g = pixels[p+1]));
			b_sum += ( b_in_sum += ( stackIn.b = pixels[p+2]));
			a_sum += ( a_in_sum += ( stackIn.a = pixels[p+3]));
		   
			stackIn = stackIn.next;
			
			r_out_sum += ( pr = stackOut.r );
			g_out_sum += ( pg = stackOut.g );
			b_out_sum += ( pb = stackOut.b );
			a_out_sum += ( pa = stackOut.a );
			
			r_in_sum -= pr;
			g_in_sum -= pg;
			b_in_sum -= pb;
			a_in_sum -= pa;
			
			stackOut = stackOut.next;
			
			yi += width;
		}
	}
	
	unpremultiplyAlpha(imageData);
	
	context.putImageData( imageData, top_x, top_y );
}

function BlurStack()
{
	this.r = 0;
	this.g = 0;
	this.b = 0;
	this.a = 0;
	this.next = null;
}

window.StackBlur = {
	stackBlurCanvasRGBA: stackBlurCanvasRGBA
};

})(window);
/*
DropShadowFilter for EaselJS
GitHub : https://github.com/u-kudox/Filters_for_EaselJS
Contact and Bug reports : http://kudox.jp/contact or http://twitter.com/u_kudox
License : public domain
*/

/**
* @namespace createjs
**/

(function() {
	"use strict";

	/**
	* Applies a DropShadowFilter to DisplayObjects of EaselJS. This filter has inherited the Filter class of EaselJS and has used BlurFilter of EaselJS at the blurring process.
	* @class DropShadowFilter
	* @extends Filter
	* @constructor
	* @param [distance=4] {Number} The offset distance for the shadow. The default value is 4.
	* @param [angle=45] {Number} The angle of the shadow. Valid values are 0 to 360 degrees. The default value is 45.
	* @param [color=0x000000] {uint} The color of the shadow. The default value is 0x000000. Valid values are in the hexadecimal format 0xRRGGBB.
	* @param [alpha=1] {Number} The alpha transparency value for the shadow color. Valid values are 0 to 1. The default value is 1.
	* @param [blurX=0] {Number} The amount of horizontal blur. The default value is 0. This value is passed to BlurFilter of EaselJS.
	* @param [blurY=0] {Number} The amount of vertical blur. The default value is 0. This value is passed to BlurFilter of EaselJS.
	* @param [strength=1] {uint} The strength of the shadow. The default value is 1. Valid values are 0 to 255. But as for this value, a low value is more preferable.
	* @param [quality=1] {Number} The number of blur iterations. The default value is 1. This value is passed to BlurFilter of EaselJS.
	* @param [inner=false] {Boolean} Specifies whether or not the shadow is an inner shadow. The default value is false, expressing outer shadow.
	* @param [knockout=false] {Boolean} Specifies whether or not the object has a knockout effect. The default value is false, expressing no knockout effect.
	* @param [hideObject=false] {Boolean} Specifies whether or not the object is hidden. If the value is true, the object is hidden and only the shadow is visible. The default value is false, expressing the object is visible.
	* @example
	* <pre><code>_text = new createjs.Text("DropShadowFilter", "bold 64px Arial", "#CC0000");
_text.set({x:centerX, y:centerY, textAlign:"center", textBaseline:"middle"});
var distance = 3;
var angle = 90;
var color = 0x000000;
var alpha = 0.5;
var blurX = 4;
var blurY = 4;
var strength = 1;
var quality = 2;
var inner = false;
var knockout = false;
var hideObject = false;
_dropShadowFilter = new createjs.DropShadowFilter(distance, angle, color, alpha, blurX, blurY, strength, quality, inner, knockout, hideObject);
_text.filters = [_dropShadowFilter];
var bounds = _text.getBounds();
_text.cache(bounds.x, bounds.y, bounds.width, bounds.height);
_stage.addChild(_text);</code></pre>
	**/
	function DropShadowFilter(distance, angle, color, alpha, blurX, blurY, strength, quality, inner, knockout, hideObject) {
        this.Filter_constructor();
        this.usesContext = true; // say to BitmapCache to call `applyFilter()`, not `_applyFilter()`

		if (distance !== undefined) this._distance = distance;
		if (angle !== undefined) this._angle = (angle % 360 + 360) % 360;
		setOffset.call(this, this._distance, this._angle);
		if (!isNaN(color)) this.color = color;
		if (alpha !== undefined) this.alpha = alpha;
		this._blurFilter = new createjs.BlurFilter(blurX, blurY, quality);
		if (strength !== undefined) this.strength = strength >> 0;
		this.inner = !!inner;
		this.knockout = !!knockout;
		this.hideObject = !!hideObject;
	}

    var p = createjs.extend(DropShadowFilter, createjs.Filter);

	/**
	* The alpha transparency value for the shadow color. Valid values are 0 to 1. The default value is 1.
	* @property alpha
	* @type Number
	* @default 1
	**/
	p.alpha = 1;

	/**
	* The strength of the shadow. The default value is 1. Valid values are 0 to 255. But as for this value, a low value is more preferable.
	* @property strength
	* @type uint
	* @default 1
	**/
	p.strength = 1;

	/**
	* Specifies whether or not the shadow is an inner shadow. The default value is false, expressing outer shadow.
	* @property inner
	* @type Boolean
	* @default false
	**/
	p.inner = false;

	/**
	* Specifies whether or not the object has a knockout effect. The default value is false, expressing no knockout effect.
	* @property knockout
	* @type Boolean
	* @default false
	**/
	p.knockout = false;

	/**
	* Specifies whether or not the object is hidden. If the value is true, the object is hidden and only the shadow is visible. The default value is false, expressing the object is visible.
	* @property hideObject
	* @type Boolean
	* @default false
	**/
	p.hideObject = false;

	Object.defineProperties(p, {
		/**
		* The angle of the shadow. Valid values are 0 to 360 degrees. The default value is 45.
		* @property angle
		* @type Number
		* @default 45
		**/
		"angle" : {
			get : function() {
				return this._angle;
			},
			set : function(value) {
				value = (value % 360 + 360) % 360;
				setOffset.call(this, this._distance, value);
				return this._angle = value;
			},
			enumerable : true
		},

		/**
		* The offset distance for the shadow. The default value is 4.
		* @property distance
		* @type Number
		* @default 4
		**/
		"distance" : {
			get : function() {
				return this._distance;
			},
			set : function(value) {
				setOffset.call(this, value, this._angle);
				return this._distance = value;
			},
			enumerable : true
		},

		/**
		* The color of the shadow. The default value is 0x000000. Valid values are in the hexadecimal format 0xRRGGBB.
		* @property color
		* @type uint
		* @default 0x000000
		**/
		"color" : {
			get : function() {
				return this._red << 16 | this._green << 8 | this._blue;
			},
			set : function(value) {
				this._red = value >> 16 & 0xFF;
				this._green = value >> 8 & 0xFF;
				this._blue = value & 0xFF;
				return this.color;
			},
			enumerable : true
		},

		/**
		* The amount of horizontal blur. The default value is 0. This value is passed to BlurFilter of EaselJS.
		* @property blurX
		* @type Number
		* @default 0
		**/
		"blurX" : {
			get : function() {
				return this._blurFilter.blurX;
			},
			set : function(value) {
				return this._blurFilter.blurX = value;
			},
			enumerable : true
		},

		/**
		* The amount of vertical blur. The default value is 0. This value is passed to BlurFilter of EaselJS.
		* @property blurY
		* @type Number
		* @default 0
		**/
		"blurY" : {
			get : function() {
				return this._blurFilter.blurY;
			},
			set : function(value) {
				return this._blurFilter.blurY = value;
			},
			enumerable : true
		},

		/**
		* The number of blur iterations. The default value is 1. This value is passed to BlurFilter of EaselJS.
		* @property quality
		* @type Number
		* @default 1
		**/
		"quality" : {
			get : function() {
				return this._blurFilter.quality;
			},
			set : function(value) {
				return this._blurFilter.quality = value;
			},
			enumerable : true
		}
	});

	p._angle = 45;

	p._distance = 4;

	p._offsetX = 0;

	p._offsetY = 0;

	p._red = 0;

	p._green = 0;

	p._blue = 0;

	p._blurFilter = null;

	/**
	* Returns a rectangle with values indicating the margins required to draw the filter or null.
	* For example, a filter that will extend the drawing area 4 pixels to the left, and 7 pixels to the right
	* (but no pixels up or down) would return a rectangle with (x=-4, y=0, width=11, height=0).
	* @method getBounds
	* @return {Rectangle} a rectangle object indicating the margins required to draw the filter or null if the filter does not effect bounds.
	**/
	p.getBounds = function(rect) {
		rect = this._blurFilter.getBounds(rect) || new createjs.Rectangle();
		var ox = this._offsetX;
		var oy = this._offsetY;
		if (ox !== 0) {
			if (ox < 0) {
				rect.x += ox;
				rect.width += -ox;
			} else {
				rect.width += ox;
			}
		}
		if (oy !== 0) {
			if (oy < 0) {
				rect.y += oy;
				rect.height += -oy;
			} else {
				rect.height += oy;
			}
		}
		return rect;
	};

	/**
	* Applies the DropShadowFilter to the specified context.
	* @method applyFilter
	* @param ctx {CanvasRenderingContext2D} The 2D context to use as the source.
	* @param x {Number} The x position to use for the source rect.
	* @param y {Number} The y position to use for the source rect.
	* @param width {Number} The width to use for the source rect.
	* @param height {Number} The height to use for the source rect.
	* @param [targetCtx] {CanvasRenderingContext2D} The 2D context to draw the result to. Defaults to the context passed to ctx.
	* @param [targetX] {Number} The x position to draw the result to. Defaults to the value passed to x.
	* @param [targetY] {Number} The y position to draw the result to. Defaults to the value passed to y.
	* @return {Boolean} If the filter was applied successfully.
	**/
	p.applyFilter = function(ctx, x, y, width, height, targetCtx, targetX, targetY) {
		if ((this.alpha <= 0 || this.strength <= 0) && (!this.knockout && !this.hideObject)) {
			return true;
		}
		targetCtx = targetCtx || ctx;
		if (targetX === undefined) targetX = x;
		if (targetY === undefined) targetY = y;
		var tImgData = targetCtx.getImageData(targetX, targetY, width, height);
		var tData = tImgData.data;
		var dCvs = document.createElement("canvas");
		dCvs.width = width;
		dCvs.height = height;
		var dCtx = dCvs.getContext("2d", { willReadFrequently:true });
		var dImgData = dCtx.getImageData(0, 0, width, height);
		var dData = dImgData.data;
		var inner = this.inner;
		var red = this._red;
		var green = this._green;
		var blue = this._blue;
		for (var i = 0, l = dData.length; i < l; i += 4) {
			var ia = i + 3;
			var alpha = tData[ia];
			if (!inner) {
				if (alpha !== 0) {
					dData[i] = red;
					dData[i + 1] = green;
					dData[i + 2] = blue;
					dData[ia] = alpha;
				}
			} else {
				if (alpha !== 255) {
					dData[i] = red;
					dData[i + 1] = green;
					dData[i + 2] = blue;
					dData[ia] = 255 - alpha;
				}
			}
		}
		dCtx.putImageData(dImgData, 0, 0);
		var strength = this.strength;
		if (0 < strength) {
			this._blurFilter.applyFilter(dCtx, 0, 0, width, height);
			if (255 < strength) strength = 255;
			for (var j = 1; j < strength; j++) {
				dCtx.drawImage(dCvs, 0, 0);
			}
		}
		var ga = this.alpha;
		if (ga < 0) ga = 0;
		else if (1 < ga) ga = 1;
		var gco;
		if (this.knockout) {
			if (inner) gco = "source-in";
			else gco = "source-out";
		} else {
			if (this.hideObject) {
				if (inner) gco = "source-in";
				else gco = "copy";
			} else {
				if (inner) gco = "source-atop";
				else gco = "destination-over";
			}
		}
		targetCtx.save();
		targetCtx.setTransform(1, 0, 0, 1, 0, 0);
		targetCtx.globalAlpha = ga;
		targetCtx.globalCompositeOperation = gco;
		targetCtx.drawImage(dCvs, targetX + this._offsetX, targetY + this._offsetY);
		targetCtx.restore();
		return true;
	};

	/**
	* Returns a clone of this DropShadowFilter instance.
	* @method clone
	* @return {DropShadowFilter} A clone of this DropShadowFilter instance.
	**/
	p.clone = function() {
		var f = this._blurFilter;
		return new createjs.DropShadowFilter(this._distance, this._angle, this.color, this.alpha, f.blurX, f.blurY, this.strength, f.quality, this.inner, this.knockout, this.hideObject);
	};

	/**
	* Returns a string representation of this filter.
	* @method toString
	* @return {String} A string representation of this filter.
	**/
	p.toString = function() {
		return "[DropShadowFilter]";
	};

	function setOffset(distance, angle) {
		var r = (angle) * createjs.Matrix2D.DEG_TO_RAD;
		this._offsetX = Math.cos(r) * distance;
		this._offsetY = Math.sin(r) * distance;
	}

    createjs.DropShadowFilter = createjs.promote(DropShadowFilter, "Filter");
}());
/*
GlowFilter for EaselJS
GitHub : https://github.com/u-kudox/Filters_for_EaselJS
Contact and Bug reports : http://kudox.jp/contact or http://twitter.com/u_kudox
License : public domain
*/

/**
* @namespace createjs
**/

(function() {
	"use strict";

	/**
	* Applies a GlowFilter to DisplayObjects of EaselJS. This filter has inherited the Filter class of EaselJS and has used BlurFilter of EaselJS at the blurring process.
	* @class GlowFilter
	* @extends Filter
	* @constructor
	* @param [color=0xFF0000] {uint} The color of the glow. The default value is 0xFF0000. Valid values are in the hexadecimal format 0xRRGGBB.
	* @param [alpha=1] {Number} The alpha transparency value for the glow color. Valid values are 0 to 1.
	* @param [blurX=0] {Number} The amount of horizontal blur. The default value is 0. This value is passed to BlurFilter of EaselJS.
	* @param [blurY=0] {Number} The amount of vertical blur. The default value is 0. This value is passed to BlurFilter of EaselJS.
	* @param [strength=1] {uint} The strength of the glow. The default value is 1. Valid values are 0 to 255. But as for this value, a low value is more preferable.
	* @param [quality=1] {Number} The number of blur iterations. The default value is 1. This value is passed to BlurFilter of EaselJS.
	* @param [inner=false] {Boolean} Specifies whether the glow is an inner glow. The default value is false, expressing outer glow.
	* @param [knockout=false] {Boolean} Specifies whether the object has a knockout effect. The default value is false, expressing no knockout effect.
	* @example
	* <pre><code>_shape = new createjs.Shape().set({x:centerX, y:centerY});
_shape.graphics.f("rgba(0,0,255,1)").dp(0, 0, 100, 5, 0.6, -90).ef();
var color = 0x00FFFF;
var alpha = 1;
var blurX = 32;
var blurY = 32;
var strength = 1;
var quality = 1;
var inner = false;
var knockout = false;
_glowFilter = new createjs.GlowFilter(color, alpha, blurX, blurY, strength, quality, inner, knockout);
_shape.filters = [_glowFilter];
_shape.cache(-100, -100, 200, 200);
_stage.addChild(_shape);</code></pre>
	**/
	function GlowFilter(color, alpha, blurX, blurY, strength, quality, inner, knockout) {
        this.Filter_constructor();
        this.usesContext = true; // say to BitmapCache to call `applyFilter()`, not `_applyFilter()`

		if (!isNaN(color)) this.color = color;
		if (alpha !== undefined) this.alpha = alpha;
		this._blurFilter = new createjs.BlurFilter(blurX, blurY, quality);
		if (strength !== undefined) this.strength = strength;
		this.inner = !!inner;
		this.knockout = !!knockout;
	}

    var p = createjs.extend(GlowFilter, createjs.Filter);

	/**
	* The alpha transparency value for the glow color. Valid values are 0 to 1.
	* @property alpha
	* @type Number
	* @default 1
	**/
	p.alpha = 1;

	/**
	* The strength of the glow. The default value is 1. Valid values are 0 to 255. But as for this value, a low value is more preferable.
	* @property strength
	* @type uint
	* @default 1
	**/
	p.strength = 1;

	/**
	* Specifies whether the glow is an inner glow. The default value is false, expressing outer glow.
	* @property inner
	* @type Boolean
	* @default false
	**/
	p.inner = false;

	/**
	* Specifies whether the object has a knockout effect. The default value is false, expressing no knockout effect.
	* @property knockout
	* @type Boolean
	* @default false
	**/
	p.knockout = false;

	Object.defineProperties(p, {
		/**
		* The color of the glow. The default value is 0xFF0000. Valid values are in the hexadecimal format 0xRRGGBB.
		* @property color
		* @type uint
		* @default 0xFF0000
		**/
		"color" : {
			get : function() {
				return this._red << 16 | this._green << 8 | this._blue;
			},
			set : function(value) {
				this._red = value >> 16 & 0xFF;
				this._green = value >> 8 & 0xFF;
				this._blue = value & 0xFF;
				return this.color;
			},
			enumerable : true
		},

		/**
		* The amount of horizontal blur. The default value is 0. This value is passed to BlurFilter of EaselJS.
		* @property blurX
		* @type Number
		* @default 0
		**/
		"blurX" : {
			get : function() {
				return this._blurFilter.blurX;
			},
			set : function(value) {
				return this._blurFilter.blurX = value;
			},
			enumerable : true
		},

		/**
		* The amount of vertical blur. The default value is 0. This value is passed to BlurFilter of EaselJS.
		* @property blurY
		* @type Number
		* @default 0
		**/
		"blurY" : {
			get : function() {
				return this._blurFilter.blurY;
			},
			set : function(value) {
				return this._blurFilter.blurY = value;
			},
			enumerable : true
		},

		/**
		* The number of blur iterations. The default value is 1. This value is passed to BlurFilter of EaselJS.
		* @property quality
		* @type Number
		* @default 1
		**/
		"quality" : {
			get : function() {
				return this._blurFilter.quality;
			},
			set : function(value) {
				return this._blurFilter.quality = value;
			},
			enumerable : true
		}
	});

	p._red = 255;

	p._green = 0;

	p._blue = 0;

	p._blurFilter = null;

	/**
	* Returns a rectangle with values indicating the margins required to draw the filter or null.
	* For example, a filter that will extend the drawing area 4 pixels to the left, and 7 pixels to the right
	* (but no pixels up or down) would return a rectangle with (x=-4, y=0, width=11, height=0).
	* @method getBounds
	* @return {Rectangle} a rectangle object indicating the margins required to draw the filter or null if the filter does not effect bounds.
	**/
	p.getBounds = function(rect) {
		if (this.inner) {
			return rect;
		} else {
			return this._blurFilter.getBounds(rect) || new createjs.Rectangle();
		}
	};

	/**
	* Applies the GlowFilter to the specified context.
	* @method applyFilter
	* @param ctx {CanvasRenderingContext2D} The 2D context to use as the source.
	* @param x {Number} The x position to use for the source rect.
	* @param y {Number} The y position to use for the source rect.
	* @param width {Number} The width to use for the source rect.
	* @param height {Number} The height to use for the source rect.
	* @param [targetCtx] {CanvasRenderingContext2D} The 2D context to draw the result to. Defaults to the context passed to ctx.
	* @param [targetX] {Number} The x position to draw the result to. Defaults to the value passed to x.
	* @param [targetY] {Number} The y position to draw the result to. Defaults to the value passed to y.
	* @return {Boolean} If the filter was applied successfully.
	**/
	p.applyFilter = function(ctx, x, y, width, height, targetCtx, targetX, targetY) {
		if ((this.alpha <= 0 || this.strength <= 0) && !this.knockout) {
			return true;
		}
		targetCtx = targetCtx || ctx;
		if (targetX === undefined) targetX = x;
		if (targetY === undefined) targetY = y;
		var tImgData = targetCtx.getImageData(targetX, targetY, width, height);
		var tData = tImgData.data;
		var dCvs = document.createElement("canvas");
		dCvs.width = width;
		dCvs.height = height;
		var dCtx = dCvs.getContext("2d", { willReadFrequently:true });
		var dImgData = dCtx.getImageData(0, 0, width, height);
		var dData = dImgData.data;
		var inner = this.inner;
		var red = this._red;
		var green = this._green;
		var blue = this._blue;
		for (var i = 0, l = dData.length; i < l; i += 4) {
			var ia = i + 3;
			var alpha = tData[ia];
			if (!inner) {
				if (alpha !== 0) {
					dData[i] = red;
					dData[i + 1] = green;
					dData[i + 2] = blue;
					dData[ia] = alpha;
				}
			} else {
				if (alpha !== 255) {
					dData[i] = red;
					dData[i + 1] = green;
					dData[i + 2] = blue;
					dData[ia] = 255 - alpha;
				}
			}
		}
		dCtx.putImageData(dImgData, 0, 0);
		var strength = this.strength;
		if (0 < strength) {
			this._blurFilter.applyFilter(dCtx, 0, 0, width, height);
			if (255 < strength) strength = 255;
			for (var j = 1; j < strength; j++) {
				dCtx.drawImage(dCvs, 0, 0);
			}
		}
		var ga = this.alpha;
		if (ga < 0) ga = 0;
		else if (1 < ga) ga = 1;
		var gco;
		if (this.knockout) {
			if (inner) gco = "source-in";
			else gco = "source-out";
		} else {
			if (inner) gco = "source-atop";
			else gco = "destination-over";
		}
		targetCtx.save();
		targetCtx.setTransform(1, 0, 0, 1, 0, 0);
		targetCtx.globalAlpha = ga;
		targetCtx.globalCompositeOperation = gco;
		targetCtx.drawImage(dCvs, targetX, targetY);
		targetCtx.restore();
		return true;
	};

	/**
	* Returns a clone of this GlowFilter instance.
	* @method clone
	* @return {GlowFilter} A clone of this GlowFilter instance.
	**/
	p.clone = function() {
		var f = this._blurFilter;
		return new createjs.GlowFilter(this.color, this.alpha, f.blurX, f.blurY, this.strength, f.quality, this.inner, this.knockout);
	};

	/**
	* Returns a string representation of this filter.
	* @method toString
	* @return {String} A string representation of this filter.
	**/
	p.toString = function() {
		return "[GlowFilter]";
	};

	createjs.GlowFilter = createjs.promote(GlowFilter, "Filter");
}());
Main.main();
})(typeof exports != "undefined" ? exports : typeof window != "undefined" ? window : typeof self != "undefined" ? self : this, {});
