window.three = window.three || {};
window.three_GLTFLoader = window.three_GLTFLoader || {};

/******/ (() => { // webpackBootstrap
/******/ 	var __webpack_modules__ = ({

/***/ "./bin/nanofl-haxe.js":
/*!****************************!*\
  !*** ./bin/nanofl-haxe.js ***!
  \****************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

// Generated by Haxe 4.3.3
(function ($hx_exports, $global) { "use strict";
$hx_exports["nanofl"] = $hx_exports["nanofl"] || {};
$hx_exports["nanofl"]["engine"] = $hx_exports["nanofl"]["engine"] || {};
$hx_exports["nanofl"]["engine"]["plugins"] = $hx_exports["nanofl"]["engine"]["plugins"] || {};
var $estr = function() { return js_Boot.__string_rec(this,''); },$hxEnums = $hxEnums || {},$_;
function $extend(from, fields) {
	var proto = Object.create(from);
	for (var name in fields) proto[name] = fields[name];
	if( fields.toString !== Object.prototype.toString ) proto.toString = fields.toString;
	return proto;
}
var EReg = function(r,opt) {
	this.r = new RegExp(r,opt.split("u").join(""));
};
EReg.__name__ = "EReg";
EReg.prototype = {
	match: function(s) {
		if(this.r.global) {
			this.r.lastIndex = 0;
		}
		this.r.m = this.r.exec(s);
		this.r.s = s;
		return this.r.m != null;
	}
	,matched: function(n) {
		if(this.r.m != null && n >= 0 && n < this.r.m.length) {
			return this.r.m[n];
		} else {
			throw haxe_Exception.thrown("EReg::matched");
		}
	}
	,matchedPos: function() {
		if(this.r.m == null) {
			throw haxe_Exception.thrown("No string matched");
		}
		return { pos : this.r.m.index, len : this.r.m[0].length};
	}
	,matchSub: function(s,pos,len) {
		if(len == null) {
			len = -1;
		}
		if(this.r.global) {
			this.r.lastIndex = pos;
			this.r.m = this.r.exec(len < 0 ? s : HxOverrides.substr(s,0,pos + len));
			var b = this.r.m != null;
			if(b) {
				this.r.s = s;
			}
			return b;
		} else {
			var b = this.match(len < 0 ? HxOverrides.substr(s,pos,null) : HxOverrides.substr(s,pos,len));
			if(b) {
				this.r.s = s;
				this.r.m.index += pos;
			}
			return b;
		}
	}
	,split: function(s) {
		var d = "#__delim__#";
		return s.replace(this.r,d).split(d);
	}
	,map: function(s,f) {
		var offset = 0;
		var buf_b = "";
		do {
			if(offset >= s.length) {
				break;
			} else if(!this.matchSub(s,offset)) {
				buf_b += Std.string(HxOverrides.substr(s,offset,null));
				break;
			}
			var p = this.matchedPos();
			buf_b += Std.string(HxOverrides.substr(s,offset,p.pos - offset));
			buf_b += Std.string(f(this));
			if(p.len == 0) {
				buf_b += Std.string(HxOverrides.substr(s,p.pos,1));
				offset = p.pos + 1;
			} else {
				offset = p.pos + p.len;
			}
		} while(this.r.global);
		if(!this.r.global && offset > 0 && offset < s.length) {
			buf_b += Std.string(HxOverrides.substr(s,offset,null));
		}
		return buf_b;
	}
	,__class__: EReg
};
var HxOverrides = function() { };
HxOverrides.__name__ = "HxOverrides";
HxOverrides.cca = function(s,index) {
	var x = s.charCodeAt(index);
	if(x != x) {
		return undefined;
	}
	return x;
};
HxOverrides.substr = function(s,pos,len) {
	if(len == null) {
		len = s.length;
	} else if(len < 0) {
		if(pos == 0) {
			len = s.length + len;
		} else {
			return "";
		}
	}
	return s.substr(pos,len);
};
HxOverrides.remove = function(a,obj) {
	var i = a.indexOf(obj);
	if(i == -1) {
		return false;
	}
	a.splice(i,1);
	return true;
};
HxOverrides.now = function() {
	return Date.now();
};
var Lambda = function() { };
Lambda.__name__ = "Lambda";
Lambda.array = function(it) {
	var a = [];
	var i = $getIterator(it);
	while(i.hasNext()) {
		var i1 = i.next();
		a.push(i1);
	}
	return a;
};
Lambda.exists = function(it,f) {
	var x = $getIterator(it);
	while(x.hasNext()) {
		var x1 = x.next();
		if(f(x1)) {
			return true;
		}
	}
	return false;
};
Lambda.foreach = function(it,f) {
	var x = $getIterator(it);
	while(x.hasNext()) {
		var x1 = x.next();
		if(!f(x1)) {
			return false;
		}
	}
	return true;
};
Lambda.count = function(it,pred) {
	var n = 0;
	if(pred == null) {
		var _ = $getIterator(it);
		while(_.hasNext()) {
			var _1 = _.next();
			++n;
		}
	} else {
		var x = $getIterator(it);
		while(x.hasNext()) {
			var x1 = x.next();
			if(pred(x1)) {
				++n;
			}
		}
	}
	return n;
};
Lambda.indexOf = function(it,v) {
	var i = 0;
	var v2 = $getIterator(it);
	while(v2.hasNext()) {
		var v21 = v2.next();
		if(v == v21) {
			return i;
		}
		++i;
	}
	return -1;
};
Lambda.find = function(it,f) {
	var v = $getIterator(it);
	while(v.hasNext()) {
		var v1 = v.next();
		if(f(v1)) {
			return v1;
		}
	}
	return null;
};
Math.__name__ = "Math";
var Reflect = function() { };
Reflect.__name__ = "Reflect";
Reflect.field = function(o,field) {
	try {
		return o[field];
	} catch( _g ) {
		return null;
	}
};
Reflect.fields = function(o) {
	var a = [];
	if(o != null) {
		var hasOwnProperty = Object.prototype.hasOwnProperty;
		for( var f in o ) {
		if(f != "__id__" && f != "hx__closures__" && hasOwnProperty.call(o,f)) {
			a.push(f);
		}
		}
	}
	return a;
};
Reflect.isFunction = function(f) {
	if(typeof(f) == "function") {
		return !(f.__name__ || f.__ename__);
	} else {
		return false;
	}
};
Reflect.compare = function(a,b) {
	if(a == b) {
		return 0;
	} else if(a > b) {
		return 1;
	} else {
		return -1;
	}
};
Reflect.deleteField = function(o,field) {
	if(!Object.prototype.hasOwnProperty.call(o,field)) {
		return false;
	}
	delete(o[field]);
	return true;
};
Reflect.copy = function(o) {
	if(o == null) {
		return null;
	}
	var o2 = { };
	var _g = 0;
	var _g1 = Reflect.fields(o);
	while(_g < _g1.length) {
		var f = _g1[_g];
		++_g;
		o2[f] = Reflect.field(o,f);
	}
	return o2;
};
Reflect.makeVarArgs = function(f) {
	return function() {
		var a = Array.prototype.slice;
		var a1 = arguments;
		var a2 = a.call(a1);
		return f(a2);
	};
};
var Std = function() { };
Std.__name__ = "Std";
Std.string = function(s) {
	return js_Boot.__string_rec(s,"");
};
Std.parseInt = function(x) {
	var v = parseInt(x);
	if(isNaN(v)) {
		return null;
	}
	return v;
};
Std.random = function(x) {
	if(x <= 0) {
		return 0;
	} else {
		return Math.floor(Math.random() * x);
	}
};
var StringBuf = function() {
	this.b = "";
};
StringBuf.__name__ = "StringBuf";
StringBuf.prototype = {
	__class__: StringBuf
};
var haxe_SysTools = function() { };
haxe_SysTools.__name__ = "haxe.SysTools";
var StringTools = function() { };
StringTools.__name__ = "StringTools";
StringTools.htmlEscape = function(s,quotes) {
	var buf_b = "";
	var _g_offset = 0;
	var _g_s = s;
	while(_g_offset < _g_s.length) {
		var s = _g_s;
		var index = _g_offset++;
		var c = s.charCodeAt(index);
		if(c >= 55296 && c <= 56319) {
			c = c - 55232 << 10 | s.charCodeAt(index + 1) & 1023;
		}
		var c1 = c;
		if(c1 >= 65536) {
			++_g_offset;
		}
		var code = c1;
		switch(code) {
		case 34:
			if(quotes) {
				buf_b += "&quot;";
			} else {
				buf_b += String.fromCodePoint(code);
			}
			break;
		case 38:
			buf_b += "&amp;";
			break;
		case 39:
			if(quotes) {
				buf_b += "&#039;";
			} else {
				buf_b += String.fromCodePoint(code);
			}
			break;
		case 60:
			buf_b += "&lt;";
			break;
		case 62:
			buf_b += "&gt;";
			break;
		default:
			buf_b += String.fromCodePoint(code);
		}
	}
	return buf_b;
};
StringTools.htmlUnescape = function(s) {
	return s.split("&gt;").join(">").split("&lt;").join("<").split("&quot;").join("\"").split("&#039;").join("'").split("&amp;").join("&");
};
StringTools.startsWith = function(s,start) {
	if(s.length >= start.length) {
		return s.lastIndexOf(start,0) == 0;
	} else {
		return false;
	}
};
StringTools.endsWith = function(s,end) {
	var elen = end.length;
	var slen = s.length;
	if(slen >= elen) {
		return s.indexOf(end,slen - elen) == slen - elen;
	} else {
		return false;
	}
};
StringTools.isSpace = function(s,pos) {
	var c = HxOverrides.cca(s,pos);
	if(!(c > 8 && c < 14)) {
		return c == 32;
	} else {
		return true;
	}
};
StringTools.ltrim = function(s) {
	var l = s.length;
	var r = 0;
	while(r < l && StringTools.isSpace(s,r)) ++r;
	if(r > 0) {
		return HxOverrides.substr(s,r,l - r);
	} else {
		return s;
	}
};
StringTools.rtrim = function(s) {
	var l = s.length;
	var r = 0;
	while(r < l && StringTools.isSpace(s,l - r - 1)) ++r;
	if(r > 0) {
		return HxOverrides.substr(s,0,l - r);
	} else {
		return s;
	}
};
StringTools.trim = function(s) {
	return StringTools.ltrim(StringTools.rtrim(s));
};
StringTools.lpad = function(s,c,l) {
	if(c.length <= 0) {
		return s;
	}
	var buf_b = "";
	l -= s.length;
	while(buf_b.length < l) buf_b += c == null ? "null" : "" + c;
	buf_b += s == null ? "null" : "" + s;
	return buf_b;
};
StringTools.rpad = function(s,c,l) {
	if(c.length <= 0) {
		return s;
	}
	var buf_b = "";
	buf_b += s == null ? "null" : "" + s;
	while(buf_b.length < l) buf_b += c == null ? "null" : "" + c;
	return buf_b;
};
StringTools.replace = function(s,sub,by) {
	return s.split(sub).join(by);
};
StringTools.hex = function(n,digits) {
	var s = "";
	var hexChars = "0123456789ABCDEF";
	do {
		s = hexChars.charAt(n & 15) + s;
		n >>>= 4;
	} while(n > 0);
	if(digits != null) {
		while(s.length < digits) s = "0" + s;
	}
	return s;
};
StringTools.quoteUnixArg = function(argument) {
	if(argument == "") {
		return "''";
	} else if(!new EReg("[^a-zA-Z0-9_@%+=:,./-]","").match(argument)) {
		return argument;
	} else {
		return "'" + StringTools.replace(argument,"'","'\"'\"'") + "'";
	}
};
StringTools.quoteWinArg = function(argument,escapeMetaCharacters) {
	var argument1 = argument;
	if(!new EReg("^(/)?[^ \t/\\\\\"]+$","").match(argument1)) {
		var result_b = "";
		var needquote = argument1.indexOf(" ") != -1 || argument1.indexOf("\t") != -1 || argument1 == "" || argument1.indexOf("/") > 0;
		if(needquote) {
			result_b += "\"";
		}
		var bs_buf = new StringBuf();
		var _g = 0;
		var _g1 = argument1.length;
		while(_g < _g1) {
			var i = _g++;
			var _g2 = HxOverrides.cca(argument1,i);
			if(_g2 == null) {
				var c = _g2;
				if(bs_buf.b.length > 0) {
					result_b += Std.string(bs_buf.b);
					bs_buf = new StringBuf();
				}
				result_b += String.fromCodePoint(c);
			} else {
				switch(_g2) {
				case 34:
					var bs = bs_buf.b;
					result_b += Std.string(bs);
					result_b += Std.string(bs);
					bs_buf = new StringBuf();
					result_b += "\\\"";
					break;
				case 92:
					bs_buf.b += "\\";
					break;
				default:
					var c1 = _g2;
					if(bs_buf.b.length > 0) {
						result_b += Std.string(bs_buf.b);
						bs_buf = new StringBuf();
					}
					result_b += String.fromCodePoint(c1);
				}
			}
		}
		result_b += Std.string(bs_buf.b);
		if(needquote) {
			result_b += Std.string(bs_buf.b);
			result_b += "\"";
		}
		argument1 = result_b;
	}
	if(escapeMetaCharacters) {
		var result_b = "";
		var _g = 0;
		var _g1 = argument1.length;
		while(_g < _g1) {
			var i = _g++;
			var c = HxOverrides.cca(argument1,i);
			if(haxe_SysTools.winMetaCharacters.indexOf(c) >= 0) {
				result_b += String.fromCodePoint(94);
			}
			result_b += String.fromCodePoint(c);
		}
		return result_b;
	} else {
		return argument1;
	}
};
var ValueType = $hxEnums["ValueType"] = { __ename__:"ValueType",__constructs__:null
	,TNull: {_hx_name:"TNull",_hx_index:0,__enum__:"ValueType",toString:$estr}
	,TInt: {_hx_name:"TInt",_hx_index:1,__enum__:"ValueType",toString:$estr}
	,TFloat: {_hx_name:"TFloat",_hx_index:2,__enum__:"ValueType",toString:$estr}
	,TBool: {_hx_name:"TBool",_hx_index:3,__enum__:"ValueType",toString:$estr}
	,TObject: {_hx_name:"TObject",_hx_index:4,__enum__:"ValueType",toString:$estr}
	,TFunction: {_hx_name:"TFunction",_hx_index:5,__enum__:"ValueType",toString:$estr}
	,TClass: ($_=function(c) { return {_hx_index:6,c:c,__enum__:"ValueType",toString:$estr}; },$_._hx_name="TClass",$_.__params__ = ["c"],$_)
	,TEnum: ($_=function(e) { return {_hx_index:7,e:e,__enum__:"ValueType",toString:$estr}; },$_._hx_name="TEnum",$_.__params__ = ["e"],$_)
	,TUnknown: {_hx_name:"TUnknown",_hx_index:8,__enum__:"ValueType",toString:$estr}
};
ValueType.__constructs__ = [ValueType.TNull,ValueType.TInt,ValueType.TFloat,ValueType.TBool,ValueType.TObject,ValueType.TFunction,ValueType.TClass,ValueType.TEnum,ValueType.TUnknown];
var Type = function() { };
Type.__name__ = "Type";
Type.createInstance = function(cl,args) {
	var ctor = Function.prototype.bind.apply(cl,[null].concat(args));
	return new (ctor);
};
Type.createEnum = function(e,constr,params) {
	var f = Reflect.field(e,constr);
	if(f == null) {
		throw haxe_Exception.thrown("No such constructor " + constr);
	}
	if(Reflect.isFunction(f)) {
		if(params == null) {
			throw haxe_Exception.thrown("Constructor " + constr + " need parameters");
		}
		return f.apply(e,params);
	}
	if(params != null && params.length != 0) {
		throw haxe_Exception.thrown("Constructor " + constr + " does not need parameters");
	}
	return f;
};
Type.typeof = function(v) {
	switch(typeof(v)) {
	case "boolean":
		return ValueType.TBool;
	case "function":
		if(v.__name__ || v.__ename__) {
			return ValueType.TObject;
		}
		return ValueType.TFunction;
	case "number":
		if(Math.ceil(v) == v % 2147483648.0) {
			return ValueType.TInt;
		}
		return ValueType.TFloat;
	case "object":
		if(v == null) {
			return ValueType.TNull;
		}
		var e = v.__enum__;
		if(e != null) {
			return ValueType.TEnum($hxEnums[e]);
		}
		var c = js_Boot.getClass(v);
		if(c != null) {
			return ValueType.TClass(c);
		}
		return ValueType.TObject;
	case "string":
		return ValueType.TClass(String);
	case "undefined":
		return ValueType.TNull;
	default:
		return ValueType.TUnknown;
	}
};
Type.enumParameters = function(e) {
	var enm = $hxEnums[e.__enum__];
	var params = enm.__constructs__[e._hx_index].__params__;
	if(params != null) {
		var _g = [];
		var _g1 = 0;
		while(_g1 < params.length) {
			var p = params[_g1];
			++_g1;
			_g.push(e[p]);
		}
		return _g;
	} else {
		return [];
	}
};
var datatools_ArrayRO = {};
datatools_ArrayRO.filterByType = function(this1,klass) {
	var _g = [];
	var _g1 = 0;
	var _g2 = this1;
	while(_g1 < _g2.length) {
		var v = _g2[_g1];
		++_g1;
		if(js_Boot.__instanceof(v,klass)) {
			_g.push(v);
		}
	}
	return _g;
};
var datatools_ArrayTools = function() { };
datatools_ArrayTools.__name__ = "datatools.ArrayTools";
datatools_ArrayTools.equ = function(a,b) {
	if(a.length != b.length) {
		return false;
	}
	var _g = 0;
	var _g1 = a.length;
	while(_g < _g1) {
		var i = _g++;
		if(a[i] == null && b[i] != null) {
			return false;
		}
		if(a[i] != null && b[i] == null) {
			return false;
		}
		if(a[i] != null && !a[i].equ(b[i])) {
			return false;
		}
	}
	return true;
};
datatools_ArrayTools.equByFunc = function(a,b,equFunc) {
	if(a.length != b.length) {
		return false;
	}
	var _g = 0;
	var _g1 = a.length;
	while(_g < _g1) {
		var i = _g++;
		if(a[i] == null && b[i] != null) {
			return false;
		}
		if(a[i] != null && b[i] == null) {
			return false;
		}
		if(a[i] != null && !equFunc(a[i],b[i])) {
			return false;
		}
	}
	return true;
};
datatools_ArrayTools.clone = function(array) {
	var r = [];
	var _g = 0;
	var _g1 = array;
	while(_g < _g1.length) {
		var item = _g1[_g];
		++_g;
		r.push(item.clone());
	}
	return r;
};
datatools_ArrayTools.swap = function(arr,i,j) {
	var z = arr[i];
	arr[i] = arr[j];
	arr[j] = z;
};
datatools_ArrayTools.equFast = function(a,b) {
	if(a.length != b.length) {
		return false;
	}
	var _g = 0;
	var _g1 = a.length;
	while(_g < _g1) {
		var i = _g++;
		if(a[i] != b[i]) {
			return false;
		}
	}
	return true;
};
datatools_ArrayTools.appendUniqueFast = function(accum,items) {
	var _g = 0;
	var _g1 = items;
	while(_g < _g1.length) {
		var item = _g1[_g];
		++_g;
		if(accum.indexOf(item) < 0) {
			accum.push(item);
		}
	}
	return accum;
};
var datatools_MapTools = function() { };
datatools_MapTools.__name__ = "datatools.MapTools";
datatools_MapTools.clone = function(m) {
	var r = Type.createInstance(js_Boot.getClass(m),[]);
	var k = m.keys();
	while(k.hasNext()) {
		var k1 = k.next();
		r.set(k1,m.get(k1).clone());
	}
	return r;
};
datatools_MapTools.cloneFast = function(m) {
	var r = Type.createInstance(js_Boot.getClass(m),[]);
	var k = m.keys();
	while(k.hasNext()) {
		var k1 = k.next();
		r.set(k1,m.get(k1));
	}
	return r;
};
datatools_MapTools.equ = function(a,b) {
	return datatools_MapTools.equCustom(a,b,function(e1,e2) {
		if(!(e1 == null && e2 == null)) {
			if(e1 != null && e2 != null) {
				return e1.equ(e2);
			} else {
				return false;
			}
		} else {
			return true;
		}
	});
};
datatools_MapTools.equFast = function(a,b) {
	return datatools_MapTools.equCustom(a,b,function(e1,e2) {
		return e1 == e2;
	});
};
datatools_MapTools.equCustom = function(a,b,cmp) {
	var keysA = [];
	var k = a.keys();
	while(k.hasNext()) {
		var k1 = k.next();
		keysA.push(k1);
	}
	var keysB = [];
	var k = b.keys();
	while(k.hasNext()) {
		var k1 = k.next();
		keysB.push(k1);
	}
	if(keysA.length != keysB.length) {
		return false;
	}
	keysA.sort(Reflect.compare);
	keysB.sort(Reflect.compare);
	if(!datatools_ArrayTools.equFast(keysA,keysB)) {
		return false;
	}
	var _g = 0;
	while(_g < keysA.length) {
		var key = keysA[_g];
		++_g;
		if(!cmp(a.get(key),b.get(key))) {
			return false;
		}
	}
	return true;
};
datatools_MapTools.toObject = function(map) {
	var r = { };
	var h = map.h;
	var k_h = h;
	var k_keys = Object.keys(h);
	var k_length = k_keys.length;
	var k_current = 0;
	while(k_current < k_length) {
		var k = k_keys[k_current++];
		r[k] = map.h[k];
	}
	return r;
};
datatools_MapTools.fromObject = function(obj) {
	var r = new haxe_ds_StringMap();
	var _g = 0;
	var _g1 = Reflect.fields(obj);
	while(_g < _g1.length) {
		var k = _g1[_g];
		++_g;
		r.h[k] = Reflect.field(obj,k);
	}
	return r;
};
var datatools_NullTools = function() { };
datatools_NullTools.__name__ = "datatools.NullTools";
datatools_NullTools.clone = function(v) {
	if(v != null) {
		return v.clone();
	} else {
		return null;
	}
};
datatools_NullTools.equ = function(a,b) {
	if(!(a == null && b == null)) {
		if(a != null && b != null) {
			return a.equ(b);
		} else {
			return false;
		}
	} else {
		return true;
	}
};
var datatools_ObjectTools = function() { };
datatools_ObjectTools.__name__ = "datatools.ObjectTools";
datatools_ObjectTools.equFast = function(a,b) {
	var fieldsA = Reflect.fields(a);
	var fieldsB = Reflect.fields(b);
	if(fieldsA.length != fieldsB.length) {
		return false;
	}
	fieldsA.sort(datatools_ObjectTools.cmpString);
	fieldsB.sort(datatools_ObjectTools.cmpString);
	if(!datatools_ArrayTools.equFast(fieldsA,fieldsB)) {
		return false;
	}
	var result = new Array(fieldsA.length);
	var _g = 0;
	var _g1 = fieldsA.length;
	while(_g < _g1) {
		var i = _g++;
		result[i] = Reflect.field(a,fieldsA[i]);
	}
	var valuesA = result;
	var result = new Array(fieldsB.length);
	var _g = 0;
	var _g1 = fieldsB.length;
	while(_g < _g1) {
		var i = _g++;
		result[i] = Reflect.field(b,fieldsB[i]);
	}
	var valuesB = result;
	if(!datatools_ArrayTools.equFast(valuesA,valuesB)) {
		return false;
	}
	return true;
};
datatools_ObjectTools.cmpString = function(a,b) {
	if(a < b) {
		return -1;
	}
	if(a > b) {
		return 1;
	}
	return 0;
};
var haxe_StackItem = $hxEnums["haxe.StackItem"] = { __ename__:"haxe.StackItem",__constructs__:null
	,CFunction: {_hx_name:"CFunction",_hx_index:0,__enum__:"haxe.StackItem",toString:$estr}
	,Module: ($_=function(m) { return {_hx_index:1,m:m,__enum__:"haxe.StackItem",toString:$estr}; },$_._hx_name="Module",$_.__params__ = ["m"],$_)
	,FilePos: ($_=function(s,file,line,column) { return {_hx_index:2,s:s,file:file,line:line,column:column,__enum__:"haxe.StackItem",toString:$estr}; },$_._hx_name="FilePos",$_.__params__ = ["s","file","line","column"],$_)
	,Method: ($_=function(classname,method) { return {_hx_index:3,classname:classname,method:method,__enum__:"haxe.StackItem",toString:$estr}; },$_._hx_name="Method",$_.__params__ = ["classname","method"],$_)
	,LocalFunction: ($_=function(v) { return {_hx_index:4,v:v,__enum__:"haxe.StackItem",toString:$estr}; },$_._hx_name="LocalFunction",$_.__params__ = ["v"],$_)
};
haxe_StackItem.__constructs__ = [haxe_StackItem.CFunction,haxe_StackItem.Module,haxe_StackItem.FilePos,haxe_StackItem.Method,haxe_StackItem.LocalFunction];
var haxe_CallStack = {};
haxe_CallStack.callStack = function() {
	return haxe_NativeStackTrace.toHaxe(haxe_NativeStackTrace.callStack());
};
haxe_CallStack.toString = function(stack) {
	var b = new StringBuf();
	var _g = 0;
	var _g1 = stack;
	while(_g < _g1.length) {
		var s = _g1[_g];
		++_g;
		b.b += "\nCalled from ";
		haxe_CallStack.itemToString(b,s);
	}
	return b.b;
};
haxe_CallStack.subtract = function(this1,stack) {
	var startIndex = -1;
	var i = -1;
	while(++i < this1.length) {
		var _g = 0;
		var _g1 = stack.length;
		while(_g < _g1) {
			var j = _g++;
			if(haxe_CallStack.equalItems(this1[i],stack[j])) {
				if(startIndex < 0) {
					startIndex = i;
				}
				++i;
				if(i >= this1.length) {
					break;
				}
			} else {
				startIndex = -1;
			}
		}
		if(startIndex >= 0) {
			break;
		}
	}
	if(startIndex >= 0) {
		return this1.slice(0,startIndex);
	} else {
		return this1;
	}
};
haxe_CallStack.equalItems = function(item1,item2) {
	if(item1 == null) {
		if(item2 == null) {
			return true;
		} else {
			return false;
		}
	} else {
		switch(item1._hx_index) {
		case 0:
			if(item2 == null) {
				return false;
			} else if(item2._hx_index == 0) {
				return true;
			} else {
				return false;
			}
			break;
		case 1:
			if(item2 == null) {
				return false;
			} else if(item2._hx_index == 1) {
				var m2 = item2.m;
				var m1 = item1.m;
				return m1 == m2;
			} else {
				return false;
			}
			break;
		case 2:
			if(item2 == null) {
				return false;
			} else if(item2._hx_index == 2) {
				var item21 = item2.s;
				var file2 = item2.file;
				var line2 = item2.line;
				var col2 = item2.column;
				var col1 = item1.column;
				var line1 = item1.line;
				var file1 = item1.file;
				var item11 = item1.s;
				if(file1 == file2 && line1 == line2 && col1 == col2) {
					return haxe_CallStack.equalItems(item11,item21);
				} else {
					return false;
				}
			} else {
				return false;
			}
			break;
		case 3:
			if(item2 == null) {
				return false;
			} else if(item2._hx_index == 3) {
				var class2 = item2.classname;
				var method2 = item2.method;
				var method1 = item1.method;
				var class1 = item1.classname;
				if(class1 == class2) {
					return method1 == method2;
				} else {
					return false;
				}
			} else {
				return false;
			}
			break;
		case 4:
			if(item2 == null) {
				return false;
			} else if(item2._hx_index == 4) {
				var v2 = item2.v;
				var v1 = item1.v;
				return v1 == v2;
			} else {
				return false;
			}
			break;
		}
	}
};
haxe_CallStack.itemToString = function(b,s) {
	switch(s._hx_index) {
	case 0:
		b.b += "a C function";
		break;
	case 1:
		var m = s.m;
		b.b += "module ";
		b.b += m == null ? "null" : "" + m;
		break;
	case 2:
		var s1 = s.s;
		var file = s.file;
		var line = s.line;
		var col = s.column;
		if(s1 != null) {
			haxe_CallStack.itemToString(b,s1);
			b.b += " (";
		}
		b.b += file == null ? "null" : "" + file;
		b.b += " line ";
		b.b += line == null ? "null" : "" + line;
		if(col != null) {
			b.b += " column ";
			b.b += col == null ? "null" : "" + col;
		}
		if(s1 != null) {
			b.b += ")";
		}
		break;
	case 3:
		var cname = s.classname;
		var meth = s.method;
		b.b += Std.string(cname == null ? "<unknown>" : cname);
		b.b += ".";
		b.b += meth == null ? "null" : "" + meth;
		break;
	case 4:
		var n = s.v;
		b.b += "local function #";
		b.b += n == null ? "null" : "" + n;
		break;
	}
};
var haxe_IMap = function() { };
haxe_IMap.__name__ = "haxe.IMap";
haxe_IMap.__isInterface__ = true;
haxe_IMap.prototype = {
	__class__: haxe_IMap
};
var haxe_Exception = function(message,previous,native) {
	Error.call(this,message);
	this.message = message;
	this.__previousException = previous;
	this.__nativeException = native != null ? native : this;
	this.__skipStack = 0;
	var old = Error.prepareStackTrace;
	Error.prepareStackTrace = function(e) { return e.stack; }
	if(((native) instanceof Error)) {
		this.stack = native.stack;
	} else {
		var e = null;
		if(Error.captureStackTrace) {
			Error.captureStackTrace(this,haxe_Exception);
			e = this;
		} else {
			e = new Error();
			if(typeof(e.stack) == "undefined") {
				try { throw e; } catch(_) {}
				this.__skipStack++;
			}
		}
		this.stack = e.stack;
	}
	Error.prepareStackTrace = old;
};
haxe_Exception.__name__ = "haxe.Exception";
haxe_Exception.thrown = function(value) {
	if(((value) instanceof haxe_Exception)) {
		return value.get_native();
	} else if(((value) instanceof Error)) {
		return value;
	} else {
		var e = new haxe_ValueException(value);
		e.__skipStack++;
		return e;
	}
};
haxe_Exception.__super__ = Error;
haxe_Exception.prototype = $extend(Error.prototype,{
	toString: function() {
		return this.get_message();
	}
	,details: function() {
		if(this.get_previous() == null) {
			var tmp = "Exception: " + this.toString();
			var tmp1 = this.get_stack();
			return tmp + (tmp1 == null ? "null" : haxe_CallStack.toString(tmp1));
		} else {
			var result = "";
			var e = this;
			var prev = null;
			while(e != null) {
				if(prev == null) {
					var result1 = "Exception: " + e.get_message();
					var tmp = e.get_stack();
					result = result1 + (tmp == null ? "null" : haxe_CallStack.toString(tmp)) + result;
				} else {
					var prevStack = haxe_CallStack.subtract(e.get_stack(),prev.get_stack());
					result = "Exception: " + e.get_message() + (prevStack == null ? "null" : haxe_CallStack.toString(prevStack)) + "\n\nNext " + result;
				}
				prev = e;
				e = e.get_previous();
			}
			return result;
		}
	}
	,__shiftStack: function() {
		this.__skipStack++;
	}
	,get_message: function() {
		return this.message;
	}
	,get_previous: function() {
		return this.__previousException;
	}
	,get_native: function() {
		return this.__nativeException;
	}
	,get_stack: function() {
		var _g = this.__exceptionStack;
		if(_g == null) {
			var value = haxe_NativeStackTrace.toHaxe(haxe_NativeStackTrace.normalize(this.stack),this.__skipStack);
			this.setProperty("__exceptionStack",value);
			return value;
		} else {
			var s = _g;
			return s;
		}
	}
	,setProperty: function(name,value) {
		try {
			Object.defineProperty(this,name,{ value : value});
		} catch( _g ) {
			this[name] = value;
		}
	}
	,__class__: haxe_Exception
});
var haxe_Log = function() { };
haxe_Log.__name__ = "haxe.Log";
haxe_Log.formatOutput = function(v,infos) {
	var str = Std.string(v);
	if(infos == null) {
		return str;
	}
	var pstr = infos.fileName + ":" + infos.lineNumber;
	if(infos.customParams != null) {
		var _g = 0;
		var _g1 = infos.customParams;
		while(_g < _g1.length) {
			var v = _g1[_g];
			++_g;
			str += ", " + Std.string(v);
		}
	}
	return pstr + ": " + str;
};
haxe_Log.trace = function(v,infos) {
	var str = haxe_Log.formatOutput(v,infos);
	if(typeof(console) != "undefined" && console.log != null) {
		console.log(str);
	}
};
var haxe_NativeStackTrace = function() { };
haxe_NativeStackTrace.__name__ = "haxe.NativeStackTrace";
haxe_NativeStackTrace.callStack = function() {
	var e = new Error("");
	var stack = haxe_NativeStackTrace.tryHaxeStack(e);
	if(typeof(stack) == "undefined") {
		try {
			throw e;
		} catch( _g ) {
		}
		stack = e.stack;
	}
	return haxe_NativeStackTrace.normalize(stack,2);
};
haxe_NativeStackTrace.toHaxe = function(s,skip) {
	if(skip == null) {
		skip = 0;
	}
	if(s == null) {
		return [];
	} else if(typeof(s) == "string") {
		var stack = s.split("\n");
		if(stack[0] == "Error") {
			stack.shift();
		}
		var m = [];
		var _g = 0;
		var _g1 = stack.length;
		while(_g < _g1) {
			var i = _g++;
			if(skip > i) {
				continue;
			}
			var line = stack[i];
			var matched = line.match(/^    at ([$A-Za-z0-9_. ]+) \(([^)]+):([0-9]+):([0-9]+)\)$/);
			if(matched != null) {
				var path = matched[1].split(".");
				if(path[0] == "$hxClasses") {
					path.shift();
				}
				var meth = path.pop();
				var file = matched[2];
				var line1 = Std.parseInt(matched[3]);
				var column = Std.parseInt(matched[4]);
				m.push(haxe_StackItem.FilePos(meth == "Anonymous function" ? haxe_StackItem.LocalFunction() : meth == "Global code" ? null : haxe_StackItem.Method(path.join("."),meth),file,line1,column));
			} else {
				m.push(haxe_StackItem.Module(StringTools.trim(line)));
			}
		}
		return m;
	} else if(skip > 0 && Array.isArray(s)) {
		return s.slice(skip);
	} else {
		return s;
	}
};
haxe_NativeStackTrace.tryHaxeStack = function(e) {
	if(e == null) {
		return [];
	}
	var oldValue = Error.prepareStackTrace;
	Error.prepareStackTrace = haxe_NativeStackTrace.prepareHxStackTrace;
	var stack = e.stack;
	Error.prepareStackTrace = oldValue;
	return stack;
};
haxe_NativeStackTrace.prepareHxStackTrace = function(e,callsites) {
	var stack = [];
	var _g = 0;
	while(_g < callsites.length) {
		var site = callsites[_g];
		++_g;
		if(haxe_NativeStackTrace.wrapCallSite != null) {
			site = haxe_NativeStackTrace.wrapCallSite(site);
		}
		var method = null;
		var fullName = site.getFunctionName();
		if(fullName != null) {
			var idx = fullName.lastIndexOf(".");
			if(idx >= 0) {
				var className = fullName.substring(0,idx);
				var methodName = fullName.substring(idx + 1);
				method = haxe_StackItem.Method(className,methodName);
			} else {
				method = haxe_StackItem.Method(null,fullName);
			}
		}
		var fileName = site.getFileName();
		var fileAddr = fileName == null ? -1 : fileName.indexOf("file:");
		if(haxe_NativeStackTrace.wrapCallSite != null && fileAddr > 0) {
			fileName = fileName.substring(fileAddr + 6);
		}
		stack.push(haxe_StackItem.FilePos(method,fileName,site.getLineNumber(),site.getColumnNumber()));
	}
	return stack;
};
haxe_NativeStackTrace.normalize = function(stack,skipItems) {
	if(skipItems == null) {
		skipItems = 0;
	}
	if(Array.isArray(stack) && skipItems > 0) {
		return stack.slice(skipItems);
	} else if(typeof(stack) == "string") {
		switch(stack.substring(0,6)) {
		case "Error\n":case "Error:":
			++skipItems;
			break;
		default:
		}
		return haxe_NativeStackTrace.skipLines(stack,skipItems);
	} else {
		return stack;
	}
};
haxe_NativeStackTrace.skipLines = function(stack,skip,pos) {
	if(pos == null) {
		pos = 0;
	}
	if(skip > 0) {
		pos = stack.indexOf("\n",pos);
		if(pos < 0) {
			return "";
		} else {
			return haxe_NativeStackTrace.skipLines(stack,--skip,pos + 1);
		}
	} else {
		return stack.substring(pos);
	}
};
var haxe_Serializer = function() {
	this.buf = new StringBuf();
	this.cache = [];
	this.useCache = haxe_Serializer.USE_CACHE;
	this.useEnumIndex = haxe_Serializer.USE_ENUM_INDEX;
	this.shash = new haxe_ds_StringMap();
	this.scount = 0;
};
haxe_Serializer.__name__ = "haxe.Serializer";
haxe_Serializer.prototype = {
	serializeString: function(s) {
		var x = this.shash.h[s];
		if(x != null) {
			this.buf.b += "R";
			this.buf.b += x == null ? "null" : "" + x;
			return;
		}
		this.shash.h[s] = this.scount++;
		this.buf.b += "y";
		s = encodeURIComponent(s);
		this.buf.b += Std.string(s.length);
		this.buf.b += ":";
		this.buf.b += s == null ? "null" : "" + s;
	}
	,serializeRef: function(v) {
		var vt = typeof(v);
		var _g = 0;
		var _g1 = this.cache.length;
		while(_g < _g1) {
			var i = _g++;
			var ci = this.cache[i];
			if(typeof(ci) == vt && ci == v) {
				this.buf.b += "r";
				this.buf.b += i == null ? "null" : "" + i;
				return true;
			}
		}
		this.cache.push(v);
		return false;
	}
	,serializeFields: function(v) {
		var _g = 0;
		var _g1 = Reflect.fields(v);
		while(_g < _g1.length) {
			var f = _g1[_g];
			++_g;
			this.serializeString(f);
			this.serialize(Reflect.field(v,f));
		}
		this.buf.b += "g";
	}
	,serialize: function(v) {
		var _g = Type.typeof(v);
		switch(_g._hx_index) {
		case 0:
			this.buf.b += "n";
			break;
		case 1:
			var v1 = v;
			if(v1 == 0) {
				this.buf.b += "z";
				return;
			}
			this.buf.b += "i";
			this.buf.b += v1 == null ? "null" : "" + v1;
			break;
		case 2:
			var v1 = v;
			if(isNaN(v1)) {
				this.buf.b += "k";
			} else if(!isFinite(v1)) {
				this.buf.b += v1 < 0 ? "m" : "p";
			} else {
				this.buf.b += "d";
				this.buf.b += v1 == null ? "null" : "" + v1;
			}
			break;
		case 3:
			this.buf.b += v ? "t" : "f";
			break;
		case 4:
			if(js_Boot.__instanceof(v,Class)) {
				var className = v.__name__;
				this.buf.b += "A";
				this.serializeString(className);
			} else if(js_Boot.__instanceof(v,Enum)) {
				this.buf.b += "B";
				this.serializeString(v.__ename__);
			} else {
				if(this.useCache && this.serializeRef(v)) {
					return;
				}
				this.buf.b += "o";
				this.serializeFields(v);
			}
			break;
		case 5:
			throw haxe_Exception.thrown("Cannot serialize function");
		case 6:
			var c = _g.c;
			if(c == String) {
				this.serializeString(v);
				return;
			}
			if(this.useCache && this.serializeRef(v)) {
				return;
			}
			switch(c) {
			case Array:
				var ucount = 0;
				this.buf.b += "a";
				var l = v["length"];
				var _g1 = 0;
				var _g2 = l;
				while(_g1 < _g2) {
					var i = _g1++;
					if(v[i] == null) {
						++ucount;
					} else {
						if(ucount > 0) {
							if(ucount == 1) {
								this.buf.b += "n";
							} else {
								this.buf.b += "u";
								this.buf.b += ucount == null ? "null" : "" + ucount;
							}
							ucount = 0;
						}
						this.serialize(v[i]);
					}
				}
				if(ucount > 0) {
					if(ucount == 1) {
						this.buf.b += "n";
					} else {
						this.buf.b += "u";
						this.buf.b += ucount == null ? "null" : "" + ucount;
					}
				}
				this.buf.b += "h";
				break;
			case Date:
				var d = v;
				this.buf.b += "v";
				this.buf.b += Std.string(d.getTime());
				break;
			case haxe_ds_IntMap:
				this.buf.b += "q";
				var v1 = v;
				var k = v1.keys();
				while(k.hasNext()) {
					var k1 = k.next();
					this.buf.b += ":";
					this.buf.b += k1 == null ? "null" : "" + k1;
					this.serialize(v1.h[k1]);
				}
				this.buf.b += "h";
				break;
			case haxe_ds_List:
				this.buf.b += "l";
				var v1 = v;
				var _g_head = v1.h;
				while(_g_head != null) {
					var val = _g_head.item;
					_g_head = _g_head.next;
					var i = val;
					this.serialize(i);
				}
				this.buf.b += "h";
				break;
			case haxe_ds_ObjectMap:
				this.buf.b += "M";
				var v1 = v;
				var k = v1.keys();
				while(k.hasNext()) {
					var k1 = k.next();
					var id = Reflect.field(k1,"__id__");
					Reflect.deleteField(k1,"__id__");
					this.serialize(k1);
					k1["__id__"] = id;
					this.serialize(v1.h[k1.__id__]);
				}
				this.buf.b += "h";
				break;
			case haxe_ds_StringMap:
				this.buf.b += "b";
				var v1 = v;
				var h = v1.h;
				var _g_h = h;
				var _g_keys = Object.keys(h);
				var _g_length = _g_keys.length;
				var _g_current = 0;
				while(_g_current < _g_length) {
					var k = _g_keys[_g_current++];
					this.serializeString(k);
					this.serialize(v1.h[k]);
				}
				this.buf.b += "h";
				break;
			case haxe_io_Bytes:
				var v1 = v;
				this.buf.b += "s";
				this.buf.b += Std.string(Math.ceil(v1.length * 8 / 6));
				this.buf.b += ":";
				var i = 0;
				var max = v1.length - 2;
				var b64 = haxe_Serializer.BASE64_CODES;
				if(b64 == null) {
					b64 = new Array(haxe_Serializer.BASE64.length);
					var _g1 = 0;
					var _g2 = haxe_Serializer.BASE64.length;
					while(_g1 < _g2) {
						var i1 = _g1++;
						b64[i1] = HxOverrides.cca(haxe_Serializer.BASE64,i1);
					}
					haxe_Serializer.BASE64_CODES = b64;
				}
				while(i < max) {
					var b1 = v1.b[i++];
					var b2 = v1.b[i++];
					var b3 = v1.b[i++];
					this.buf.b += String.fromCodePoint(b64[b1 >> 2]);
					this.buf.b += String.fromCodePoint(b64[(b1 << 4 | b2 >> 4) & 63]);
					this.buf.b += String.fromCodePoint(b64[(b2 << 2 | b3 >> 6) & 63]);
					this.buf.b += String.fromCodePoint(b64[b3 & 63]);
				}
				if(i == max) {
					var b1 = v1.b[i++];
					var b2 = v1.b[i++];
					this.buf.b += String.fromCodePoint(b64[b1 >> 2]);
					this.buf.b += String.fromCodePoint(b64[(b1 << 4 | b2 >> 4) & 63]);
					this.buf.b += String.fromCodePoint(b64[b2 << 2 & 63]);
				} else if(i == max + 1) {
					var b1 = v1.b[i++];
					this.buf.b += String.fromCodePoint(b64[b1 >> 2]);
					this.buf.b += String.fromCodePoint(b64[b1 << 4 & 63]);
				}
				break;
			default:
				if(this.useCache) {
					this.cache.pop();
				}
				if(v.hxSerialize != null) {
					this.buf.b += "C";
					this.serializeString(c.__name__);
					if(this.useCache) {
						this.cache.push(v);
					}
					v.hxSerialize(this);
					this.buf.b += "g";
				} else {
					this.buf.b += "c";
					this.serializeString(c.__name__);
					if(this.useCache) {
						this.cache.push(v);
					}
					this.serializeFields(v);
				}
			}
			break;
		case 7:
			var e = _g.e;
			if(this.useCache) {
				if(this.serializeRef(v)) {
					return;
				}
				this.cache.pop();
			}
			this.buf.b += Std.string(this.useEnumIndex ? "j" : "w");
			this.serializeString(e.__ename__);
			if(this.useEnumIndex) {
				this.buf.b += ":";
				this.buf.b += Std.string(v._hx_index);
			} else {
				var e = v;
				this.serializeString($hxEnums[e.__enum__].__constructs__[e._hx_index]._hx_name);
			}
			this.buf.b += ":";
			var params = Type.enumParameters(v);
			this.buf.b += Std.string(params.length);
			var _g = 0;
			while(_g < params.length) {
				var p = params[_g];
				++_g;
				this.serialize(p);
			}
			if(this.useCache) {
				this.cache.push(v);
			}
			break;
		default:
			throw haxe_Exception.thrown("Cannot serialize " + Std.string(v));
		}
	}
	,__class__: haxe_Serializer
};
var haxe_Timer = function(time_ms) {
	var me = this;
	this.id = setInterval(function() {
		me.run();
	},time_ms);
};
haxe_Timer.__name__ = "haxe.Timer";
haxe_Timer.delay = function(f,time_ms) {
	var t = new haxe_Timer(time_ms);
	t.run = function() {
		t.stop();
		f();
	};
	return t;
};
haxe_Timer.prototype = {
	stop: function() {
		if(this.id == null) {
			return;
		}
		clearInterval(this.id);
		this.id = null;
	}
	,run: function() {
	}
	,__class__: haxe_Timer
};
var haxe_Unserializer = function() { };
haxe_Unserializer.__name__ = "haxe.Unserializer";
var haxe_ValueException = function(value,previous,native) {
	haxe_Exception.call(this,String(value),previous,native);
	this.value = value;
	this.__skipStack++;
};
haxe_ValueException.__name__ = "haxe.ValueException";
haxe_ValueException.__super__ = haxe_Exception;
haxe_ValueException.prototype = $extend(haxe_Exception.prototype,{
	__class__: haxe_ValueException
});
var haxe_ds_IntMap = function() {
	this.h = { };
};
haxe_ds_IntMap.__name__ = "haxe.ds.IntMap";
haxe_ds_IntMap.__interfaces__ = [haxe_IMap];
haxe_ds_IntMap.prototype = {
	set: function(key,value) {
		this.h[key] = value;
	}
	,get: function(key) {
		return this.h[key];
	}
	,keys: function() {
		var a = [];
		for( var key in this.h ) if(this.h.hasOwnProperty(key)) a.push(+key);
		return new haxe_iterators_ArrayIterator(a);
	}
	,__class__: haxe_ds_IntMap
};
var haxe_ds_List = function() {
	this.length = 0;
};
haxe_ds_List.__name__ = "haxe.ds.List";
haxe_ds_List.prototype = {
	__class__: haxe_ds_List
};
var haxe_ds__$List_ListNode = function(item,next) {
	this.item = item;
	this.next = next;
};
haxe_ds__$List_ListNode.__name__ = "haxe.ds._List.ListNode";
haxe_ds__$List_ListNode.prototype = {
	__class__: haxe_ds__$List_ListNode
};
var haxe_ds_ObjectMap = function() {
	this.h = { __keys__ : { }};
};
haxe_ds_ObjectMap.__name__ = "haxe.ds.ObjectMap";
haxe_ds_ObjectMap.__interfaces__ = [haxe_IMap];
haxe_ds_ObjectMap.prototype = {
	set: function(key,value) {
		var id = key.__id__;
		if(id == null) {
			id = (key.__id__ = $global.$haxeUID++);
		}
		this.h[id] = value;
		this.h.__keys__[id] = key;
	}
	,get: function(key) {
		return this.h[key.__id__];
	}
	,remove: function(key) {
		var id = key.__id__;
		if(this.h.__keys__[id] == null) {
			return false;
		}
		delete(this.h[id]);
		delete(this.h.__keys__[id]);
		return true;
	}
	,keys: function() {
		var a = [];
		for( var key in this.h.__keys__ ) {
		if(this.h.hasOwnProperty(key)) {
			a.push(this.h.__keys__[key]);
		}
		}
		return new haxe_iterators_ArrayIterator(a);
	}
	,iterator: function() {
		return { ref : this.h, it : this.keys(), hasNext : function() {
			return this.it.hasNext();
		}, next : function() {
			var i = this.it.next();
			return this.ref[i.__id__];
		}};
	}
	,__class__: haxe_ds_ObjectMap
};
var haxe_ds_StringMap = function() {
	this.h = Object.create(null);
};
haxe_ds_StringMap.__name__ = "haxe.ds.StringMap";
haxe_ds_StringMap.__interfaces__ = [haxe_IMap];
haxe_ds_StringMap.prototype = {
	get: function(key) {
		return this.h[key];
	}
	,set: function(key,value) {
		this.h[key] = value;
	}
	,keys: function() {
		return new haxe_ds__$StringMap_StringMapKeyIterator(this.h);
	}
	,iterator: function() {
		return new haxe_ds__$StringMap_StringMapValueIterator(this.h);
	}
	,__class__: haxe_ds_StringMap
};
var haxe_ds__$StringMap_StringMapKeyIterator = function(h) {
	this.h = h;
	this.keys = Object.keys(h);
	this.length = this.keys.length;
	this.current = 0;
};
haxe_ds__$StringMap_StringMapKeyIterator.__name__ = "haxe.ds._StringMap.StringMapKeyIterator";
haxe_ds__$StringMap_StringMapKeyIterator.prototype = {
	hasNext: function() {
		return this.current < this.length;
	}
	,next: function() {
		return this.keys[this.current++];
	}
	,__class__: haxe_ds__$StringMap_StringMapKeyIterator
};
var haxe_ds__$StringMap_StringMapValueIterator = function(h) {
	this.h = h;
	this.keys = Object.keys(h);
	this.length = this.keys.length;
	this.current = 0;
};
haxe_ds__$StringMap_StringMapValueIterator.__name__ = "haxe.ds._StringMap.StringMapValueIterator";
haxe_ds__$StringMap_StringMapValueIterator.prototype = {
	hasNext: function() {
		return this.current < this.length;
	}
	,next: function() {
		return this.h[this.keys[this.current++]];
	}
	,__class__: haxe_ds__$StringMap_StringMapValueIterator
};
var haxe_io_Bytes = function(data) {
	this.length = data.byteLength;
	this.b = new Uint8Array(data);
	this.b.bufferValue = data;
	data.hxBytes = this;
	data.bytes = this.b;
};
haxe_io_Bytes.__name__ = "haxe.io.Bytes";
haxe_io_Bytes.prototype = {
	__class__: haxe_io_Bytes
};
var haxe_io_Path = function(path) {
	switch(path) {
	case ".":case "..":
		this.dir = path;
		this.file = "";
		return;
	}
	var c1 = path.lastIndexOf("/");
	var c2 = path.lastIndexOf("\\");
	if(c1 < c2) {
		this.dir = HxOverrides.substr(path,0,c2);
		path = HxOverrides.substr(path,c2 + 1,null);
		this.backslash = true;
	} else if(c2 < c1) {
		this.dir = HxOverrides.substr(path,0,c1);
		path = HxOverrides.substr(path,c1 + 1,null);
	} else {
		this.dir = null;
	}
	var cp = path.lastIndexOf(".");
	if(cp != -1) {
		this.ext = HxOverrides.substr(path,cp + 1,null);
		this.file = HxOverrides.substr(path,0,cp);
	} else {
		this.ext = null;
		this.file = path;
	}
};
haxe_io_Path.__name__ = "haxe.io.Path";
haxe_io_Path.withoutDirectory = function(path) {
	var s = new haxe_io_Path(path);
	s.dir = null;
	return s.toString();
};
haxe_io_Path.prototype = {
	toString: function() {
		return (this.dir == null ? "" : this.dir + (this.backslash ? "\\" : "/")) + this.file + (this.ext == null ? "" : "." + this.ext);
	}
	,__class__: haxe_io_Path
};
var haxe_iterators_ArrayIterator = function(array) {
	this.current = 0;
	this.array = array;
};
haxe_iterators_ArrayIterator.__name__ = "haxe.iterators.ArrayIterator";
haxe_iterators_ArrayIterator.prototype = {
	hasNext: function() {
		return this.current < this.array.length;
	}
	,next: function() {
		return this.array[this.current++];
	}
	,__class__: haxe_iterators_ArrayIterator
};
var haxe_iterators_StringIterator = function(s) {
	this.offset = 0;
	this.s = s;
};
haxe_iterators_StringIterator.__name__ = "haxe.iterators.StringIterator";
haxe_iterators_StringIterator.prototype = {
	hasNext: function() {
		return this.offset < this.s.length;
	}
	,next: function() {
		return this.s.charCodeAt(this.offset++);
	}
	,__class__: haxe_iterators_StringIterator
};
var haxe_iterators_StringKeyValueIterator = function(s) {
	this.s = s;
};
haxe_iterators_StringKeyValueIterator.__name__ = "haxe.iterators.StringKeyValueIterator";
haxe_iterators_StringKeyValueIterator.prototype = {
	__class__: haxe_iterators_StringKeyValueIterator
};
var htmlparser_CssSelector = function(type) {
	this.classes = [];
	this.type = type;
};
htmlparser_CssSelector.__name__ = "htmlparser.CssSelector";
htmlparser_CssSelector.parse = function(selector) {
	var r = [];
	var selectors = new EReg("\\s*,\\s*","g").split(selector);
	var _g = 0;
	while(_g < selectors.length) {
		var s = selectors[_g];
		++_g;
		if(s != "") {
			r.push(htmlparser_CssSelector.parseInner(s));
		}
	}
	return r;
};
htmlparser_CssSelector.parseInner = function(selector) {
	var rr = [];
	selector = " " + selector;
	var r = null;
	var re = new EReg(htmlparser_CssSelector.reSelector,"gi");
	var pos = 0;
	while(re.matchSub(selector,pos)) {
		var type1;
		try {
			type1 = re.matched(1);
		} catch( _g ) {
			type1 = null;
		}
		if(type1 == null) {
			type1 = "";
		}
		var type2;
		try {
			type2 = re.matched(2);
		} catch( _g1 ) {
			type2 = null;
		}
		if(type2 == null) {
			type2 = "";
		}
		if(type1.length > 0 || type2.length > 0) {
			if(r != null) {
				rr.push(r);
			}
			r = new htmlparser_CssSelector(type2.length > 0 ? ">" : " ");
		}
		var name = re.matched(4);
		if(name != "*") {
			var s = re.matched(3);
			if(s == "#") {
				r.id = name;
			} else if(s == ".") {
				r.classes.push(name);
			} else {
				r.tagNameLC = name.toLowerCase();
			}
			var sIndex;
			try {
				sIndex = re.matched(5);
			} catch( _g2 ) {
				sIndex = null;
			}
			if(sIndex != null && sIndex != "") {
				r.index = Std.parseInt(sIndex.substring(1,sIndex.length - 1));
				var f = r.index;
				if(isNaN(f)) {
					r.index = null;
				}
			}
		}
		var p = re.matchedPos();
		pos = p.pos + p.len;
	}
	if(r != null) {
		rr.push(r);
	}
	return rr;
};
htmlparser_CssSelector.getMatched = function(re,n) {
	try {
		return re.matched(n);
	} catch( _g ) {
		return null;
	}
};
htmlparser_CssSelector.prototype = {
	__class__: htmlparser_CssSelector
};
var htmlparser_HtmlAttribute = function(name,value,quote) {
	this.name = name;
	this.value = value;
	this.quote = quote;
};
htmlparser_HtmlAttribute.__name__ = "htmlparser.HtmlAttribute";
htmlparser_HtmlAttribute.prototype = {
	toString: function() {
		if(this.value != null && this.quote != null) {
			return this.name + "=" + this.quote + htmlparser_HtmlTools.escape(this.value,"\r\n" + (this.quote == "'" ? "\"" : "'")) + this.quote;
		} else {
			return this.name;
		}
	}
	,__class__: htmlparser_HtmlAttribute
};
var htmlparser_HtmlNode = function() { };
htmlparser_HtmlNode.__name__ = "htmlparser.HtmlNode";
htmlparser_HtmlNode.prototype = {
	remove: function() {
		if(this.parent != null) {
			this.parent.removeChild(this);
		}
	}
	,getPrevSiblingNode: function() {
		if(this.parent == null) {
			return null;
		}
		var siblings = this.parent.nodes;
		var n = Lambda.indexOf(siblings,this);
		if(n <= 0) {
			return null;
		}
		if(n > 0) {
			return siblings[n - 1];
		}
		return null;
	}
	,getNextSiblingNode: function() {
		if(this.parent == null) {
			return null;
		}
		var siblings = this.parent.nodes;
		var n = Lambda.indexOf(siblings,this);
		if(n < 0) {
			return null;
		}
		if(n + 1 < siblings.length) {
			return siblings[n + 1];
		}
		return null;
	}
	,toString: function() {
		return "";
	}
	,toText: function() {
		return "";
	}
	,hxSerialize: function(s) {
	}
	,hxUnserialize: function(s) {
	}
	,__class__: htmlparser_HtmlNode
};
var htmlparser_HtmlNodeElement = function(name,attributes) {
	var _gthis = this;
	Object.defineProperty(this,"innerHTML",{ get : function() {
		return _gthis.get_innerHTML();
	}, set : function(v) {
		_gthis.set_innerHTML(v);
	}});
	Object.defineProperty(this,"innerText",{ get : function() {
		return _gthis.get_innerText();
	}, set : function(v) {
		_gthis.set_innerText(v);
	}});
	this.name = name;
	this.attributes = attributes;
	this.nodes = [];
	this.children = [];
};
htmlparser_HtmlNodeElement.__name__ = "htmlparser.HtmlNodeElement";
htmlparser_HtmlNodeElement.__super__ = htmlparser_HtmlNode;
htmlparser_HtmlNodeElement.prototype = $extend(htmlparser_HtmlNode.prototype,{
	getPrevSiblingElement: function() {
		if(this.parent == null) {
			return null;
		}
		var n = this.parent.children.indexOf(this);
		if(n < 0) {
			return null;
		}
		if(n > 0) {
			return this.parent.children[n - 1];
		}
		return null;
	}
	,getNextSiblingElement: function() {
		if(this.parent == null) {
			return null;
		}
		var n = this.parent.children.indexOf(this);
		if(n < 0) {
			return null;
		}
		if(n + 1 < this.parent.children.length) {
			return this.parent.children[n + 1];
		}
		return null;
	}
	,addChild: function(node,beforeNode) {
		if(beforeNode == null) {
			this.nodes.push(node);
			node.parent = this;
			if(((node) instanceof htmlparser_HtmlNodeElement)) {
				this.children.push(node);
			}
		} else {
			var n = this.nodes.indexOf(beforeNode);
			if(n < 0) {
				throw new haxe_Exception("`beforeNode` is not found.");
			}
			this.nodes.splice(n,0,node);
			node.parent = this;
			var _g = [];
			var _g1 = 0;
			var _g2 = this.nodes;
			while(_g1 < _g2.length) {
				var v = _g2[_g1];
				++_g1;
				if(((v) instanceof htmlparser_HtmlNodeElement)) {
					_g.push(v);
				}
			}
			this.children = _g;
		}
	}
	,addChildren: function(nodesToAdd,beforeNode) {
		var n = beforeNode != null ? this.nodes.indexOf(beforeNode) : 0;
		if(n < 0) {
			throw new haxe_Exception("`beforeNode` is not found.");
		}
		this.nodes = (n > 0 ? this.nodes.slice(0,n) : []).concat(nodesToAdd).concat(this.nodes.slice(n));
		var _g = 0;
		while(_g < nodesToAdd.length) {
			var node = nodesToAdd[_g];
			++_g;
			node.parent = this;
		}
		var _g = [];
		var _g1 = 0;
		var _g2 = this.nodes;
		while(_g1 < _g2.length) {
			var v = _g2[_g1];
			++_g1;
			if(((v) instanceof htmlparser_HtmlNodeElement)) {
				_g.push(v);
			}
		}
		this.children = _g;
	}
	,toString: function() {
		var sAttrs_b = "";
		var _g = 0;
		var _g1 = this.attributes;
		while(_g < _g1.length) {
			var a = _g1[_g];
			++_g;
			sAttrs_b += " ";
			sAttrs_b += Std.string(a.toString());
		}
		var innerBuf_b = "";
		var _g = 0;
		var _g1 = this.nodes;
		while(_g < _g1.length) {
			var node = _g1[_g];
			++_g;
			innerBuf_b += Std.string(node.toString());
		}
		var inner = innerBuf_b;
		if(inner == "" && this.isSelfClosing()) {
			return "<" + this.name + sAttrs_b + " />";
		}
		if(this.name != null && this.name != "") {
			return "<" + this.name + sAttrs_b + ">" + inner + "</" + this.name + ">";
		} else {
			return inner;
		}
	}
	,getAttribute: function(name) {
		var nameLC = name.toLowerCase();
		var _g = 0;
		var _g1 = this.attributes;
		while(_g < _g1.length) {
			var a = _g1[_g];
			++_g;
			if(a.name.toLowerCase() == nameLC) {
				return a.value;
			}
		}
		return null;
	}
	,setAttribute: function(name,value) {
		var nameLC = name.toLowerCase();
		var _g = 0;
		var _g1 = this.attributes;
		while(_g < _g1.length) {
			var a = _g1[_g];
			++_g;
			if(a.name.toLowerCase() == nameLC) {
				a.value = value;
				return;
			}
		}
		this.attributes.push(new htmlparser_HtmlAttribute(name,value,"\""));
	}
	,removeAttribute: function(name) {
		var nameLC = name.toLowerCase();
		var _g = 0;
		var _g1 = this.attributes.length;
		while(_g < _g1) {
			var i = _g++;
			var a = this.attributes[i];
			if(a.name.toLowerCase() == nameLC) {
				this.attributes.splice(i,1);
				return;
			}
		}
	}
	,hasAttribute: function(name) {
		var nameLC = name.toLowerCase();
		var _g = 0;
		var _g1 = this.attributes;
		while(_g < _g1.length) {
			var a = _g1[_g];
			++_g;
			if(a.name.toLowerCase() == nameLC) {
				return true;
			}
		}
		return false;
	}
	,get_innerHTML: function() {
		var r_b = "";
		var _g = 0;
		var _g1 = this.nodes;
		while(_g < _g1.length) {
			var node = _g1[_g];
			++_g;
			r_b += Std.string(node.toString());
		}
		return r_b;
	}
	,set_innerHTML: function(value) {
		var newNodes = htmlparser_HtmlParser.run(value);
		this.nodes = [];
		this.children = [];
		var _g = 0;
		while(_g < newNodes.length) {
			var node = newNodes[_g];
			++_g;
			this.addChild(node);
		}
		return value;
	}
	,get_innerText: function() {
		return this.toText();
	}
	,set_innerText: function(text) {
		this.fastSetInnerHTML(htmlparser_HtmlTools.escape(text));
		return text;
	}
	,fastSetInnerHTML: function(html) {
		this.nodes = [];
		this.children = [];
		this.addChild(new htmlparser_HtmlNodeText(html));
	}
	,toText: function() {
		var r_b = "";
		var _g = 0;
		var _g1 = this.nodes;
		while(_g < _g1.length) {
			var node = _g1[_g];
			++_g;
			r_b += Std.string(node.toText());
		}
		return r_b;
	}
	,find: function(selector) {
		var parsedSelectors = htmlparser_CssSelector.parse(selector);
		var resNodes = [];
		var _g = 0;
		while(_g < parsedSelectors.length) {
			var s = parsedSelectors[_g];
			++_g;
			var _g1 = 0;
			var _g2 = this.children;
			while(_g1 < _g2.length) {
				var node = _g2[_g1];
				++_g1;
				var nodesToAdd = node.findInner(s);
				var _g3 = 0;
				while(_g3 < nodesToAdd.length) {
					var nodeToAdd = nodesToAdd[_g3];
					++_g3;
					if(resNodes.indexOf(nodeToAdd) < 0) {
						resNodes.push(nodeToAdd);
					}
				}
			}
		}
		return resNodes;
	}
	,findInner: function(selectors) {
		if(selectors.length == 0) {
			return [];
		}
		var nodes = [];
		if(selectors[0].type == " ") {
			var _g = 0;
			var _g1 = this.children;
			while(_g < _g1.length) {
				var child = _g1[_g];
				++_g;
				nodes = nodes.concat(child.findInner(selectors));
			}
		}
		if(this.isSelectorTrue(selectors[0])) {
			if(selectors.length > 1) {
				var subSelectors = selectors.slice(1);
				var _g = 0;
				var _g1 = this.children;
				while(_g < _g1.length) {
					var child = _g1[_g];
					++_g;
					nodes = nodes.concat(child.findInner(subSelectors));
				}
			} else if(selectors.length == 1) {
				if(this.parent != null) {
					nodes.push(this);
				}
			}
		}
		return nodes;
	}
	,isSelectorTrue: function(selector) {
		if(selector.tagNameLC != null && this.name.toLowerCase() != selector.tagNameLC) {
			return false;
		}
		if(selector.id != null && this.getAttribute("id") != selector.id) {
			return false;
		}
		var _g = 0;
		var _g1 = selector.classes;
		while(_g < _g1.length) {
			var clas = _g1[_g];
			++_g;
			var reg = new EReg("(?:^|\\s)" + clas + "(?:$|\\s)","");
			var classAttr = this.getAttribute("class");
			if(classAttr == null || !reg.match(classAttr)) {
				return false;
			}
		}
		if(selector.index != null && (this.parent == null || this.parent.children.indexOf(this) + 1 != selector.index)) {
			return false;
		}
		return true;
	}
	,replaceChild: function(node,newNode) {
		if(((newNode) instanceof Array)) {
			this.replaceChildByMany(node,newNode);
		} else {
			this.replaceChildByOne(node,newNode);
		}
	}
	,replaceChildByOne: function(node,newNode) {
		var n = this.nodes.indexOf(node);
		if(n < 0) {
			throw new haxe_Exception("Node to replace is not found.");
		}
		this.nodes[n].parent = null;
		this.nodes[n] = newNode;
		newNode.parent = this;
		var _g = [];
		var _g1 = 0;
		var _g2 = this.nodes;
		while(_g1 < _g2.length) {
			var v = _g2[_g1];
			++_g1;
			if(((v) instanceof htmlparser_HtmlNodeElement)) {
				_g.push(v);
			}
		}
		this.children = _g;
	}
	,replaceChildByMany: function(node,newNodes) {
		var n = this.nodes.indexOf(node);
		if(n < 0) {
			throw new haxe_Exception("Node to replace is not found.");
		}
		this.nodes[n].parent = null;
		var lastNodes = this.nodes.slice(n + 1,this.nodes.length);
		this.nodes = (n > 0 ? this.nodes.slice(0,n) : []).concat(newNodes).concat(lastNodes);
		var _g = 0;
		while(_g < newNodes.length) {
			var n = newNodes[_g];
			++_g;
			n.parent = this;
		}
		var _g = [];
		var _g1 = 0;
		var _g2 = this.nodes;
		while(_g1 < _g2.length) {
			var v = _g2[_g1];
			++_g1;
			if(((v) instanceof htmlparser_HtmlNodeElement)) {
				_g.push(v);
			}
		}
		this.children = _g;
	}
	,removeChild: function(node) {
		var n = this.nodes.indexOf(node);
		if(n < 0) {
			throw new haxe_Exception("Node to remove is not found.");
		}
		this.nodes.splice(n,1);
		node.parent = null;
		if(((node) instanceof htmlparser_HtmlNodeElement)) {
			n = this.children.indexOf(node);
			if(n >= 0) {
				this.children.splice(n,1);
			}
		}
	}
	,getAttributesAssoc: function() {
		var attrs = new haxe_ds_StringMap();
		var _g = 0;
		var _g1 = this.attributes;
		while(_g < _g1.length) {
			var attr = _g1[_g];
			++_g;
			attrs.h[attr.name] = attr.value;
		}
		return attrs;
	}
	,getAttributesObject: function() {
		var attrs = { };
		var _g = 0;
		var _g1 = this.attributes;
		while(_g < _g1.length) {
			var attr = _g1[_g];
			++_g;
			attrs[attr.name] = attr.value;
		}
		return attrs;
	}
	,isSelfClosing: function() {
		if(!Object.prototype.hasOwnProperty.call(htmlparser_HtmlParser.SELF_CLOSING_TAGS_HTML,this.name)) {
			return this.name.indexOf(":") >= 0;
		} else {
			return true;
		}
	}
	,hxSerialize: function(s) {
		s.serialize(this.name);
		s.serialize(this.attributes);
		s.serialize(this.nodes);
	}
	,hxUnserialize: function(s) {
		var _gthis = this;
		Object.defineProperty(this,"innerHTML",{ get : function() {
			return _gthis.get_innerHTML();
		}, set : function(v) {
			_gthis.set_innerHTML(v);
		}});
		Object.defineProperty(this,"innerText",{ get : function() {
			return _gthis.get_innerText();
		}, set : function(v) {
			_gthis.set_innerText(v);
		}});
		this.name = s.unserialize();
		this.attributes = s.unserialize();
		this.nodes = [];
		this.children = [];
		var ns = s.unserialize();
		var _g = 0;
		while(_g < ns.length) {
			var n = ns[_g];
			++_g;
			this.addChild(n);
		}
	}
	,__class__: htmlparser_HtmlNodeElement
});
var htmlparser_HtmlNodeText = function(text) {
	this.text = text;
};
htmlparser_HtmlNodeText.__name__ = "htmlparser.HtmlNodeText";
htmlparser_HtmlNodeText.__super__ = htmlparser_HtmlNode;
htmlparser_HtmlNodeText.prototype = $extend(htmlparser_HtmlNode.prototype,{
	toString: function() {
		return this.text;
	}
	,toText: function() {
		return htmlparser_HtmlTools.unescape(this.text);
	}
	,hxSerialize: function(s) {
		s.serialize(this.text);
	}
	,hxUnserialize: function(s) {
		this.text = s.unserialize();
	}
	,__class__: htmlparser_HtmlNodeText
});
var htmlparser_HtmlParser = function() {
};
htmlparser_HtmlParser.__name__ = "htmlparser.HtmlParser";
htmlparser_HtmlParser.run = function(str,tolerant) {
	if(tolerant == null) {
		tolerant = false;
	}
	return new htmlparser_HtmlParser().parse(str,tolerant);
};
htmlparser_HtmlParser.parseAttrs = function(str) {
	var attributes = [];
	var pos = 0;
	while(pos < str.length && htmlparser_HtmlParser.reParseAttrs.matchSub(str,pos)) {
		var name = htmlparser_HtmlParser.reParseAttrs.matched(1);
		var value = htmlparser_HtmlParser.reParseAttrs.matched(2);
		var quote = null;
		var unescaped = null;
		if(value != null) {
			quote = HxOverrides.substr(value,0,1);
			if(quote == "\"" || quote == "'") {
				value = HxOverrides.substr(value,1,value.length - 2);
			} else {
				quote = "";
			}
			unescaped = htmlparser_HtmlTools.unescape(value);
		}
		attributes.push(new htmlparser_HtmlAttribute(name,unescaped,quote));
		var p = htmlparser_HtmlParser.reParseAttrs.matchedPos();
		pos = p.pos + p.len;
	}
	return attributes;
};
htmlparser_HtmlParser.getMatched = function(re,n) {
	try {
		return re.matched(n);
	} catch( _g ) {
		return null;
	}
};
htmlparser_HtmlParser.prototype = {
	parse: function(str,tolerant) {
		if(tolerant == null) {
			tolerant = false;
		}
		this.tolerant = tolerant;
		this.matches = [];
		var pos = 0;
		while(pos < str.length && htmlparser_HtmlParser.reMain.matchSub(str,pos)) {
			var p = htmlparser_HtmlParser.reMain.matchedPos();
			var re = htmlparser_HtmlParser.reMain;
			var cdata;
			try {
				cdata = re.matched(1);
			} catch( _g ) {
				cdata = null;
			}
			if(cdata == null || cdata == "") {
				var r = htmlparser_HtmlParser.reMain.matched(0);
				var p1 = p.pos;
				var re1 = htmlparser_HtmlParser.reMain;
				var r1;
				try {
					r1 = re1.matched(2);
				} catch( _g1 ) {
					r1 = null;
				}
				var re2 = htmlparser_HtmlParser.reMain;
				var r2;
				try {
					r2 = re2.matched(3);
				} catch( _g2 ) {
					r2 = null;
				}
				var re3 = htmlparser_HtmlParser.reMain;
				var r3;
				try {
					r3 = re3.matched(4);
				} catch( _g3 ) {
					r3 = null;
				}
				var re4 = htmlparser_HtmlParser.reMain;
				var r4;
				try {
					r4 = re4.matched(5);
				} catch( _g4 ) {
					r4 = null;
				}
				var re5 = htmlparser_HtmlParser.reMain;
				var r5;
				try {
					r5 = re5.matched(6);
				} catch( _g5 ) {
					r5 = null;
				}
				var re6 = htmlparser_HtmlParser.reMain;
				var r6;
				try {
					r6 = re6.matched(7);
				} catch( _g6 ) {
					r6 = null;
				}
				var re7 = htmlparser_HtmlParser.reMain;
				var r7;
				try {
					r7 = re7.matched(8);
				} catch( _g7 ) {
					r7 = null;
				}
				var re8 = htmlparser_HtmlParser.reMain;
				var r8;
				try {
					r8 = re8.matched(9);
				} catch( _g8 ) {
					r8 = null;
				}
				var re9 = htmlparser_HtmlParser.reMain;
				var r9;
				try {
					r9 = re9.matched(10);
				} catch( _g9 ) {
					r9 = null;
				}
				var re10 = htmlparser_HtmlParser.reMain;
				var r10;
				try {
					r10 = re10.matched(11);
				} catch( _g10 ) {
					r10 = null;
				}
				var re11 = htmlparser_HtmlParser.reMain;
				var r11;
				try {
					r11 = re11.matched(12);
				} catch( _g11 ) {
					r11 = null;
				}
				var re12 = htmlparser_HtmlParser.reMain;
				var r12;
				try {
					r12 = re12.matched(13);
				} catch( _g12 ) {
					r12 = null;
				}
				var re13 = htmlparser_HtmlParser.reMain;
				var r13;
				try {
					r13 = re13.matched(14);
				} catch( _g13 ) {
					r13 = null;
				}
				var r14 = { all : r, allPos : p1, script : r1, scriptAttrs : r2, scriptText : r3, style : r4, styleAttrs : r5, styleText : r6, elem : r7, tagOpen : r8, attrs : r9, tagEnd : r10, close : r11, tagClose : r12, comment : r13, tagOpenLC : null, tagCloseLC : null};
				if(r14.tagOpen != null) {
					r14.tagOpenLC = r14.tagOpen.toLowerCase();
				}
				if(r14.tagClose != null) {
					r14.tagCloseLC = r14.tagClose.toLowerCase();
				}
				this.matches.push(r14);
			}
			pos = p.pos + p.len;
		}
		if(this.matches.length > 0) {
			this.str = str;
			this.i = 0;
			var nodes = this.processMatches([]).nodes;
			if(this.i < this.matches.length) {
				throw haxe_Exception.thrown(new htmlparser_HtmlParserException("Not all nodes processed.",this.getPosition(this.i)));
			}
			return nodes;
		}
		if(str.length > 0) {
			return [new htmlparser_HtmlNodeText(str)];
		} else {
			return [];
		}
	}
	,processMatches: function(openedTagsLC) {
		var nodes = [];
		var prevEnd = this.i > 0 ? this.matches[this.i - 1].allPos + this.matches[this.i - 1].all.length : 0;
		var curStart = this.matches[this.i].allPos;
		if(prevEnd < curStart) {
			nodes.push(new htmlparser_HtmlNodeText(HxOverrides.substr(this.str,prevEnd,curStart - prevEnd)));
		}
		while(this.i < this.matches.length) {
			var m = this.matches[this.i];
			if(m.elem != null && m.elem != "") {
				var ee = this.parseElement(openedTagsLC);
				nodes.push(ee.element);
				if(ee.closeTagLC != "") {
					return { nodes : nodes, closeTagLC : ee.closeTagLC};
				}
			} else if(m.script != null && m.script != "") {
				var scriptNode = this.newElement("script",htmlparser_HtmlParser.parseAttrs(m.scriptAttrs));
				scriptNode.addChild(new htmlparser_HtmlNodeText(m.scriptText));
				nodes.push(scriptNode);
			} else if(m.style != null && m.style != "") {
				var styleNode = this.newElement("style",htmlparser_HtmlParser.parseAttrs(m.styleAttrs));
				styleNode.addChild(new htmlparser_HtmlNodeText(m.styleText));
				nodes.push(styleNode);
			} else if(m.close != null && m.close != "") {
				if(m.tagCloseLC == openedTagsLC[openedTagsLC.length - 1]) {
					break;
				}
				if(this.tolerant) {
					if(openedTagsLC.lastIndexOf(m.tagCloseLC) >= 0) {
						break;
					}
				} else {
					throw haxe_Exception.thrown(new htmlparser_HtmlParserException("Closed tag <" + m.tagClose + "> don't match to open tag <" + openedTagsLC[openedTagsLC.length - 1] + ">.",this.getPosition(this.i)));
				}
			} else if(m.comment != null && m.comment != "") {
				nodes.push(new htmlparser_HtmlNodeText(m.comment));
			} else {
				throw haxe_Exception.thrown(new htmlparser_HtmlParserException("Unexpected XML node.",this.getPosition(this.i)));
			}
			if(this.tolerant && this.i >= this.matches.length) {
				break;
			}
			var curEnd = this.matches[this.i].allPos + this.matches[this.i].all.length;
			var nextStart = this.i + 1 < this.matches.length ? this.matches[this.i + 1].allPos : this.str.length;
			if(curEnd < nextStart) {
				nodes.push(new htmlparser_HtmlNodeText(HxOverrides.substr(this.str,curEnd,nextStart - curEnd)));
			}
			this.i++;
		}
		return { nodes : nodes, closeTagLC : ""};
	}
	,parseElement: function(openedTagsLC) {
		var tag = this.matches[this.i].tagOpen;
		var tagLC = this.matches[this.i].tagOpenLC;
		var attrs = this.matches[this.i].attrs;
		var isWithClose = this.matches[this.i].tagEnd != null && this.matches[this.i].tagEnd != "" || this.isSelfClosingTag(tagLC);
		var elem = this.newElement(tag,htmlparser_HtmlParser.parseAttrs(attrs));
		var closeTagLC = "";
		if(!isWithClose) {
			this.i++;
			openedTagsLC.push(tagLC);
			var m = this.processMatches(openedTagsLC);
			var _g = 0;
			var _g1 = m.nodes;
			while(_g < _g1.length) {
				var node = _g1[_g];
				++_g;
				elem.addChild(node);
			}
			openedTagsLC.pop();
			closeTagLC = m.closeTagLC != tagLC ? m.closeTagLC : "";
			if(this.i < this.matches.length || !this.tolerant) {
				if(this.matches[this.i].close == null || this.matches[this.i].close == "" || this.matches[this.i].tagCloseLC != tagLC) {
					if(!this.tolerant) {
						throw haxe_Exception.thrown(new htmlparser_HtmlParserException("Tag <" + tag + "> not closed.",this.getPosition(this.i)));
					} else {
						closeTagLC = this.matches[this.i].tagCloseLC;
					}
				}
			}
		}
		return { element : elem, closeTagLC : closeTagLC};
	}
	,isSelfClosingTag: function(tag) {
		return Object.prototype.hasOwnProperty.call(htmlparser_HtmlParser.SELF_CLOSING_TAGS_HTML,tag);
	}
	,newElement: function(name,attributes) {
		return new htmlparser_HtmlNodeElement(name,attributes);
	}
	,getPosition: function(matchIndex) {
		var m = this.matches[matchIndex];
		var line = 1;
		var lastNewLinePos = -1;
		var i = 0;
		while(i < m.allPos) {
			var chars = i + 1 < this.str.length ? this.str.substring(i,i + 2) : this.str.charAt(i);
			if(chars == "\r\n") {
				i += 2;
				lastNewLinePos = i;
				++line;
			} else if(chars.charAt(0) == "\n" || chars.charAt(0) == "\r") {
				++i;
				lastNewLinePos = i;
				++line;
			} else {
				++i;
			}
		}
		return { line : line, column : m.allPos - lastNewLinePos, length : m.all.length};
	}
	,__class__: htmlparser_HtmlParser
};
var htmlparser_HtmlParserException = function(message,pos) {
	this.message = message;
	this.line = pos.line;
	this.column = pos.column;
	this.length = pos.length;
};
htmlparser_HtmlParserException.__name__ = "htmlparser.HtmlParserException";
htmlparser_HtmlParserException.prototype = {
	toString: function() {
		return "Parse error at " + this.line + ":" + this.column + ". " + this.message;
	}
	,__class__: htmlparser_HtmlParserException
};
var htmlparser_HtmlParserTools = function() { };
htmlparser_HtmlParserTools.__name__ = "htmlparser.HtmlParserTools";
htmlparser_HtmlParserTools.getAttr = function(node,attrName,defaultValue) {
	if(node == null || !node.hasAttribute(attrName)) {
		if(((defaultValue) instanceof Array)) {
			return null;
		} else {
			return defaultValue;
		}
	}
	return htmlparser_HtmlParserTools.parseValue(node.getAttribute(attrName),defaultValue);
};
htmlparser_HtmlParserTools.getAttrString = function(node,attrName,defaultValue) {
	var r = node.getAttribute(attrName);
	if(r == null) {
		return defaultValue;
	} else {
		return r;
	}
};
htmlparser_HtmlParserTools.getAttrInt = function(node,attrName,defaultValue) {
	var r = Std.parseInt(node.getAttribute(attrName));
	if(r == null || isNaN(r)) {
		return defaultValue;
	} else {
		return r;
	}
};
htmlparser_HtmlParserTools.getAttrFloat = function(node,attrName,defaultValue) {
	var r = parseFloat(node.getAttribute(attrName));
	if(r == null || isNaN(r)) {
		return defaultValue;
	} else {
		return r;
	}
};
htmlparser_HtmlParserTools.getAttrBool = function(node,attrName,defaultValue) {
	var r = node.getAttribute(attrName);
	if(r == null || r == "") {
		return defaultValue;
	} else if(r != "0" && r.toLowerCase() != "false") {
		return r.toLowerCase() != "no";
	} else {
		return false;
	}
};
htmlparser_HtmlParserTools.findOne = function(node,selector) {
	var nodes = node.find(selector);
	if(nodes.length > 0) {
		return nodes[0];
	} else {
		return null;
	}
};
htmlparser_HtmlParserTools.parseValue = function(value,defaultValue) {
	if(typeof(defaultValue) == "number") {
		return parseFloat(value);
	}
	if(typeof(defaultValue) == "boolean") {
		if(value != null && value != "" && value != "0") {
			return ["false","no"].indexOf(value.toLowerCase()) < 0;
		} else {
			return false;
		}
	}
	if(((defaultValue) instanceof Array)) {
		var elems = [];
		var parCounter = 0;
		var lastCommaIndex = -1;
		var _g = 0;
		var _g1 = value.length;
		while(_g < _g1) {
			var i = _g++;
			var c = value.charAt(i);
			if(c == "(" || c == "[" || c == "{") {
				++parCounter;
			} else if(c == ")" || c == "]" || c == "}") {
				--parCounter;
			} else if(c == "," && parCounter == 0) {
				elems.push(value.substring(lastCommaIndex + 1,i));
				lastCommaIndex = i;
			}
		}
		elems.push(value.substring(lastCommaIndex + 1,value.length));
		if(defaultValue.length > 0) {
			var result = new Array(elems.length);
			var _g = 0;
			var _g1 = elems.length;
			while(_g < _g1) {
				var i = _g++;
				result[i] = htmlparser_HtmlParserTools.parseValue(elems[i],defaultValue[0]);
			}
			return result;
		} else {
			return elems;
		}
	}
	return value;
};
var htmlparser_HtmlTools = function() { };
htmlparser_HtmlTools.__name__ = "htmlparser.HtmlTools";
htmlparser_HtmlTools.get_htmlUnescapeMap = function() {
	if(htmlparser_HtmlTools.htmlUnescapeMap == null) {
		var _g = new haxe_ds_StringMap();
		_g.h["nbsp"] = " ";
		_g.h["amp"] = "&";
		_g.h["lt"] = "<";
		_g.h["gt"] = ">";
		_g.h["quot"] = "\"";
		_g.h["apos"] = "'";
		_g.h["euro"] = "";
		_g.h["iexcl"] = "";
		_g.h["cent"] = "";
		_g.h["pound"] = "";
		_g.h["curren"] = "";
		_g.h["yen"] = "";
		_g.h["brvbar"] = "";
		_g.h["sect"] = "";
		_g.h["uml"] = "";
		_g.h["copy"] = "";
		_g.h["ordf"] = "";
		_g.h["not"] = "";
		_g.h["shy"] = "";
		_g.h["reg"] = "";
		_g.h["macr"] = "";
		_g.h["deg"] = "";
		_g.h["plusmn"] = "";
		_g.h["sup2"] = "";
		_g.h["sup3"] = "";
		_g.h["acute"] = "";
		_g.h["micro"] = "";
		_g.h["para"] = "";
		_g.h["middot"] = "";
		_g.h["cedil"] = "";
		_g.h["sup1"] = "";
		_g.h["ordm"] = "";
		_g.h["raquo"] = "";
		_g.h["frac14"] = "";
		_g.h["frac12"] = "";
		_g.h["frac34"] = "";
		_g.h["iquest"] = "";
		_g.h["Agrave"] = "";
		_g.h["Aacute"] = "";
		_g.h["Acirc"] = "";
		_g.h["Atilde"] = "";
		_g.h["Auml"] = "";
		_g.h["Aring"] = "";
		_g.h["AElig"] = "";
		_g.h["Ccedil"] = "";
		_g.h["Egrave"] = "";
		_g.h["Eacute"] = "";
		_g.h["Ecirc"] = "";
		_g.h["Euml"] = "";
		_g.h["Igrave"] = "";
		_g.h["Iacute"] = "";
		_g.h["Icirc"] = "";
		_g.h["Iuml"] = "";
		_g.h["ETH"] = "";
		_g.h["Ntilde"] = "";
		_g.h["Ograve"] = "";
		_g.h["Oacute"] = "";
		_g.h["Ocirc"] = "";
		_g.h["Otilde"] = "";
		_g.h["Ouml"] = "";
		_g.h["times"] = "";
		_g.h["Oslash"] = "";
		_g.h["Ugrave"] = "";
		_g.h["Uacute"] = "";
		_g.h["Ucirc"] = "";
		_g.h["Uuml"] = "";
		_g.h["Yacute"] = "";
		_g.h["THORN"] = "";
		_g.h["szlig"] = "";
		_g.h["agrave"] = "";
		_g.h["aacute"] = "";
		_g.h["acirc"] = "";
		_g.h["atilde"] = "";
		_g.h["auml"] = "";
		_g.h["aring"] = "";
		_g.h["aelig"] = "";
		_g.h["ccedil"] = "";
		_g.h["egrave"] = "";
		_g.h["eacute"] = "";
		_g.h["ecirc"] = "";
		_g.h["euml"] = "";
		_g.h["igrave"] = "";
		_g.h["iacute"] = "";
		_g.h["icirc"] = "";
		_g.h["iuml"] = "";
		_g.h["eth"] = "";
		_g.h["ntilde"] = "";
		_g.h["ograve"] = "";
		_g.h["oacute"] = "";
		_g.h["ocirc"] = "";
		_g.h["otilde"] = "";
		_g.h["ouml"] = "";
		_g.h["divide"] = "";
		_g.h["oslash"] = "";
		_g.h["ugrave"] = "";
		_g.h["uacute"] = "";
		_g.h["ucirc"] = "";
		_g.h["uuml"] = "";
		_g.h["yacute"] = "";
		_g.h["thorn"] = "";
		htmlparser_HtmlTools.htmlUnescapeMap = _g;
	}
	return htmlparser_HtmlTools.htmlUnescapeMap;
};
htmlparser_HtmlTools.escape = function(text,chars) {
	if(chars == null) {
		chars = "";
	}
	var r = text.split("&").join("&amp;");
	r = r.split("<").join("&lt;");
	r = r.split(">").join("&gt;");
	if(chars.indexOf("\"") >= 0) {
		r = r.split("\"").join("&quot;");
	}
	if(chars.indexOf("'") >= 0) {
		r = r.split("'").join("&apos;");
	}
	if(chars.indexOf(" ") >= 0) {
		r = r.split(" ").join("&nbsp;");
	}
	if(chars.indexOf("\n") >= 0) {
		r = r.split("\n").join("&#xA;");
	}
	if(chars.indexOf("\r") >= 0) {
		r = r.split("\r").join("&#xD;");
	}
	return r;
};
htmlparser_HtmlTools.unescape = function(text) {
	return new EReg("[<]!\\[CDATA\\[((?:.|[\r\n])*?)\\]\\][>]|&[^;]+;","g").map(text,function(re) {
		var s = re.matched(0);
		if(s.charAt(0) == "&") {
			if(s.charAt(1) == "#") {
				var numbers = s.substring(2,s.length - 1);
				if(numbers.charAt(0) == "x") {
					numbers = "0" + numbers;
				}
				var code = Std.parseInt(numbers);
				if(code != null && code != 0) {
					return String.fromCodePoint(code);
				} else {
					return s;
				}
			} else {
				var r = htmlparser_HtmlTools.get_htmlUnescapeMap().h[s.substring(1,s.length - 1)];
				if(r != null) {
					return r;
				} else {
					return s;
				}
			}
		}
		return re.matched(1);
	});
};
var htmlparser_XmlBuilder = function(indent,newLine) {
	if(newLine == null) {
		newLine = "\n";
	}
	if(indent == null) {
		indent = "\t";
	}
	this.level = 0;
	this.indent = indent;
	this.newLine = newLine;
	this.cur = this.xml = new htmlparser_XmlDocument();
};
htmlparser_XmlBuilder.__name__ = "htmlparser.XmlBuilder";
htmlparser_XmlBuilder.prototype = {
	begin: function(tag,attrs) {
		if(this.indent != null) {
			if(this.level > 0 || this.cur.nodes.length > 0) {
				this.cur.addChild(new htmlparser_HtmlNodeText(this.newLine + StringTools.rpad("",this.indent,this.level * this.indent.length)));
			}
			this.level++;
		}
		var node;
		if(attrs != null) {
			var result = new Array(attrs.length);
			var _g = 0;
			var _g1 = attrs.length;
			while(_g < _g1) {
				var i = _g++;
				var a = attrs[i];
				result[i] = new htmlparser_HtmlAttribute(a.name,a.value,"\"");
			}
			node = result;
		} else {
			node = [];
		}
		var node1 = new htmlparser_XmlNodeElement(tag,node);
		this.cur.addChild(node1);
		this.cur = node1;
		return this;
	}
	,end: function() {
		if(this.indent != null) {
			this.level--;
			if(Lambda.exists(this.cur.nodes,function(e) {
				return !((e) instanceof htmlparser_HtmlNodeText);
			})) {
				this.cur.addChild(new htmlparser_HtmlNodeText(this.newLine + StringTools.rpad("",this.indent,this.level * this.indent.length)));
			}
		}
		this.cur = this.cur.parent;
		return this;
	}
	,attr: function(name,value,defValue) {
		if(value != null && (typeof(value) != "number" || !isNaN(value)) && value != defValue) {
			if(((value) instanceof Array)) {
				value = value.join(",");
			}
			this.cur.setAttribute(name,Std.string(value));
		}
		return this;
	}
	,content: function(s) {
		this.cur.addChild(new htmlparser_HtmlNodeText(s));
		return this;
	}
	,toString: function() {
		return this.xml.toString();
	}
	,__class__: htmlparser_XmlBuilder
};
var htmlparser_XmlNodeElement = function(name,attributes) {
	htmlparser_HtmlNodeElement.call(this,name,attributes);
};
htmlparser_XmlNodeElement.__name__ = "htmlparser.XmlNodeElement";
htmlparser_XmlNodeElement.__super__ = htmlparser_HtmlNodeElement;
htmlparser_XmlNodeElement.prototype = $extend(htmlparser_HtmlNodeElement.prototype,{
	isSelfClosing: function() {
		return true;
	}
	,set_innerHTML: function(value) {
		var newNodes = htmlparser_XmlParser.run(value);
		this.nodes = [];
		this.children = [];
		var _g = 0;
		while(_g < newNodes.length) {
			var node = newNodes[_g];
			++_g;
			this.addChild(node);
		}
		return value;
	}
	,__class__: htmlparser_XmlNodeElement
});
var htmlparser_XmlDocument = function(str) {
	if(str == null) {
		str = "";
	}
	htmlparser_XmlNodeElement.call(this,"",[]);
	var nodes = htmlparser_XmlParser.run(str);
	var _g = 0;
	while(_g < nodes.length) {
		var node = nodes[_g];
		++_g;
		this.addChild(node);
	}
};
htmlparser_XmlDocument.__name__ = "htmlparser.XmlDocument";
htmlparser_XmlDocument.__super__ = htmlparser_XmlNodeElement;
htmlparser_XmlDocument.prototype = $extend(htmlparser_XmlNodeElement.prototype,{
	__class__: htmlparser_XmlDocument
});
var htmlparser_XmlParser = function() {
	htmlparser_HtmlParser.call(this);
};
htmlparser_XmlParser.__name__ = "htmlparser.XmlParser";
htmlparser_XmlParser.run = function(str) {
	return new htmlparser_XmlParser().parse(str);
};
htmlparser_XmlParser.__super__ = htmlparser_HtmlParser;
htmlparser_XmlParser.prototype = $extend(htmlparser_HtmlParser.prototype,{
	isSelfClosingTag: function(tag) {
		return false;
	}
	,newElement: function(name,attributes) {
		return new htmlparser_XmlNodeElement(name,attributes);
	}
	,__class__: htmlparser_XmlParser
});
var js_Boot = function() { };
js_Boot.__name__ = "js.Boot";
js_Boot.getClass = function(o) {
	if(o == null) {
		return null;
	} else if(((o) instanceof Array)) {
		return Array;
	} else {
		var cl = o.__class__;
		if(cl != null) {
			return cl;
		}
		var name = js_Boot.__nativeClassName(o);
		if(name != null) {
			return js_Boot.__resolveNativeClass(name);
		}
		return null;
	}
};
js_Boot.__string_rec = function(o,s) {
	if(o == null) {
		return "null";
	}
	if(s.length >= 5) {
		return "<...>";
	}
	var t = typeof(o);
	if(t == "function" && (o.__name__ || o.__ename__)) {
		t = "object";
	}
	switch(t) {
	case "function":
		return "<function>";
	case "object":
		if(o.__enum__) {
			var e = $hxEnums[o.__enum__];
			var con = e.__constructs__[o._hx_index];
			var n = con._hx_name;
			if(con.__params__) {
				s = s + "\t";
				return n + "(" + ((function($this) {
					var $r;
					var _g = [];
					{
						var _g1 = 0;
						var _g2 = con.__params__;
						while(true) {
							if(!(_g1 < _g2.length)) {
								break;
							}
							var p = _g2[_g1];
							_g1 = _g1 + 1;
							_g.push(js_Boot.__string_rec(o[p],s));
						}
					}
					$r = _g;
					return $r;
				}(this))).join(",") + ")";
			} else {
				return n;
			}
		}
		if(((o) instanceof Array)) {
			var str = "[";
			s += "\t";
			var _g = 0;
			var _g1 = o.length;
			while(_g < _g1) {
				var i = _g++;
				str += (i > 0 ? "," : "") + js_Boot.__string_rec(o[i],s);
			}
			str += "]";
			return str;
		}
		var tostr;
		try {
			tostr = o.toString;
		} catch( _g ) {
			return "???";
		}
		if(tostr != null && tostr != Object.toString && typeof(tostr) == "function") {
			var s2 = o.toString();
			if(s2 != "[object Object]") {
				return s2;
			}
		}
		var str = "{\n";
		s += "\t";
		var hasp = o.hasOwnProperty != null;
		var k = null;
		for( k in o ) {
		if(hasp && !o.hasOwnProperty(k)) {
			continue;
		}
		if(k == "prototype" || k == "__class__" || k == "__super__" || k == "__interfaces__" || k == "__properties__") {
			continue;
		}
		if(str.length != 2) {
			str += ", \n";
		}
		str += s + k + " : " + js_Boot.__string_rec(o[k],s);
		}
		s = s.substring(1);
		str += "\n" + s + "}";
		return str;
	case "string":
		return o;
	default:
		return String(o);
	}
};
js_Boot.__interfLoop = function(cc,cl) {
	if(cc == null) {
		return false;
	}
	if(cc == cl) {
		return true;
	}
	var intf = cc.__interfaces__;
	if(intf != null) {
		var _g = 0;
		var _g1 = intf.length;
		while(_g < _g1) {
			var i = _g++;
			var i1 = intf[i];
			if(i1 == cl || js_Boot.__interfLoop(i1,cl)) {
				return true;
			}
		}
	}
	return js_Boot.__interfLoop(cc.__super__,cl);
};
js_Boot.__instanceof = function(o,cl) {
	if(cl == null) {
		return false;
	}
	switch(cl) {
	case Array:
		return ((o) instanceof Array);
	case Bool:
		return typeof(o) == "boolean";
	case Dynamic:
		return o != null;
	case Float:
		return typeof(o) == "number";
	case Int:
		if(typeof(o) == "number") {
			return ((o | 0) === o);
		} else {
			return false;
		}
		break;
	case String:
		return typeof(o) == "string";
	default:
		if(o != null) {
			if(typeof(cl) == "function") {
				if(js_Boot.__downcastCheck(o,cl)) {
					return true;
				}
			} else if(typeof(cl) == "object" && js_Boot.__isNativeObj(cl)) {
				if(((o) instanceof cl)) {
					return true;
				}
			}
		} else {
			return false;
		}
		if(cl == Class ? o.__name__ != null : false) {
			return true;
		}
		if(cl == Enum ? o.__ename__ != null : false) {
			return true;
		}
		return o.__enum__ != null ? $hxEnums[o.__enum__] == cl : false;
	}
};
js_Boot.__downcastCheck = function(o,cl) {
	if(!((o) instanceof cl)) {
		if(cl.__isInterface__) {
			return js_Boot.__interfLoop(js_Boot.getClass(o),cl);
		} else {
			return false;
		}
	} else {
		return true;
	}
};
js_Boot.__implements = function(o,iface) {
	return js_Boot.__interfLoop(js_Boot.getClass(o),iface);
};
js_Boot.__cast = function(o,t) {
	if(o == null || js_Boot.__instanceof(o,t)) {
		return o;
	} else {
		throw haxe_Exception.thrown("Cannot cast " + Std.string(o) + " to " + Std.string(t));
	}
};
js_Boot.__nativeClassName = function(o) {
	var name = js_Boot.__toStr.call(o).slice(8,-1);
	if(name == "Object" || name == "Function" || name == "Math" || name == "JSON") {
		return null;
	}
	return name;
};
js_Boot.__isNativeObj = function(o) {
	return js_Boot.__nativeClassName(o) != null;
};
js_Boot.__resolveNativeClass = function(name) {
	return $global[name];
};
var js_html_VideoFrameBufferInit = function() { };
js_html_VideoFrameBufferInit.__name__ = "js.html.VideoFrameBufferInit";
js_html_VideoFrameBufferInit.__isInterface__ = true;
js_html_VideoFrameBufferInit.prototype = {
	__class__: js_html_VideoFrameBufferInit
};
var js_html_VideoColorSpaceInit = function() { };
js_html_VideoColorSpaceInit.__name__ = "js.html.VideoColorSpaceInit";
js_html_VideoColorSpaceInit.__isInterface__ = true;
js_html_VideoColorSpaceInit.prototype = {
	__class__: js_html_VideoColorSpaceInit
};
var js_html_PlaneLayout = function() { };
js_html_PlaneLayout.__name__ = "js.html.PlaneLayout";
js_html_PlaneLayout.__isInterface__ = true;
js_html_PlaneLayout.prototype = {
	__class__: js_html_PlaneLayout
};
var js_html_DOMRectInit = function() { };
js_html_DOMRectInit.__name__ = "js.html.DOMRectInit";
js_html_DOMRectInit.__isInterface__ = true;
js_html_DOMRectInit.prototype = {
	__class__: js_html_DOMRectInit
};
var js_html_VideoFrameInit = function() { };
js_html_VideoFrameInit.__name__ = "js.html.VideoFrameInit";
js_html_VideoFrameInit.__isInterface__ = true;
js_html_VideoFrameInit.prototype = {
	__class__: js_html_VideoFrameInit
};
var js_three_ArrayLike = {};
js_three_ArrayLike.get = function(this1,key) {
	return this1[key];
};
js_three_ArrayLike.arrayWrite = function(this1,k,v) {
	this1[k] = v;
	return v;
};
var GLTFLoader = (__webpack_require__(/*! three/addons/loaders/GLTFLoader.js */ "three/addons/loaders/GLTFLoader.js").GLTFLoader);
var THREE_Color = (__webpack_require__(/*! three */ "three").Color);
var THREE_PerspectiveCamera = (__webpack_require__(/*! three */ "three").PerspectiveCamera);
var THREE_AmbientLight = (__webpack_require__(/*! three */ "three").AmbientLight);
var THREE_DirectionalLight = (__webpack_require__(/*! three */ "three").DirectionalLight);
var THREE_Euler = (__webpack_require__(/*! three */ "three").Euler);
var THREE_Vector3 = (__webpack_require__(/*! three */ "three").Vector3);
var THREE_Group = (__webpack_require__(/*! three */ "three").Group);
var THREE_WebGLRenderer = (__webpack_require__(/*! three */ "three").WebGLRenderer);
var THREE_Scene = (__webpack_require__(/*! three */ "three").Scene);
var nanofl_IInstance = function() { };
nanofl_IInstance.__name__ = "nanofl.IInstance";
nanofl_IInstance.__isInterface__ = true;
nanofl_IInstance.prototype = {
	__class__: nanofl_IInstance
};
var nanofl_Bitmap = $hx_exports["nanofl"]["Bitmap"] = function(symbol) {
	createjs.Bitmap.call(this,null);
	this.symbol = symbol;
	symbol.updateDisplayObject(this,null);
	nanofl_InstanceTools.bindEventHandlers(this);
};
nanofl_Bitmap.__name__ = "nanofl.Bitmap";
nanofl_Bitmap.__interfaces__ = [nanofl_IInstance];
nanofl_Bitmap.__super__ = createjs.Bitmap;
nanofl_Bitmap.prototype = $extend(createjs.Bitmap.prototype,{
	clone: function(recursive) {
		return this._cloneProps(new nanofl_Bitmap(this.symbol));
	}
	,toString: function() {
		return this.symbol.toString();
	}
	,onEnterFrame: function() {
	}
	,onMouseDown: function(e) {
	}
	,onMouseMove: function(e) {
	}
	,onMouseUp: function(e) {
	}
	,__class__: nanofl_Bitmap
});
var nanofl_MovieClip = $hx_exports["nanofl"]["MovieClip"] = function(symbol,initFrameIndex,childFrameIndexes) {
	this.currentFrame = 0;
	this.layerOfChild = new haxe_ds_ObjectMap();
	stdlib_Debug.assert(((symbol) instanceof nanofl_engine_libraryitems_MovieClipItem),null,{ fileName : "engine/nanofl/MovieClip.hx", lineNumber : 27, className : "nanofl.MovieClip", methodName : "new"});
	createjs.Container.call(this);
	this.symbol = symbol;
	if(initFrameIndex != null) {
		this.currentFrame = initFrameIndex;
	}
	symbol.updateDisplayObject(this,childFrameIndexes);
	this.paused = !symbol.autoPlay;
	this.loop = symbol.loop;
	nanofl_InstanceTools.bindEventHandlers(this);
};
nanofl_MovieClip.__name__ = "nanofl.MovieClip";
nanofl_MovieClip.__interfaces__ = [nanofl_IInstance];
nanofl_MovieClip.applyMask = function(mask,obj) {
	var objBounds = nanofl_DisplayObjectTools.getOuterBounds(obj);
	if(objBounds == null || objBounds.width == 0 || objBounds.height == 0) {
		return false;
	}
	mask = mask.clone(true);
	mask.transformMatrix = obj.getMatrix().invert();
	mask.visible = true;
	var maskContainer = new createjs.Container();
	maskContainer.addChild(mask);
	var maskContainerBounds = nanofl_DisplayObjectTools.getOuterBounds(maskContainer);
	if(maskContainerBounds == null || maskContainerBounds.width == 0 || maskContainerBounds.height == 0) {
		obj.visible = false;
		return false;
	}
	nanofl_DisplayObjectTools.smartCache(mask);
	if(((obj) instanceof createjs.Container)) {
		var _g = 0;
		var _g1 = obj.children;
		while(_g < _g1.length) {
			var child = _g1[_g];
			++_g;
			nanofl_DisplayObjectTools.smartCache(child);
		}
	}
	var intersection = maskContainerBounds.intersection(objBounds);
	if(intersection == null || intersection.width == 0 || intersection.height == 0) {
		obj.visible = false;
		return false;
	}
	var union = objBounds.union(intersection);
	maskContainer.cache(union.x,union.y,union.width,union.height);
	var objBounds2 = nanofl_DisplayObjectTools.getOuterBounds(obj,true);
	obj.cache(objBounds2.x,objBounds2.y,objBounds2.width,objBounds2.height);
	new createjs.AlphaMaskFilter(maskContainer.cacheCanvas).applyFilter(obj.cacheCanvas.getContext("2d",null),0,0,objBounds.width | 0,objBounds.height | 0);
	return true;
};
nanofl_MovieClip.__super__ = createjs.Container;
nanofl_MovieClip.prototype = $extend(createjs.Container.prototype,{
	addChildToLayer: function(child,layerIndex) {
		this.layerOfChild.set(child,layerIndex);
		var _g = 0;
		var _g1 = this.children.length;
		while(_g < _g1) {
			var i = _g++;
			if(this.layerOfChild.h[this.children[i].__id__] < layerIndex) {
				return this.addChildAt(child,i);
			}
		}
		return this.addChild(child);
	}
	,removeAllChildren: function() {
		createjs.Container.prototype.removeAllChildren.call(this);
		this.layerOfChild = new haxe_ds_ObjectMap();
	}
	,removeChild: function(child) {
		this.layerOfChild.remove(child);
		return createjs.Container.prototype.removeChild.call(this,child);
	}
	,removeChildAt: function(index) {
		this.layerOfChild.remove(this.children[index]);
		return createjs.Container.prototype.removeChildAt.call(this,index);
	}
	,play: function() {
		this.paused = false;
	}
	,stop: function() {
		this.paused = true;
	}
	,gotoAndStop: function(labelOrIndex) {
		this.gotoFrame(labelOrIndex);
		this.stop();
	}
	,gotoAndPlay: function(labelOrIndex) {
		this.gotoFrame(labelOrIndex);
		this.play();
	}
	,getTotalFrames: function() {
		return this.symbol.getTotalFrames();
	}
	,maskChild: function(child) {
		var n = this.layerOfChild.h[child.__id__];
		if(n != null) {
			var parentLayerIndex = this.symbol.get_layers()[n].parentIndex;
			if(parentLayerIndex != null && this.symbol.get_layers()[parentLayerIndex].type == nanofl_engine_LayerType.mask) {
				var mask = new createjs.Container();
				var _g = 0;
				var _g1 = this.getLayerChildren(parentLayerIndex);
				while(_g < _g1.length) {
					var obj = _g1[_g];
					++_g;
					var clonedObj = obj.clone(true);
					clonedObj.visible = true;
					nanofl_DisplayObjectTools.smartCache(clonedObj);
					mask.addChild(clonedObj);
				}
				return nanofl_MovieClip.applyMask(mask,child);
			}
		}
		return false;
	}
	,uncacheChild: function(child) {
		child.uncache();
		if(nanofl_DisplayObjectTools.autoHitArea) {
			child.hitArea = null;
		}
		var layerIndex = this.layerOfChild.h[child.__id__];
		if(layerIndex != null && this.symbol.get_layers()[layerIndex].type == nanofl_engine_LayerType.mask) {
			var _g = 0;
			var _g1 = this.children;
			while(_g < _g1.length) {
				var c = _g1[_g];
				++_g;
				var n = this.layerOfChild.h[c.__id__];
				if(n != null && this.symbol.get_layers()[n].parentIndex == layerIndex) {
					c.uncache();
					if(nanofl_DisplayObjectTools.autoHitArea) {
						c.hitArea = null;
					}
				}
			}
		}
	}
	,getLayerChildren: function(layerIndex) {
		var r = [];
		var _g = 0;
		var _g1 = this.children;
		while(_g < _g1.length) {
			var child = _g1[_g];
			++_g;
			if(this.layerOfChild.h[child.__id__] == layerIndex) {
				r.push(child);
			}
		}
		return r;
	}
	,gotoFrame: function(labelOrIndex) {
		var frameIndex = this.getFrameIndexByLabel(labelOrIndex);
		if(this.currentFrame == frameIndex) {
			return null;
		}
		var movieClipChanged = false;
		var createdDisplayObjects = [];
		var keepedChildMovieClips = [];
		var _g = 0;
		var _g1 = this.symbol.get_layers().length;
		while(_g < _g1) {
			var i = _g++;
			var layerChanged = false;
			var layer = this.symbol.get_layers()[i];
			var oldFrame = layer.getFrame(this.currentFrame);
			var newFrame = layer.getFrame(frameIndex);
			if(oldFrame != null && newFrame != null && oldFrame.keyFrame == newFrame.keyFrame) {
				if(newFrame.keyFrame.hasMotionTween()) {
					var tweenedElements = layer.getTweenedElements(frameIndex);
					var layerChildren = this.getLayerChildren(i);
					stdlib_Debug.assert(tweenedElements.length == layerChildren.length,"tweenedElements.length=" + tweenedElements.length + " != layerChildren.length=" + layerChildren.length,{ fileName : "engine/nanofl/MovieClip.hx", lineNumber : 225, className : "nanofl.MovieClip", methodName : "gotoFrame"});
					var _g2 = 0;
					var _g3 = tweenedElements.length;
					while(_g2 < _g3) {
						var i1 = _g2++;
						tweenedElements[i1].current.updateDisplayObject(layerChildren[i1],null);
						layerChildren[i1].visible = layer.type == nanofl_engine_LayerType.normal;
						if(((tweenedElements[i1].current) instanceof nanofl_MovieClip) || ((tweenedElements[i1].current) instanceof createjs.Sprite)) {
							keepedChildMovieClips.push(tweenedElements[i1].current);
						}
					}
					layerChanged = true;
				}
			} else if(oldFrame != null || newFrame != null) {
				if(oldFrame != null) {
					var j = 0;
					while(j < this.children.length) if(this.layerOfChild.h[this.children[j].__id__] == i) {
						this.removeChildAt(j);
					} else {
						++j;
					}
				}
				if(newFrame != null) {
					var _g4 = 0;
					var _g5 = layer.getTweenedElements(frameIndex);
					while(_g4 < _g5.length) {
						var tweenedElement = _g5[_g4];
						++_g4;
						var obj = tweenedElement.current.createDisplayObject(null);
						obj.visible = layer.type == nanofl_engine_LayerType.normal;
						this.addChildToLayer(obj,i);
						createdDisplayObjects.push(obj);
					}
				}
				layerChanged = true;
			}
			if(layerChanged) {
				movieClipChanged = true;
				if(layer.type == nanofl_engine_LayerType.mask) {
					var _g6 = 0;
					var _g7 = this.symbol.get_layers().length;
					while(_g6 < _g7) {
						var j1 = _g6++;
						if(this.symbol.get_layers()[j1].parentIndex == i) {
							var _g8 = 0;
							var _g9 = this.getLayerChildren(j1);
							while(_g8 < _g9.length) {
								var child = _g9[_g8];
								++_g8;
								child.uncache();
							}
						}
					}
				}
			}
		}
		if(movieClipChanged) {
			nanofl_DisplayObjectTools.smartUncache(this);
		}
		this.currentFrame = frameIndex;
		var _g = 0;
		while(_g < createdDisplayObjects.length) {
			var obj = createdDisplayObjects[_g];
			++_g;
			nanofl_DisplayObjectTools.callMethod(obj,"init");
		}
		return keepedChildMovieClips;
	}
	,getFrameIndexByLabel: function(labelOrIndex) {
		if(typeof(labelOrIndex) == "number" && ((labelOrIndex | 0) === labelOrIndex)) {
			return labelOrIndex;
		}
		var _g = 0;
		var _g1 = this.symbol.get_layers();
		while(_g < _g1.length) {
			var layer = _g1[_g];
			++_g;
			var _g2 = 0;
			var _g3 = layer._keyFrames;
			while(_g2 < _g3.length) {
				var keyFrame = _g3[_g2];
				++_g2;
				if(keyFrame.label == labelOrIndex) {
					return keyFrame.getIndex();
				}
			}
		}
		return null;
	}
	,advance: function() {
		var childrenToAdvance = null;
		if(!this.paused) {
			var childrenToAdvance1;
			if(this.loop) {
				childrenToAdvance1 = (this.currentFrame + 1) % this.getTotalFrames();
			} else {
				var a = this.currentFrame + 1;
				var b = this.getTotalFrames() - 1;
				childrenToAdvance1 = a < b ? a : b;
			}
			childrenToAdvance = this.gotoFrame(childrenToAdvance1);
		}
		if(childrenToAdvance == null) {
			var _g = 0;
			var _g1 = this.children;
			while(_g < _g1.length) {
				var child = _g1[_g];
				++_g;
				if(((child) instanceof nanofl_MovieClip)) {
					child.advance();
				} else if(((child) instanceof createjs.Sprite)) {
					child.advance();
				}
			}
		} else {
			var _g = 0;
			while(_g < childrenToAdvance.length) {
				var child = childrenToAdvance[_g];
				++_g;
				child.advance();
			}
		}
	}
	,clone: function(recursive) {
		return this._cloneProps(new nanofl_MovieClip(this.symbol,this.currentFrame,null));
	}
	,toString: function() {
		return this.symbol.toString();
	}
	,onEnterFrame: function() {
	}
	,onMouseDown: function(e) {
	}
	,onMouseMove: function(e) {
	}
	,onMouseUp: function(e) {
	}
	,__class__: nanofl_MovieClip
});
var nanofl_Button = $hx_exports["nanofl"]["Button"] = function(symbol) {
	nanofl_MovieClip.call(this,symbol,0,null);
	this.stop();
	if(this.getTotalFrames() >= 4) {
		var hitSymbol = js_Boot.__cast(symbol.duplicate("__nanofl_temp") , nanofl_engine_libraryitems_MovieClipItem);
		hitSymbol.likeButton = false;
		hitSymbol.linkedClass = "";
		this.hitArea = hitSymbol.createDisplayObject(3,null);
		hitSymbol.remove();
	}
	this.cursor = "pointer";
};
nanofl_Button.__name__ = "nanofl.Button";
nanofl_Button.__super__ = nanofl_MovieClip;
nanofl_Button.prototype = $extend(nanofl_MovieClip.prototype,{
	onMouseDown: function(e) {
		if(this.getTotalFrames() >= 3 && this.currentFrame != 2) {
			if((this.hitArea != null ? this.hitArea : this).hitTest(e.localX,e.localY)) {
				this.gotoAndStop(2);
			}
		}
	}
	,onMouseMove: function(e) {
		if(this.getTotalFrames() >= 2 && this.currentFrame != 2) {
			this.gotoAndStop((this.hitArea != null ? this.hitArea : this).hitTest(e.localX,e.localY) ? 1 : 0);
		}
	}
	,onMouseUp: function(e) {
		if(this.getTotalFrames() > 0 && this.currentFrame != 0) {
			this.gotoAndStop(0);
		}
	}
	,__class__: nanofl_Button
});
var nanofl_DisplayObjectTools = $hx_exports["nanofl"]["DisplayObjectTools"] = function() { };
nanofl_DisplayObjectTools.__name__ = "nanofl.DisplayObjectTools";
nanofl_DisplayObjectTools.smartCache = function(obj) {
	if(obj.visible && obj.cacheCanvas == null) {
		if(((obj) instanceof createjs.Container) && !((obj) instanceof nanofl_SolidContainer)) {
			var _g = 0;
			var _g1 = obj.children;
			while(_g < _g1.length) {
				var child = _g1[_g];
				++_g;
				nanofl_DisplayObjectTools.smartCache(child);
			}
		}
		if(obj.parent == null || !((obj.parent) instanceof nanofl_MovieClip) || !obj.parent.maskChild(obj)) {
			if(obj.filters != null && obj.filters.length > 0) {
				var bounds = nanofl_DisplayObjectTools.getInnerBounds(obj);
				if(bounds != null && bounds.width > 0 && bounds.height > 0) {
					obj.cache(bounds.x,bounds.y,bounds.width,bounds.height);
					if(nanofl_DisplayObjectTools.autoHitArea) {
						var hitArea = new createjs.Container();
						var hitBmp = new createjs.Bitmap(obj.cacheCanvas);
						hitBmp.x = obj.bitmapCache.offX + obj.bitmapCache._filterOffX;
						hitBmp.y = obj.bitmapCache.offY + obj.bitmapCache._filterOffY;
						hitArea.addChild(hitBmp);
						obj.hitArea = hitArea;
					}
				}
			}
		}
	}
};
nanofl_DisplayObjectTools.smartUncache = function(obj) {
	var inspiredByChild = null;
	while(obj != null) {
		obj.uncache();
		if(nanofl_DisplayObjectTools.autoHitArea) {
			obj.hitArea = null;
		}
		if(((obj) instanceof nanofl_MovieClip) && inspiredByChild != null) {
			obj.uncacheChild(inspiredByChild);
		}
		inspiredByChild = obj;
		obj = obj.parent;
	}
};
nanofl_DisplayObjectTools.getOuterBounds = function(obj,ignoreSelf) {
	if(ignoreSelf == null) {
		ignoreSelf = false;
	}
	var r = null;
	if(((obj) instanceof createjs.Container) && !((obj) instanceof nanofl_SolidContainer)) {
		var _g = 0;
		var _g1 = obj.children;
		while(_g < _g1.length) {
			var child = _g1[_g];
			++_g;
			var b = nanofl_engine_geom_BoundsTools.transform(nanofl_DisplayObjectTools.getOuterBounds(child),child.getMatrix());
			if(b != null) {
				if(r != null) {
					r = r.union(b);
				} else {
					r = b;
				}
			}
		}
	} else {
		r = nanofl_DisplayObjectTools.getInnerBounds(obj);
	}
	if(r == null) {
		return null;
	}
	if(!ignoreSelf && obj.filters != null) {
		var _g = 0;
		var _g1 = obj.filters;
		while(_g < _g1.length) {
			var f = _g1[_g];
			++_g;
			f.getBounds(r);
		}
	}
	return r;
};
nanofl_DisplayObjectTools.getInnerBounds = function(obj) {
	var r = null;
	if(((obj) instanceof createjs.Container) && !((obj) instanceof nanofl_SolidContainer)) {
		var _g = 0;
		var _g1 = obj.children;
		while(_g < _g1.length) {
			var child = _g1[_g];
			++_g;
			var b = nanofl_engine_geom_BoundsTools.transform(nanofl_DisplayObjectTools.getInnerBounds(child),child.getMatrix());
			if(b != null) {
				if(r != null) {
					r = r.union(b);
				} else {
					r = b;
				}
			}
		}
		if(r == null) {
			return null;
		}
	} else {
		if(obj.cacheCanvas == null) {
			r = obj.getBounds();
		} else {
			var savedCacheCanvas = obj.cacheCanvas;
			obj.cacheCanvas = null;
			r = obj.getBounds();
			obj.cacheCanvas = savedCacheCanvas;
		}
		if(r == null) {
			return null;
		}
		r = r.clone();
	}
	return r;
};
nanofl_DisplayObjectTools.callMethod = function(parent,name) {
	if(((parent) instanceof createjs.Container)) {
		var _g = 0;
		var _g1 = parent.children;
		while(_g < _g1.length) {
			var child = _g1[_g];
			++_g;
			nanofl_DisplayObjectTools.callMethod(child,name);
		}
	}
	var method = Reflect.field(parent,name);
	if(Reflect.isFunction(method)) {
		method.apply(parent,[]);
	}
};
nanofl_DisplayObjectTools.smartHitTest = function(obj,x,y,minAlpha) {
	if(minAlpha == null) {
		minAlpha = 1;
	}
	if(obj.cacheCanvas == null) {
		return obj.hitTest(x,y);
	} else {
		if(x < obj.bitmapCache.offX || y < obj.bitmapCache.offY || x > obj.bitmapCache.offX + obj.bitmapCache.width || y > obj.bitmapCache.offY + obj.bitmapCache.height) {
			return false;
		}
		x = Math.round((x - obj.bitmapCache.offX - obj.bitmapCache._filterOffX) * obj.bitmapCache.scale);
		y = Math.round((y - obj.bitmapCache.offY - obj.bitmapCache._filterOffY) * obj.bitmapCache.scale);
		var alpha = obj.cacheCanvas.getContext("2d",null).getImageData(x,y,1,1).data[3];
		return alpha >= minAlpha;
	}
};
nanofl_DisplayObjectTools.dump = function(obj,level) {
	if(level == null) {
		level = 0;
	}
	var s = StringTools.rpad("","\t",level);
	if(((obj) instanceof nanofl_MovieClip)) {
		s += "MovieClip(" + obj.symbol.namePath + ")";
	} else if(((obj) instanceof nanofl_Mesh)) {
		s += "Mesh(" + obj.symbol.namePath + ")";
	} else if(((obj) instanceof nanofl_TextField)) {
		s += "TextField";
	} else if(((obj) instanceof nanofl_Bitmap)) {
		s += "Bitmap(" + obj.symbol.namePath + ")";
	} else if(((obj) instanceof createjs.Container)) {
		s += "Container";
	} else if(((obj) instanceof createjs.Shape)) {
		s += "Shape";
	} else {
		s += "Unknow";
	}
	if(obj.cacheCanvas != null) {
		s += " cached";
	}
	if(obj._bounds != null) {
		s += " fixed";
	}
	s += " bounds(" + nanofl_DisplayObjectTools.rectToString(obj.getBounds()) + ")";
	s += " outers(" + nanofl_DisplayObjectTools.rectToString(nanofl_DisplayObjectTools.getOuterBounds(obj)) + ")";
	if(((obj) instanceof nanofl_TextField)) {
		s += " '" + StringTools.replace(StringTools.replace(obj.text,"\r"," "),"\n"," ") + "'";
	}
	haxe_Log.trace(s,{ fileName : "engine/nanofl/DisplayObjectTools.hx", lineNumber : 215, className : "nanofl.DisplayObjectTools", methodName : "dump"});
	if(((obj) instanceof createjs.Container) && !((obj) instanceof nanofl_SolidContainer)) {
		var _g = 0;
		var _g1 = obj.children;
		while(_g < _g1.length) {
			var child = _g1[_g];
			++_g;
			nanofl_DisplayObjectTools.dump(child,level + 1);
		}
	}
};
nanofl_DisplayObjectTools.rectToString = function(rect) {
	if(rect == null) {
		return "null";
	}
	return rect.x + "," + rect.y + " " + rect.width + " x " + rect.height;
};
var nanofl_InstanceTools = function() { };
nanofl_InstanceTools.__name__ = "nanofl.InstanceTools";
nanofl_InstanceTools.bindEventHandlers = function(instance) {
	var instance1 = instance;
	var f = $bind(instance,instance.onMouseDown);
	var tmp = function(e) {
		nanofl_InstanceTools.stageMouseEventProxy(instance1,f,e);
	};
	nanofl_Player.stage.addEventListener("stagemousedown",tmp,null);
	var instance2 = instance;
	var f1 = $bind(instance,instance.onMouseMove);
	var tmp = function(e) {
		nanofl_InstanceTools.stageMouseEventProxy(instance2,f1,e);
	};
	nanofl_Player.stage.addEventListener("stagemousemove",tmp,null);
	var instance3 = instance;
	var f2 = $bind(instance,instance.onMouseUp);
	var tmp = function(e) {
		nanofl_InstanceTools.stageMouseEventProxy(instance3,f2,e);
	};
	nanofl_Player.stage.addEventListener("stagemouseup",tmp,null);
};
nanofl_InstanceTools.stageMouseEventProxy = function(instance,f,e) {
	var t = e.currentTarget;
	e.currentTarget = instance;
	f(e);
	e.currentTarget = t;
};
var nanofl_SolidContainer = function() {
	createjs.Container.call(this);
};
nanofl_SolidContainer.__name__ = "nanofl.SolidContainer";
nanofl_SolidContainer.__super__ = createjs.Container;
nanofl_SolidContainer.prototype = $extend(createjs.Container.prototype,{
	__class__: nanofl_SolidContainer
});
var nanofl_Mesh = $hx_exports["nanofl"]["Mesh"] = function(symbol) {
	this.directionalLight = new THREE_DirectionalLight(8421504,1);
	this.ambientLight = new THREE_AmbientLight(14737632);
	this.autoCamera = true;
	this.camera = new THREE_PerspectiveCamera(70,1,0,1e7);
	this.rotationZ = 0.0;
	this.rotationY = 0.0;
	this.rotationX = 0.0;
	nanofl_SolidContainer.call(this);
	this.symbol = symbol;
	var d = symbol.renderAreaSize >> 1;
	if(symbol.renderAreaSize % 2 != 0) {
		++d;
	}
	this.setBounds(-d,-d,d,d);
	symbol.updateDisplayObject(this,null);
	nanofl_InstanceTools.bindEventHandlers(this);
};
nanofl_Mesh.__name__ = "nanofl.Mesh";
nanofl_Mesh.__interfaces__ = [nanofl_IInstance];
nanofl_Mesh.__super__ = nanofl_SolidContainer;
nanofl_Mesh.prototype = $extend(nanofl_SolidContainer.prototype,{
	clone: function(recursive) {
		return this._cloneProps(new nanofl_Mesh(this.symbol));
	}
	,toString: function() {
		return this.symbol.toString();
	}
	,draw: function(ctx,ignoreCache) {
		this.update();
		return nanofl_SolidContainer.prototype.draw.call(this,ctx,ignoreCache);
	}
	,update: function() {
		this.removeAllChildren();
		var bitmap = new createjs.Bitmap(this.symbol.get_renderer().domElement);
		this.addChild(bitmap);
		bitmap.x = bitmap.y = -this.symbol.renderAreaSize / 2;
		this.group.setRotationFromEuler(new THREE_Euler(this.rotationX * nanofl_Mesh.DEG_TO_RAD,this.rotationY * nanofl_Mesh.DEG_TO_RAD,this.rotationZ * nanofl_Mesh.DEG_TO_RAD));
		this.group.updateMatrix();
		var posZ = this.symbol.boundingRadius / Math.sin(this.camera.fov / 2 * nanofl_Mesh.DEG_TO_RAD);
		if(this.directionalLight != null) {
			this.directionalLight.position.x = 0.0;
			this.directionalLight.position.y = 0.0;
			this.directionalLight.position.z = -posZ;
			this.directionalLight.position.applyEuler(new THREE_Euler(this.directionalLight.rotation.x,this.directionalLight.rotation.y));
		}
		if(this.autoCamera) {
			this.camera.position.z = -posZ;
			this.camera.lookAt(new THREE_Vector3(0,0,0));
			this.camera.near = posZ - this.symbol.boundingRadius;
			this.camera.far = posZ + this.symbol.boundingRadius;
			this.camera.updateProjectionMatrix();
			this.camera.updateMatrix();
		}
		if(this.ambientLight != null) {
			this.scene.add(this.ambientLight);
		}
		if(this.directionalLight != null) {
			this.scene.add(this.directionalLight);
		}
		this.symbol.get_renderer().render(this.scene,this.camera);
	}
	,onEnterFrame: function() {
	}
	,onMouseDown: function(e) {
	}
	,onMouseMove: function(e) {
	}
	,onMouseUp: function(e) {
	}
	,__class__: nanofl_Mesh
});
var nanofl_Player = $hx_exports["nanofl"]["Player"] = function() { };
nanofl_Player.__name__ = "nanofl.Player";
nanofl_Player.init = function(container,libraryData,framerate,scaleMode,textureAtlasesData) {
	if(scaleMode == null) {
		scaleMode = "custom";
	}
	if(framerate == null) {
		framerate = 24.0;
	}
	nanofl_Player.container = container;
	nanofl_Player.library = nanofl_engine_Library.loadFromJson("library",libraryData);
	container.innerHTML = "";
	var canvas = window.document.createElement("canvas");
	canvas.style.position = "absolute";
	container.appendChild(canvas);
	if(textureAtlasesData != null) {
		var _g = 0;
		while(_g < textureAtlasesData.length) {
			var textureAtlasData = textureAtlasesData[_g];
			++_g;
			var _g1 = 0;
			var _g2 = Reflect.fields(textureAtlasData);
			while(_g1 < _g2.length) {
				var namePath = _g2[_g1];
				++_g1;
				nanofl_Player.spriteSheets[namePath] = new createjs.SpriteSheet(Reflect.field(textureAtlasData,namePath));
			}
		}
	}
	createjs.Sound.alternateExtensions = ["ogg","mp3","wav"];
	var _this = nanofl_Player.library.getSounds();
	var result = new Array(_this.length);
	var _g = 0;
	var _g1 = _this.length;
	while(_g < _g1) {
		var i = _g++;
		var item = _this[i];
		result[i] = { src : item.getUrl(), id : item.linkage};
	}
	createjs.Sound.registerSounds(result,null);
	nanofl_Player.library.preload().then(function(_) {
		nanofl_Player.stage = new nanofl_Stage(canvas);
		if(scaleMode != nanofl_engine_ScaleMode.custom) {
			var originalWidth = container.offsetWidth;
			var originalHeight = container.offsetHeight;
			window.addEventListener("resize",function() {
				nanofl_Player.resize(scaleMode,originalWidth,originalHeight);
			});
			nanofl_Player.resize(scaleMode,originalWidth,originalHeight);
		}
		nanofl_Player.stage.addChild(nanofl_Player.scene = nanofl_Player.library.getSceneInstance().createDisplayObject(null));
		nanofl_DisplayObjectTools.callMethod(nanofl_Player.scene,"init");
		nanofl_DisplayObjectTools.callMethod(nanofl_Player.scene,"onEnterFrame");
		nanofl_Player.stage.update();
		createjs.Ticker.framerate = framerate;
		return createjs.Ticker.addEventListener("tick",function() {
			nanofl_Player.scene.advance();
			nanofl_DisplayObjectTools.callMethod(nanofl_Player.scene,"onEnterFrame");
			nanofl_Player.stage.update();
		});
	});
};
nanofl_Player.resize = function(scaleMode,originalWidth,originalHeight) {
	var tmp = Std.string(window.innerWidth);
	window.document.body.style.width = tmp + "px";
	var tmp = Std.string(window.innerHeight);
	window.document.body.style.height = tmp + "px";
	var kx;
	var ky;
	switch(scaleMode) {
	case nanofl_engine_ScaleMode.fill:
		ky = Math.max(window.innerWidth / originalWidth,window.innerHeight / originalHeight);
		kx = ky;
		break;
	case nanofl_engine_ScaleMode.fit:
		ky = Math.min(window.innerWidth / originalWidth,window.innerHeight / originalHeight);
		kx = ky;
		break;
	case nanofl_engine_ScaleMode.stretch:
		kx = window.innerWidth / originalWidth;
		ky = window.innerHeight / originalHeight;
		break;
	default:
		ky = 1;
		kx = ky;
	}
	var w = Math.round(originalWidth * kx);
	var h = Math.round(originalHeight * ky);
	nanofl_Player.container.style.width = w + "px";
	nanofl_Player.container.style.height = h + "px";
	var _g = 0;
	var _g1 = nanofl_Player.container.children;
	while(_g < _g1.length) {
		var node = _g1[_g];
		++_g;
		if(node.tagName.toUpperCase() == "CANVAS") {
			node.width = w;
			node.height = h;
		}
	}
	var tmp = Math.round((window.innerWidth - nanofl_Player.container.offsetWidth) / 2);
	nanofl_Player.container.style.left = tmp + "px";
	var tmp = Math.round((window.innerHeight - nanofl_Player.container.offsetHeight) / 2);
	nanofl_Player.container.style.top = tmp + "px";
	nanofl_Player.stage.scaleX = kx;
	nanofl_Player.stage.scaleY = ky;
};
var nanofl_SeamlessSoundLoop = $hx_exports["nanofl"]["SeamlessSoundLoop"] = function(sound) {
	this.n = 1;
	if(sound.duration == null || sound.duration == 0) {
		return;
	}
	if(nanofl_SeamlessSoundLoop.delay == null) {
		nanofl_SeamlessSoundLoop.delay = this.detectDelay();
	}
	this.sounds = [sound,createjs.Sound.createInstance(sound.src)];
	this.switchSound();
};
nanofl_SeamlessSoundLoop.__name__ = "nanofl.SeamlessSoundLoop";
nanofl_SeamlessSoundLoop.prototype = {
	stop: function() {
		this.sounds[0].destroy();
		this.sounds[1].destroy();
		this.timer.stop();
	}
	,switchSound: function() {
		this.n = this.n == 1 ? 0 : 1;
		this.sounds[this.n].play();
		this.timer = haxe_Timer.delay($bind(this,this.switchSound),Math.round(this.sounds[0].duration));
	}
	,detectDelay: function() {
		var $window = window;
		var document = window.document;
		if($window.mozInnerScreenX != null && new EReg("firefox","i").match($global.navigator.userAgent)) {
			return -25;
		}
		if(document.all) {
			return -30;
		}
		if($window.chrome) {
			return -25;
		}
		if(new EReg("safari","i").match($global.navigator.userAgent) && $window.getComputedStyle && !$window.globalStorage) {
			return -30;
		}
		return 0;
	}
	,__class__: nanofl_SeamlessSoundLoop
};
var nanofl_SpriteButton = $hx_exports["nanofl"]["SpriteButton"] = function(spriteSheet) {
	createjs.Sprite.call(this,spriteSheet);
	this.stop();
	if(spriteSheet.getNumFrames() >= 4) {
		this.hitArea = spriteSheet.getFrame(3);
	}
	this.cursor = "pointer";
};
nanofl_SpriteButton.__name__ = "nanofl.SpriteButton";
nanofl_SpriteButton.__super__ = createjs.Sprite;
nanofl_SpriteButton.prototype = $extend(createjs.Sprite.prototype,{
	onMouseDown: function(e) {
		if(this.spriteSheet.getNumFrames() >= 3 && this.currentFrame != 2) {
			if((this.hitArea != null ? this.hitArea : this).hitTest(e.localX,e.localY)) {
				this.gotoAndStop(2);
			}
		}
	}
	,onMouseMove: function(e) {
		if(this.spriteSheet.getNumFrames() >= 2 && this.currentFrame != 2) {
			this.gotoAndStop((this.hitArea != null ? this.hitArea : this).hitTest(e.localX,e.localY) ? 1 : 0);
		}
	}
	,onMouseUp: function(e) {
		if(this.spriteSheet.getNumFrames() > 0 && this.currentFrame != 0) {
			this.gotoAndStop(0);
		}
	}
	,stageMouseEventProxy: function(f,e) {
		var t = e.currentTarget;
		e.currentTarget = this;
		f(e);
		e.currentTarget = t;
	}
	,__class__: nanofl_SpriteButton
});
var nanofl_Stage = $hx_exports["nanofl"]["Stage"] = function(canvas) {
	createjs.Stage.call(this,canvas);
	this.tickOnUpdate = false;
	this.enableMouseOver(10);
};
nanofl_Stage.__name__ = "nanofl.Stage";
nanofl_Stage.__super__ = createjs.Stage;
nanofl_Stage.prototype = $extend(createjs.Stage.prototype,{
	update: function(params) {
		nanofl_DisplayObjectTools.smartCache(this);
		createjs.Stage.prototype.update.call(this,params);
	}
	,__class__: nanofl_Stage
});
var nanofl_TextField = $hx_exports["nanofl"]["TextField"] = function(width,height,selectable,border,dashedBorder,textRuns,newTextFormat) {
	if(dashedBorder == null) {
		dashedBorder = false;
	}
	if(border == null) {
		border = false;
	}
	if(selectable == null) {
		selectable = false;
	}
	if(height == null) {
		height = 0.0;
	}
	if(width == null) {
		width = 0.0;
	}
	this._dashedBorder = false;
	this._border = false;
	var _gthis = this;
	Object.defineProperty(this,"minWidth",{ get : function() {
		return _gthis.get_minWidth();
	}});
	Object.defineProperty(this,"minHeight",{ get : function() {
		return _gthis.get_minHeight();
	}});
	Object.defineProperty(this,"width",{ get : function() {
		return _gthis.get_width();
	}, set : function(v) {
		_gthis.set_width(v);
	}});
	Object.defineProperty(this,"height",{ get : function() {
		return _gthis.get_height();
	}, set : function(v) {
		_gthis.set_height(v);
	}});
	Object.defineProperty(this,"border",{ get : function() {
		return _gthis.get_border();
	}, set : function(v) {
		_gthis.set_border(v);
	}});
	Object.defineProperty(this,"dashedBorder",{ get : function() {
		return _gthis.get_dashedBorder();
	}, set : function(v) {
		_gthis.set_dashedBorder(v);
	}});
	Object.defineProperty(this,"newTextFormat",{ get : function() {
		return _gthis.get_newTextFormat();
	}, set : function(v) {
		_gthis.set_newTextFormat(v);
	}});
	Object.defineProperty(this,"text",{ get : function() {
		return _gthis.get_text();
	}, set : function(v) {
		_gthis.set_text(v);
	}});
	nanofl_SolidContainer.call(this);
	this.width = width;
	this.height = height;
	this.selectable = selectable;
	this.border = border;
	this.dashedBorder = dashedBorder;
	this.textRuns = textRuns != null ? textRuns : [];
	this._newTextFormat = newTextFormat;
	this.resize = new stdlib_Event(this);
	this.change = new stdlib_Event(this);
	var _g = 0;
	var _g1 = this.textRuns;
	while(_g < _g1.length) {
		var textRun = _g1[_g];
		++_g;
		textRun.characters = StringTools.replace(StringTools.replace(textRun.characters,"\r\n","\n"),"\r","\n");
	}
	this.textLines = [];
	this.addChild(this.globalBackground = new createjs.Shape());
	this.addChild(this.background = new createjs.Shape());
	this.addChild(this.textsContainer = new createjs.Container());
	this.addChild(this.borders = new createjs.Shape());
	this.addChild(this.caret = new createjs.Shape());
	this.hitBox = new createjs.Shape();
	this.optionsChanged();
};
nanofl_TextField.__name__ = "nanofl.TextField";
nanofl_TextField.measureFontHeight = function(family,style,size) {
	var key = family + "|" + style + "|" + size;
	if(Object.prototype.hasOwnProperty.call(nanofl_TextField.fontHeightCache.h,key)) {
		return nanofl_TextField.fontHeightCache.h[key];
	}
	var div = window.document.createElement("div");
	div.innerHTML = "Mp";
	div.style.position = "absolute";
	div.style.top = "0";
	div.style.left = "0";
	div.style.fontFamily = family;
	div.style.fontWeight = style.indexOf("bold") >= 0 ? "bold" : "normal";
	div.style.fontStyle = style.indexOf("italic") >= 0 ? "italic" : "normal";
	div.style.fontSize = size + "px";
	div.style.lineHeight = "normal";
	if(window.document.body == null) {
		window.document.body = window.document.querySelector("body");
	}
	window.document.body.appendChild(div);
	var r = div.offsetHeight;
	window.document.body.removeChild(div);
	nanofl_TextField.fontHeightCache.h[key] = r;
	return r;
};
nanofl_TextField.measureFontBaselineCoef = function(family,style) {
	var key = family + "|" + style;
	if(Object.prototype.hasOwnProperty.call(nanofl_TextField.fontBaselineCoefCache.h,key)) {
		return nanofl_TextField.fontBaselineCoefCache.h[key];
	}
	var container = window.document.createElement("div");
	container.style.height = "100px";
	container.style.position = "absolute";
	container.style.top = "0";
	container.style.left = "0";
	var letter = window.document.createElement("span");
	letter.style.fontFamily = family;
	letter.style.fontWeight = style.indexOf("bold") >= 0 ? "bold" : "normal";
	letter.style.fontStyle = style.indexOf("italic") >= 0 ? "italic" : "normal";
	letter.style.fontSize = "100px";
	letter.style.lineHeight = "0";
	letter.innerHTML = "A";
	var strut = window.document.createElement("span");
	strut.style.fontFamily = family;
	strut.style.fontWeight = style.indexOf("bold") >= 0 ? "bold" : "normal";
	strut.style.fontStyle = style.indexOf("italic") >= 0 ? "italic" : "normal";
	strut.style.fontSize = "999px";
	strut.style.lineHeight = "normal";
	strut.style.display = "inline-block";
	strut.style.height = "100px";
	strut.innerHTML = "";
	container.appendChild(letter);
	container.appendChild(strut);
	window.document.body.appendChild(container);
	var r = 1 - (letter.offsetTop + letter.offsetHeight - container.offsetHeight - container.offsetTop) / 100;
	container.remove();
	nanofl_TextField.fontBaselineCoefCache.h[key] = r;
	return r;
};
nanofl_TextField.log = function(v,infos) {
};
nanofl_TextField.__super__ = nanofl_SolidContainer;
nanofl_TextField.prototype = $extend(nanofl_SolidContainer.prototype,{
	get_minWidth: function() {
		this.update();
		return this._minWidth;
	}
	,get_minHeight: function() {
		this.update();
		return this._minHeight;
	}
	,get_width: function() {
		return this._width;
	}
	,set_width: function(v) {
		if(this._width != v) {
			this._width = v;
			this.needUpdate = true;
		}
		return v;
	}
	,get_height: function() {
		return this._height;
	}
	,set_height: function(v) {
		if(this._height != v) {
			this._height = v;
			this.needUpdate = true;
		}
		return v;
	}
	,get_border: function() {
		return this._border;
	}
	,set_border: function(v) {
		if(this._border != v) {
			this._border = v;
			this.optionsChanged();
		}
		return v;
	}
	,get_dashedBorder: function() {
		return this._dashedBorder;
	}
	,set_dashedBorder: function(v) {
		if(this._dashedBorder != v) {
			this._dashedBorder = v;
			this.optionsChanged();
		}
		return v;
	}
	,get_newTextFormat: function() {
		if(this._newTextFormat != null) {
			return this._newTextFormat;
		} else {
			return this._newTextFormat = new nanofl_TextRun();
		}
	}
	,set_newTextFormat: function(format) {
		stdlib_Debug.assert(format != null,"TextField.newTextFormat must not be null." + haxe_CallStack.toString(haxe_CallStack.callStack()),{ fileName : "engine/nanofl/TextField.hx", lineNumber : 110, className : "nanofl.TextField", methodName : "set_newTextFormat"});
		return this._newTextFormat = format;
	}
	,get_text: function() {
		var _this = this.textRuns;
		var result = new Array(_this.length);
		var _g = 0;
		var _g1 = _this.length;
		while(_g < _g1) {
			var i = _g++;
			result[i] = _this[i].characters;
		}
		return result.join("");
	}
	,set_text: function(v) {
		var format = this.textRuns.length > 0 ? this.textRuns[this.textRuns.length - 1] : this.newTextFormat;
		this.textRuns.splice(0,this.textRuns.length);
		this.textRuns.push(format.duplicate(v));
		return v;
	}
	,getSplittedByPosition: function(runs,position,textToInsert) {
		if(textToInsert == null) {
			textToInsert = "";
		}
		var r = [];
		if(position > 0) {
			var charIndex = 0;
			var _g = 0;
			while(_g < runs.length) {
				var run = runs[_g];
				++_g;
				var len = run.characters.length;
				if(position > charIndex && position < charIndex + len) {
					r.push(run.duplicate(HxOverrides.substr(run.characters,0,position - charIndex)));
					if(textToInsert.length > 0) {
						r.push(run.duplicate(textToInsert));
					}
					r.push(run.duplicate(HxOverrides.substr(run.characters,position - charIndex,len - (position - charIndex))));
					len += textToInsert.length;
				} else {
					r.push(run.clone());
					if(position == charIndex + len) {
						if(textToInsert.length > 0) {
							r.push(run.duplicate(textToInsert));
							len += textToInsert.length;
						}
					}
				}
				charIndex += len;
			}
		} else {
			if(textToInsert.length > 0) {
				r.push(runs.length > 0 ? runs[0].duplicate(textToInsert) : this.newTextFormat.duplicate(textToInsert));
			}
			var _g = 0;
			while(_g < runs.length) {
				var run = runs[_g];
				++_g;
				r.push(run);
			}
		}
		return r;
	}
	,getSplittedToLines: function(runs) {
		var runLines = [];
		var runLine = [];
		var _g = 0;
		while(_g < runs.length) {
			var run = runs[_g];
			++_g;
			var lines = run.characters.split("\n");
			if(lines.length == 1) {
				if(run.characters != "") {
					runLine.push(run);
				}
			} else {
				var _g1 = 0;
				var _g2 = lines.length;
				while(_g1 < _g2) {
					var i = _g1++;
					if(lines[i] != "") {
						runLine.push(run.duplicate(lines[i]));
					}
					if(i < lines.length - 1) {
						runLine.push(run.duplicate(" "));
						runLines.push(runLine);
						runLine = [];
					}
				}
			}
		}
		if(runLine.length == 0) {
			runLine.push(runs.length > 0 ? runs[runs.length - 1].duplicate(" ") : this.newTextFormat.duplicate(" "));
		}
		runLines.push(runLine);
		return runLines;
	}
	,getTextLines: function() {
		var runs = this.textRuns.slice();
		if(this.selectable && !this.dashedBorder) {
			runs = this.getSplittedByPosition(runs,0);
		}
		var lines = this.getSplittedToLines(runs);
		var r = [];
		var charIndex = 0;
		var _g = 0;
		var _g1 = lines.length;
		while(_g < _g1) {
			var i = _g++;
			var runsLine = [];
			var _g2 = 0;
			var _g3 = lines[i];
			while(_g2 < _g3.length) {
				var run = _g3[_g2];
				++_g2;
				if(run.kerning) {
					runsLine.push(run);
				} else {
					var _g_offset = 0;
					var _g_s = run.characters;
					while(_g_offset < _g_s.length) {
						var c = _g_s.charCodeAt(_g_offset++);
						runsLine.push(run.duplicate(String.fromCodePoint(c)));
					}
				}
			}
			var lineWidth = 0.0;
			var lineMinY = 1.0e10;
			var lineMaxY = -1.0e10;
			var lineSpacing = null;
			var chunks = [];
			var _g4 = 0;
			var _g5 = runsLine.length;
			while(_g4 < _g5) {
				var j = _g4++;
				var run1 = runsLine[j];
				var selected = this.selectable && !this.dashedBorder && charIndex >= 0 && charIndex < 0;
				var text = this.createFirstText(run1,selected);
				var bounds = text.getBounds();
				var fontHeight = nanofl_TextField.measureFontHeight(run1.family,run1.style,run1.size);
				var fontBaselineCoef = nanofl_TextField.measureFontBaselineCoef(run1.family,run1.style);
				stdlib_Debug.assert(run1.letterSpacing != null,null,{ fileName : "engine/nanofl/TextField.hx", lineNumber : 303, className : "nanofl.TextField", methodName : "getTextLines"});
				text.setBounds(bounds.x,-fontHeight * fontBaselineCoef,bounds.width + (!run1.kerning ? run1.letterSpacing : 0),fontHeight);
				bounds = text.getBounds();
				if(i == lines.length - 1 || j < runsLine.length - 1) {
					lineWidth += bounds.width;
				}
				lineMinY = Math.min(lineMinY,bounds.y);
				lineMaxY = Math.max(lineMaxY,bounds.y + bounds.height);
				stdlib_Debug.assert(run1.lineSpacing != null,null,{ fileName : "engine/nanofl/TextField.hx", lineNumber : 321, className : "nanofl.TextField", methodName : "getTextLines"});
				lineSpacing = lineSpacing != null ? Math.max(lineSpacing,run1.lineSpacing) : run1.lineSpacing;
				chunks.push({ text : text, textSecond : this.createSecondText(run1,selected), charIndex : charIndex, bounds : bounds, backgroundColor : !selected ? run1.backgroundColor : "darkblue", format : run1});
				charIndex += run1.characters.length;
			}
			r.push({ chunks : chunks, width : lineWidth, minY : lineMinY, maxY : lineMaxY, align : StringTools.trim(runsLine[0].align).toLowerCase(), spacing : lineSpacing - 2});
		}
		return r;
	}
	,update: function() {
		if(!this.needUpdate && !this.isTextChanged()) {
			return;
		}
		this.needUpdate = false;
		nanofl_TextRun.optimize(this.textRuns);
		var _this = this.textRuns;
		var result = new Array(_this.length);
		var _g = 0;
		var _g1 = _this.length;
		while(_g < _g1) {
			var i = _g++;
			result[i] = _this[i].clone();
		}
		this.textRunsOnLastUpdate = result;
		this.globalBackground.visible = false;
		this.borders.visible = false;
		var sizeChanged = false;
		this.textLines = this.getTextLines();
		this._minWidth = 0.0;
		this._minHeight = nanofl_TextField.PADDING * 2;
		var _g = 0;
		var _g1 = this.textLines;
		while(_g < _g1.length) {
			var line = _g1[_g];
			++_g;
			this._minWidth = Math.max(this._minWidth,line.width + nanofl_TextField.PADDING * 2);
			if(this._minWidth > this.width) {
				switch(line.align) {
				case "center":
					this.x -= (line.width - (this.width - nanofl_TextField.PADDING * 2)) / 2;
					break;
				case "right":
					this.x -= line.width - (this.width - nanofl_TextField.PADDING * 2);
					break;
				}
				this.width = line.width + nanofl_TextField.PADDING * 2;
				sizeChanged = true;
			}
			this._minHeight += line.maxY - line.minY + line.spacing;
		}
		if(this.textLines.length > 0) {
			this._minHeight -= this.textLines[this.textLines.length - 1].spacing;
		}
		if(this._minHeight > this.height) {
			this.height = this._minHeight;
			sizeChanged = true;
		}
		this.textsContainer.removeAllChildren();
		this.background.graphics.clear();
		var innerY = nanofl_TextField.PADDING;
		var _g = 0;
		var _g1 = this.textLines.length;
		while(_g < _g1) {
			var i = _g++;
			var line = this.textLines[i];
			var innerX;
			switch(line.align) {
			case "center":
				innerX = (this.width - nanofl_TextField.PADDING * 2 - line.width) / 2.0;
				break;
			case "right":
				innerX = this.width - nanofl_TextField.PADDING * 2 - line.width;
				break;
			default:
				innerX = 0.0;
			}
			var innerX1 = nanofl_TextField.PADDING + innerX;
			var _g2 = 0;
			var _g3 = line.chunks;
			while(_g2 < _g3.length) {
				var t = _g3[_g2];
				++_g2;
				if(t.textSecond != null) {
					this.textsContainer.addChild(t.textSecond);
				}
				this.textsContainer.addChild(t.text);
				t.text.x = innerX1;
				t.text.y = innerY - line.minY;
				if(t.backgroundColor != null) {
					this.background.graphics.beginFill(t.backgroundColor).rect(t.text.x + t.bounds.x,t.text.y + line.minY,t.bounds.width,line.maxY - line.minY).endFill();
				}
				if(t.textSecond != null) {
					t.textSecond.x = t.text.x;
					t.textSecond.y = t.text.y;
				}
				innerX1 += t.bounds.width;
			}
			innerY += line.maxY - line.minY + line.spacing;
		}
		if(this.border || this.dashedBorder) {
			var pt0 = this.localToGlobal(0,0);
			pt0 = this.globalToLocal(Math.round(pt0.x) + 0.5,Math.round(pt0.y) + 0.5);
			var pt1 = this.localToGlobal(this.width,this.height);
			pt1 = this.globalToLocal(Math.round(pt1.x) + 0.5,Math.round(pt1.y) + 0.5);
			if(this.border) {
				this.globalBackground.visible = true;
				this.globalBackground.graphics.clear().beginFill("#FFFFFF").rect(pt0.x,pt0.y,pt1.x - pt0.x,pt1.y - pt0.y).endFill();
			}
			this.drawBorders(pt0,pt1);
		}
		if(sizeChanged) {
			this.resize.call({ width : this.width, height : this.height});
		}
		this.updateHitArea();
		this.setBounds(0,0,this.width,this.height);
	}
	,draw: function(ctx,ignoreCache) {
		this.update();
		return nanofl_SolidContainer.prototype.draw.call(this,ctx,ignoreCache);
	}
	,drawBorders: function(pt0,pt1) {
		if(this.border) {
			this.borders.visible = true;
			this.borders.graphics.clear().setStrokeStyle(1.0,null,null,null,true).beginStroke("#000000").rect(pt0.x,pt0.y,pt1.x - pt0.x,pt1.y - pt0.y).endStroke();
		} else if(this.dashedBorder) {
			this.borders.visible = true;
			var dashPt0 = this.globalToLocal(0,0);
			var dashPt1 = this.globalToLocal(2,2);
			var dashLen = (Math.abs(dashPt1.x - dashPt0.x) + Math.abs(dashPt1.y - dashPt0.y)) / 2;
			nanofl_engine_DrawTools.drawDashedRect(this.borders.graphics.clear().setStrokeStyle(1.0,null,null,null,true),pt0.x,pt0.y,pt1.x,pt1.y,"#000000","#FFFFFF",dashLen);
		}
	}
	,updateHitArea: function() {
		this.hitBox.graphics.clear().beginFill("#000000").rect(0,0,this.width,this.height).endFill();
	}
	,optionsChanged: function() {
		this.hitArea = this.hitBox;
		this.needUpdate = true;
	}
	,updateStage: function() {
		this.update();
		if(this.stage != null) {
			this.stage.update();
		}
	}
	,isTextChanged: function() {
		if(this.textRunsOnLastUpdate.length != this.textRuns.length) {
			return true;
		}
		var _g = 0;
		var _g1 = this.textRuns.length;
		while(_g < _g1) {
			var i = _g++;
			if(!this.textRunsOnLastUpdate[i].equ(this.textRuns[i])) {
				return true;
			}
		}
		return false;
	}
	,createFirstText: function(run,selected) {
		if(!selected && run.isStroked()) {
			return run.createText(run.strokeColor,run.strokeSize);
		} else {
			return run.createText(!selected ? run.fillColor : "white");
		}
	}
	,createSecondText: function(run,selected) {
		if(!selected && run.isFilled() && run.isStroked()) {
			return run.createText();
		} else {
			return null;
		}
	}
	,clone: function(recursive) {
		var tmp = this;
		var tmp1 = this.width;
		var tmp2 = this.height;
		var tmp3 = this.selectable;
		var tmp4 = this.border;
		var tmp5 = this.dashedBorder;
		var tmp6;
		if(recursive) {
			var _this = this.textRuns;
			var result = new Array(_this.length);
			var _g = 0;
			var _g1 = _this.length;
			while(_g < _g1) {
				var i = _g++;
				result[i] = _this[i].clone();
			}
			tmp6 = result;
		} else {
			tmp6 = this.textRuns;
		}
		var tmp7 = recursive && this.newTextFormat != null ? this.newTextFormat.clone() : this.newTextFormat;
		return tmp._cloneProps(new nanofl_TextField(tmp1,tmp2,tmp3,tmp4,tmp5,tmp6,tmp7));
	}
	,hxUnserialize: function(s) {
		var _gthis = this;
		Object.defineProperty(this,"minWidth",{ get : function() {
			return _gthis.get_minWidth();
		}});
		Object.defineProperty(this,"minHeight",{ get : function() {
			return _gthis.get_minHeight();
		}});
		Object.defineProperty(this,"width",{ get : function() {
			return _gthis.get_width();
		}, set : function(v) {
			_gthis.set_width(v);
		}});
		Object.defineProperty(this,"height",{ get : function() {
			return _gthis.get_height();
		}, set : function(v) {
			_gthis.set_height(v);
		}});
		Object.defineProperty(this,"border",{ get : function() {
			return _gthis.get_border();
		}, set : function(v) {
			_gthis.set_border(v);
		}});
		Object.defineProperty(this,"dashedBorder",{ get : function() {
			return _gthis.get_dashedBorder();
		}, set : function(v) {
			_gthis.set_dashedBorder(v);
		}});
		Object.defineProperty(this,"newTextFormat",{ get : function() {
			return _gthis.get_newTextFormat();
		}, set : function(v) {
			_gthis.set_newTextFormat(v);
		}});
		Object.defineProperty(this,"text",{ get : function() {
			return _gthis.get_text();
		}, set : function(v) {
			_gthis.set_text(v);
		}});
		s.unserializeObject(this);
	}
	,hxSerialize: function(s) {
		s.serializeFields(this);
	}
	,__class__: nanofl_TextField
});
var nanofl_TextRun = $hx_exports["nanofl"]["TextRun"] = function(characters,fillColor,size) {
	if(size == null) {
		size = 12.0;
	}
	if(fillColor == null) {
		fillColor = "#000000";
	}
	if(characters == null) {
		characters = "";
	}
	this.lineSpacing = 2.0;
	this.letterSpacing = 0.0;
	this.kerning = true;
	this.strokeColor = "#000000";
	this.strokeSize = 0.0;
	this.align = "left";
	this.style = "";
	this.family = "Times";
	this.characters = characters;
	this.fillColor = fillColor;
	this.size = size;
};
nanofl_TextRun.__name__ = "nanofl.TextRun";
nanofl_TextRun.create = function(characters,fillColor,family,style,size,align,strokeSize,strokeColor,kerning,letterSpacing,lineSpacing) {
	var r = new nanofl_TextRun();
	r.characters = characters;
	r.fillColor = fillColor;
	r.family = family;
	r.style = style;
	r.size = size;
	r.align = align;
	r.strokeSize = strokeSize;
	r.strokeColor = strokeColor;
	r.kerning = kerning;
	r.letterSpacing = letterSpacing;
	r.lineSpacing = lineSpacing;
	return r;
};
nanofl_TextRun.optimize = function(textRuns) {
	var i = 0;
	while(i < textRuns.length - 1) if(textRuns[i].equFormat(textRuns[i + 1])) {
		textRuns[i].characters += textRuns[i + 1].characters;
		textRuns.splice(i + 1,1);
	} else {
		++i;
	}
	return textRuns;
};
nanofl_TextRun.prototype = {
	getFontString: function() {
		return StringTools.trim((this.style != null ? this.style : "") + " " + (this.size != null ? this.size + "px" : "") + " " + (this.family != null && this.family != "" ? this.family : "serif"));
	}
	,clone: function() {
		return this.duplicate();
	}
	,duplicate: function(characters) {
		var r = nanofl_TextRun.create(characters != null ? characters : this.characters,this.fillColor,this.family,this.style,this.size,this.align,this.strokeSize,this.strokeColor,this.kerning,this.letterSpacing,this.lineSpacing);
		r.backgroundColor = this.backgroundColor;
		return r;
	}
	,equ: function(textRun) {
		if(this.characters == textRun.characters) {
			return this.equFormat(textRun);
		} else {
			return false;
		}
	}
	,createText: function(color,outline) {
		var r = new createjs.Text(this.characters,this.getFontString(),color != null ? color : this.fillColor);
		if(outline != null) {
			r.outline = outline;
		}
		r.textBaseline = "alphabetic";
		r.textAlign = "left";
		return r;
	}
	,isFilled: function() {
		return !this.isEmptyColor(this.fillColor);
	}
	,isStroked: function() {
		if(this.strokeSize != null && this.strokeSize != 0) {
			return !this.isEmptyColor(this.strokeColor);
		} else {
			return false;
		}
	}
	,isEmptyColor: function(s) {
		if(!(s == null || s == "" || s == "transparent" || s == "none")) {
			return new EReg("^\\s*rgba\\s*\\(\\s*\\d+\\s*,\\s*\\d+\\s*,\\s*\\d+\\s*,\\s*0(?:\\.0)?\\s*\\)$","i").match(s);
		} else {
			return true;
		}
	}
	,equFormat: function(format) {
		if(this.fillColor == format.fillColor && this.family == format.family && this.style == format.style && this.size == format.size && this.align == format.align && this.strokeSize == format.strokeSize && this.strokeColor == format.strokeColor && this.kerning == format.kerning && this.letterSpacing == format.letterSpacing) {
			return this.lineSpacing == format.lineSpacing;
		} else {
			return false;
		}
	}
	,__class__: nanofl_TextRun
};
var nanofl_engine_ColorTools = $hx_exports["nanofl"]["engine"]["ColorTools"] = function() { };
nanofl_engine_ColorTools.__name__ = "nanofl.engine.ColorTools";
nanofl_engine_ColorTools.parse = function(s) {
	nanofl_engine_ColorTools.log("parse color " + s,{ fileName : "engine/nanofl/engine/ColorTools.hx", lineNumber : 45, className : "nanofl.engine.ColorTools", methodName : "parse"});
	var r = -1;
	var g = -1;
	var b = -1;
	var a = 1.0;
	s = StringTools.replace(s," ","");
	if(Object.prototype.hasOwnProperty.call(nanofl_engine_ColorTools.colors,s.toLowerCase())) {
		s = Reflect.field(nanofl_engine_ColorTools.colors,s.toLowerCase());
	}
	var reRGB = new EReg("^rgb\\(([0-9]+),([0-9]+),([0-9]+)\\)$","i");
	var reRGBA = new EReg("^rgba\\(([0-9]+),([0-9]+),([0-9]+),([0-9.e+-]+)\\)$","i");
	if(new EReg("^#?[0-9A-F]{6}$","i").match(s)) {
		if(StringTools.startsWith(s,"#")) {
			s = HxOverrides.substr(s,1,null);
		}
		r = Std.parseInt("0x" + HxOverrides.substr(s,0,2));
		g = Std.parseInt("0x" + HxOverrides.substr(s,2,2));
		b = Std.parseInt("0x" + HxOverrides.substr(s,4,2));
	} else if(new EReg("^#?[0-9A-F]{3}$","i").match(s)) {
		if(StringTools.startsWith(s,"#")) {
			s = HxOverrides.substr(s,1,null);
		}
		r = Std.parseInt("0x" + HxOverrides.substr(s,0,1) + HxOverrides.substr(s,0,1));
		g = Std.parseInt("0x" + HxOverrides.substr(s,1,1) + HxOverrides.substr(s,1,1));
		b = Std.parseInt("0x" + HxOverrides.substr(s,2,1) + HxOverrides.substr(s,2,1));
	} else if(reRGB.match(s)) {
		r = Std.parseInt(reRGB.matched(1));
		g = Std.parseInt(reRGB.matched(2));
		b = Std.parseInt(reRGB.matched(3));
	} else if(reRGBA.match(s)) {
		r = Std.parseInt(reRGBA.matched(1));
		g = Std.parseInt(reRGBA.matched(2));
		b = Std.parseInt(reRGBA.matched(3));
		a = parseFloat(reRGBA.matched(4));
	}
	if(r >= 0 && g >= 0 && b >= 0) {
		return { r : r, g : g, b : b, a : a};
	}
	return null;
};
nanofl_engine_ColorTools.joinStringAndAlpha = function(color,alpha) {
	var rgba = nanofl_engine_ColorTools.parse(color);
	if(rgba != null) {
		if(alpha != null) {
			rgba.a = alpha;
		}
		return nanofl_engine_ColorTools.rgbaToString(rgba);
	}
	return null;
};
nanofl_engine_ColorTools.stringToNumber = function(color,defValue) {
	var rgba = nanofl_engine_ColorTools.parse(color);
	if(rgba != null) {
		return nanofl_engine_ColorTools.rgbaToNumber(rgba);
	} else {
		return defValue;
	}
};
nanofl_engine_ColorTools.rgbaToString = function(rgba) {
	if(rgba.a == null || rgba.a == 1.0) {
		return "#" + StringTools.hex(rgba.r,2) + StringTools.hex(rgba.g,2) + StringTools.hex(rgba.b,2);
	} else {
		return "rgba(" + rgba.r + "," + rgba.g + "," + rgba.b + "," + rgba.a + ")";
	}
};
nanofl_engine_ColorTools.rgbaToNumber = function(rgba) {
	if(rgba.a == null || rgba.a == 1.0) {
		return rgba.r << 16 | rgba.g << 8 | rgba.b;
	} else {
		return Math.round(rgba.a * 255) << 24 | rgba.r << 16 | rgba.g << 8 | rgba.b;
	}
};
nanofl_engine_ColorTools.rgbToHsl = function(rgb) {
	var r = rgb.r / 255;
	var g = rgb.g / 255;
	var b = rgb.b / 255;
	var max = Math.max(r,Math.max(g,b));
	var min = Math.min(r,Math.min(g,b));
	var h;
	var s;
	var l = (max + min) / 2;
	if(max == min) {
		s = 0.0;
		h = s;
	} else {
		var d = max - min;
		s = l > 0.5 ? d / (2 - max - min) : d / (max + min);
		if(max == r) {
			h = (g - b) / d + (g < b ? 6 : 0);
		} else if(max == g) {
			h = (b - r) / d + 2;
		} else {
			h = (r - g) / d + 4;
		}
		h /= 6;
	}
	return { h : h, s : s, l : l};
};
nanofl_engine_ColorTools.hslToRgb = function(hsl) {
	var r;
	var g;
	var b;
	if(hsl.s == 0.0) {
		b = hsl.l;
		g = b;
		r = g;
	} else {
		var hue2rgb = function(p,q,t) {
			if(t < 0) {
				++t;
			}
			if(t > 1) {
				--t;
			}
			if(t < 0.16666666666666666) {
				return p + (q - p) * 6 * t;
			}
			if(t < 0.5) {
				return q;
			}
			if(t < 0.66666666666666663) {
				return p + (q - p) * (0.66666666666666663 - t) * 6;
			}
			return p;
		};
		var q = hsl.l < 0.5 ? hsl.l * (1 + hsl.s) : hsl.l + hsl.s - hsl.l * hsl.s;
		var p = 2 * hsl.l - q;
		r = hue2rgb(p,q,hsl.h + 0.33333333333333331);
		g = hue2rgb(p,q,hsl.h);
		b = hue2rgb(p,q,hsl.h - 0.33333333333333331);
	}
	return { r : r * 255 | 0, g : g * 255 | 0, b : b * 255 | 0};
};
nanofl_engine_ColorTools.rgbToHsv = function(rgb) {
	var r = rgb.r / 255;
	var g = rgb.g / 255;
	var b = rgb.b / 255;
	var max = Math.max(r,Math.max(g,b));
	var min = Math.min(r,Math.min(g,b));
	var h;
	var v = max;
	var d = max - min;
	var s = max == 0 ? 0 : d / max;
	if(max == min) {
		h = 0;
	} else {
		if(max == r) {
			h = (g - b) / d + (g < b ? 6 : 0);
		} else if(max == g) {
			h = (b - r) / d + 2;
		} else {
			h = (r - g) / d + 4;
		}
		h /= 6;
	}
	return { h : h, s : s, v : v};
};
nanofl_engine_ColorTools.hsvToRgb = function(hsv) {
	var r;
	var g;
	var b;
	var i = Math.floor(hsv.h * 6);
	var f = hsv.h * 6 - i;
	var p = hsv.v * (1 - hsv.s);
	var q = hsv.v * (1 - f * hsv.s);
	var t = hsv.v * (1 - (1 - f) * hsv.s);
	switch(i % 6) {
	case 0:
		r = hsv.v;
		g = t;
		b = p;
		break;
	case 1:
		r = q;
		g = hsv.v;
		b = p;
		break;
	case 2:
		r = p;
		g = hsv.v;
		b = t;
		break;
	case 3:
		r = p;
		g = q;
		b = hsv.v;
		break;
	case 4:
		r = t;
		g = p;
		b = hsv.v;
		break;
	default:
		r = hsv.v;
		g = p;
		b = q;
	}
	return { r : r * 255 | 0, g : g * 255 | 0, b : b * 255 | 0};
};
nanofl_engine_ColorTools.tweenRgba = function(start,finish,t) {
	var r = nanofl_engine_ColorTools.hslToRgb(nanofl_engine_ColorTools.tweenHsl(nanofl_engine_ColorTools.rgbToHsl(start),nanofl_engine_ColorTools.rgbToHsl(finish),t));
	if(start.a != null || finish.a != null) {
		var a1 = start.a != null ? start.a : 1.0;
		var a2 = finish.a != null ? finish.a : 1.0;
		r.a = a1 + (a2 - a1) * t;
	}
	return r;
};
nanofl_engine_ColorTools.tweenHsl = function(start,finish,t) {
	return { h : start.h + (finish.h - start.h) * t, s : start.s + (finish.s - start.s) * t, l : start.l + (finish.l - start.l) * t};
};
nanofl_engine_ColorTools.normalize = function(s) {
	if(s == null) {
		return null;
	}
	if(s == "") {
		return "";
	}
	return nanofl_engine_ColorTools.rgbaToString(nanofl_engine_ColorTools.parse(s));
};
nanofl_engine_ColorTools.getTweened = function(start,k,finish) {
	var rgbaStart = nanofl_engine_ColorTools.parse(start);
	var rgbaFinish = nanofl_engine_ColorTools.parse(finish);
	return nanofl_engine_ColorTools.rgbaToString({ r : rgbaStart.r + Math.round((rgbaFinish.r - rgbaStart.r) * k), g : rgbaStart.g + Math.round((rgbaFinish.g - rgbaStart.g) * k), b : rgbaStart.b + Math.round((rgbaFinish.b - rgbaStart.b) * k), a : rgbaStart.a + (rgbaFinish.a - rgbaStart.a) * k});
};
nanofl_engine_ColorTools.log = function(v,infos) {
};
var nanofl_engine_Console = function() {
};
nanofl_engine_Console.__name__ = "nanofl.engine.Console";
nanofl_engine_Console.filter = function(method,filter) {
	if($global.console == null) {
		return null;
	}
	var r = Reflect.field($global.console,method);
	$global.console[method] = nanofl_engine_Console.getFilterFunction(r,filter);
	return r;
};
nanofl_engine_Console.getFilterFunction = function(oldConsoleMethod,filter) {
	return Reflect.makeVarArgs(function(args) {
		if(filter(args)) {
			var o = $global.console;
			oldConsoleMethod.apply(o,args);
		}
	});
};
nanofl_engine_Console.prototype = {
	log: function(v) {
		$global.console.log(v);
	}
	,info: function(v) {
		$global.console.info(v);
	}
	,warn: function(v) {
		$global.console.warn(v);
	}
	,error: function(v) {
		$global.console.error(v);
	}
	,__class__: nanofl_engine_Console
};
var nanofl_engine_CustomPropertiesTools = function() { };
nanofl_engine_CustomPropertiesTools.__name__ = "nanofl.engine.CustomPropertiesTools";
nanofl_engine_CustomPropertiesTools.equ = function(params1,params2) {
	var fields1 = Reflect.fields(params1);
	var fields2 = Reflect.fields(params2);
	if(fields1.length != fields2.length) {
		return false;
	}
	fields1.sort(Reflect.compare);
	fields2.sort(Reflect.compare);
	var _g = 0;
	var _g1 = fields1.length;
	while(_g < _g1) {
		var i = _g++;
		if(fields1[i] != fields2[i]) {
			return false;
		}
		if(Reflect.field(params1,fields1[i]) != Reflect.field(params2,fields1[i])) {
			return false;
		}
	}
	return true;
};
nanofl_engine_CustomPropertiesTools.tween = function(start,t,finish,properties) {
	if(t == 0.0 || properties == null) {
		return;
	}
	var _g = 0;
	while(_g < properties.length) {
		var p = properties[_g];
		++_g;
		if(p.type == "delimiter" || p.type == "info") {
			continue;
		}
		var startV = Reflect.field(start,p.name);
		var finishV = finish != null ? Reflect.field(finish,p.name) : p.neutralValue != null ? p.neutralValue : startV;
		switch(p.type.toLowerCase()) {
		case "color":
			start[p.name] = nanofl_engine_ColorTools.rgbaToString(nanofl_engine_ColorTools.tweenRgba(nanofl_engine_ColorTools.parse(startV),nanofl_engine_ColorTools.parse(finishV),t));
			break;
		case "float":case "int":
			start[p.name] = startV + (finishV - startV) * t;
			break;
		default:
			start[p.name] = startV;
		}
	}
};
nanofl_engine_CustomPropertiesTools.fix = function(params,properties) {
	if(properties == null) {
		return params;
	}
	var _g = 0;
	while(_g < properties.length) {
		var p = properties[_g];
		++_g;
		if(p.type == "delimiter" || p.type == "info") {
			continue;
		}
		var v = Reflect.field(params,p.name);
		if(v == null) {
			params[p.name] = p.defaultValue;
		} else {
			switch(p.type) {
			case "bool":
				params[p.name] = typeof(v) == "string" ? stdlib_Std.bool(v) : v;
				break;
			case "float":
				params[p.name] = typeof(v) == "string" ? stdlib_Std.parseFloat(v) : v;
				break;
			case "int":
				params[p.name] = typeof(v) == "string" ? stdlib_Std.parseInt(v) : v;
				break;
			default:
				params[p.name] = v;
			}
		}
	}
	return params;
};
nanofl_engine_CustomPropertiesTools.resetToNeutral = function(params,properties) {
	var _g = 0;
	while(_g < properties.length) {
		var p = properties[_g];
		++_g;
		if(p.type == "delimiter" || p.type == "info") {
			continue;
		}
		if(p.neutralValue != null) {
			params[p.name] = p.neutralValue;
		}
	}
};
var nanofl_engine_Debug = function() { };
nanofl_engine_Debug.__name__ = "nanofl.engine.Debug";
var nanofl_engine_DrawTools = function() { };
nanofl_engine_DrawTools.__name__ = "nanofl.engine.DrawTools";
nanofl_engine_DrawTools.drawDashedLine = function(g,x1,y1,x2,y2,color1,color2,dashLen) {
	if(dashLen == null) {
		dashLen = 2.0;
	}
	var dX = x2 - x1;
	var dY = y2 - y1;
	var dashes = Math.floor(Math.sqrt(dX * dX + dY * dY) / dashLen);
	var dashX = dX / dashes;
	var dashY = dY / dashes;
	g.beginStroke(color1);
	var x = x1;
	var y = y1;
	g.moveTo(x,y);
	var q = 0;
	while(q++ < dashes) {
		x += dashX;
		y += dashY;
		if(q % 2 == 0) {
			g.moveTo(x,y);
		} else {
			g.lineTo(x,y);
		}
	}
	if(q % 2 == 0) {
		g.moveTo(x2,y2);
	} else {
		g.lineTo(x2,y2);
	}
	g.endStroke();
	if(color2 != null) {
		g.beginStroke(color2);
		x = x1 + dashX;
		y = y1 + dashY;
		g.moveTo(x,y);
		q = 1;
		while(q++ < dashes) {
			x += dashX;
			y += dashY;
			if(q % 2 == 1) {
				g.moveTo(x,y);
			} else {
				g.lineTo(x,y);
			}
		}
		if(q % 2 == 1) {
			g.moveTo(x2,y2);
		} else {
			g.lineTo(x2,y2);
		}
		g.endStroke();
	}
	return g;
};
nanofl_engine_DrawTools.drawDashedRect = function(g,x1,y1,x2,y2,color1,color2,dashLen) {
	if(dashLen == null) {
		dashLen = 2.0;
	}
	nanofl_engine_DrawTools.drawDashedLine(g,x1,y1,x2,y1,color1,color2,dashLen);
	nanofl_engine_DrawTools.drawDashedLine(g,x2,y1,x2,y2,color1,color2,dashLen);
	nanofl_engine_DrawTools.drawDashedLine(g,x2,y2,x1,y2,color1,color2,dashLen);
	nanofl_engine_DrawTools.drawDashedLine(g,x1,y2,x1,y1,color1,color2,dashLen);
	return g;
};
var nanofl_engine_ElementType = $hxEnums["nanofl.engine.ElementType"] = { __ename__:"nanofl.engine.ElementType",__constructs__:null
	,shape: {_hx_name:"shape",_hx_index:0,__enum__:"nanofl.engine.ElementType",toString:$estr}
	,instance: {_hx_name:"instance",_hx_index:1,__enum__:"nanofl.engine.ElementType",toString:$estr}
	,group: {_hx_name:"group",_hx_index:2,__enum__:"nanofl.engine.ElementType",toString:$estr}
	,text: {_hx_name:"text",_hx_index:3,__enum__:"nanofl.engine.ElementType",toString:$estr}
	,spriteFrame: {_hx_name:"spriteFrame",_hx_index:4,__enum__:"nanofl.engine.ElementType",toString:$estr}
};
nanofl_engine_ElementType.__constructs__ = [nanofl_engine_ElementType.shape,nanofl_engine_ElementType.instance,nanofl_engine_ElementType.group,nanofl_engine_ElementType.text,nanofl_engine_ElementType.spriteFrame];
var nanofl_engine_FilterDef = function(name,params) {
	stdlib_Debug.assert(params != null,null,{ fileName : "engine/nanofl/engine/FilterDef.hx", lineNumber : 27, className : "nanofl.engine.FilterDef", methodName : "new"});
	this.name = name;
	this._params = params;
};
nanofl_engine_FilterDef.__name__ = "nanofl.engine.FilterDef";
nanofl_engine_FilterDef.load = function(node,version) {
	if(node == null) {
		return null;
	}
	var params = { };
	var _g = 0;
	var _g1 = node.attributes;
	while(_g < _g1.length) {
		var attr = _g1[_g];
		++_g;
		params[attr.name] = attr.value;
	}
	var _g = new haxe_ds_StringMap();
	_g.h["1.0.0"] = function() {
		if(node.name != "BlurFilter") {
			return node.name;
		}
		nanofl_engine_FilterDef.fixParam(params,"blurX",function(s) {
			return Std.string(Std.parseInt(s) * 2);
		});
		nanofl_engine_FilterDef.fixParam(params,"blurY",function(s) {
			return Std.string(Std.parseInt(s) * 2);
		});
		return "BoxBlurFilter";
	};
	_g.h["2.0.0"] = function() {
		return node.name;
	};
	var name = nanofl_engine_Version.handle(version,_g);
	return new nanofl_engine_FilterDef(name,params);
};
nanofl_engine_FilterDef.loadJson = function(obj,version) {
	return new nanofl_engine_FilterDef(obj.name,obj.params);
};
nanofl_engine_FilterDef.fixParam = function(params,name,fixFunc) {
	if(Object.prototype.hasOwnProperty.call(params,name)) {
		params[name] = fixFunc(Reflect.field(params,name));
	}
};
nanofl_engine_FilterDef.prototype = {
	get_params: function() {
		if(this.isParamsFixed || !Object.prototype.hasOwnProperty.call(nanofl_engine_plugins_FilterPlugins.plugins.h,this.name)) {
			return this._params;
		}
		this.isParamsFixed = true;
		return nanofl_engine_CustomPropertiesTools.fix(this._params,this.getProperties());
	}
	,save: function(out) {
		out.begin(this.name);
		var names = Reflect.fields(this._params);
		names.sort(Reflect.compare);
		var _g = 0;
		while(_g < names.length) {
			var name = names[_g];
			++_g;
			out.attr(name,Reflect.field(this._params,name));
		}
		out.end();
	}
	,saveJson: function() {
		return { name : this.name, params : this._params};
	}
	,equ: function(filter) {
		if(filter.name == this.name) {
			return nanofl_engine_CustomPropertiesTools.equ(filter.get_params(),this.get_params());
		} else {
			return false;
		}
	}
	,clone: function() {
		var r = new nanofl_engine_FilterDef(this.name,Reflect.copy(this._params));
		r.isParamsFixed = this.isParamsFixed;
		return r;
	}
	,tween: function(t,finish) {
		stdlib_Debug.assert(finish == null || this.name == finish.name,this.name + " != " + finish.name,{ fileName : "engine/nanofl/engine/FilterDef.hx", lineNumber : 113, className : "nanofl.engine.FilterDef", methodName : "tween"});
		if(t == 0.0 || !Object.prototype.hasOwnProperty.call(nanofl_engine_plugins_FilterPlugins.plugins.h,this.name)) {
			return this;
		}
		var plugin = nanofl_engine_plugins_FilterPlugins.plugins.h[this.name];
		nanofl_engine_CustomPropertiesTools.tween(this.get_params(),t,finish != null ? finish.get_params() : null,plugin != null ? plugin.properties : null);
		return this;
	}
	,getFilter: function() {
		if(Object.prototype.hasOwnProperty.call(nanofl_engine_plugins_FilterPlugins.plugins.h,this.name)) {
			return nanofl_engine_plugins_FilterPlugins.plugins.h[this.name].getFilter(this.get_params());
		} else {
			return null;
		}
	}
	,getLabel: function() {
		if(Object.prototype.hasOwnProperty.call(nanofl_engine_plugins_FilterPlugins.plugins.h,this.name)) {
			return nanofl_engine_plugins_FilterPlugins.plugins.h[this.name].label;
		} else {
			return this.name;
		}
	}
	,getProperties: function() {
		if(Object.prototype.hasOwnProperty.call(nanofl_engine_plugins_FilterPlugins.plugins.h,this.name)) {
			return nanofl_engine_plugins_FilterPlugins.plugins.h[this.name].properties;
		} else {
			return [];
		}
	}
	,resetToNeutral: function() {
		var plugin = nanofl_engine_plugins_FilterPlugins.plugins.h[this.name];
		if(plugin != null) {
			nanofl_engine_CustomPropertiesTools.resetToNeutral(this.get_params(),plugin.properties);
		}
		return this;
	}
	,__class__: nanofl_engine_FilterDef
};
var nanofl_engine_FontVariant = function(style,weight,locals,urls) {
	if(weight == null) {
		weight = 400;
	}
	if(style == null) {
		style = "normal";
	}
	this.style = style;
	this.weight = weight;
	this.locals = locals != null ? locals : [];
	this.urls = urls != null ? urls : new haxe_ds_StringMap();
};
nanofl_engine_FontVariant.__name__ = "nanofl.engine.FontVariant";
nanofl_engine_FontVariant.prototype = {
	equ: function(e) {
		if(e.style == this.style && e.weight == this.weight) {
			return datatools_MapTools.equFast(e.urls,this.urls);
		} else {
			return false;
		}
	}
	,getUrlByFormats: function(formats) {
		var _g = 0;
		while(_g < formats.length) {
			var format = formats[_g];
			++_g;
			if(Object.prototype.hasOwnProperty.call(this.urls.h,format)) {
				return this.urls.h[format];
			}
		}
		return null;
	}
	,__class__: nanofl_engine_FontVariant
};
var nanofl_engine_IElementsContainer = function() { };
nanofl_engine_IElementsContainer.__name__ = "nanofl.engine.IElementsContainer";
nanofl_engine_IElementsContainer.__isInterface__ = true;
nanofl_engine_IElementsContainer.prototype = {
	__class__: nanofl_engine_IElementsContainer
};
var nanofl_engine_movieclip_KeyFrame = function(label,duration,motionTween,elements) {
	if(duration == null) {
		duration = 1;
	}
	if(label == null) {
		label = "";
	}
	this.label = label;
	this.duration = duration;
	this._elements = elements != null ? elements : [];
	var _g = 0;
	var _g1 = this.get_elements();
	while(_g < _g1.length) {
		var element = _g1[_g];
		++_g;
		element.parent = this;
	}
	if(motionTween != null) {
		this.motionTween = motionTween;
		motionTween.keyFrame = this;
	}
};
nanofl_engine_movieclip_KeyFrame.__name__ = "nanofl.engine.movieclip.KeyFrame";
nanofl_engine_movieclip_KeyFrame.__interfaces__ = [nanofl_engine_IElementsContainer];
nanofl_engine_movieclip_KeyFrame.parseJson = function(obj,version) {
	return new nanofl_engine_movieclip_KeyFrame(obj.label,obj.duration,nanofl_engine_movieclip_MotionTween.loadJson(obj.motionTween),nanofl_engine_elements_Elements.parseJson(obj.elements,version));
};
nanofl_engine_movieclip_KeyFrame.prototype = {
	get_elements: function() {
		return this._elements;
	}
	,getNextKeyFrame: function() {
		return this.layer._keyFrames[this.getKeyIndex() + 1];
	}
	,getKeyIndex: function() {
		return this.layer._keyFrames.indexOf(this);
	}
	,addElement: function(element,index) {
		if(index == null) {
			this._elements.push(element);
		} else {
			this._elements.splice(index,0,element);
		}
		element.parent = this;
	}
	,removeElementAt: function(n) {
		this._elements.splice(n,1);
	}
	,removeElement: function(element) {
		var n = this.get_elements().indexOf(element);
		if(n >= 0) {
			this.removeElementAt(n);
		}
	}
	,swapElement: function(i,j) {
		var element = this.get_elements()[i];
		this._elements[i] = this.get_elements()[j];
		this._elements[j] = element;
	}
	,isEmpty: function() {
		if(this.get_elements().length != 0) {
			if(this.get_elements().length == 1 && ((this.get_elements()[0]) instanceof nanofl_engine_elements_ShapeElement)) {
				return this.get_elements()[0].isEmpty();
			} else {
				return false;
			}
		} else {
			return true;
		}
	}
	,getElementsState: function() {
		return { elements : this._elements.slice()};
	}
	,setElementsState: function(state) {
		this._elements = state.elements.slice();
	}
	,getTweenedElements: function(frameSubIndex) {
		if(this.motionTween != null && frameSubIndex != 0) {
			return this.motionTween.apply(frameSubIndex);
		} else {
			var _this = this.get_elements();
			var result = new Array(_this.length);
			var _g = 0;
			var _g1 = _this.length;
			while(_g < _g1) {
				var i = _g++;
				var x = _this[i];
				result[i] = new nanofl_engine_movieclip_TweenedElement(x,x);
			}
			return result;
		}
	}
	,setLibrary: function(library) {
		var _g = 0;
		var _g1 = this.get_elements();
		while(_g < _g1.length) {
			var element = _g1[_g];
			++_g;
			element.setLibrary(library);
		}
	}
	,toString: function() {
		return (this.layer != null ? this.layer.toString() + " / " : "") + "frame";
	}
	,getIndex: function() {
		var r = 0;
		var _g = 0;
		var _g1 = this.getKeyIndex();
		while(_g < _g1) {
			var i = _g++;
			r += this.layer._keyFrames[i].duration;
		}
		return r;
	}
	,hasGoodMotionTween: function() {
		if(this.motionTween == null) {
			return false;
		}
		if(this.getNextKeyFrame() == null) {
			return false;
		}
		return this.motionTween.isGood();
	}
	,getParentLayerFrame: function(frameSubIndex) {
		var parentLayer = this.layer.get_parentLayer();
		if(parentLayer == null) {
			return null;
		}
		return parentLayer.getFrame(this.getIndex() + frameSubIndex);
	}
	,clone: function() {
		return this.duplicate();
	}
	,hasMotionTween: function() {
		return this.motionTween != null;
	}
	,removeMotionTween: function() {
		this.motionTween = null;
	}
	,getGuideLine: function() {
		return new nanofl_engine_movieclip_GuideLine(this.getShape(false));
	}
	,getShape: function(createIfNotExist) {
		if(this.get_elements().length > 0 && ((this.get_elements()[0]) instanceof nanofl_engine_elements_ShapeElement)) {
			return this.get_elements()[0];
		}
		if(createIfNotExist) {
			var shape = new nanofl_engine_elements_ShapeElement();
			this.addElement(shape,0);
			return shape;
		}
		return null;
	}
	,duplicate: function(label,duration,elements) {
		return new nanofl_engine_movieclip_KeyFrame(label != null ? label : this.label,duration != null ? duration : this.duration,this.motionTween != null ? this.motionTween.clone() : null,elements != null ? datatools_ArrayTools.clone(elements) : datatools_ArrayTools.clone(this._elements));
	}
	,equ: function(keyFrame) {
		if(keyFrame.label != this.label) {
			return false;
		}
		if(keyFrame.duration != this.duration) {
			return false;
		}
		if(keyFrame.motionTween == null && this.motionTween != null) {
			return false;
		}
		if(keyFrame.motionTween != null && this.motionTween == null) {
			return false;
		}
		if(keyFrame.motionTween != null && this.motionTween != null && !keyFrame.motionTween.equ(this.motionTween)) {
			return false;
		}
		if(!datatools_ArrayTools.equ(this.getElementsWithoutEmptyShapes(keyFrame._elements),this.getElementsWithoutEmptyShapes(this._elements))) {
			return false;
		}
		return true;
	}
	,getMotionTween: function() {
		return this.motionTween;
	}
	,addDefaultMotionTween: function() {
		var mt = new nanofl_engine_movieclip_MotionTween(0,false,0,0,0,0,0);
		mt.keyFrame = this;
		this.motionTween = mt;
	}
	,getElementsWithoutEmptyShapes: function(elements) {
		var _g = [];
		var _g1 = 0;
		var _g2 = elements;
		while(_g1 < _g2.length) {
			var v = _g2[_g1];
			++_g1;
			if(!((v) instanceof nanofl_engine_elements_ShapeElement) || !v.isEmpty()) {
				_g.push(v);
			}
		}
		return _g;
	}
	,__class__: nanofl_engine_movieclip_KeyFrame
};
var nanofl_engine_GroupKeyFrame = function(group) {
	nanofl_engine_movieclip_KeyFrame.call(this,null,null,null,group._elements);
	this.group = group;
	var _g = 0;
	var _g1 = this.get_elements();
	while(_g < _g1.length) {
		var element = _g1[_g];
		++_g;
		element.parent = group;
	}
};
nanofl_engine_GroupKeyFrame.__name__ = "nanofl.engine.GroupKeyFrame";
nanofl_engine_GroupKeyFrame.__super__ = nanofl_engine_movieclip_KeyFrame;
nanofl_engine_GroupKeyFrame.prototype = $extend(nanofl_engine_movieclip_KeyFrame.prototype,{
	addElement: function(element,index) {
		nanofl_engine_movieclip_KeyFrame.prototype.addElement.call(this,element,index);
		element.parent = this.group;
	}
	,duplicate: function(label,duration,elements) {
		return stdlib_Debug.methodNotSupported(this,{ fileName : "engine/nanofl/engine/GroupKeyFrame.hx", lineNumber : 24, className : "nanofl.engine.GroupKeyFrame", methodName : "duplicate"});
	}
	,__class__: nanofl_engine_GroupKeyFrame
});
var nanofl_engine_IFramedItem = function() { };
nanofl_engine_IFramedItem.__name__ = "nanofl.engine.IFramedItem";
nanofl_engine_IFramedItem.__isInterface__ = true;
nanofl_engine_IFramedItem.prototype = {
	__class__: nanofl_engine_IFramedItem
};
var nanofl_engine_IInstance = function() { };
nanofl_engine_IInstance.__name__ = "nanofl.engine.IInstance";
nanofl_engine_IInstance.__isInterface__ = true;
nanofl_engine_IInstance.prototype = {
	__class__: nanofl_engine_IInstance
};
var nanofl_engine_ILayersContainer = function() { };
nanofl_engine_ILayersContainer.__name__ = "nanofl.engine.ILayersContainer";
nanofl_engine_ILayersContainer.__isInterface__ = true;
nanofl_engine_ILayersContainer.prototype = {
	__class__: nanofl_engine_ILayersContainer
};
var nanofl_engine_ILibraryItem = function() { };
nanofl_engine_ILibraryItem.__name__ = "nanofl.engine.ILibraryItem";
nanofl_engine_ILibraryItem.__isInterface__ = true;
nanofl_engine_ILibraryItem.prototype = {
	__class__: nanofl_engine_ILibraryItem
};
var nanofl_engine_IMotionTween = function() { };
nanofl_engine_IMotionTween.__name__ = "nanofl.engine.IMotionTween";
nanofl_engine_IMotionTween.__isInterface__ = true;
nanofl_engine_IMotionTween.prototype = {
	__class__: nanofl_engine_IMotionTween
};
var nanofl_engine_IPathElement = function() { };
nanofl_engine_IPathElement.__name__ = "nanofl.engine.IPathElement";
nanofl_engine_IPathElement.__isInterface__ = true;
nanofl_engine_IPathElement.__interfaces__ = [nanofl_engine_ILayersContainer];
nanofl_engine_IPathElement.prototype = {
	__class__: nanofl_engine_IPathElement
};
var nanofl_engine_ISelectable = function() { };
nanofl_engine_ISelectable.__name__ = "nanofl.engine.ISelectable";
nanofl_engine_ISelectable.__isInterface__ = true;
nanofl_engine_ISelectable.prototype = {
	__class__: nanofl_engine_ISelectable
};
var nanofl_engine_ISpriteSheetableItem = function() { };
nanofl_engine_ISpriteSheetableItem.__name__ = "nanofl.engine.ISpriteSheetableItem";
nanofl_engine_ISpriteSheetableItem.__isInterface__ = true;
nanofl_engine_ISpriteSheetableItem.prototype = {
	__class__: nanofl_engine_ISpriteSheetableItem
};
var nanofl_engine_ITextureItem = function() { };
nanofl_engine_ITextureItem.__name__ = "nanofl.engine.ITextureItem";
nanofl_engine_ITextureItem.__isInterface__ = true;
nanofl_engine_ITextureItem.prototype = {
	__class__: nanofl_engine_ITextureItem
};
var nanofl_engine_ITimeline = function() { };
nanofl_engine_ITimeline.__name__ = "nanofl.engine.ITimeline";
nanofl_engine_ITimeline.__isInterface__ = true;
nanofl_engine_ITimeline.prototype = {
	__class__: nanofl_engine_ITimeline
};
var nanofl_engine_LayerType = $hxEnums["nanofl.engine.LayerType"] = { __ename__:"nanofl.engine.LayerType",__constructs__:null
	,normal: {_hx_name:"normal",_hx_index:0,__enum__:"nanofl.engine.LayerType",toString:$estr}
	,mask: {_hx_name:"mask",_hx_index:1,__enum__:"nanofl.engine.LayerType",toString:$estr}
	,folder: {_hx_name:"folder",_hx_index:2,__enum__:"nanofl.engine.LayerType",toString:$estr}
	,guide: {_hx_name:"guide",_hx_index:3,__enum__:"nanofl.engine.LayerType",toString:$estr}
};
nanofl_engine_LayerType.__constructs__ = [nanofl_engine_LayerType.normal,nanofl_engine_LayerType.mask,nanofl_engine_LayerType.folder,nanofl_engine_LayerType.guide];
var nanofl_engine_LayersTools = function() { };
nanofl_engine_LayersTools.__name__ = "nanofl.engine.LayersTools";
nanofl_engine_LayersTools.addLayer = function(obj,layer) {
	layer.layersContainer = obj;
	obj._layers.push(layer);
};
nanofl_engine_LayersTools.addLayersBlock = function(obj,layersToAdd,index) {
	if(index == null || index < 0 || index > obj._layers.length) {
		index = obj._layers.length;
	}
	var _g = 0;
	var _g1 = obj._layers;
	while(_g < _g1.length) {
		var layer = _g1[_g];
		++_g;
		if(layer.parentIndex != null && layer.parentIndex >= index) {
			layer.parentIndex += layersToAdd.length;
		}
	}
	var n = index;
	var _g = 0;
	while(_g < layersToAdd.length) {
		var layer = layersToAdd[_g];
		++_g;
		layer.layersContainer = obj;
		if(layer.parentIndex != null) {
			layer.parentIndex += index;
		}
		obj._layers.splice(n,0,layer);
		++n;
	}
};
nanofl_engine_LayersTools.removeLayer = function(obj,index) {
	obj._layers.splice(index,1);
	var _g = 0;
	var _g1 = obj._layers;
	while(_g < _g1.length) {
		var layer = _g1[_g];
		++_g;
		if(layer.parentIndex != null) {
			if(layer.parentIndex == index) {
				layer.parentIndex = null;
			} else if(layer.parentIndex > index) {
				layer.parentIndex--;
			}
		}
	}
};
nanofl_engine_LayersTools.removeLayerWithChildren = function(obj,index) {
	var n = index + 1;
	while(n < obj._layers.length && nanofl_engine_LayersTools.isLayerChildOf(obj,n,index)) ++n;
	var _g = 0;
	var _g1 = obj._layers.slice(n);
	while(_g < _g1.length) {
		var layer = _g1[_g];
		++_g;
		if(layer.parentIndex != null) {
			layer.parentIndex -= n - index;
		}
	}
	var removedLayers = obj._layers.splice(index,n - index);
	var _g = 0;
	while(_g < removedLayers.length) {
		var layer = removedLayers[_g];
		++_g;
		layer.parentIndex -= index;
	}
	removedLayers[0].parentIndex = null;
	return removedLayers;
};
nanofl_engine_LayersTools.isLayerChildOf = function(obj,childIndex,parentIndex) {
	var pi = obj._layers[childIndex].parentIndex;
	if(pi == null) {
		return false;
	}
	if(pi == parentIndex) {
		return true;
	}
	return nanofl_engine_LayersTools.isLayerChildOf(obj,pi,parentIndex);
};
nanofl_engine_LayersTools.getFramesAt = function(obj,frameIndex) {
	var r = [];
	var i = obj.get_layers().length - 1;
	while(i >= 0) {
		if(obj.get_layers()[i].visible) {
			var frame = obj.get_layers()[i].getFrame(frameIndex);
			if(frame != null) {
				r.push(frame);
			}
		}
		--i;
	}
	return r;
};
nanofl_engine_LayersTools.getTotalFrames = function(obj) {
	var r = 0;
	var _g = 0;
	var _g1 = obj.get_layers();
	while(_g < _g1.length) {
		var layer = _g1[_g];
		++_g;
		var b = layer.getTotalFrames();
		if(r <= b) {
			r = b;
		}
	}
	return r;
};
var nanofl_engine_Library = function(libraryDir,items) {
	this.items = new haxe_ds_StringMap();
	this.libraryDir = libraryDir;
	if(items != null) {
		var _g = 0;
		var _g1 = items;
		while(_g < _g1.length) {
			var item = _g1[_g];
			++_g;
			this.addItem(item);
		}
	}
};
nanofl_engine_Library.__name__ = "nanofl.engine.Library";
nanofl_engine_Library.loadFromJson = function(libraryDir,obj) {
	var _this = Reflect.fields(obj);
	var result = new Array(_this.length);
	var _g = 0;
	var _g1 = _this.length;
	while(_g < _g1) {
		var i = _g++;
		var namePath = _this[i];
		result[i] = nanofl_engine_libraryitems_LibraryItem.loadFromJson(namePath,Reflect.field(obj,namePath));
	}
	var items = result;
	return new nanofl_engine_Library(libraryDir,items);
};
nanofl_engine_Library.prototype = {
	addItem: function(item) {
		item.setLibrary(this);
		this.items.h[item.namePath] = item;
		this.ensureFolderOfItemExists(item.namePath);
	}
	,removeItem: function(namePath) {
		var _g = 0;
		var _g1 = this.getItemsInFolder(namePath);
		while(_g < _g1.length) {
			var item = _g1[_g];
			++_g;
			this.removeItemInner(item.namePath);
		}
		this.removeItemInner(namePath);
	}
	,removeItemInner: function(namePath) {
		var itemToRemove = this.getItem(namePath);
		var _this = this.items;
		if(Object.prototype.hasOwnProperty.call(_this.h,namePath)) {
			delete(_this.h[namePath]);
		}
		if(((itemToRemove) instanceof nanofl_engine_libraryitems_InstancableItem)) {
			var instances = [];
			var h = this.items.h;
			var item_h = h;
			var item_keys = Object.keys(h);
			var item_length = item_keys.length;
			var item_current = 0;
			while(item_current < item_length) {
				var item = item_h[item_keys[item_current++]];
				if(((item) instanceof nanofl_engine_libraryitems_MovieClipItem)) {
					nanofl_engine_MovieClipItemTools.iterateInstances(item,true,null,function(instance,_) {
						if(instance.namePath == namePath) {
							instances.push(instance);
						}
					});
				}
			}
			var _g = 0;
			while(_g < instances.length) {
				var instance = instances[_g];
				++_g;
				instance.parent.removeElement(instance);
			}
		}
	}
	,getItem: function(namePath) {
		stdlib_Debug.assert(namePath != null,null,{ fileName : "engine/nanofl/engine/Library.hx", lineNumber : 72, className : "nanofl.engine.Library", methodName : "getItem"});
		stdlib_Debug.assert(namePath != "",null,{ fileName : "engine/nanofl/engine/Library.hx", lineNumber : 73, className : "nanofl.engine.Library", methodName : "getItem"});
		var r = this.items.h[namePath];
		if(r != null) {
			return r;
		}
		haxe_Log.trace("Symbol '" + namePath + "' is not found.",{ fileName : "engine/nanofl/engine/Library.hx", lineNumber : 76, className : "nanofl.engine.Library", methodName : "getItem"});
		return this.createItemOnItemNotFound(namePath);
	}
	,getItems: function(includeScene) {
		var _gthis = this;
		var namePaths = stdlib_LambdaIterator.array(new haxe_ds__$StringMap_StringMapKeyIterator(this.items.h));
		if(!includeScene) {
			var _g = [];
			var _g1 = 0;
			var _g2 = namePaths;
			while(_g1 < _g2.length) {
				var v = _g2[_g1];
				++_g1;
				if(v != nanofl_engine_Library.SCENE_NAME_PATH) {
					_g.push(v);
				}
			}
			namePaths = _g;
		}
		namePaths.sort(function(a,b) {
			return Reflect.compare(a.toLowerCase(),b.toLowerCase());
		});
		var result = new Array(namePaths.length);
		var _g = 0;
		var _g1 = namePaths.length;
		while(_g < _g1) {
			var i = _g++;
			result[i] = _gthis.items.h[namePaths[i]];
		}
		return result;
	}
	,hasItem: function(namePath) {
		return Object.prototype.hasOwnProperty.call(this.items.h,namePath);
	}
	,realUrl: function(url) {
		if(url.indexOf("//") >= 0) {
			return url;
		}
		return this.libraryDir + "/" + url;
	}
	,preload: function() {
		var r = Promise.resolve();
		var h = this.items.h;
		var item_h = h;
		var item_keys = Object.keys(h);
		var item_length = item_keys.length;
		var item_current = 0;
		while(item_current < item_length) {
			var item = [item_h[item_keys[item_current++]]];
			r = r.then((function(item) {
				return function(_) {
					return item[0].preload();
				};
			})(item));
		}
		return r;
	}
	,getItemCount: function() {
		return Lambda.count(this.items);
	}
	,ensureFolderOfItemExists: function(namePath) {
		var parts = namePath.split("/");
		var _g = 1;
		var _g1 = parts.length;
		while(_g < _g1) {
			var i = _g++;
			var folder = parts.slice(0,i).join("/");
			if(!this.hasItem(folder)) {
				this.addItem(new nanofl_engine_libraryitems_FolderItem(folder));
			}
		}
	}
	,createItemOnItemNotFound: function(namePath) {
		return nanofl_engine_libraryitems_MovieClipItem.createWithFrame(namePath,[new nanofl_engine_elements_TextElement("",0,0,false,true,[new nanofl_TextRun("Symbol '" + namePath + "' is not found.")])],"temp");
	}
	,getItemsInFolder: function(folderNamePath) {
		if(((this.items.h[folderNamePath]) instanceof nanofl_engine_libraryitems_FolderItem)) {
			var _g = [];
			var _g1 = 0;
			var _g2 = this.getItems();
			while(_g1 < _g2.length) {
				var v = _g2[_g1];
				++_g1;
				if(StringTools.startsWith(v.namePath,folderNamePath + "/")) {
					_g.push(v);
				}
			}
			return _g;
		}
		return [];
	}
	,clone: function() {
		return new nanofl_engine_Library(this.libraryDir,datatools_ArrayTools.clone(this.getItems(true)));
	}
	,getSceneItem: function() {
		return js_Boot.__cast(this.items.h[nanofl_engine_Library.SCENE_NAME_PATH] , nanofl_engine_libraryitems_MovieClipItem);
	}
	,getSceneInstance: function() {
		return this.getSceneItem().newInstance();
	}
	,getInstancableItems: function() {
		return stdlib_LambdaIterable.filterByType(this.getItems(true),nanofl_engine_libraryitems_InstancableItem);
	}
	,getBitmaps: function() {
		return stdlib_LambdaIterable.filterByType(this.getItems(),nanofl_engine_libraryitems_BitmapItem);
	}
	,getMeshes: function() {
		return stdlib_LambdaIterable.filterByType(this.getItems(),nanofl_engine_libraryitems_MeshItem);
	}
	,getSounds: function() {
		return stdlib_LambdaIterable.filterByType(this.getItems(),nanofl_engine_libraryitems_SoundItem);
	}
	,getFonts: function() {
		var fontItems = stdlib_LambdaIterable.filterByType(this.getItems(),nanofl_engine_libraryitems_FontItem);
		var result = new Array(fontItems.length);
		var _g = 0;
		var _g1 = fontItems.length;
		while(_g < _g1) {
			var i = _g++;
			result[i] = fontItems[i].toFont();
		}
		var fonts = result;
		fonts.sort(function(a,b) {
			return Reflect.compare(a.family,b.family);
		});
		return fonts;
	}
	,equ: function(library) {
		return datatools_MapTools.equ(this.items,library.items);
	}
	,__class__: nanofl_engine_Library
};
var nanofl_engine_LibraryItemType = $hxEnums["nanofl.engine.LibraryItemType"] = { __ename__:"nanofl.engine.LibraryItemType",__constructs__:null
	,bitmap: {_hx_name:"bitmap",_hx_index:0,__enum__:"nanofl.engine.LibraryItemType",toString:$estr}
	,folder: {_hx_name:"folder",_hx_index:1,__enum__:"nanofl.engine.LibraryItemType",toString:$estr}
	,font: {_hx_name:"font",_hx_index:2,__enum__:"nanofl.engine.LibraryItemType",toString:$estr}
	,mesh: {_hx_name:"mesh",_hx_index:3,__enum__:"nanofl.engine.LibraryItemType",toString:$estr}
	,movieclip: {_hx_name:"movieclip",_hx_index:4,__enum__:"nanofl.engine.LibraryItemType",toString:$estr}
	,sound: {_hx_name:"sound",_hx_index:5,__enum__:"nanofl.engine.LibraryItemType",toString:$estr}
	,sprite: {_hx_name:"sprite",_hx_index:6,__enum__:"nanofl.engine.LibraryItemType",toString:$estr}
};
nanofl_engine_LibraryItemType.__constructs__ = [nanofl_engine_LibraryItemType.bitmap,nanofl_engine_LibraryItemType.folder,nanofl_engine_LibraryItemType.font,nanofl_engine_LibraryItemType.mesh,nanofl_engine_LibraryItemType.movieclip,nanofl_engine_LibraryItemType.sound,nanofl_engine_LibraryItemType.sprite];
var nanofl_engine_Loader = function() { };
nanofl_engine_Loader.__name__ = "nanofl.engine.Loader";
nanofl_engine_Loader.image = function(url) {
	return new Promise(function(resolve,reject) {
		var image = new Image();
		image.onload = function(_) {
			resolve(image);
		};
		image.onerror = function(_) {
			nanofl_engine_Debug.console.error("Failed to load '" + url + "'.");
			image.src = "data:image/gif;base64,R0lGODlhAQABAIAAAP///wAAACwAAAAAAQABAAACAkQBADs=";
			reject("Failed to load '" + url + "'.");
		};
		image.src = url;
	});
};
nanofl_engine_Loader.file = function(url) {
	return new Promise(function(resolve,reject) {
		var xmlhttp = new XMLHttpRequest();
		xmlhttp.responseType = "text";
		xmlhttp.onreadystatechange = function() {
			if(xmlhttp.readyState == 4) {
				if(xmlhttp.status == 200) {
					resolve(xmlhttp.responseText);
				} else {
					nanofl_engine_Debug.console.error("Failed to load '" + url + "': " + xmlhttp.status + " / " + xmlhttp.statusText);
					reject("Failed to load '" + url + "': " + xmlhttp.status + " / " + xmlhttp.statusText);
				}
			}
		};
		xmlhttp.open("GET",url,true);
		xmlhttp.send();
	});
};
nanofl_engine_Loader.queued = function(urls,load) {
	var result = new Array(urls.length);
	var _g = 0;
	var _g1 = urls.length;
	while(_g < _g1) {
		var i = _g++;
		result[i] = load(urls[i]);
	}
	return Promise.all(result);
};
nanofl_engine_Loader.loadJsScript = function(url) {
	return new Promise(function(resolve,reject) {
		var elem = window.document.createElement("script");
		elem.type = "text/javascript";
		elem.async = true;
		elem.src = url;
		elem.addEventListener("load",function(_) {
			elem.remove();
			resolve(null);
		});
		elem.addEventListener("error",function(e) {
			elem.remove();
			reject(e);
		});
		window.document.head.appendChild(elem);
	});
};
var nanofl_engine_MeshParams = function() {
	this.directionalLightRotationY = 0.0;
	this.directionalLightRotationX = 0.0;
	this.directionalLightColor = "#808080";
	this.ambientLightColor = "#E0E0E0";
	this.cameraFov = 70;
	this.rotationY = 0.0;
	this.rotationX = 0.0;
};
nanofl_engine_MeshParams.__name__ = "nanofl.engine.MeshParams";
nanofl_engine_MeshParams.load = function(node) {
	var r = new nanofl_engine_MeshParams();
	r.rotationX = htmlparser_HtmlParserTools.getAttrFloat(node,"rotationX",r.rotationX);
	r.rotationY = htmlparser_HtmlParserTools.getAttrFloat(node,"rotationY",r.rotationY);
	r.cameraFov = htmlparser_HtmlParserTools.getAttrInt(node,"cameraFov",r.cameraFov);
	r.ambientLightColor = htmlparser_HtmlParserTools.getAttrString(node,"ambientLightColor",r.ambientLightColor);
	r.directionalLightColor = htmlparser_HtmlParserTools.getAttrString(node,"directionalLightColor",r.directionalLightColor);
	r.directionalLightRotationX = htmlparser_HtmlParserTools.getAttrFloat(node,"directionalLightRotationX",r.directionalLightRotationX);
	r.directionalLightRotationY = htmlparser_HtmlParserTools.getAttrFloat(node,"directionalLightRotationY",r.directionalLightRotationY);
	return r;
};
nanofl_engine_MeshParams.loadJson = function(obj) {
	var r = new nanofl_engine_MeshParams();
	var tmp = obj.rotationX;
	r.rotationX = tmp != null ? tmp : r.rotationX;
	var tmp = obj.rotationY;
	r.rotationY = tmp != null ? tmp : r.rotationY;
	var tmp = obj.cameraFov;
	r.cameraFov = tmp != null ? tmp : r.cameraFov;
	var tmp = obj.ambientLightColor;
	r.ambientLightColor = tmp != null ? tmp : r.ambientLightColor;
	var tmp = obj.directionalLightColor;
	r.directionalLightColor = tmp != null ? tmp : r.directionalLightColor;
	var tmp = obj.directionalLightRotationX;
	r.directionalLightRotationX = tmp != null ? tmp : r.directionalLightRotationX;
	var tmp = obj.directionalLightRotationY;
	r.directionalLightRotationY = tmp != null ? tmp : r.directionalLightRotationY;
	return r;
};
nanofl_engine_MeshParams.prototype = {
	save: function(out) {
		var def = new nanofl_engine_MeshParams();
		out.attr("rotationX",this.rotationX,def.rotationX);
		out.attr("rotationY",this.rotationY,def.rotationY);
		out.attr("cameraFov",this.cameraFov,def.cameraFov);
		out.attr("ambientLightColor",this.ambientLightColor,def.ambientLightColor);
		out.attr("directionalLightColor",this.directionalLightColor,def.directionalLightColor);
		out.attr("directionalLightRotationX",this.directionalLightRotationX,def.directionalLightRotationX);
		out.attr("directionalLightRotationY",this.directionalLightRotationY,def.directionalLightRotationY);
	}
	,saveJson: function() {
		var def = new nanofl_engine_MeshParams();
		var tmp = this.rotationX;
		this.rotationX = tmp != null ? tmp : def.rotationX;
		var tmp = this.rotationY;
		this.rotationY = tmp != null ? tmp : def.rotationY;
		var tmp = this.cameraFov;
		this.cameraFov = tmp != null ? tmp : def.cameraFov;
		var tmp = this.ambientLightColor;
		this.ambientLightColor = tmp != null ? tmp : def.ambientLightColor;
		var tmp = this.directionalLightColor;
		this.directionalLightColor = tmp != null ? tmp : def.directionalLightColor;
		var tmp = this.directionalLightRotationX;
		this.directionalLightRotationX = tmp != null ? tmp : def.directionalLightRotationX;
		var tmp = this.directionalLightRotationY;
		return this.directionalLightRotationY = tmp != null ? tmp : def.directionalLightRotationY;
	}
	,equ: function(obj) {
		if(obj.rotationX == this.rotationX && obj.rotationY == this.rotationY && obj.cameraFov == this.cameraFov && obj.ambientLightColor == this.ambientLightColor && obj.directionalLightColor == this.directionalLightColor && obj.directionalLightRotationX == this.directionalLightRotationX) {
			return obj.directionalLightRotationY == this.directionalLightRotationY;
		} else {
			return false;
		}
	}
	,clone: function() {
		var r = new nanofl_engine_MeshParams();
		r.rotationX = this.rotationX;
		r.rotationY = this.rotationY;
		r.cameraFov = this.cameraFov;
		r.ambientLightColor = this.ambientLightColor;
		r.directionalLightColor = this.directionalLightColor;
		r.directionalLightRotationX = this.directionalLightRotationX;
		r.directionalLightRotationY = this.directionalLightRotationY;
		return r;
	}
	,applyToMesh: function(mesh) {
		mesh.rotationX = this.rotationX;
		mesh.rotationY = this.rotationY;
		mesh.camera.fov = this.cameraFov;
		var tmp = nanofl_engine_ColorTools.stringToNumber(this.ambientLightColor);
		mesh.ambientLight.color = new THREE_Color(tmp);
		var tmp = nanofl_engine_ColorTools.stringToNumber(this.directionalLightColor);
		mesh.directionalLight.color = new THREE_Color(tmp);
		mesh.directionalLight.setRotationFromEuler(new THREE_Euler(this.directionalLightRotationX * Math.PI / 180,this.directionalLightRotationY * Math.PI / 180));
	}
	,__class__: nanofl_engine_MeshParams
};
var nanofl_engine_MovieClipItemTools = function() { };
nanofl_engine_MovieClipItemTools.__name__ = "nanofl.engine.MovieClipItemTools";
nanofl_engine_MovieClipItemTools.findShapes = function(item,allFrames,matrix,callb) {
	if(matrix == null) {
		matrix = new nanofl_engine_geom_Matrix();
	}
	nanofl_engine_MovieClipItemTools.findShapesInner(item,allFrames,matrix,false,callb);
	nanofl_engine_MovieClipItemTools.findMovieClipItems(item,allFrames,matrix,function(item,matrix,insideMask) {
		nanofl_engine_MovieClipItemTools.findShapesInner(item,allFrames,matrix,insideMask,callb);
	});
};
nanofl_engine_MovieClipItemTools.findShapesInner = function(item,allFrames,matrix,insideMask,callb) {
	nanofl_engine_MovieClipItemTools.iterateElements(item,allFrames,insideMask,function(element,e) {
		if(((element) instanceof nanofl_engine_elements_ShapeElement)) {
			callb(element,{ item : item, layerIndex : e.layerIndex, keyFrameIndex : e.keyFrameIndex, matrix : matrix, insideMask : e.insideMask});
		}
	});
};
nanofl_engine_MovieClipItemTools.findMovieClipItems = function(item,allFrames,matrix,callb) {
	nanofl_engine_MovieClipItemTools.findInstances(item,allFrames,matrix,function(instance,e) {
		if(((instance.get_symbol()) instanceof nanofl_engine_libraryitems_MovieClipItem)) {
			callb(instance.get_symbol(),matrix.clone().appendMatrix(instance.matrix),e.insideMask);
		}
	});
};
nanofl_engine_MovieClipItemTools.findInstances = function(item,allFrames,matrix,callb,insideMask) {
	if(insideMask == null) {
		insideMask = false;
	}
	if(matrix == null) {
		matrix = new nanofl_engine_geom_Matrix();
	}
	nanofl_engine_MovieClipItemTools.iterateInstances(item,allFrames,insideMask,function(instance,e) {
		callb(instance,{ item : item, layerIndex : e.layerIndex, keyFrameIndex : e.keyFrameIndex, matrix : matrix, insideMask : e.insideMask});
		if(((instance.get_symbol()) instanceof nanofl_engine_libraryitems_MovieClipItem)) {
			nanofl_engine_MovieClipItemTools.findInstances(instance.get_symbol(),allFrames,matrix.clone().appendMatrix(instance.matrix),callb,insideMask);
		}
	});
};
nanofl_engine_MovieClipItemTools.iterateInstances = function(item,allFrames,insideMask,callb) {
	if(insideMask == null) {
		insideMask = false;
	}
	nanofl_engine_MovieClipItemTools.iterateElements(item,allFrames,insideMask,function(element,e) {
		if(((element) instanceof nanofl_engine_elements_Instance)) {
			callb(element,e);
		}
	});
};
nanofl_engine_MovieClipItemTools.iterateElements = function(item,allFrames,insideMask,callb) {
	if(insideMask == null) {
		insideMask = false;
	}
	var _g = 0;
	var _g1 = item.get_layers().length;
	while(_g < _g1) {
		var layerIndex = _g++;
		var layer = item.get_layers()[layerIndex];
		if(layer._keyFrames.length > 0) {
			var localInsideMask = insideMask || layer.type == nanofl_engine_LayerType.mask;
			var _g2 = 0;
			var _g3 = allFrames ? layer._keyFrames.length : 1;
			while(_g2 < _g3) {
				var keyFrameIndex = _g2++;
				var keyFrame = layer._keyFrames[keyFrameIndex];
				var _g4 = 0;
				var _g5 = nanofl_engine_elements_Elements.expandGroups(keyFrame.get_elements());
				while(_g4 < _g5.length) {
					var element = _g5[_g4];
					++_g4;
					callb(element,{ keyFrameIndex : keyFrameIndex, layerIndex : layerIndex, insideMask : localInsideMask});
				}
			}
		}
	}
};
var nanofl_engine_ScaleMode = function() { };
nanofl_engine_ScaleMode.__name__ = "nanofl.engine.ScaleMode";
var nanofl_engine_TextureItemTools = function() { };
nanofl_engine_TextureItemTools.__name__ = "nanofl.engine.TextureItemTools";
nanofl_engine_TextureItemTools.getSpriteSheet = function(item) {
	if(item.textureAtlas != null && item.textureAtlas != "" && Object.prototype.hasOwnProperty.call(nanofl_Player.spriteSheets,item.namePath)) {
		return Reflect.field(nanofl_Player.spriteSheets,item.namePath);
	} else {
		return null;
	}
};
nanofl_engine_TextureItemTools.preload = function(item) {
	var spriteSheet = nanofl_engine_TextureItemTools.getSpriteSheet(item);
	if(spriteSheet != null) {
		if(spriteSheet.complete) {
			return Promise.resolve();
		} else {
			return new Promise(function(resolve,reject) {
				spriteSheet.addEventListener("complete",function(_) {
					resolve(null);
				},null);
			});
		}
	} else {
		return Promise.resolve();
	}
};
var nanofl_engine_Version = function() { };
nanofl_engine_Version.__name__ = "nanofl.engine.Version";
nanofl_engine_Version.compare = function(v1,v2) {
	var _this = v1.split(".");
	var f = Std.parseInt;
	var result = new Array(_this.length);
	var _g = 0;
	var _g1 = _this.length;
	while(_g < _g1) {
		var i = _g++;
		result[i] = f(_this[i]);
	}
	var n1 = result;
	var _this = v2.split(".");
	var f = Std.parseInt;
	var result = new Array(_this.length);
	var _g = 0;
	var _g1 = _this.length;
	while(_g < _g1) {
		var i = _g++;
		result[i] = f(_this[i]);
	}
	var n2 = result;
	var r = Reflect.compare(n1[0],n2[0]);
	if(r != 0) {
		return r;
	}
	var r = Reflect.compare(n1[1],n2[1]);
	if(r != 0) {
		return r;
	}
	var r = Reflect.compare(n1[2],n2[2]);
	if(r != 0) {
		return r;
	}
	return 0;
};
nanofl_engine_Version.handle = function(version,handlers) {
	var versions = stdlib_LambdaIterable.sorted(stdlib_LambdaIterator.filter(new haxe_ds__$StringMap_StringMapKeyIterator(handlers.h),function(x) {
		return nanofl_engine_Version.compare(x,version) <= 0;
	}),nanofl_engine_Version.compare);
	if(versions.length == 0) {
		versions = stdlib_LambdaIterator.sorted(new haxe_ds__$StringMap_StringMapKeyIterator(handlers.h),nanofl_engine_Version.compare);
	}
	return handlers.h[versions[versions.length - 1]]();
};
var nanofl_engine_coloreffects_ColorEffect = function() { };
nanofl_engine_coloreffects_ColorEffect.__name__ = "nanofl.engine.coloreffects.ColorEffect";
nanofl_engine_coloreffects_ColorEffect.loadJson = function(obj) {
	var _g = obj != null ? obj.type : null;
	if(_g == null) {
		return null;
	} else {
		switch(_g) {
		case "advanced":
			return nanofl_engine_coloreffects_ColorEffectAdvanced.loadJson(obj);
		case "alpha":
			return nanofl_engine_coloreffects_ColorEffectAlpha.loadJson(obj);
		case "brightness":
			return nanofl_engine_coloreffects_ColorEffectBrightness.loadJson(obj);
		case "tint":
			return nanofl_engine_coloreffects_ColorEffectTint.loadJson(obj);
		default:
			return null;
		}
	}
};
nanofl_engine_coloreffects_ColorEffect.prototype = {
	__class__: nanofl_engine_coloreffects_ColorEffect
};
var nanofl_engine_coloreffects_ColorEffectAdvanced = function(alphaMultiplier,redMultiplier,greenMultiplier,blueMultiplier,alphaOffset,redOffset,greenOffset,blueOffset) {
	this.alphaMultiplier = alphaMultiplier;
	this.redMultiplier = redMultiplier;
	this.greenMultiplier = greenMultiplier;
	this.blueMultiplier = blueMultiplier;
	this.alphaOffset = alphaOffset;
	this.redOffset = redOffset;
	this.greenOffset = greenOffset;
	this.blueOffset = blueOffset;
};
nanofl_engine_coloreffects_ColorEffectAdvanced.__name__ = "nanofl.engine.coloreffects.ColorEffectAdvanced";
nanofl_engine_coloreffects_ColorEffectAdvanced.loadJson = function(obj) {
	var tmp = obj.alphaMultiplier;
	var tmp1 = obj.redMultiplier;
	var tmp2 = obj.greenMultiplier;
	var tmp3 = obj.blueMultiplier;
	var tmp4 = obj.alphaOffset;
	var tmp5 = obj.redOffset;
	var tmp6 = obj.greenOffset;
	var tmp7 = obj.blueOffset;
	return new nanofl_engine_coloreffects_ColorEffectAdvanced(tmp != null ? tmp : 1.0,tmp1 != null ? tmp1 : 1.0,tmp2 != null ? tmp2 : 1.0,tmp3 != null ? tmp3 : 1.0,tmp4 != null ? tmp4 : 0.0,tmp5 != null ? tmp5 : 0.0,tmp6 != null ? tmp6 : 0.0,tmp7 != null ? tmp7 : 0.0);
};
nanofl_engine_coloreffects_ColorEffectAdvanced.__super__ = nanofl_engine_coloreffects_ColorEffect;
nanofl_engine_coloreffects_ColorEffectAdvanced.prototype = $extend(nanofl_engine_coloreffects_ColorEffect.prototype,{
	apply: function(obj) {
		if(obj.filters == null) {
			obj.filters = [];
		}
		obj.filters.push(new createjs.ColorFilter(this.redMultiplier,this.greenMultiplier,this.blueMultiplier,this.alphaMultiplier,this.redOffset,this.greenOffset,this.blueOffset,this.alphaOffset));
	}
	,clone: function() {
		return new nanofl_engine_coloreffects_ColorEffectAdvanced(this.alphaMultiplier,this.redMultiplier,this.greenMultiplier,this.blueMultiplier,this.alphaOffset,this.redOffset,this.greenOffset,this.blueOffset);
	}
	,getNeutralClone: function() {
		return new nanofl_engine_coloreffects_ColorEffectAdvanced(1,1,1,1,0,0,0,0);
	}
	,getTweened: function(k,finish) {
		stdlib_Debug.assert(((finish) instanceof nanofl_engine_coloreffects_ColorEffectAdvanced),null,{ fileName : "engine/nanofl/engine/coloreffects/ColorEffectAdvanced.hx", lineNumber : 125, className : "nanofl.engine.coloreffects.ColorEffectAdvanced", methodName : "getTweened"});
		return new nanofl_engine_coloreffects_ColorEffectAdvanced(this.alphaMultiplier + (finish.alphaMultiplier - this.alphaMultiplier) * k,this.redMultiplier + (finish.redMultiplier - this.redMultiplier) * k,this.greenMultiplier + (finish.greenMultiplier - this.greenMultiplier) * k,this.blueMultiplier + (finish.blueMultiplier - this.blueMultiplier) * k,this.alphaOffset + (finish.alphaOffset - this.alphaOffset) * k,this.redOffset + (finish.redOffset - this.redOffset) * k,this.greenOffset + (finish.greenOffset - this.greenOffset) * k,this.blueOffset + (finish.blueOffset - this.blueOffset) * k);
	}
	,equ: function(c) {
		if(((c) instanceof nanofl_engine_coloreffects_ColorEffectAdvanced) && this.redMultiplier == c.redMultiplier && this.greenMultiplier == c.greenMultiplier && this.blueMultiplier == c.blueMultiplier && this.alphaMultiplier == c.alphaMultiplier && this.redOffset == c.redOffset && this.greenOffset == c.greenOffset && this.blueOffset == c.blueOffset) {
			return this.alphaOffset == c.alphaOffset;
		} else {
			return false;
		}
	}
	,__class__: nanofl_engine_coloreffects_ColorEffectAdvanced
});
var nanofl_engine_coloreffects_ColorEffectAlpha = function(value) {
	this.value = value;
};
nanofl_engine_coloreffects_ColorEffectAlpha.__name__ = "nanofl.engine.coloreffects.ColorEffectAlpha";
nanofl_engine_coloreffects_ColorEffectAlpha.loadJson = function(obj) {
	var tmp = obj.value;
	return new nanofl_engine_coloreffects_ColorEffectAlpha(tmp != null ? tmp : 1.0);
};
nanofl_engine_coloreffects_ColorEffectAlpha.__super__ = nanofl_engine_coloreffects_ColorEffect;
nanofl_engine_coloreffects_ColorEffectAlpha.prototype = $extend(nanofl_engine_coloreffects_ColorEffect.prototype,{
	apply: function(obj) {
		obj.alpha = this.value;
	}
	,clone: function() {
		return new nanofl_engine_coloreffects_ColorEffectAlpha(this.value);
	}
	,getNeutralClone: function() {
		return new nanofl_engine_coloreffects_ColorEffectAlpha(1);
	}
	,getTweened: function(k,finish) {
		return new nanofl_engine_coloreffects_ColorEffectAlpha(this.value + ((js_Boot.__cast(finish , nanofl_engine_coloreffects_ColorEffectAlpha)).value - this.value) * k);
	}
	,equ: function(c) {
		if(((c) instanceof nanofl_engine_coloreffects_ColorEffectAlpha)) {
			return this.value == c.value;
		} else {
			return false;
		}
	}
	,__class__: nanofl_engine_coloreffects_ColorEffectAlpha
});
var nanofl_engine_coloreffects_ColorEffectBrightness = function(value) {
	this.value = value;
};
nanofl_engine_coloreffects_ColorEffectBrightness.__name__ = "nanofl.engine.coloreffects.ColorEffectBrightness";
nanofl_engine_coloreffects_ColorEffectBrightness.loadJson = function(obj) {
	var tmp = obj.value;
	return new nanofl_engine_coloreffects_ColorEffectBrightness(tmp != null ? tmp : 0.0);
};
nanofl_engine_coloreffects_ColorEffectBrightness.__super__ = nanofl_engine_coloreffects_ColorEffect;
nanofl_engine_coloreffects_ColorEffectBrightness.prototype = $extend(nanofl_engine_coloreffects_ColorEffect.prototype,{
	apply: function(obj) {
		if(obj.filters == null) {
			obj.filters = [];
		}
		if(this.value > 0) {
			obj.filters.push(new createjs.ColorFilter(1,1,1,1,this.value * 255,this.value * 255,this.value * 255,0));
		} else if(this.value < 0) {
			obj.filters.push(new createjs.ColorFilter(1 + this.value,1 + this.value,1 + this.value,1,0,0,0,0));
		}
	}
	,clone: function() {
		return new nanofl_engine_coloreffects_ColorEffectBrightness(this.value);
	}
	,getNeutralClone: function() {
		return new nanofl_engine_coloreffects_ColorEffectBrightness(0);
	}
	,getTweened: function(k,finish) {
		return new nanofl_engine_coloreffects_ColorEffectBrightness(this.value + ((js_Boot.__cast(finish , nanofl_engine_coloreffects_ColorEffectBrightness)).value - this.value) * k);
	}
	,equ: function(c) {
		if(((c) instanceof nanofl_engine_coloreffects_ColorEffectBrightness)) {
			return this.value == c.value;
		} else {
			return false;
		}
	}
	,__class__: nanofl_engine_coloreffects_ColorEffectBrightness
});
var nanofl_engine_coloreffects_ColorEffectDouble = function(effect0,effect1) {
	this.effect0 = effect0;
	this.effect1 = effect1;
};
nanofl_engine_coloreffects_ColorEffectDouble.__name__ = "nanofl.engine.coloreffects.ColorEffectDouble";
nanofl_engine_coloreffects_ColorEffectDouble.__super__ = nanofl_engine_coloreffects_ColorEffect;
nanofl_engine_coloreffects_ColorEffectDouble.prototype = $extend(nanofl_engine_coloreffects_ColorEffect.prototype,{
	apply: function(obj) {
		this.effect0.apply(obj);
		this.effect1.apply(obj);
	}
	,equ: function(c) {
		if(((c) instanceof nanofl_engine_coloreffects_ColorEffectDouble) && this.effect0.equ(c.effect0)) {
			return this.effect1.equ(c.effect1);
		} else {
			return false;
		}
	}
	,clone: function() {
		return new nanofl_engine_coloreffects_ColorEffectDouble(this.effect0.clone(),this.effect1.clone());
	}
	,getNeutralClone: function() {
		return new nanofl_engine_coloreffects_ColorEffectDouble(this.effect0.getNeutralClone(),this.effect1.getNeutralClone());
	}
	,getTweened: function(k,finish) {
		return new nanofl_engine_coloreffects_ColorEffectDouble(this.effect0.getTweened(k,finish.effect0),this.effect1.getTweened(k,finish.effect1));
	}
	,__class__: nanofl_engine_coloreffects_ColorEffectDouble
});
var nanofl_engine_coloreffects_ColorEffectTint = function(color,multiplier) {
	this.color = color;
	this.multiplier = multiplier;
};
nanofl_engine_coloreffects_ColorEffectTint.__name__ = "nanofl.engine.coloreffects.ColorEffectTint";
nanofl_engine_coloreffects_ColorEffectTint.loadJson = function(obj) {
	var tmp = obj.multiplier;
	return new nanofl_engine_coloreffects_ColorEffectTint(obj.color,tmp != null ? tmp : 1.0);
};
nanofl_engine_coloreffects_ColorEffectTint.__super__ = nanofl_engine_coloreffects_ColorEffect;
nanofl_engine_coloreffects_ColorEffectTint.prototype = $extend(nanofl_engine_coloreffects_ColorEffect.prototype,{
	apply: function(obj) {
		var rgb = nanofl_engine_ColorTools.parse(this.color);
		if(obj.filters == null) {
			obj.filters = [];
		}
		obj.filters.push(new createjs.ColorFilter(1 - this.multiplier,1 - this.multiplier,1 - this.multiplier,1,rgb.r * this.multiplier,rgb.g * this.multiplier,rgb.b * this.multiplier,0));
	}
	,clone: function() {
		return new nanofl_engine_coloreffects_ColorEffectTint(this.color,this.multiplier);
	}
	,getNeutralClone: function() {
		return new nanofl_engine_coloreffects_ColorEffectTint(this.color,0);
	}
	,getTweened: function(k,finish) {
		return new nanofl_engine_coloreffects_ColorEffectTint(nanofl_engine_ColorTools.getTweened(this.color,k,(js_Boot.__cast(finish , nanofl_engine_coloreffects_ColorEffectTint)).color),this.multiplier + ((js_Boot.__cast(finish , nanofl_engine_coloreffects_ColorEffectTint)).multiplier - this.multiplier) * k);
	}
	,equ: function(c) {
		if(((c) instanceof nanofl_engine_coloreffects_ColorEffectTint) && this.color == c.color) {
			return this.multiplier == c.multiplier;
		} else {
			return false;
		}
	}
	,__class__: nanofl_engine_coloreffects_ColorEffectTint
});
var nanofl_engine_elements_Element = function() {
	this.regY = 0.0;
	this.regX = 0.0;
	this.matrix = new nanofl_engine_geom_Matrix();
	this.visible = true;
};
nanofl_engine_elements_Element.__name__ = "nanofl.engine.elements.Element";
nanofl_engine_elements_Element.parseJson = function(obj,version) {
	var element;
	switch(Type.createEnum(nanofl_engine_ElementType,obj.type,null)._hx_index) {
	case 0:
		element = new nanofl_engine_elements_ShapeElement();
		break;
	case 1:
		element = new nanofl_engine_elements_Instance(null);
		break;
	case 2:
		element = new nanofl_engine_elements_GroupElement([]);
		break;
	case 3:
		element = new nanofl_engine_elements_TextElement(null,null,null,null,null,null);
		break;
	case 4:
		element = new nanofl_engine_elements_SpriteFrameElement(null,0);
		break;
	}
	if(element != null) {
		element.visible = true;
		if(!element.loadPropertiesJson(obj,version)) {
			return null;
		}
		stdlib_Debug.assert(element.matrix != null,null,{ fileName : "engine/nanofl/engine/elements/Element.hx", lineNumber : 95, className : "nanofl.engine.elements.Element", methodName : "parseJson"});
	}
	return element;
};
nanofl_engine_elements_Element.prototype = {
	setLibrary: function(library) {
	}
	,toString: function() {
		var c = js_Boot.getClass(this);
		var className = c.__name__;
		className = HxOverrides.substr(className,className.lastIndexOf(".") + 1,null);
		var parents = this.parent != null ? this.parent.toString() : "";
		if(StringTools.endsWith(parents," / layer / frame")) {
			parents = parents.substring(0,parents.length - " / layer / frame".length);
		}
		return (parents != "" ? parents + " / " : "") + className;
	}
	,loadPropertiesJson: function(obj,version) {
		this.matrix = nanofl_engine_geom_Matrix.loadJson(obj);
		var tmp = obj.regX;
		this.regX = tmp != null ? tmp : 0.0;
		var tmp = obj.regY;
		this.regY = tmp != null ? tmp : 0.0;
		return true;
	}
	,copyBaseProperties: function(obj) {
		obj.parent = this.parent;
		obj.visible = this.visible;
		obj.matrix = this.matrix.clone();
		obj.regX = this.regX;
		obj.regY = this.regY;
	}
	,translate: function(dx,dy) {
		this.matrix.translate(dx,dy);
	}
	,updateDisplayObjectProperties: function(dispObj) {
		dispObj.visible = this.visible;
		dispObj.set(this.matrix.decompose());
		dispObj.filters = [];
		dispObj.setBounds(null,null,null,null);
		dispObj.uncache();
	}
	,transform: function(m,applyToStrokeAndFill) {
		if(applyToStrokeAndFill == null) {
			applyToStrokeAndFill = true;
		}
		this.matrix.prependMatrix(m);
	}
	,equ: function(element) {
		if(js_Boot.getClass(element) != js_Boot.getClass(this)) {
			return false;
		}
		if(element.visible != this.visible) {
			return false;
		}
		if(!element.matrix.equ(this.matrix)) {
			return false;
		}
		if(element.regX != this.regX) {
			return false;
		}
		if(element.regY != this.regY) {
			return false;
		}
		return true;
	}
	,getNearestPoint: function(pos) {
		var pos1 = this.matrix.clone().invert().transformPointP(pos);
		var points = this.getNearestPointsLocal(pos1);
		if(points.length == 0 || points.length == 1 && points[0].x == 1e100 && points[0].y == 1e100) {
			return { x : 1e100, y : 1e100};
		}
		points.sort(function(a,b) {
			return Reflect.compare(nanofl_engine_geom_PointTools.getDist(pos1.x,pos1.y,a.x,a.y),nanofl_engine_geom_PointTools.getDist(pos1.x,pos1.y,b.x,b.y));
		});
		return this.matrix.transformPointP(points[0]);
	}
	,getNearestPointsLocal: function(pos) {
		return [];
	}
	,__class__: nanofl_engine_elements_Element
};
var nanofl_engine_elements_Elements = function() { };
nanofl_engine_elements_Elements.__name__ = "nanofl.engine.elements.Elements";
nanofl_engine_elements_Elements.parseJson = function(obj,version) {
	var elements = [];
	var _g = 0;
	while(_g < obj.length) {
		var itemObj = obj[_g];
		++_g;
		var element = nanofl_engine_elements_Element.parseJson(itemObj,version);
		if(element != null) {
			elements.push(element);
		}
	}
	return elements;
};
nanofl_engine_elements_Elements.expandGroups = function(elements) {
	var r = [];
	var _g = 0;
	var _g1 = elements;
	while(_g < _g1.length) {
		var element = _g1[_g];
		++_g;
		if(((element) instanceof nanofl_engine_elements_GroupElement)) {
			r = r.concat(nanofl_engine_elements_Elements.expandGroups(element.getChildren()));
		} else {
			r.push(element);
		}
	}
	return r;
};
var nanofl_engine_elements_GroupElement = function(elements) {
	this.name = "";
	nanofl_engine_elements_Element.call(this);
	this._elements = elements != null ? elements : [];
	var _g = 0;
	var _g1 = this.get_elements();
	while(_g < _g1.length) {
		var element = _g1[_g];
		++_g;
		element.parent = this;
	}
};
nanofl_engine_elements_GroupElement.__name__ = "nanofl.engine.elements.GroupElement";
nanofl_engine_elements_GroupElement.__interfaces__ = [nanofl_engine_IElementsContainer,nanofl_engine_IPathElement];
nanofl_engine_elements_GroupElement.__super__ = nanofl_engine_elements_Element;
nanofl_engine_elements_GroupElement.prototype = $extend(nanofl_engine_elements_Element.prototype,{
	get_type: function() {
		return nanofl_engine_ElementType.group;
	}
	,get_elements: function() {
		return this._elements;
	}
	,get_currentFrame: function() {
		return 0;
	}
	,set_currentFrame: function(v) {
		return v;
	}
	,get_layers: function() {
		if(this._layers == null) {
			var layer = new nanofl_engine_movieclip_Layer("auto");
			layer.layersContainer = this;
			layer.addKeyFrame(new nanofl_engine_GroupKeyFrame(this));
			this._layers = [layer];
		}
		return this._layers;
	}
	,addElement: function(element,index) {
		if(index == null) {
			this._elements.push(element);
		} else {
			this._elements.splice(index,0,element);
		}
		element.parent = this;
	}
	,removeElementAt: function(n) {
		this._elements.splice(n,1);
	}
	,removeElement: function(element) {
		var n = this.get_elements().indexOf(element);
		if(n >= 0) {
			this.removeElementAt(n);
		}
	}
	,loadPropertiesJson: function(obj,version) {
		if(!nanofl_engine_elements_Element.prototype.loadPropertiesJson.call(this,obj,version)) {
			return false;
		}
		var tmp = obj.name;
		this.name = tmp != null ? tmp : "";
		this._elements = nanofl_engine_elements_Elements.parseJson(obj.elements,version);
		return this.get_elements().length > 0;
	}
	,clone: function() {
		var obj = new nanofl_engine_elements_GroupElement(datatools_ArrayTools.clone(this._elements));
		this.copyBaseProperties(obj);
		obj.name = this.name;
		return obj;
	}
	,setLibrary: function(library) {
		var _g = 0;
		var _g1 = this.get_elements();
		while(_g < _g1.length) {
			var element = _g1[_g];
			++_g;
			element.setLibrary(library);
		}
	}
	,getChildren: function() {
		return this.get_elements();
	}
	,createDisplayObject: function(frameIndexes) {
		return this.updateDisplayObject(new createjs.Container(),frameIndexes);
	}
	,updateDisplayObject: function(dispObj,frameIndexes) {
		stdlib_Debug.assert(((dispObj) instanceof createjs.Container),this.toString(),{ fileName : "engine/nanofl/engine/elements/GroupElement.hx", lineNumber : 137, className : "nanofl.engine.elements.GroupElement", methodName : "updateDisplayObject"});
		stdlib_Debug.assert(this.get_elements().length > 0,this.toString(),{ fileName : "engine/nanofl/engine/elements/GroupElement.hx", lineNumber : 138, className : "nanofl.engine.elements.GroupElement", methodName : "updateDisplayObject"});
		if(frameIndexes != null && frameIndexes.length > 0 && frameIndexes[0].element == this) {
			frameIndexes = frameIndexes.slice(1);
		} else {
			frameIndexes = null;
		}
		this.updateDisplayObjectProperties(dispObj);
		var container = dispObj;
		container.removeAllChildren();
		var topElement = null;
		var _g = 0;
		var _g1 = this.get_elements();
		while(_g < _g1.length) {
			var element = _g1[_g];
			++_g;
			if(frameIndexes == null || frameIndexes.length == 0 || frameIndexes[0].element != element) {
				container.addChild(element.createDisplayObject(frameIndexes));
			} else if(frameIndexes != null && frameIndexes.length != 0 && frameIndexes[0].element == element) {
				topElement = element;
			}
		}
		if(topElement != null) {
			container.addChild(topElement.createDisplayObject(frameIndexes));
		}
		return container;
	}
	,getMaskFilter: function(layer,frameIndex) {
		return null;
	}
	,isScene: function() {
		return false;
	}
	,getNavigatorName: function() {
		return "group";
	}
	,getNavigatorIcon: function() {
		return "custom-icon-group";
	}
	,getTimeline: function() {
		return null;
	}
	,transform: function(m,applyToStrokeAndFill) {
		if(applyToStrokeAndFill == null) {
			applyToStrokeAndFill = true;
		}
		var _g = 0;
		var _g1 = this.get_elements();
		while(_g < _g1.length) {
			var e = _g1[_g];
			++_g;
			e.transform(m,applyToStrokeAndFill);
		}
	}
	,getNearestPointsLocal: function(pos) {
		var _this = this.get_elements();
		var result = new Array(_this.length);
		var _g = 0;
		var _g1 = _this.length;
		while(_g < _g1) {
			var i = _g++;
			result[i] = _this[i].getNearestPoint(pos);
		}
		return result;
	}
	,equ: function(element) {
		if(!nanofl_engine_elements_Element.prototype.equ.call(this,element)) {
			return false;
		}
		if(element.name != this.name) {
			return false;
		}
		if(!datatools_ArrayTools.equ(element._elements,this._elements)) {
			return false;
		}
		return true;
	}
	,__class__: nanofl_engine_elements_GroupElement
});
var nanofl_engine_elements_Instance = function(namePath,name,colorEffect,filters,blendMode,meshParams) {
	nanofl_engine_elements_Element.call(this);
	this.namePath = namePath;
	this.name = name;
	this.colorEffect = colorEffect;
	var tmp = filters;
	this.filters = tmp != null ? tmp : [];
	var tmp = blendMode;
	this.blendMode = tmp != null ? tmp : "normal";
	var tmp = meshParams;
	this.meshParams = tmp != null ? tmp : new nanofl_engine_MeshParams();
};
nanofl_engine_elements_Instance.__name__ = "nanofl.engine.elements.Instance";
nanofl_engine_elements_Instance.__interfaces__ = [nanofl_engine_IPathElement,nanofl_engine_IInstance];
nanofl_engine_elements_Instance.__super__ = nanofl_engine_elements_Element;
nanofl_engine_elements_Instance.prototype = $extend(nanofl_engine_elements_Element.prototype,{
	get_type: function() {
		return nanofl_engine_ElementType.instance;
	}
	,get_symbol: function() {
		return js_Boot.__cast(this.library.getItem(this.namePath) , nanofl_engine_libraryitems_InstancableItem);
	}
	,loadPropertiesJson: function(obj,version) {
		if(!nanofl_engine_elements_Element.prototype.loadPropertiesJson.call(this,obj,version)) {
			return false;
		}
		this.namePath = obj.libraryItem;
		stdlib_Debug.assert(this.namePath != null,null,{ fileName : "engine/nanofl/engine/elements/Instance.hx", lineNumber : 75, className : "nanofl.engine.elements.Instance", methodName : "loadPropertiesJson"});
		stdlib_Debug.assert(this.namePath != "",null,{ fileName : "engine/nanofl/engine/elements/Instance.hx", lineNumber : 76, className : "nanofl.engine.elements.Instance", methodName : "loadPropertiesJson"});
		var tmp = obj.name;
		this.name = tmp != null ? tmp : "";
		this.colorEffect = nanofl_engine_coloreffects_ColorEffect.loadJson(obj.colorEffect);
		var tmp = obj.filters;
		var _this = tmp != null ? tmp : [];
		var result = new Array(_this.length);
		var _g = 0;
		var _g1 = _this.length;
		while(_g < _g1) {
			var i = _g++;
			result[i] = nanofl_engine_FilterDef.loadJson(_this[i],version);
		}
		this.filters = result;
		var tmp = obj.blendMode;
		this.blendMode = tmp != null ? tmp : "normal";
		this.meshParams = obj.meshParams != null ? nanofl_engine_MeshParams.loadJson(obj.meshParams) : null;
		return true;
	}
	,clone: function() {
		var obj = new nanofl_engine_elements_Instance(this.namePath,this.name,datatools_NullTools.clone(this.colorEffect),datatools_ArrayTools.clone(this.filters),this.blendMode,datatools_NullTools.clone(this.meshParams));
		obj.library = this.library;
		this.copyBaseProperties(obj);
		return obj;
	}
	,isScene: function() {
		return this.namePath == nanofl_engine_Library.SCENE_NAME_PATH;
	}
	,toString: function() {
		return (this.parent != null ? this.parent.toString() + " / " : "") + "Instance(" + this.namePath + ")";
	}
	,get_layers: function() {
		if(js_Boot.__implements(this.get_symbol(),nanofl_engine_ILayersContainer)) {
			return this.get_symbol().get_layers();
		} else {
			return null;
		}
	}
	,createDisplayObject: function(frameIndexes) {
		var initFrameIndex = 0;
		if(frameIndexes != null && frameIndexes.length > 0 && frameIndexes[0].element == this) {
			initFrameIndex = frameIndexes[0].frameIndex;
			frameIndexes = frameIndexes.slice(1);
		} else {
			frameIndexes = null;
		}
		var dispObj = this.get_symbol().createDisplayObject(initFrameIndex,frameIndexes);
		this.updateDisplayObjectProperties(dispObj);
		this.updateDisplayObjectInstanceProperties(dispObj);
		return dispObj;
	}
	,updateDisplayObject: function(dispObj,frameIndexes) {
		this.updateDisplayObjectProperties(dispObj);
		this.get_symbol().updateDisplayObject(dispObj,frameIndexes);
		this.updateDisplayObjectInstanceProperties(dispObj);
		return dispObj;
	}
	,updateDisplayObjectInstanceProperties: function(dispObj) {
		if(dispObj.filters == null) {
			dispObj.filters = [];
		}
		dispObj.alpha = 1.0;
		if(this.colorEffect != null) {
			this.colorEffect.apply(dispObj);
		}
		var _g = 0;
		var _g1 = this.filters;
		while(_g < _g1.length) {
			var filter = _g1[_g];
			++_g;
			var f = filter.getFilter();
			if(f != null) {
				dispObj.filters.push(f);
			}
		}
		if(this.name != "") {
			dispObj.name = this.name;
		}
		dispObj.compositeOperation = this.blendMode;
		if(this.meshParams != null && ((dispObj) instanceof nanofl_Mesh)) {
			this.meshParams.applyToMesh(dispObj);
		}
	}
	,getNavigatorName: function() {
		return this.namePath;
	}
	,getNavigatorIcon: function() {
		return this.get_symbol().getIcon();
	}
	,getChildren: function() {
		var r = [];
		var _g = 0;
		var _g1 = this.get_layers();
		while(_g < _g1.length) {
			var layer = _g1[_g];
			++_g;
			if(layer._keyFrames.length > 0) {
				r = layer._keyFrames[0].get_elements().concat(r);
			}
		}
		return r;
	}
	,getTimeline: function() {
		if(js_Boot.__implements(this.get_symbol(),nanofl_engine_ITimeline)) {
			return this.get_symbol();
		} else {
			return null;
		}
	}
	,getNearestPointsLocal: function(pos) {
		return [this.get_symbol().getNearestPoint(pos)];
	}
	,setLibrary: function(library) {
		this.library = library;
	}
	,equ: function(element) {
		if(!nanofl_engine_elements_Element.prototype.equ.call(this,element)) {
			return false;
		}
		if(element.namePath != this.namePath) {
			return false;
		}
		if(element.name != this.name) {
			return false;
		}
		if(!datatools_NullTools.equ(element.colorEffect,this.colorEffect)) {
			return false;
		}
		if(!datatools_ArrayTools.equ(element.filters,this.filters)) {
			return false;
		}
		if(element.blendMode != this.blendMode) {
			return false;
		}
		if(!datatools_NullTools.equ(element.meshParams,this.meshParams)) {
			return false;
		}
		return true;
	}
	,getFilters: function() {
		return this.filters;
	}
	,setFilters: function(filters) {
		this.filters = filters;
	}
	,__class__: nanofl_engine_elements_Instance
});
var nanofl_engine_elements_ShapeElement = function(edges,polygons,isNormalize) {
	if(isNormalize == null) {
		isNormalize = true;
	}
	nanofl_engine_elements_Element.call(this);
	this.edges = edges != null ? edges : [];
	this.polygons = polygons != null ? polygons : [];
	if(isNormalize) {
		this.normalize();
	}
};
nanofl_engine_elements_ShapeElement.__name__ = "nanofl.engine.elements.ShapeElement";
nanofl_engine_elements_ShapeElement.createRectangle = function(x,y,width,height,rTopLeft,rTopRight,rBottomRight,rBottomLeft,stroke,fill) {
	var x1 = x;
	var y1 = y;
	var x2 = x + width;
	var y2 = y + height;
	var rTL = Math.abs(rTopLeft);
	var rTR = Math.abs(rTopRight);
	var rBR = Math.abs(rBottomRight);
	var rBL = Math.abs(rBottomLeft);
	var edges = [];
	var k = 0.87;
	if(rTopLeft > 0.0) {
		edges.push(new nanofl_engine_geom_Edge(x1 + rTL,y1,x1,y1,x1,y1 + rTL));
	} else if(rTopLeft < 0.0) {
		edges.push(new nanofl_engine_geom_Edge(x1 + rTL,y1,x1 + rTL * k,y1 + rTL * k,x1,y1 + rTL));
	}
	edges.push(new nanofl_engine_geom_Edge(x1,y1 + rTL,x1,y2 - rBL));
	if(rBottomLeft > 0.0) {
		edges.push(new nanofl_engine_geom_Edge(x1,y2 - rBL,x1,y2,x1 + rBL,y2));
	} else if(rBottomLeft < 0.0) {
		edges.push(new nanofl_engine_geom_Edge(x1,y2 - rBL,x1 + rBL * k,y2 - rBL * k,x1 + rBL,y2));
	}
	edges.push(new nanofl_engine_geom_Edge(x1 + rBL,y2,x2 - rBR,y2));
	if(rBottomRight > 0.0) {
		edges.push(new nanofl_engine_geom_Edge(x2 - rBR,y2,x2,y2,x2,y2 - rBR));
	} else if(rBottomRight < 0.0) {
		edges.push(new nanofl_engine_geom_Edge(x2 - rBR,y2,x2 - rBR * k,y2 - rBR * k,x2,y2 - rBR));
	}
	edges.push(new nanofl_engine_geom_Edge(x2,y2 - rBR,x2,y1 + rTR));
	if(rTopRight > 0.0) {
		edges.push(new nanofl_engine_geom_Edge(x2,y1 + rTR,x2,y1,x2 - rTR,y1));
	} else if(rTopRight < 0.0) {
		edges.push(new nanofl_engine_geom_Edge(x2,y1 + rTR,x2 - rTR * k,y1 + rTR * k,x2 - rTR,y1));
	}
	edges.push(new nanofl_engine_geom_Edge(x2 - rTR,y1,x1 + rTL,y1));
	var tmp;
	if(stroke != null) {
		var result = new Array(edges.length);
		var _g = 0;
		var _g1 = edges.length;
		while(_g < _g1) {
			var i = _g++;
			result[i] = nanofl_engine_geom_StrokeEdge.fromEdge(edges[i],stroke);
		}
		tmp = result;
	} else {
		tmp = [];
	}
	return new nanofl_engine_elements_ShapeElement(tmp,fill != null ? [new nanofl_engine_geom_Polygon(fill,[new nanofl_engine_geom_Contour(edges)])] : []);
};
nanofl_engine_elements_ShapeElement.createOval = function(cx,cy,rx,ry,startAngle,endAngle,innerRadius,closePath,stroke,fill) {
	if(endAngle == startAngle) {
		endAngle = startAngle + 360.0;
	}
	if(startAngle != 0.0 || endAngle != 360.0 || innerRadius != 0.0 || !closePath) {
		nanofl_engine_Debug.console.warn("Oval: processing startAngle, endAngle, innerRadius and closePath arguments are not implemented yet.");
	}
	var k = 1.075;
	var edges = [];
	var da = -Math.PI / 8;
	var i = 1;
	while(i <= 16) {
		edges.push(new nanofl_engine_geom_Edge(cx + rx * Math.cos(da * i),cy + ry * Math.sin(da * i),cx + rx * Math.cos(da * (i + 1)) * k,cy + ry * Math.sin(da * (i + 1)) * k,cx + rx * Math.cos(da * (i + 2)),cy + ry * Math.sin(da * (i + 2))));
		i += 2;
	}
	var tmp;
	if(stroke != null) {
		var result = new Array(edges.length);
		var _g = 0;
		var _g1 = edges.length;
		while(_g < _g1) {
			var i = _g++;
			result[i] = nanofl_engine_geom_StrokeEdge.fromEdge(edges[i],stroke);
		}
		tmp = result;
	} else {
		tmp = [];
	}
	return new nanofl_engine_elements_ShapeElement(tmp,fill != null ? [new nanofl_engine_geom_Polygon(fill,[new nanofl_engine_geom_Contour(edges)])] : []);
};
nanofl_engine_elements_ShapeElement.log = function(v,infos) {
};
nanofl_engine_elements_ShapeElement.__super__ = nanofl_engine_elements_Element;
nanofl_engine_elements_ShapeElement.prototype = $extend(nanofl_engine_elements_Element.prototype,{
	get_type: function() {
		return nanofl_engine_ElementType.shape;
	}
	,loadPropertiesJson: function(obj,version) {
		if(!nanofl_engine_elements_Element.prototype.loadPropertiesJson.call(this,obj,version)) {
			return false;
		}
		var fills = [];
		var strokes = [];
		var _g = 0;
		var tmp = obj.fills;
		var _g1 = tmp != null ? tmp : [];
		while(_g < _g1.length) {
			var fillObj = [_g1[_g]];
			++_g;
			var tmp = fillObj[0].type;
			switch(tmp != null ? tmp : "solid") {
			case "bitmap":
				fills.push(nanofl_engine_fills_BitmapFill.loadJson(fillObj[0],version));
				break;
			case "linear":
				fills.push(nanofl_engine_fills_LinearFill.loadJson(fillObj[0],version));
				break;
			case "radial":
				fills.push(nanofl_engine_fills_RadialFill.loadJson(fillObj[0],version));
				break;
			case "solid":
				fills.push(nanofl_engine_fills_SolidFill.loadJson(fillObj[0],version));
				break;
			default:
				nanofl_engine_elements_ShapeElement.log((function(fillObj) {
					return function() {
						return "Unknow fill type '" + Std.string(fillObj[0].type) + "'.";
					};
				})(fillObj),{ fileName : "engine/nanofl/engine/elements/ShapeElement.hx", lineNumber : 106, className : "nanofl.engine.elements.ShapeElement", methodName : "loadPropertiesJson"});
			}
		}
		var _g = 0;
		var tmp = obj.strokes;
		var _g1 = tmp != null ? tmp : [];
		while(_g < _g1.length) {
			var strokeObj = _g1[_g];
			++_g;
			strokes.push(nanofl_engine_strokes_BaseStroke.loadJson(strokeObj,version));
		}
		if(obj.figure != null) {
			this.edges = nanofl_engine_geom_StrokeEdges.loadJson(obj.figure.edges,strokes,version);
			var _this = obj.figure.polygons;
			var result = new Array(_this.length);
			var _g = 0;
			var _g1 = _this.length;
			while(_g < _g1) {
				var i = _g++;
				result[i] = nanofl_engine_geom_Polygon.loadJson(_this[i],fills,version);
			}
			this.polygons = result;
		}
		this.ensureNoTransform();
		return true;
	}
	,getFills: function() {
		var fills = [];
		var _g = 0;
		var _g1 = this.polygons;
		while(_g < _g1.length) {
			var p = [_g1[_g]];
			++_g;
			if(stdlib_LambdaIterable.findIndex(fills,(function(p) {
				return function(fill) {
					return fill.equ(p[0].fill);
				};
			})(p)) < 0) {
				fills.push(p[0].fill);
			}
		}
		return fills;
	}
	,getStrokes: function() {
		var strokes = [];
		var _g = 0;
		var _g1 = this.edges;
		while(_g < _g1.length) {
			var e = [_g1[_g]];
			++_g;
			if(stdlib_LambdaIterable.findIndex(strokes,(function(e) {
				return function(stroke) {
					return stroke.equ(e[0].stroke);
				};
			})(e)) < 0) {
				strokes.push(e[0].stroke);
			}
		}
		return strokes;
	}
	,ensureNoTransform: function() {
		this.transform(this.matrix);
		this.matrix.tx = 0;
		this.matrix.ty = 0;
		this.matrix.a = 1;
		this.matrix.b = 0;
		this.matrix.c = 0;
		this.matrix.d = 1;
	}
	,draw: function(g,scaleSelection) {
		var _g = 0;
		var _g1 = this.polygons;
		while(_g < _g1.length) {
			var p = _g1[_g];
			++_g;
			p.draw(g,scaleSelection);
		}
		nanofl_engine_geom_StrokeEdges.drawSorted(this.edges,g,scaleSelection);
	}
	,createDisplayObject: function(frameIndexes) {
		return this.updateDisplayObject(new createjs.Shape(),null);
	}
	,updateDisplayObject: function(dispObj,frameIndexes) {
		stdlib_Debug.assert(((dispObj) instanceof createjs.Shape),null,{ fileName : "engine/nanofl/engine/elements/ShapeElement.hx", lineNumber : 238, className : "nanofl.engine.elements.ShapeElement", methodName : "updateDisplayObject"});
		this.updateDisplayObjectProperties(dispObj);
		var shape = dispObj;
		shape.graphics.clear();
		var m = dispObj.getConcatenatedMatrix().invert();
		this.draw(shape.graphics,(m.a + m.d) / 2);
		if(!this.isEmpty()) {
			var b = this.getBounds();
			shape.setBounds(b.minX,b.minY,b.maxX - b.minX,b.maxY - b.minY);
		}
		return shape;
	}
	,clone: function() {
		var obj = new nanofl_engine_elements_ShapeElement(datatools_ArrayTools.clone(this.edges),datatools_ArrayTools.clone(this.polygons));
		this.copyBaseProperties(obj);
		return obj;
	}
	,translate: function(dx,dy) {
		if(dx == 0 && dy == 0) {
			return;
		}
		var _g = 0;
		var _g1 = this.edges;
		while(_g < _g1.length) {
			var e = _g1[_g];
			++_g;
			e.translate(dx,dy);
		}
		var _g = 0;
		var _g1 = this.polygons;
		while(_g < _g1.length) {
			var p = _g1[_g];
			++_g;
			p.translate(dx,dy);
		}
	}
	,isEmpty: function() {
		if(this.edges.length == 0) {
			return this.polygons.length == 0;
		} else {
			return false;
		}
	}
	,hasSelected: function() {
		if(!this.hasSelectedEdges()) {
			return this.hasSelectedPolygons();
		} else {
			return true;
		}
	}
	,isAllSelected: function() {
		if(Lambda.foreach(this.edges,function(e) {
			return e.get_selected();
		})) {
			return Lambda.foreach(this.polygons,function(e) {
				return e.get_selected();
			});
		} else {
			return false;
		}
	}
	,hasSelectedEdges: function() {
		return Lambda.exists(this.edges,function(e) {
			return e.get_selected();
		});
	}
	,hasSelectedPolygons: function() {
		return Lambda.exists(this.polygons,function(e) {
			return e.get_selected();
		});
	}
	,select: function(obj) {
		this.deselectAll();
		if(obj != null) {
			obj.selected = true;
		}
	}
	,selectAll: function() {
		var _g = 0;
		var _g1 = this.edges;
		while(_g < _g1.length) {
			var edge = _g1[_g];
			++_g;
			edge.set_selected(true);
		}
		var _g = 0;
		var _g1 = this.polygons;
		while(_g < _g1.length) {
			var polygon = _g1[_g];
			++_g;
			polygon.set_selected(true);
		}
	}
	,deselectAll: function() {
		var _g = 0;
		var _g1 = this.edges;
		while(_g < _g1.length) {
			var edge = _g1[_g];
			++_g;
			edge.set_selected(false);
		}
		var _g = 0;
		var _g1 = this.polygons;
		while(_g < _g1.length) {
			var polygon = _g1[_g];
			++_g;
			polygon.set_selected(false);
		}
	}
	,translateSelected: function(dx,dy) {
		var _g = 0;
		var _g1 = this.edges;
		while(_g < _g1.length) {
			var edge = _g1[_g];
			++_g;
			if(edge.get_selected()) {
				edge.translate(dx,dy);
			}
		}
		var _g = 0;
		var _g1 = this.polygons;
		while(_g < _g1.length) {
			var polygon = _g1[_g];
			++_g;
			if(polygon.get_selected()) {
				polygon.translate(dx,dy);
			}
		}
	}
	,translateVertex: function(point,dx,dy) {
		var _g = 0;
		var _g1 = this.edges;
		while(_g < _g1.length) {
			var edge = _g1[_g];
			++_g;
			edge.translateVertex(point,dx,dy);
		}
		var _g = 0;
		var _g1 = this.polygons;
		while(_g < _g1.length) {
			var polygon = _g1[_g];
			++_g;
			polygon.translateVertex(point,dx,dy);
		}
	}
	,removeSelected: function() {
		var edgeWasRemoved = Lambda.exists(this.edges,function(e) {
			return e.get_selected();
		});
		var i = 0;
		while(i < this.edges.length) if(this.edges[i].get_selected()) {
			this.edges.splice(i,1);
		} else {
			++i;
		}
		var i = 0;
		while(i < this.polygons.length) if(this.polygons[i].get_selected()) {
			this.polygons.splice(i,1);
		} else {
			++i;
		}
		if(edgeWasRemoved) {
			nanofl_engine_geom_Polygons.mergeByCommonEdges(this.polygons,this.edges);
		}
	}
	,getPolygonAtPos: function(pt) {
		var _g = 0;
		var _g1 = this.polygons;
		while(_g < _g1.length) {
			var polygon = _g1[_g];
			++_g;
			if(polygon.isPointInside(pt.x,pt.y)) {
				return polygon;
			}
		}
		return null;
	}
	,getSameEdges: function(edge) {
		var r = [];
		if(edge == null) {
			return r;
		}
		var _g = 0;
		var _g1 = this.edges;
		while(_g < _g1.length) {
			var e = _g1[_g];
			++_g;
			if(e.equ(edge)) {
				r.push(e);
			}
		}
		var _g = 0;
		var _g1 = this.polygons;
		while(_g < _g1.length) {
			var p = _g1[_g];
			++_g;
			var _g2 = 0;
			var _g3 = p.contours;
			while(_g2 < _g3.length) {
				var c = _g3[_g2];
				++_g2;
				var _g4 = 0;
				var _g5 = c.edges;
				while(_g4 < _g5.length) {
					var e = _g5[_g4];
					++_g4;
					if(e.equ(edge)) {
						r.push(e);
					}
				}
			}
		}
		return r;
	}
	,getNearestStrokeEdge: function(pt) {
		var r = { edge : null, dist : 1e100, point : null, t : 0.0};
		var _g = 0;
		var _g1 = this.edges;
		while(_g < _g1.length) {
			var edge = _g1[_g];
			++_g;
			var pointAndT = new nanofl_engine_geom_Edge(edge.x1,edge.y1,edge.x2,edge.y2,edge.x3,edge.y3).getNearestPoint(pt.x,pt.y);
			var b = pointAndT.point;
			var dist = nanofl_engine_geom_PointTools.getDist(pt.x,pt.y,b.x,b.y);
			if(dist < r.dist) {
				r.edge = edge;
				r.dist = dist;
				r.point = pointAndT.point;
				r.t = pointAndT.t;
			}
		}
		if(r.edge != null) {
			return r;
		} else {
			return null;
		}
	}
	,getNearestPolygonEdge: function(pt) {
		var edges = [];
		var _g = 0;
		var _g1 = this.polygons;
		while(_g < _g1.length) {
			var polygon = _g1[_g];
			++_g;
			polygon.getEdges(edges);
		}
		var bestEdge = null;
		var bestDist2 = 1.0e100;
		var bestPoint = null;
		var bestT = null;
		var _g = 0;
		while(_g < edges.length) {
			var edge = edges[_g];
			++_g;
			var posAndT = edge.getNearestPoint(pt.x,pt.y);
			var b = posAndT.point;
			var dist2 = nanofl_engine_geom_PointTools.getSqrDist(pt.x,pt.y,b.x,b.y);
			if(dist2 < bestDist2) {
				bestEdge = edge;
				bestDist2 = dist2;
				bestPoint = posAndT.point;
				bestT = posAndT.t;
			}
		}
		if(bestEdge != null) {
			return { edge : bestEdge, dist : Math.sqrt(bestDist2), point : bestPoint, t : bestT};
		} else {
			return null;
		}
	}
	,getNearestVertex: function(pt,excludeSelf) {
		if(excludeSelf == null) {
			excludeSelf = false;
		}
		var bestPoint = null;
		var bestDist = 1.0e100;
		var bestDistMinusEdgeThickness = 1.0e100;
		var _g = 0;
		var _g1 = this.edges;
		while(_g < _g1.length) {
			var edge = _g1[_g];
			++_g;
			var M1 = { x : edge.x1, y : edge.y1};
			if(!excludeSelf || M1.x != pt.x || M1.y != pt.y) {
				var dist = nanofl_engine_geom_PointTools.getDist(pt.x,pt.y,M1.x,M1.y);
				if(dist < bestDist) {
					bestPoint = M1;
					bestDist = dist;
					bestDistMinusEdgeThickness = Math.max(0,dist - edge.stroke.thickness / 2);
				}
			}
			var M2 = { x : edge.x3, y : edge.y3};
			if(!excludeSelf || M2.x != pt.x || M2.y != pt.y) {
				var dist1 = nanofl_engine_geom_PointTools.getSqrDist(pt.x,pt.y,M2.x,M2.y);
				if(dist1 < bestDist) {
					bestPoint = M2;
					bestDist = dist1;
					bestDistMinusEdgeThickness = Math.max(0,dist1 - edge.stroke.thickness / 2);
				}
			}
		}
		var _g = 0;
		var _g1 = this.polygons;
		while(_g < _g1.length) {
			var polygon = _g1[_g];
			++_g;
			var _g2 = 0;
			var _g3 = polygon.getEdges();
			while(_g2 < _g3.length) {
				var edge = _g3[_g2];
				++_g2;
				var M1 = { x : edge.x1, y : edge.y1};
				if(!excludeSelf || M1.x != pt.x || M1.y != pt.y) {
					var dist = nanofl_engine_geom_PointTools.getDist(pt.x,pt.y,M1.x,M1.y);
					if(dist < bestDist) {
						bestPoint = M1;
						bestDist = dist;
						bestDistMinusEdgeThickness = dist;
					}
				}
				var M2 = { x : edge.x3, y : edge.y3};
				if(!excludeSelf || M2.x != pt.x || M2.y != pt.y) {
					var dist1 = nanofl_engine_geom_PointTools.getDist(pt.x,pt.y,M2.x,M2.y);
					if(dist1 < bestDist) {
						bestPoint = M2;
						bestDist = dist1;
						bestDistMinusEdgeThickness = dist1;
					}
				}
			}
		}
		if(bestPoint != null) {
			return { point : bestPoint, dist : bestDist, distMinusEdgeThickness : bestDistMinusEdgeThickness};
		} else {
			return null;
		}
	}
	,setSelectedEdgesStroke: function(stroke) {
		var _g = 0;
		var _g1 = this.edges;
		while(_g < _g1.length) {
			var edge = _g1[_g];
			++_g;
			if(edge.get_selected()) {
				edge.stroke = stroke;
			}
		}
	}
	,setSelectedEdgesStrokeParams: function(params) {
		var _g = 0;
		var _g1 = this.edges;
		while(_g < _g1.length) {
			var edge = _g1[_g];
			++_g;
			if(edge.get_selected()) {
				var stroke = edge.stroke.clone();
				if(params.thickness != null) {
					stroke.thickness = params.thickness;
				}
				if(params.ignoreScale != null) {
					stroke.ignoreScale = params.ignoreScale;
				}
				if(params.caps != null) {
					stroke.caps = params.caps;
				}
				if(params.joints != null) {
					stroke.joints = params.joints;
				}
				if(params.miterLimit != null) {
					stroke.miterLimit = params.miterLimit;
				}
				var _g2 = stroke.getTyped();
				switch(_g2._hx_index) {
				case 0:
					var stroke1 = _g2.stroke;
					if(params.color != null) {
						stroke1.color = params.color;
					}
					break;
				case 1:
					var stroke2 = _g2.stroke;
					if(params.colors != null) {
						stroke2.colors = params.colors;
					}
					if(params.ratios != null) {
						stroke2.ratios = params.ratios;
					}
					if(params.x0 != null) {
						stroke2.x0 = params.x0;
					}
					if(params.y0 != null) {
						stroke2.y0 = params.y0;
					}
					if(params.x1 != null) {
						stroke2.x1 = params.x1;
					}
					if(params.y1 != null) {
						stroke2.y1 = params.y1;
					}
					break;
				case 2:
					var stroke3 = _g2.stroke;
					if(params.colors != null) {
						stroke3.colors = params.colors;
					}
					if(params.ratios != null) {
						stroke3.ratios = params.ratios;
					}
					if(params.x0 != null) {
						stroke3.fx = params.x0;
					}
					if(params.y0 != null) {
						stroke3.fy = params.y0;
					}
					if(params.x1 != null) {
						stroke3.cx = params.x1;
					}
					if(params.y1 != null) {
						stroke3.cy = params.y1;
					}
					if(params.r != null) {
						stroke3.r = params.r;
					}
					break;
				case 3:
					var stroke4 = _g2.stroke;
					if(params.bitmapPath != null) {
						stroke4.bitmapPath = params.bitmapPath;
					}
					break;
				}
				edge.stroke = stroke;
			}
		}
	}
	,getSelectedEdgesStrokeParams: function() {
		var r = { type : null, thickness : null, ignoreScale : null, color : null, colors : null, ratios : null, x0 : null, y0 : null, x1 : null, y1 : null, r : null, bitmapPath : null, caps : null, joints : null, miterLimit : null};
		var _g = 0;
		var _g1 = this.edges;
		while(_g < _g1.length) {
			var edge = _g1[_g];
			++_g;
			if(edge.get_selected()) {
				r.thickness = r.thickness == null || r.thickness == edge.stroke.thickness ? edge.stroke.thickness : -1;
				r.ignoreScale = (r.ignoreScale == null || r.ignoreScale == edge.stroke.ignoreScale) && edge.stroke.ignoreScale;
				r.caps = r.caps == null || r.caps == edge.stroke.caps ? edge.stroke.caps : "mixed";
				r.joints = r.joints == null || r.joints == edge.stroke.joints ? edge.stroke.joints : "mixed";
				r.miterLimit = r.miterLimit == null || r.miterLimit == edge.stroke.miterLimit ? edge.stroke.miterLimit : -1;
				var _g2 = edge.stroke.getTyped();
				switch(_g2._hx_index) {
				case 0:
					var stroke = _g2.stroke;
					r.type = r.type == null || r.type == "solid" ? "solid" : "mixed";
					r.color = stroke.color;
					break;
				case 1:
					var stroke1 = _g2.stroke;
					r.type = r.type == null || r.type == "linear" ? "linear" : "mixed";
					r.colors = stroke1.colors;
					r.ratios = stroke1.ratios;
					r.x0 = stroke1.x0;
					r.y0 = stroke1.y0;
					r.x1 = stroke1.x1;
					r.y1 = stroke1.y1;
					break;
				case 2:
					var stroke2 = _g2.stroke;
					r.type = r.type == null || r.type == "radial" ? "radial" : "mixed";
					r.colors = stroke2.colors;
					r.ratios = stroke2.ratios;
					r.x0 = stroke2.fx;
					r.y0 = stroke2.fy;
					r.x1 = stroke2.cx;
					r.y1 = stroke2.cy;
					r.r = stroke2.r;
					break;
				case 3:
					var stroke3 = _g2.stroke;
					r.type = r.type == null || r.type == "bitmap" ? "bitmap" : "mixed";
					r.bitmapPath = stroke3.bitmapPath;
					break;
				}
			}
		}
		return r;
	}
	,setSelectedPolygonsFill: function(fill,x1,y1,x2,y2) {
		var _g = 0;
		var _g1 = this.polygons;
		while(_g < _g1.length) {
			var polygon = _g1[_g];
			++_g;
			if(polygon.get_selected()) {
				polygon.applyFill(fill,x1,y1,x2,y2);
			}
		}
	}
	,setSelectedPolygonsFillParams: function(params) {
		var _g = 0;
		var _g1 = this.polygons;
		while(_g < _g1.length) {
			var polygon = _g1[_g];
			++_g;
			if(polygon.get_selected()) {
				var fill = polygon.fill.clone();
				var _g2 = fill.getTyped();
				switch(_g2._hx_index) {
				case 0:
					var fill1 = _g2.fill;
					if(params.color != null) {
						fill1.color = params.color;
					}
					break;
				case 1:
					var fill2 = _g2.fill;
					if(params.colors != null) {
						fill2.colors = params.colors;
					}
					if(params.ratios != null) {
						fill2.ratios = params.ratios;
					}
					if(params.x0 != null) {
						fill2.x0 = params.x0;
					}
					if(params.y0 != null) {
						fill2.y0 = params.y0;
					}
					if(params.x1 != null) {
						fill2.x1 = params.x1;
					}
					if(params.y1 != null) {
						fill2.y1 = params.y1;
					}
					break;
				case 2:
					var fill3 = _g2.fill;
					if(params.colors != null) {
						fill3.colors = params.colors;
					}
					if(params.ratios != null) {
						fill3.ratios = params.ratios;
					}
					if(params.x0 != null) {
						fill3.fx = params.x0;
					}
					if(params.y0 != null) {
						fill3.fy = params.y0;
					}
					if(params.x1 != null) {
						fill3.cx = params.x1;
					}
					if(params.y1 != null) {
						fill3.cy = params.y1;
					}
					if(params.r != null) {
						fill3.r = params.r;
					}
					break;
				case 3:
					var fill4 = _g2.fill;
					if(params.bitmapPath != null) {
						fill4.bitmapPath = params.bitmapPath;
					}
					if(params.matrix != null) {
						fill4.matrix = params.matrix;
					}
					if(params.repeat != null) {
						fill4.repeat = params.repeat;
					}
					break;
				}
				polygon.fill = fill;
			}
		}
	}
	,getSelectedPolygonsFillParams: function() {
		var r = { type : null, color : null, colors : null, ratios : null, x0 : null, y0 : null, x1 : null, y1 : null, r : null, bitmapPath : null, matrix : null, repeat : null};
		var _g = 0;
		var _g1 = this.polygons;
		while(_g < _g1.length) {
			var polygon = _g1[_g];
			++_g;
			if(polygon.get_selected()) {
				var _g2 = polygon.fill.getTyped();
				switch(_g2._hx_index) {
				case 0:
					var fill = _g2.fill;
					r.type = r.type == null || r.type == "solid" ? "solid" : "mixed";
					r.color = fill.color;
					break;
				case 1:
					var fill1 = _g2.fill;
					r.type = r.type == null || r.type == "linear" ? "linear" : "mixed";
					r.colors = fill1.colors;
					r.ratios = fill1.ratios;
					r.x0 = fill1.x0;
					r.y0 = fill1.y0;
					r.x1 = fill1.x1;
					r.y1 = fill1.y1;
					break;
				case 2:
					var fill2 = _g2.fill;
					r.type = r.type == null || r.type == "radial" ? "radial" : "mixed";
					r.colors = fill2.colors;
					r.ratios = fill2.ratios;
					r.x0 = fill2.fx;
					r.y0 = fill2.fy;
					r.x1 = fill2.cx;
					r.y1 = fill2.cy;
					r.r = fill2.r;
					break;
				case 3:
					var fill3 = _g2.fill;
					r.type = r.type == null || r.type == "bitmap" ? "bitmap" : "mixed";
					r.bitmapPath = fill3.bitmapPath;
					r.matrix = fill3.matrix;
					r.repeat = fill3.repeat;
					break;
				}
			}
		}
		if(r.type == "mixed") {
			r.type = null;
		}
		return r;
	}
	,floodFill: function(fill,x1,y1,x2,y2) {
		var polygon = this.findOrCreatePolygonByPoint((x1 + x2) / 2,(y1 + y2) / 2);
		if(polygon != null) {
			polygon.applyFill(fill,x1,y1,x2,y2);
		}
	}
	,getBounds: function(bounds,useStrokeThickness) {
		if(useStrokeThickness == null) {
			useStrokeThickness = true;
		}
		if(this.edges.length > 0 || this.polygons.length > 0) {
			if(bounds == null) {
				bounds = { minX : 1e100, minY : 1e100, maxX : -1e100, maxY : -1e100};
			}
			if(useStrokeThickness) {
				nanofl_engine_geom_StrokeEdges.getBounds(this.edges,bounds);
			} else {
				nanofl_engine_geom_Edges.getBounds(this.edges,bounds);
			}
			var _g = 0;
			var _g1 = this.polygons;
			while(_g < _g1.length) {
				var polygon = _g1[_g];
				++_g;
				polygon.getBounds(bounds);
			}
		}
		return bounds;
	}
	,getSelectedBounds: function(bounds,useStrokeThickness) {
		if(useStrokeThickness == null) {
			useStrokeThickness = true;
		}
		var selectedEdges = [];
		var _g = 0;
		var _g1 = this.edges;
		while(_g < _g1.length) {
			var e = _g1[_g];
			++_g;
			if(e.get_selected()) {
				selectedEdges.push(e);
			}
		}
		var selectedPolygons = [];
		var _g = 0;
		var _g1 = this.polygons;
		while(_g < _g1.length) {
			var p = _g1[_g];
			++_g;
			if(p.get_selected()) {
				selectedPolygons.push(p);
			}
		}
		if(selectedEdges.length > 0 || selectedPolygons.length > 0) {
			if(bounds == null) {
				bounds = { minX : 1e100, minY : 1e100, maxX : -1e100, maxY : -1e100};
			}
			if(useStrokeThickness) {
				nanofl_engine_geom_StrokeEdges.getBounds(selectedEdges,bounds);
			} else {
				nanofl_engine_geom_Edges.getBounds(selectedEdges,bounds);
			}
			var _g = 0;
			while(_g < selectedPolygons.length) {
				var polygon = selectedPolygons[_g];
				++_g;
				polygon.getBounds(bounds);
			}
		}
		return bounds;
	}
	,findOrCreatePolygonByPoint: function(x,y,fill) {
		var polygon = nanofl_engine_geom_Polygons.findByPoint(this.polygons,x,y);
		if(polygon != null) {
			return polygon;
		}
		var allEdges = this.getEdges();
		stdlib_Debug.assert(!nanofl_engine_geom_Edges.hasDuplicates(allEdges),allEdges.toString(),{ fileName : "engine/nanofl/engine/elements/ShapeElement.hx", lineNumber : 770, className : "nanofl.engine.elements.ShapeElement", methodName : "findOrCreatePolygonByPoint"});
		var contours = nanofl_engine_geom_Contours.fromEdges(allEdges);
		var outers = [];
		var inners = [];
		var _g = 0;
		while(_g < contours.length) {
			var contour = contours[_g];
			++_g;
			if(contour.isPointInside(x,y)) {
				outers.push(contour);
			} else {
				inners.push(contour);
			}
		}
		var i = 0;
		while(i < outers.length) {
			var j = 0;
			while(j < outers.length) {
				if(i != j && outers[i].isNestedTo(outers[j])) {
					outers.splice(j,1);
					if(i > j) {
						--i;
					}
					--j;
				}
				++j;
			}
			++i;
		}
		if(outers.length == 0) {
			return null;
		}
		var outer = outers[0];
		var _g = [];
		var _g1 = 0;
		var _g2 = inners;
		while(_g1 < _g2.length) {
			var v = _g2[_g1];
			++_g1;
			if(v.isNestedTo(outer)) {
				_g.push(v);
			}
		}
		inners = _g;
		var i = 0;
		while(i < inners.length) {
			var j = 0;
			while(j < inners.length) {
				if(i != j && inners[j].isNestedTo(inners[i])) {
					inners.splice(j,1);
					if(i > j) {
						--i;
					}
					--j;
				}
				++j;
			}
			++i;
		}
		stdlib_Debug.assert(outer.isClockwise(),null,{ fileName : "engine/nanofl/engine/elements/ShapeElement.hx", lineNumber : 824, className : "nanofl.engine.elements.ShapeElement", methodName : "findOrCreatePolygonByPoint"});
		polygon = new nanofl_engine_geom_Polygon(fill);
		polygon.contours.push(outer);
		var _g = 0;
		while(_g < inners.length) {
			var inner = inners[_g];
			++_g;
			inner.reverse();
			stdlib_Debug.assert(inner.isCounterClockwise(),null,{ fileName : "engine/nanofl/engine/elements/ShapeElement.hx", lineNumber : 831, className : "nanofl.engine.elements.ShapeElement", methodName : "findOrCreatePolygonByPoint"});
			polygon.contours.push(inner);
		}
		this.polygons.push(polygon);
		return polygon;
	}
	,transform: function(m,applyToStrokeAndFill) {
		if(applyToStrokeAndFill == null) {
			applyToStrokeAndFill = true;
		}
		if(m.isIdentity()) {
			return;
		}
		var _g = 0;
		var _g1 = this.edges;
		while(_g < _g1.length) {
			var edge = _g1[_g];
			++_g;
			edge.transform(m,applyToStrokeAndFill);
		}
		var _g = 0;
		var _g1 = this.polygons;
		while(_g < _g1.length) {
			var polygon = _g1[_g];
			++_g;
			polygon.transform(m,applyToStrokeAndFill);
		}
		this.normalize();
	}
	,transformSelected: function(m,applyToStrokeThickness) {
		if(applyToStrokeThickness == null) {
			applyToStrokeThickness = true;
		}
		var _g = 0;
		var _g1 = this.edges;
		while(_g < _g1.length) {
			var edge = _g1[_g];
			++_g;
			if(edge.get_selected()) {
				edge.transform(m,applyToStrokeThickness);
			}
		}
		var _g = 0;
		var _g1 = this.polygons;
		while(_g < _g1.length) {
			var polygon = _g1[_g];
			++_g;
			if(polygon.get_selected()) {
				polygon.transform(m);
			}
		}
		this.normalize();
	}
	,extractSelected: function() {
		var _g = [];
		var _g1 = 0;
		var _g2 = this.edges;
		while(_g1 < _g2.length) {
			var v = _g2[_g1];
			++_g1;
			if(v.get_selected()) {
				_g.push(v);
			}
		}
		var tmp = datatools_ArrayTools.clone(_g);
		var _g = [];
		var _g1 = 0;
		var _g2 = this.polygons;
		while(_g1 < _g2.length) {
			var v = _g2[_g1];
			++_g1;
			if(v.get_selected()) {
				_g.push(v);
			}
		}
		return new nanofl_engine_elements_ShapeElement(tmp,datatools_ArrayTools.clone(_g));
	}
	,assertCorrect: function() {
	}
	,getEdges: function() {
		var r = this.edges.slice();
		var _g = 0;
		var _g1 = this.polygons;
		while(_g < _g1.length) {
			var p = _g1[_g];
			++_g;
			p.getEdges(r);
		}
		stdlib_Debug.assert(!nanofl_engine_geom_Edges.hasDuplicates(r),null,{ fileName : "engine/nanofl/engine/elements/ShapeElement.hx", lineNumber : 1063, className : "nanofl.engine.elements.ShapeElement", methodName : "getEdges"});
		return r;
	}
	,replaceEdge: function(search,replacement) {
		nanofl_engine_geom_StrokeEdges.replace(this.edges,search,replacement);
		stdlib_Debug.assert(search.indexIn(this.edges) < 0,"\nsearch = " + Std.string(search) + "\nreplacement = " + Std.string(replacement),{ fileName : "engine/nanofl/engine/elements/ShapeElement.hx", lineNumber : 1070, className : "nanofl.engine.elements.ShapeElement", methodName : "replaceEdge"});
		var _g = 0;
		var _g1 = this.polygons;
		while(_g < _g1.length) {
			var p = _g1[_g];
			++_g;
			p.replaceEdge(search,replacement);
			stdlib_Debug.assert(search.indexIn(p.getEdges()) < 0,"\nsearch = " + Std.string(search) + "\nreplacement = " + Std.string(replacement),{ fileName : "engine/nanofl/engine/elements/ShapeElement.hx", lineNumber : 1075, className : "nanofl.engine.elements.ShapeElement", methodName : "replaceEdge"});
		}
		stdlib_Debug.assert(search.indexIn(this.getEdges()) < 0,"\nsearch = " + Std.string(search) + "\nreplacement = " + Std.string(replacement),{ fileName : "engine/nanofl/engine/elements/ShapeElement.hx", lineNumber : 1078, className : "nanofl.engine.elements.ShapeElement", methodName : "replaceEdge"});
	}
	,normalize: function() {
		nanofl_engine_geom_Edges.normalize(this.edges);
		nanofl_engine_geom_Polygons.normalize(this.polygons);
	}
	,swapInstance: function(oldNamePath,newNamePath) {
		var _g = 0;
		var _g1 = this.edges;
		while(_g < _g1.length) {
			var edge = _g1[_g];
			++_g;
			edge.stroke.swapInstance(oldNamePath,newNamePath);
		}
		var _g = 0;
		var _g1 = this.polygons;
		while(_g < _g1.length) {
			var polygon = _g1[_g];
			++_g;
			polygon.fill.swapInstance(oldNamePath,newNamePath);
		}
	}
	,applyStrokeAlpha: function(alpha) {
		if(alpha == 1) {
			return;
		}
		var processed = new haxe_ds_ObjectMap();
		var _g = 0;
		var _g1 = this.edges;
		while(_g < _g1.length) {
			var edge = _g1[_g];
			++_g;
			if(processed.h.__keys__[edge.stroke.__id__] == null) {
				edge.stroke.applyAlpha(alpha);
				processed.set(edge.stroke,true);
			}
		}
	}
	,applyFillAlpha: function(alpha) {
		if(alpha == 1) {
			return;
		}
		var processed = new haxe_ds_ObjectMap();
		var _g = 0;
		var _g1 = this.polygons;
		while(_g < _g1.length) {
			var polygon = _g1[_g];
			++_g;
			if(processed.h.__keys__[polygon.fill.__id__] == null) {
				polygon.fill.applyAlpha(alpha);
				processed.set(polygon.fill,true);
			}
		}
	}
	,getEdgeCount: function() {
		var r = this.edges.length;
		var _g = 0;
		var _g1 = this.polygons;
		while(_g < _g1.length) {
			var p = _g1[_g];
			++_g;
			r += p.getEdges().length;
		}
		return r;
	}
	,setLibrary: function(library) {
		var _g = 0;
		var _g1 = this.edges;
		while(_g < _g1.length) {
			var edge = _g1[_g];
			++_g;
			edge.stroke.setLibrary(library);
		}
		var _g = 0;
		var _g1 = this.polygons;
		while(_g < _g1.length) {
			var polygon = _g1[_g];
			++_g;
			polygon.fill.setLibrary(library);
		}
	}
	,equ: function(element) {
		if(!nanofl_engine_elements_Element.prototype.equ.call(this,element)) {
			return false;
		}
		if(!datatools_ArrayTools.equ(element.edges,this.edges)) {
			return false;
		}
		if(!datatools_ArrayTools.equ(element.polygons,this.polygons)) {
			return false;
		}
		return true;
	}
	,getNearestPointsLocal: function(pos) {
		var _g = 0;
		var _g1 = this.polygons;
		while(_g < _g1.length) {
			var polygon = _g1[_g];
			++_g;
			if(polygon.isPointInside(pos.x,pos.y)) {
				return [pos];
			}
		}
		var points = [];
		var _g = 0;
		var _g1 = this.polygons;
		while(_g < _g1.length) {
			var polygon = _g1[_g];
			++_g;
			var _this = polygon.getEdges();
			var result = new Array(_this.length);
			var _g2 = 0;
			var _g3 = _this.length;
			while(_g2 < _g3) {
				var i = _g2++;
				result[i] = _this[i].getNearestPoint(pos.x,pos.y).point;
			}
			points = points.concat(result);
		}
		var _this = this.edges;
		var result = new Array(_this.length);
		var _g = 0;
		var _g1 = _this.length;
		while(_g < _g1) {
			var i = _g++;
			result[i] = _this[i].getNearestPointUseStrokeSize(pos.x,pos.y).point;
		}
		points = points.concat(result);
		return points;
	}
	,toString: function() {
		return (this.parent != null ? this.parent.toString() + " / " : "") + "Shape";
	}
	,__class__: nanofl_engine_elements_ShapeElement
});
var nanofl_engine_elements_SpriteFrameElement = function(sprite,index) {
	nanofl_engine_elements_Element.call(this);
	this.sprite = sprite;
	this.index = index;
};
nanofl_engine_elements_SpriteFrameElement.__name__ = "nanofl.engine.elements.SpriteFrameElement";
nanofl_engine_elements_SpriteFrameElement.__super__ = nanofl_engine_elements_Element;
nanofl_engine_elements_SpriteFrameElement.prototype = $extend(nanofl_engine_elements_Element.prototype,{
	get_type: function() {
		return nanofl_engine_ElementType.spriteFrame;
	}
	,loadPropertiesJson: function(obj,version) {
		return stdlib_Debug.methodNotSupported(this,{ fileName : "engine/nanofl/engine/elements/SpriteFrameElement.hx", lineNumber : 30, className : "nanofl.engine.elements.SpriteFrameElement", methodName : "loadPropertiesJson"});
	}
	,clone: function() {
		return stdlib_Debug.methodNotSupported(this,{ fileName : "engine/nanofl/engine/elements/SpriteFrameElement.hx", lineNumber : 37, className : "nanofl.engine.elements.SpriteFrameElement", methodName : "clone"});
	}
	,createDisplayObject: function(frameIndexes) {
		var dispObj = this.sprite.createDisplayObject(this.index,null);
		this.updateDisplayObjectProperties(dispObj);
		return dispObj;
	}
	,updateDisplayObject: function(dispObj,frameIndexes) {
		this.updateDisplayObjectProperties(dispObj);
		this.sprite.updateDisplayObject(dispObj,frameIndexes);
		return dispObj;
	}
	,getNearestPointsLocal: function(pos) {
		return [this.sprite.getNearestPoint(pos)];
	}
	,equ: function(element) {
		return stdlib_Debug.methodNotSupported(this,{ fileName : "engine/nanofl/engine/elements/SpriteFrameElement.hx", lineNumber : 63, className : "nanofl.engine.elements.SpriteFrameElement", methodName : "equ"});
	}
	,toString: function() {
		return "SpriteFrameElement(" + this.sprite.namePath + ":" + this.index + ")";
	}
	,__class__: nanofl_engine_elements_SpriteFrameElement
});
var nanofl_engine_elements_TextElement = function(name,width,height,selectable,border,textRuns,newTextFormat) {
	nanofl_engine_elements_Element.call(this);
	this.name = name;
	this.width = width;
	this.height = height;
	this.selectable = selectable;
	this.border = border;
	this.textRuns = textRuns;
	this.newTextFormat = newTextFormat != null ? newTextFormat : new nanofl_TextRun();
};
nanofl_engine_elements_TextElement.__name__ = "nanofl.engine.elements.TextElement";
nanofl_engine_elements_TextElement.__super__ = nanofl_engine_elements_Element;
nanofl_engine_elements_TextElement.prototype = $extend(nanofl_engine_elements_Element.prototype,{
	get_type: function() {
		return nanofl_engine_ElementType.text;
	}
	,loadPropertiesJson: function(obj,version) {
		var _gthis = this;
		if(!nanofl_engine_elements_Element.prototype.loadPropertiesJson.call(this,obj,version)) {
			return false;
		}
		var tmp = obj.name;
		this.name = tmp != null ? tmp : "";
		var tmp = obj.width;
		this.width = tmp != null ? tmp : 0.0;
		var tmp = obj.height;
		this.height = tmp != null ? tmp : 0.0;
		var tmp = obj.selectable;
		this.selectable = tmp != null && tmp;
		var tmp = obj.border;
		this.border = tmp != null && tmp;
		var _this = obj.textRuns;
		var result = new Array(_this.length);
		var _g = 0;
		var _g1 = _this.length;
		while(_g < _g1) {
			var i = _g++;
			result[i] = _gthis.loadTextRunJson(_this[i]);
		}
		var _g = [];
		var _g1 = 0;
		var _g2 = result;
		while(_g1 < _g2.length) {
			var v = _g2[_g1];
			++_g1;
			if(!stdlib_StringTools.isNullOrEmpty(v.characters)) {
				_g.push(v);
			}
		}
		this.textRuns = _g;
		this.newTextFormat = this.loadTextRunJson(obj.newTextFormat);
		return true;
	}
	,loadTextRunJson: function(obj) {
		var tmp = obj.fillColor;
		var tmp1 = obj.family;
		var tmp2 = obj.style;
		var tmp3 = obj.size;
		var tmp4 = obj.align;
		var tmp5 = obj.strokeSize;
		var tmp6 = obj.strokeColor;
		var tmp7 = obj.kerning;
		var tmp8 = obj.letterSpacing;
		var tmp9 = obj.lineSpacing;
		return nanofl_TextRun.create(obj.characters,tmp != null ? tmp : "#000000",tmp1 != null ? tmp1 : "Times",tmp2 != null ? tmp2 : "",tmp3 != null ? tmp3 : 12.0,tmp4 != null ? tmp4 : "left",tmp5 != null ? tmp5 : 0.0,tmp6 != null ? tmp6 : "#000000",tmp7 != null ? tmp7 : true,tmp8 != null ? tmp8 : 0.0,tmp9 != null ? tmp9 : 2.0);
	}
	,getText: function() {
		var _this = this.textRuns;
		var result = new Array(_this.length);
		var _g = 0;
		var _g1 = _this.length;
		while(_g < _g1) {
			var i = _g++;
			result[i] = _this[i].characters;
		}
		return result.join("");
	}
	,createDisplayObject: function(frameIndexes) {
		var dispObj = new nanofl_TextField();
		this.updateDisplayObject(dispObj,null);
		if(this.name != "") {
			dispObj.name = this.name;
		}
		return dispObj;
	}
	,updateDisplayObject: function(dispObj,frameIndexes) {
		stdlib_Debug.assert(((dispObj) instanceof nanofl_TextField),null,{ fileName : "engine/nanofl/engine/elements/TextElement.hx", lineNumber : 211, className : "nanofl.engine.elements.TextElement", methodName : "updateDisplayObject"});
		this.updateDisplayObjectProperties(dispObj);
		var tf = dispObj;
		tf.width = this.width;
		tf.height = this.height;
		tf.selectable = this.selectable;
		tf.border = this.border;
		tf.textRuns = datatools_ArrayTools.clone(this.textRuns);
		tf.newTextFormat = this.newTextFormat;
		tf.setBounds(0.5,0.5,this.width,this.height);
		return tf;
	}
	,getMinSize: function(dispObj) {
		stdlib_Debug.assert(((dispObj) instanceof nanofl_TextField),null,{ fileName : "engine/nanofl/engine/elements/TextElement.hx", lineNumber : 235, className : "nanofl.engine.elements.TextElement", methodName : "getMinSize"});
		return { width : dispObj.minWidth, height : dispObj.minHeight};
	}
	,getNearestPointsLocal: function(pos) {
		var bounds = { minX : 0.0, minY : 0.0, maxX : this.width, maxY : this.height};
		return [nanofl_engine_geom_BoundsTools.getNearestPoint(bounds,pos)];
	}
	,equ: function(element) {
		if(!nanofl_engine_elements_Element.prototype.equ.call(this,element)) {
			return false;
		}
		if(element.name != this.name) {
			return false;
		}
		if(element.width != this.width) {
			return false;
		}
		if(element.height != this.height) {
			return false;
		}
		if(element.selectable != this.selectable) {
			return false;
		}
		if(element.border != this.border) {
			return false;
		}
		if(!datatools_ArrayTools.equ(element.textRuns,this.textRuns)) {
			return false;
		}
		if(!element.newTextFormat.equ(this.newTextFormat)) {
			return false;
		}
		return true;
	}
	,clone: function() {
		var obj = new nanofl_engine_elements_TextElement(this.name,this.width,this.height,this.selectable,this.border,datatools_ArrayTools.clone(this.textRuns),this.newTextFormat.clone());
		this.copyBaseProperties(obj);
		return obj;
	}
	,__class__: nanofl_engine_elements_TextElement
});
var nanofl_engine_fills_BaseFill = function() { };
nanofl_engine_fills_BaseFill.__name__ = "nanofl.engine.fills.BaseFill";
nanofl_engine_fills_BaseFill.load = function(node,version) {
	switch(htmlparser_HtmlParserTools.getAttr(node,"type","solid")) {
	case "bitmap":
		return nanofl_engine_fills_BitmapFill.load(node,version);
	case "linear":
		return nanofl_engine_fills_LinearFill.load(node,version);
	case "radial":
		return nanofl_engine_fills_RadialFill.load(node,version);
	case "solid":
		return nanofl_engine_fills_SolidFill.load(node,version);
	default:
		throw new Error("Unknow fill type '" + Std.string(htmlparser_HtmlParserTools.getAttr(node,"type")) + "'.");
	}
};
nanofl_engine_fills_BaseFill.prototype = {
	__class__: nanofl_engine_fills_BaseFill
};
var nanofl_engine_fills_IFill = function() { };
nanofl_engine_fills_IFill.__name__ = "nanofl.engine.fills.IFill";
nanofl_engine_fills_IFill.__isInterface__ = true;
nanofl_engine_fills_IFill.prototype = {
	__class__: nanofl_engine_fills_IFill
};
var nanofl_engine_fills_BitmapFill = function(bitmapPath,repeat,matrix) {
	this.bitmapPath = bitmapPath;
	this.repeat = repeat;
	this.matrix = matrix;
};
nanofl_engine_fills_BitmapFill.__name__ = "nanofl.engine.fills.BitmapFill";
nanofl_engine_fills_BitmapFill.__interfaces__ = [nanofl_engine_fills_IFill];
nanofl_engine_fills_BitmapFill.load = function(node,version) {
	return new nanofl_engine_fills_BitmapFill(htmlparser_HtmlParserTools.getAttr(node,"bitmapPath"),htmlparser_HtmlParserTools.getAttr(node,"repeat","repeat"),nanofl_engine_geom_Matrix.load(node));
};
nanofl_engine_fills_BitmapFill.loadJson = function(obj,version) {
	var tmp = obj.repeat;
	return new nanofl_engine_fills_BitmapFill(obj.bitmapPath,tmp != null ? tmp : "repeat",nanofl_engine_geom_Matrix.loadJson(obj));
};
nanofl_engine_fills_BitmapFill.__super__ = nanofl_engine_fills_BaseFill;
nanofl_engine_fills_BitmapFill.prototype = $extend(nanofl_engine_fills_BaseFill.prototype,{
	save: function(out) {
		out.begin("fill").attr("type","bitmap");
		out.attr("bitmapPath",this.bitmapPath);
		out.attr("repeat",this.repeat,"repeat");
		this.matrix.save(out);
		out.end();
	}
	,saveJson: function() {
		var r = { type : "bitmap", bitmapPath : this.bitmapPath, repeat : this.repeat};
		this.matrix.saveJson(r);
		return r;
	}
	,clone: function() {
		var r = new nanofl_engine_fills_BitmapFill(this.bitmapPath,this.repeat,this.matrix.clone());
		r.library = this.library;
		return r;
	}
	,applyAlpha: function(alpha) {
	}
	,getTyped: function() {
		return nanofl_engine_fills_TypedFill.bitmap(this);
	}
	,begin: function(g) {
		if(this.library.hasItem(this.bitmapPath)) {
			var image = (js_Boot.__cast(this.library.getItem(this.bitmapPath) , nanofl_engine_libraryitems_BitmapItem)).image;
			g.beginBitmapFill(image,this.repeat,this.matrix.toNative());
		} else {
			g.beginFill("rgba(0,0,0,0)");
		}
	}
	,getBitmapWidth: function() {
		var item = this.library.getItem(this.bitmapPath);
		if(item == null || !((item) instanceof nanofl_engine_libraryitems_BitmapItem)) {
			return 1.0;
		}
		return item.image.width;
	}
	,equ: function(e) {
		if(e == this) {
			return true;
		}
		if(((e) instanceof nanofl_engine_fills_BitmapFill)) {
			var ee = e;
			if(ee.bitmapPath == this.bitmapPath && ee.matrix.equ(this.matrix)) {
				return ee.repeat == this.repeat;
			} else {
				return false;
			}
		}
		return false;
	}
	,swapInstance: function(oldNamePath,newNamePath) {
		if(this.bitmapPath == oldNamePath) {
			this.bitmapPath = newNamePath;
		}
	}
	,setLibrary: function(library) {
		this.library = library;
	}
	,getTransformed: function(m) {
		var r = this.clone();
		r.matrix.prependMatrix(m);
		return r;
	}
	,toString: function() {
		return "new BitmapFill(\"red\")";
	}
	,__class__: nanofl_engine_fills_BitmapFill
});
var nanofl_engine_fills_EraseFill = function() {
};
nanofl_engine_fills_EraseFill.__name__ = "nanofl.engine.fills.EraseFill";
nanofl_engine_fills_EraseFill.__interfaces__ = [nanofl_engine_fills_IFill];
nanofl_engine_fills_EraseFill.__super__ = nanofl_engine_fills_BaseFill;
nanofl_engine_fills_EraseFill.prototype = $extend(nanofl_engine_fills_BaseFill.prototype,{
	save: function(out) {
		stdlib_Debug.methodNotSupported(this,{ fileName : "engine/nanofl/engine/fills/EraseFill.hx", lineNumber : 10, className : "nanofl.engine.fills.EraseFill", methodName : "save"});
	}
	,saveJson: function() {
		return stdlib_Debug.methodNotSupported(this,{ fileName : "engine/nanofl/engine/fills/EraseFill.hx", lineNumber : 11, className : "nanofl.engine.fills.EraseFill", methodName : "saveJson"});
	}
	,clone: function() {
		return new nanofl_engine_fills_EraseFill();
	}
	,applyAlpha: function(alpha) {
		stdlib_Debug.methodNotSupported(this,{ fileName : "engine/nanofl/engine/fills/EraseFill.hx", lineNumber : 13, className : "nanofl.engine.fills.EraseFill", methodName : "applyAlpha"});
	}
	,getTyped: function() {
		return stdlib_Debug.methodNotSupported(this,{ fileName : "engine/nanofl/engine/fills/EraseFill.hx", lineNumber : 14, className : "nanofl.engine.fills.EraseFill", methodName : "getTyped"});
	}
	,begin: function(g) {
		stdlib_Debug.methodNotSupported(this,{ fileName : "engine/nanofl/engine/fills/EraseFill.hx", lineNumber : 15, className : "nanofl.engine.fills.EraseFill", methodName : "begin"});
	}
	,equ: function(e) {
		return ((e) instanceof nanofl_engine_fills_EraseFill);
	}
	,swapInstance: function(oldNamePath,newNamePath) {
		stdlib_Debug.methodNotSupported(this,{ fileName : "engine/nanofl/engine/fills/EraseFill.hx", lineNumber : 17, className : "nanofl.engine.fills.EraseFill", methodName : "swapInstance"});
	}
	,setLibrary: function(library) {
	}
	,getTransformed: function(m) {
		return this.clone();
	}
	,toString: function() {
		return "new EraseFill";
	}
	,__class__: nanofl_engine_fills_EraseFill
});
var nanofl_engine_fills_LinearFill = function(colors,ratios,x0,y0,x1,y1) {
	this.colors = colors;
	this.ratios = ratios;
	this.x0 = x0;
	this.y0 = y0;
	this.x1 = x1;
	this.y1 = y1;
};
nanofl_engine_fills_LinearFill.__name__ = "nanofl.engine.fills.LinearFill";
nanofl_engine_fills_LinearFill.__interfaces__ = [nanofl_engine_fills_IFill];
nanofl_engine_fills_LinearFill.load = function(node,version) {
	var _g = new haxe_ds_StringMap();
	_g.h["1.0.0"] = function() {
		var matrix = nanofl_engine_geom_Matrix.load(node);
		var pt0 = matrix.transformPoint(-1,0);
		var pt1 = matrix.transformPoint(1,0);
		return new nanofl_engine_fills_LinearFill(htmlparser_HtmlParserTools.getAttr(node,"colors",[]),htmlparser_HtmlParserTools.getAttr(node,"ratios",[0.0]),htmlparser_HtmlParserTools.getAttr(node,"x0",pt0.x),htmlparser_HtmlParserTools.getAttr(node,"y0",pt0.y),htmlparser_HtmlParserTools.getAttr(node,"x1",pt1.x),htmlparser_HtmlParserTools.getAttr(node,"y1",pt1.y));
	};
	_g.h["2.0.0"] = function() {
		return new nanofl_engine_fills_LinearFill(htmlparser_HtmlParserTools.getAttr(node,"colors",[]),htmlparser_HtmlParserTools.getAttr(node,"ratios",[0.0]),htmlparser_HtmlParserTools.getAttr(node,"x0",0.0),htmlparser_HtmlParserTools.getAttr(node,"y0",0.0),htmlparser_HtmlParserTools.getAttr(node,"x1",0.0),htmlparser_HtmlParserTools.getAttr(node,"y1",0.0));
	};
	return nanofl_engine_Version.handle(version,_g);
};
nanofl_engine_fills_LinearFill.loadJson = function(obj,version) {
	var tmp = obj.colors;
	var tmp1 = obj.ratios;
	var tmp2 = obj.x0;
	var tmp3 = obj.y0;
	var tmp4 = obj.x1;
	var tmp5 = obj.y1;
	return new nanofl_engine_fills_LinearFill(tmp != null ? tmp : [],tmp1 != null ? tmp1 : [0.0],tmp2 != null ? tmp2 : 0.0,tmp3 != null ? tmp3 : 0.0,tmp4 != null ? tmp4 : 0.0,tmp5 != null ? tmp5 : 0.0);
};
nanofl_engine_fills_LinearFill.__super__ = nanofl_engine_fills_BaseFill;
nanofl_engine_fills_LinearFill.prototype = $extend(nanofl_engine_fills_BaseFill.prototype,{
	save: function(out) {
		out.begin("fill").attr("type","linear");
		out.attr("colors",this.colors);
		out.attr("ratios",this.ratios);
		out.attr("x0",this.x0);
		out.attr("y0",this.y0);
		out.attr("x1",this.x1);
		out.attr("y1",this.y1);
		out.end();
	}
	,saveJson: function() {
		return { type : "linear", colors : this.colors, ratios : this.ratios, x0 : this.x0, y0 : this.y0, x1 : this.x1, y1 : this.y1};
	}
	,clone: function() {
		return new nanofl_engine_fills_LinearFill(this.colors.slice(),this.ratios.slice(),this.x0,this.y0,this.x1,this.y1);
	}
	,applyAlpha: function(alpha) {
		var _g = 0;
		var _g1 = this.colors.length;
		while(_g < _g1) {
			var i = _g++;
			var rgba = nanofl_engine_ColorTools.parse(this.colors[i]);
			rgba.a *= alpha;
			this.colors[i] = nanofl_engine_ColorTools.rgbaToString(rgba);
		}
	}
	,getTyped: function() {
		return nanofl_engine_fills_TypedFill.linear(this);
	}
	,begin: function(g) {
		g.beginLinearGradientFill(this.colors,this.ratios,this.x0,this.y0,this.x1,this.y1);
	}
	,equ: function(e) {
		if(e == this) {
			return true;
		}
		if(((e) instanceof nanofl_engine_fills_LinearFill)) {
			var ee = e;
			if(this.arrEqu(ee.colors,this.colors) && this.arrEqu(ee.ratios,this.ratios) && ee.x0 == this.x0 && ee.y0 == this.y0 && ee.x1 == this.x1) {
				return ee.y1 == this.y1;
			} else {
				return false;
			}
		}
		return false;
	}
	,arrEqu: function(a,b) {
		if(a.length != b.length) {
			return false;
		}
		var _g = 0;
		var _g1 = a.length;
		while(_g < _g1) {
			var i = _g++;
			if(a[i] != b[i]) {
				return false;
			}
		}
		return true;
	}
	,swapInstance: function(oldNamePath,newNamePath) {
	}
	,setLibrary: function(library) {
	}
	,getTransformed: function(m) {
		var r = this.clone();
		var p0 = m.transformPoint(this.x0,this.y0);
		r.x0 = p0.x;
		r.y0 = p0.y;
		var p1 = m.transformPoint(this.x1,this.y1);
		r.x1 = p1.x;
		r.y1 = p1.y;
		return r;
	}
	,toString: function() {
		var _this = this.colors;
		var result = new Array(_this.length);
		var _g = 0;
		var _g1 = _this.length;
		while(_g < _g1) {
			var i = _g++;
			result[i] = "\"" + _this[i] + "\"";
		}
		return "new LinearFill(" + Std.string(result) + (", " + Std.string(this.ratios) + ", " + this.x0 + ", " + this.y0 + ", " + this.x1 + ", " + this.y1 + ")");
	}
	,__class__: nanofl_engine_fills_LinearFill
});
var nanofl_engine_fills_RadialFill = function(colors,ratios,cx,cy,r,fx,fy) {
	this.colors = colors;
	this.ratios = ratios;
	this.cx = cx;
	this.cy = cy;
	this.r = r;
	this.fx = fx;
	this.fy = fy;
};
nanofl_engine_fills_RadialFill.__name__ = "nanofl.engine.fills.RadialFill";
nanofl_engine_fills_RadialFill.__interfaces__ = [nanofl_engine_fills_IFill];
nanofl_engine_fills_RadialFill.load = function(node,version) {
	var _g = new haxe_ds_StringMap();
	_g.h["1.0.0"] = function() {
		var matrix = nanofl_engine_geom_Matrix.load(node);
		var props = matrix.decompose();
		return new nanofl_engine_fills_RadialFill(htmlparser_HtmlParserTools.getAttr(node,"colors",[]),htmlparser_HtmlParserTools.getAttr(node,"ratios",[0.0]),props.x,props.y,(props.scaleX + props.scaleY) / 2,props.x,props.y);
	};
	_g.h["2.0.0"] = function() {
		var cx = htmlparser_HtmlParserTools.getAttr(node,"cx",0.0);
		var cy = htmlparser_HtmlParserTools.getAttr(node,"cy",0.0);
		return new nanofl_engine_fills_RadialFill(htmlparser_HtmlParserTools.getAttr(node,"colors",[]),htmlparser_HtmlParserTools.getAttr(node,"ratios",[0.0]),cx,cy,htmlparser_HtmlParserTools.getAttr(node,"r",0.0),htmlparser_HtmlParserTools.getAttr(node,"fx",cx),htmlparser_HtmlParserTools.getAttr(node,"fy",cy));
	};
	return nanofl_engine_Version.handle(version,_g);
};
nanofl_engine_fills_RadialFill.loadJson = function(obj,version) {
	var tmp = obj.cx;
	var cx = tmp != null ? tmp : 0.0;
	var tmp = obj.cy;
	var cy = tmp != null ? tmp : 0.0;
	var tmp = obj.colors;
	var tmp1 = obj.ratios;
	var tmp2 = obj.r;
	var tmp3 = obj.fx;
	var tmp4 = obj.fy;
	return new nanofl_engine_fills_RadialFill(tmp != null ? tmp : [],tmp1 != null ? tmp1 : [0.0],cx,cy,tmp2 != null ? tmp2 : 0.0,tmp3 != null ? tmp3 : cx,tmp4 != null ? tmp4 : cy);
};
nanofl_engine_fills_RadialFill.__super__ = nanofl_engine_fills_BaseFill;
nanofl_engine_fills_RadialFill.prototype = $extend(nanofl_engine_fills_BaseFill.prototype,{
	save: function(out) {
		out.begin("fill").attr("type","radial");
		out.attr("colors",this.colors);
		out.attr("ratios",this.ratios);
		out.attr("cx",this.cx);
		out.attr("cy",this.cy);
		out.attr("r",this.r);
		out.attr("fx",this.fx,this.cx);
		out.attr("fy",this.fy,this.cy);
		out.end();
	}
	,saveJson: function() {
		var tmp = this.fx;
		var tmp1 = this.fy;
		return { type : "radial", colors : this.colors, ratios : this.ratios, cx : this.cx, cy : this.cy, r : this.r, fx : tmp != null ? tmp : this.cx, fy : tmp1 != null ? tmp1 : this.cy};
	}
	,clone: function() {
		return new nanofl_engine_fills_RadialFill(this.colors.slice(),this.ratios.slice(),this.cx,this.cy,this.r,this.fx,this.fy);
	}
	,applyAlpha: function(alpha) {
		var _g = 0;
		var _g1 = this.colors.length;
		while(_g < _g1) {
			var i = _g++;
			var rgba = nanofl_engine_ColorTools.parse(this.colors[i]);
			rgba.a *= alpha;
			this.colors[i] = nanofl_engine_ColorTools.rgbaToString(rgba);
		}
	}
	,getTyped: function() {
		return nanofl_engine_fills_TypedFill.radial(this);
	}
	,begin: function(g) {
		g.beginRadialGradientFill(this.colors,this.ratios,this.fx,this.fy,0,this.cx,this.cy,this.r);
	}
	,equ: function(e) {
		if(e == this) {
			return true;
		}
		if(((e) instanceof nanofl_engine_fills_RadialFill)) {
			var ee = e;
			if(this.arrEqu(ee.colors,this.colors) && this.arrEqu(ee.ratios,this.ratios) && ee.cx == this.cx && ee.cy == this.cy && ee.r == this.r && ee.fx == this.fx) {
				return ee.fy == this.fy;
			} else {
				return false;
			}
		}
		return false;
	}
	,arrEqu: function(a,b) {
		if(a.length != b.length) {
			return false;
		}
		var _g = 0;
		var _g1 = a.length;
		while(_g < _g1) {
			var i = _g++;
			if(a[i] != b[i]) {
				return false;
			}
		}
		return true;
	}
	,swapInstance: function(oldNamePath,newNamePath) {
	}
	,setLibrary: function(library) {
	}
	,getTransformed: function(m) {
		var fill = this.clone();
		var c = m.transformPoint(this.cx,this.cy);
		fill.cx = c.x;
		fill.cy = c.y;
		var f = m.transformPoint(this.fx,this.fy);
		fill.fx = f.x;
		fill.fy = f.y;
		fill.r *= m.getAverageScale();
		return fill;
	}
	,toString: function() {
		return "new RadialFill(" + Std.string(this.colors) + ", " + Std.string(this.ratios) + ", " + this.cx + ", " + this.cy + ", " + this.r + ", " + this.fx + ", " + this.fy + ")";
	}
	,__class__: nanofl_engine_fills_RadialFill
});
var nanofl_engine_fills_SelectionFill = function(scale) {
	if(nanofl_engine_fills_SelectionFill.pattern == null) {
		nanofl_engine_fills_SelectionFill.pattern = new createjs.Shape();
		nanofl_engine_fills_SelectionFill.pattern.graphics.beginFill("rgba(0,0,0,0.75)").rect(0,0,1,1).rect(2,2,1,1).endFill().beginFill("rgba(255,255,255,0.75)").rect(2,0,1,1).rect(0,2,1,1).endFill();
		nanofl_engine_fills_SelectionFill.pattern.cache(0,0,4,4);
	}
	this.scale = scale;
};
nanofl_engine_fills_SelectionFill.__name__ = "nanofl.engine.fills.SelectionFill";
nanofl_engine_fills_SelectionFill.__interfaces__ = [nanofl_engine_fills_IFill];
nanofl_engine_fills_SelectionFill.__super__ = nanofl_engine_fills_BaseFill;
nanofl_engine_fills_SelectionFill.prototype = $extend(nanofl_engine_fills_BaseFill.prototype,{
	save: function(out) {
		stdlib_Debug.methodNotSupported(this,{ fileName : "engine/nanofl/engine/fills/SelectionFill.hx", lineNumber : 31, className : "nanofl.engine.fills.SelectionFill", methodName : "save"});
	}
	,saveJson: function() {
		return stdlib_Debug.methodNotSupported(this,{ fileName : "engine/nanofl/engine/fills/SelectionFill.hx", lineNumber : 32, className : "nanofl.engine.fills.SelectionFill", methodName : "saveJson"});
	}
	,clone: function() {
		return stdlib_Debug.methodNotSupported(this,{ fileName : "engine/nanofl/engine/fills/SelectionFill.hx", lineNumber : 34, className : "nanofl.engine.fills.SelectionFill", methodName : "clone"});
	}
	,applyAlpha: function(alpha) {
	}
	,setLibrary: function(library) {
	}
	,getTransformed: function(m) {
		return this;
	}
	,getTyped: function() {
		return stdlib_Debug.methodNotSupported(this,{ fileName : "engine/nanofl/engine/fills/SelectionFill.hx", lineNumber : 43, className : "nanofl.engine.fills.SelectionFill", methodName : "getTyped"});
	}
	,begin: function(g) {
		g.beginBitmapFill(nanofl_engine_fills_SelectionFill.pattern.cacheCanvas,"repeat",new createjs.Matrix2D(this.scale,0,0,this.scale));
	}
	,equ: function(e) {
		return stdlib_Debug.methodNotSupported(this,{ fileName : "engine/nanofl/engine/fills/SelectionFill.hx", lineNumber : 50, className : "nanofl.engine.fills.SelectionFill", methodName : "equ"});
	}
	,swapInstance: function(oldNamePath,newNamePath) {
	}
	,toString: function() {
		return "new SelectionFill()";
	}
	,__class__: nanofl_engine_fills_SelectionFill
});
var nanofl_engine_fills_SolidFill = function(color) {
	this.color = color;
};
nanofl_engine_fills_SolidFill.__name__ = "nanofl.engine.fills.SolidFill";
nanofl_engine_fills_SolidFill.__interfaces__ = [nanofl_engine_fills_IFill];
nanofl_engine_fills_SolidFill.load = function(node,version) {
	return new nanofl_engine_fills_SolidFill(htmlparser_HtmlParserTools.getAttr(node,"color","#000000"));
};
nanofl_engine_fills_SolidFill.loadJson = function(obj,version) {
	var tmp = obj.color;
	return new nanofl_engine_fills_SolidFill(tmp != null ? tmp : "#000000");
};
nanofl_engine_fills_SolidFill.__super__ = nanofl_engine_fills_BaseFill;
nanofl_engine_fills_SolidFill.prototype = $extend(nanofl_engine_fills_BaseFill.prototype,{
	save: function(out) {
		out.begin("fill").attr("type","solid");
		out.attr("color",this.color);
		out.end();
	}
	,saveJson: function() {
		return { type : "solid", color : this.color};
	}
	,clone: function() {
		return new nanofl_engine_fills_SolidFill(this.color);
	}
	,applyAlpha: function(alpha) {
		var rgba = nanofl_engine_ColorTools.parse(this.color);
		rgba.a *= alpha;
		this.color = nanofl_engine_ColorTools.rgbaToString(rgba);
	}
	,setLibrary: function(library) {
	}
	,getTransformed: function(m) {
		return this;
	}
	,getTyped: function() {
		return nanofl_engine_fills_TypedFill.solid(this);
	}
	,begin: function(g) {
		g.beginFill(this.color);
	}
	,equ: function(e) {
		if(e == this) {
			return true;
		}
		if(((e) instanceof nanofl_engine_fills_SolidFill)) {
			var ee = e;
			return ee.color == this.color;
		}
		return false;
	}
	,swapInstance: function(oldNamePath,newNamePath) {
	}
	,toString: function() {
		return "new SolidFill(\"" + this.color + "\")";
	}
	,__class__: nanofl_engine_fills_SolidFill
});
var nanofl_engine_fills_TypedFill = $hxEnums["nanofl.engine.fills.TypedFill"] = { __ename__:"nanofl.engine.fills.TypedFill",__constructs__:null
	,solid: ($_=function(fill) { return {_hx_index:0,fill:fill,__enum__:"nanofl.engine.fills.TypedFill",toString:$estr}; },$_._hx_name="solid",$_.__params__ = ["fill"],$_)
	,linear: ($_=function(fill) { return {_hx_index:1,fill:fill,__enum__:"nanofl.engine.fills.TypedFill",toString:$estr}; },$_._hx_name="linear",$_.__params__ = ["fill"],$_)
	,radial: ($_=function(fill) { return {_hx_index:2,fill:fill,__enum__:"nanofl.engine.fills.TypedFill",toString:$estr}; },$_._hx_name="radial",$_.__params__ = ["fill"],$_)
	,bitmap: ($_=function(fill) { return {_hx_index:3,fill:fill,__enum__:"nanofl.engine.fills.TypedFill",toString:$estr}; },$_._hx_name="bitmap",$_.__params__ = ["fill"],$_)
};
nanofl_engine_fills_TypedFill.__constructs__ = [nanofl_engine_fills_TypedFill.solid,nanofl_engine_fills_TypedFill.linear,nanofl_engine_fills_TypedFill.radial,nanofl_engine_fills_TypedFill.bitmap];
var nanofl_engine_geom_BezierCurve = function(x1,y1,x2,y2,x3,y3) {
	this.p1 = { x : x1, y : y1};
	this.p2 = { x : x2, y : y2};
	this.p3 = { x : x3, y : y3};
};
nanofl_engine_geom_BezierCurve.__name__ = "nanofl.engine.geom.BezierCurve";
nanofl_engine_geom_BezierCurve.isTrianglesIntersect = function(curveA,curveB) {
	var contourA = new nanofl_engine_geom_Contour(curveA.getTriangle());
	var contourB = new nanofl_engine_geom_Contour(curveB.getTriangle());
	var _g = 0;
	var _g1 = contourA.edges;
	while(_g < _g1.length) {
		var a = _g1[_g];
		++_g;
		var _g2 = 0;
		var _g3 = contourB.edges;
		while(_g2 < _g3.length) {
			var b = _g3[_g2];
			++_g2;
			if(a.asStraightLine().getIntersection_straightSection(b.asStraightLine()) != null) {
				return true;
			}
		}
	}
	if((contourA.hasPoint(curveB.p1.x,curveB.p1.y) || !contourA.isPointInside(curveB.p1.x,curveB.p1.y)) && (contourA.hasPoint(curveB.p2.x,curveB.p2.y) || !contourA.isPointInside(curveB.p2.x,curveB.p2.y)) && (contourA.hasPoint(curveB.p3.x,curveB.p3.y) || !contourA.isPointInside(curveB.p3.x,curveB.p3.y))) {
		if((contourB.hasPoint(curveA.p1.x,curveA.p1.y) || !contourB.isPointInside(curveA.p1.x,curveA.p1.y)) && (contourB.hasPoint(curveA.p2.x,curveA.p2.y) || !contourB.isPointInside(curveA.p2.x,curveA.p2.y)) && (contourB.hasPoint(curveA.p3.x,curveA.p3.y) || !contourB.isPointInside(curveA.p3.x,curveA.p3.y))) {
			return false;
		}
	}
	return true;
};
nanofl_engine_geom_BezierCurve.getIntersection_bezierCurve_inner = function(curveA,curveB) {
	if(curveA.equ(curveB)) {
		return null;
	}
	var I = nanofl_engine_geom_BezierCurve.getIntersection_bezierCurve_getT(0,1,curveA,0,1,curveB,0);
	if(I == null) {
		return null;
	}
	stdlib_Debug.assert(I.a.length == I.b.length,"I.a.length=" + I.a.length + " != I.b.length=" + I.b.length,{ fileName : "engine/nanofl/engine/geom/BezierCurve.hx", lineNumber : 434, className : "nanofl.engine.geom.BezierCurve", methodName : "getIntersection_bezierCurve_inner"});
	if(I.a.length > 4) {
		nanofl_engine_geom_BezierCurve.log("I.a.length = " + I.a.length + " ON:\ngetIntersection_bezierCurve_inner(" + Std.string(curveA) + ", " + Std.string(curveB) + ")",{ fileName : "engine/nanofl/engine/geom/BezierCurve.hx", lineNumber : 438, className : "nanofl.engine.geom.BezierCurve", methodName : "getIntersection_bezierCurve_inner"});
		return null;
	}
	if(I.a.length == 0) {
		return null;
	}
	var _g = [];
	var _g1 = 0;
	var _g2 = I.a.length;
	while(_g1 < _g2) {
		var i = _g1++;
		_g.push(i);
	}
	var relatedIndexesInB = _g;
	nanofl_engine_geom_BezierCurve.parallelSort(I.a,relatedIndexesInB);
	nanofl_engine_geom_BezierCurve.parallelSort(I.b,relatedIndexesInB,true);
	var r = { a : curveA.split(I.a), b : curveB.split(I.b)};
	var _g = 0;
	var _g1 = r.a.length - 1;
	while(_g < _g1) {
		var i = _g++;
		r.a[i].p3.x = r.a[i + 1].p1.x = r.b[relatedIndexesInB[i]].p3.x;
		r.a[i].p3.y = r.a[i + 1].p1.y = r.b[relatedIndexesInB[i]].p3.y;
	}
	nanofl_engine_geom_BezierCurve.excludeDegenerated(r.a);
	nanofl_engine_geom_BezierCurve.excludeDegenerated(r.b);
	return r;
};
nanofl_engine_geom_BezierCurve.excludeDegenerated = function(arr) {
	var i = 0;
	while(i < arr.length) if(arr[i].isDegenerated()) {
		arr.splice(i,1);
	} else {
		++i;
	}
	return arr;
};
nanofl_engine_geom_BezierCurve.getIntersection_bezierCurve_getT = function(ta1,ta2,curveA,tb1,tb2,curveB,level) {
	++level;
	if(!nanofl_engine_geom_BoundsTools.isIntersect(curveA.getBounds(),curveB.getBounds())) {
		return null;
	}
	if(!nanofl_engine_geom_BezierCurve.isTrianglesIntersect(curveA,curveB)) {
		return null;
	}
	var tinyA = curveA.isTiny();
	var tinyB = curveB.isTiny();
	var I1 = null;
	var I2 = null;
	var I3 = null;
	var I4 = null;
	if(!tinyA && !tinyB) {
		var subCurvesA = curveA.split([0.5]);
		var subCurvesB = curveB.split([0.5]);
		I1 = nanofl_engine_geom_BezierCurve.getIntersection_bezierCurve_getT(ta1,(ta1 + ta2) / 2,subCurvesA[0],tb1,(tb1 + tb2) / 2,subCurvesB[0],level);
		I2 = nanofl_engine_geom_BezierCurve.getIntersection_bezierCurve_getT(ta1,(ta1 + ta2) / 2,subCurvesA[0],(tb1 + tb2) / 2,tb2,subCurvesB[1],level);
		I3 = nanofl_engine_geom_BezierCurve.getIntersection_bezierCurve_getT((ta1 + ta2) / 2,ta2,subCurvesA[1],tb1,(tb1 + tb2) / 2,subCurvesB[0],level);
		I4 = nanofl_engine_geom_BezierCurve.getIntersection_bezierCurve_getT((ta1 + ta2) / 2,ta2,subCurvesA[1],(tb1 + tb2) / 2,tb2,subCurvesB[1],level);
	} else if(!tinyA && tinyB) {
		var subCurvesA = curveA.split([0.5]);
		I1 = nanofl_engine_geom_BezierCurve.getIntersection_bezierCurve_getT(ta1,(ta1 + ta2) / 2,subCurvesA[0],tb1,tb2,curveB,level);
		I2 = nanofl_engine_geom_BezierCurve.getIntersection_bezierCurve_getT((ta1 + ta2) / 2,ta2,subCurvesA[1],tb1,tb2,curveB,level);
	} else if(tinyA && !tinyB) {
		var subCurvesB = curveB.split([0.5]);
		I1 = nanofl_engine_geom_BezierCurve.getIntersection_bezierCurve_getT(ta1,ta2,curveA,tb1,(tb1 + tb2) / 2,subCurvesB[0],level);
		I2 = nanofl_engine_geom_BezierCurve.getIntersection_bezierCurve_getT(ta1,ta2,curveA,(tb1 + tb2) / 2,tb2,subCurvesB[1],level);
	} else {
		var lineA = new nanofl_engine_geom_StraightLine(curveA.p1.x,curveA.p1.y,curveA.p3.x,curveA.p3.y);
		var lineB = new nanofl_engine_geom_StraightLine(curveB.p1.x,curveB.p1.y,curveB.p3.x,curveB.p3.y);
		if(lineA.getIntersection_straightSection(lineB) != null) {
			return { a : [(ta1 + ta2) / 2], b : [(tb1 + tb2) / 2]};
		}
		return null;
	}
	if(I1 == null && I2 == null && I3 == null && I4 == null) {
		return null;
	}
	var r = { a : [], b : []};
	if(I1 != null) {
		var _g = 0;
		var _g1 = I1.a;
		while(_g < _g1.length) {
			var e = _g1[_g];
			++_g;
			r.a.push(e);
		}
		var _g = 0;
		var _g1 = I1.b;
		while(_g < _g1.length) {
			var e = _g1[_g];
			++_g;
			r.b.push(e);
		}
	}
	if(I2 != null) {
		var _g = 0;
		var _g1 = I2.a;
		while(_g < _g1.length) {
			var e = _g1[_g];
			++_g;
			r.a.push(e);
		}
		var _g = 0;
		var _g1 = I2.b;
		while(_g < _g1.length) {
			var e = _g1[_g];
			++_g;
			r.b.push(e);
		}
	}
	if(I3 != null) {
		var _g = 0;
		var _g1 = I3.a;
		while(_g < _g1.length) {
			var e = _g1[_g];
			++_g;
			r.a.push(e);
		}
		var _g = 0;
		var _g1 = I3.b;
		while(_g < _g1.length) {
			var e = _g1[_g];
			++_g;
			r.b.push(e);
		}
	}
	if(I4 != null) {
		var _g = 0;
		var _g1 = I4.a;
		while(_g < _g1.length) {
			var e = _g1[_g];
			++_g;
			r.a.push(e);
		}
		var _g = 0;
		var _g1 = I4.b;
		while(_g < _g1.length) {
			var e = _g1[_g];
			++_g;
			r.b.push(e);
		}
	}
	stdlib_Debug.assert(r.a.length == r.b.length,null,{ fileName : "engine/nanofl/engine/geom/BezierCurve.hx", lineNumber : 587, className : "nanofl.engine.geom.BezierCurve", methodName : "getIntersection_bezierCurve_getT"});
	return r;
};
nanofl_engine_geom_BezierCurve.parallelSort = function(a,b,byValue) {
	if(byValue == null) {
		byValue = false;
	}
	var _g = 0;
	var _g1 = a.length - 1;
	while(_g < _g1) {
		var i = _g++;
		var _g2 = 0;
		var _g3 = a.length - 1;
		while(_g2 < _g3) {
			var j = _g2++;
			if(a[j] > a[j + 1]) {
				var z = a[j];
				a[j] = a[j + 1];
				a[j + 1] = z;
				if(!byValue) {
					var t = b[j];
					b[j] = b[j + 1];
					b[j + 1] = t;
				} else {
					var n1 = b.indexOf(j);
					var n2 = b.indexOf(j + 1);
					b[n1] = j + 1;
					b[n2] = j;
				}
			}
		}
	}
};
nanofl_engine_geom_BezierCurve.log = function(v,infos) {
};
nanofl_engine_geom_BezierCurve.prototype = {
	getNearestPoint: function(x,y) {
		var Ax = this.p2.x - this.p1.x;
		var Ay = this.p2.y - this.p1.y;
		var Bx = this.p1.x - 2 * this.p2.x + this.p3.x;
		var By = this.p1.y - 2 * this.p2.y + this.p3.y;
		var dx = this.p1.x - x;
		var dy = this.p1.y - y;
		var sol = nanofl_engine_geom_Equation.solveCube(Bx * Bx + By * By,3 * (Ax * Bx + Ay * By),2 * (Ax * Ax + Ay * Ay) + dx * Bx + dy * By,dx * Ax + dy * Ay);
		var d1 = nanofl_engine_geom_PointTools.getSqrDist(x,y,this.p1.x,this.p1.y);
		var d3 = nanofl_engine_geom_PointTools.getSqrDist(x,y,this.p3.x,this.p3.y);
		if(sol.length > 0) {
			var tMin = null;
			var distMin = 1.0e100;
			var pointMin = null;
			var _g = 0;
			while(_g < sol.length) {
				var t = sol[_g];
				++_g;
				if(t >= 0 && t <= 1) {
					var pt = this.getPoint(t);
					var dist = nanofl_engine_geom_PointTools.getSqrDist(x,y,pt.x,pt.y);
					if(dist < distMin) {
						tMin = t;
						distMin = dist;
						pointMin = pt;
					}
				}
			}
			if(tMin != null && distMin < d1 && distMin < d3) {
				var nor = { x : Ay + tMin * By, y : -(Ax + tMin * Bx)};
				nanofl_engine_geom_PointTools.normalize(nor);
				var dist = Math.sqrt(distMin);
				var orientedDist = dist;
				if((x - pointMin.x) * nor.x + (y - pointMin.y) * nor.y < 0) {
					nor.x *= -1;
					nor.y *= -1;
					orientedDist *= -1;
				}
				return { t : tMin, point : pointMin, nor : nor, dist : dist, orientedDist : orientedDist};
			}
		}
		if(d1 < d3) {
			var dist = Math.sqrt(d1);
			return { t : 0, point : nanofl_engine_geom_PointTools.clone(this.p1), nor : nanofl_engine_geom_PointTools.normalize({ x : x - this.p1.x, y : y - this.p1.y}), dist : dist, orientedDist : dist};
		} else {
			var dist = Math.sqrt(d3);
			return { t : 1, point : nanofl_engine_geom_PointTools.clone(this.p3), nor : nanofl_engine_geom_PointTools.normalize({ x : x - this.p3.x, y : y - this.p3.y}), dist : dist, orientedDist : dist};
		}
	}
	,getNearestPointP: function(pt) {
		return this.getNearestPoint(pt.x,pt.y);
	}
	,getPoint: function(t) {
		if(t == 0) {
			return nanofl_engine_geom_PointTools.clone(this.p1);
		}
		if(t == 1) {
			return nanofl_engine_geom_PointTools.clone(this.p3);
		}
		var z = 1 - t;
		var a = z * z;
		var b = 2 * t * z;
		var c = t * t;
		return { x : a * this.p1.x + b * this.p2.x + c * this.p3.x, y : a * this.p1.y + b * this.p2.y + c * this.p3.y};
	}
	,getPointX: function(t) {
		if(t == 0) {
			return this.p1.x;
		}
		if(t == 1) {
			return this.p3.x;
		}
		var z = 1 - t;
		var a = z * z;
		var b = 2 * t * z;
		var c = t * t;
		return a * this.p1.x + b * this.p2.x + c * this.p3.x;
	}
	,getNor: function(t) {
		var Ax = this.p2.x - this.p1.x;
		var Ay = this.p2.y - this.p1.y;
		var Bx = this.p1.x - 2 * this.p2.x + this.p3.x;
		var By = this.p1.y - 2 * this.p2.y + this.p3.y;
		var nor = { x : Ay + t * By, y : -(Ax + t * Bx)};
		nanofl_engine_geom_PointTools.normalize(nor);
		return nor;
	}
	,getBounds: function() {
		var r = { minX : Math.min(this.p1.x,Math.min(this.p2.x,this.p3.x)), maxX : Math.max(this.p1.x,Math.max(this.p2.x,this.p3.x)), minY : Math.min(this.p1.y,Math.min(this.p2.y,this.p3.y)), maxY : Math.max(this.p1.y,Math.max(this.p2.y,this.p3.y))};
		var Ax = this.p2.x - this.p1.x;
		var Ay = this.p2.y - this.p1.y;
		var Bx = this.p1.x - 2 * this.p2.x + this.p3.x;
		var By = this.p1.y - 2 * this.p2.y + this.p3.y;
		if(Math.abs(Bx) > 1e-10 && (r.minX == this.p2.x || r.maxX == this.p2.x)) {
			var u = -Ax / Bx;
			u = (1 - u) * (1 - u) * this.p1.x + 2 * u * (1 - u) * this.p2.x + u * u * this.p3.x;
			if(r.minX == this.p2.x) {
				r.minX = u;
			} else {
				r.maxX = u;
			}
		}
		if(Math.abs(By) > 1e-10 && (r.minY == this.p2.y || r.maxY == this.p2.y)) {
			var u = -Ay / By;
			u = (1 - u) * (1 - u) * this.p1.y + 2 * u * (1 - u) * this.p2.y + u * u * this.p3.y;
			if(r.minY == this.p2.y) {
				r.minY = u;
			} else {
				r.maxY = u;
			}
		}
		return r;
	}
	,getIntersectionPointsX_rightRay: function(mx,my) {
		var r = [];
		if(my >= Math.min(this.p1.y,Math.min(this.p2.y,this.p3.y)) && my <= Math.max(this.p1.y,Math.max(this.p2.y,this.p3.y)) && mx <= Math.max(this.p1.x,Math.max(this.p2.x,this.p3.x))) {
			var Ay = this.p2.y - this.p1.y;
			var By = this.p1.y - 2 * this.p2.y + this.p3.y;
			var lineIntersectionCount = 0;
			var _g = 0;
			var _g1 = nanofl_engine_geom_Equation.solveQuadratic(By,2 * Ay,this.p1.y - my);
			while(_g < _g1.length) {
				var t = _g1[_g];
				++_g;
				if(t > 0 && t < 1.0) {
					var x = this.getPointX(t);
					if(x > mx) {
						r.push(x);
					}
					++lineIntersectionCount;
				}
			}
			if(lineIntersectionCount == 1 && (this.p1.y < my && this.p3.y < my || this.p1.y > my && this.p3.y > my)) {
				return [];
			}
		}
		return r;
	}
	,getIntersectionCount_rightRay: function(mx,my) {
		return this.getIntersectionPointsX_rightRay(mx,my).length;
	}
	,getIntersections_horizontalStraightSection: function(m1x,my,m2x) {
		var r = [];
		if(my >= Math.min(this.p1.y,Math.min(this.p2.y,this.p3.y)) && my <= Math.max(this.p1.y,Math.max(this.p2.y,this.p3.y))) {
			var Ay = this.p2.y - this.p1.y;
			var By = this.p1.y - 2 * this.p2.y + this.p3.y;
			var tt = nanofl_engine_geom_Equation.solveQuadratic(By,2 * Ay,this.p1.y - my);
			var _g = 0;
			while(_g < tt.length) {
				var t = tt[_g];
				++_g;
				if(t >= 0 && t <= 1) {
					var x = (1 - t) * (1 - t) * this.p1.x + 2 * (1 - t) * t * this.p2.x + t * t * this.p3.x;
					if(x > Math.min(m1x,m2x) && x < Math.max(m1x,m2x)) {
						r.push({ t : t, x : x, y : my});
					}
				}
			}
			if(r.length == 2 && r[0].t > r[1].t) {
				var z = r[0];
				r[0] = r[1];
				r[1] = z;
			}
		}
		return r;
	}
	,getIntersection_straightSection: function(line) {
		if(!nanofl_engine_geom_BoundsTools.isIntersect(this.getBounds(),line.getBounds())) {
			return null;
		}
		var tt = this.getIntersection_straightSection_getT(line);
		if(tt == null) {
			return null;
		}
		if(tt.length == 1) {
			var curves = this.split(tt);
			var m = curves[0].p3;
			var lines = [new nanofl_engine_geom_StraightLine(line.x1,line.y1,m.x,m.y),new nanofl_engine_geom_StraightLine(m.x,m.y,line.x2,line.y2)];
			return { curves : nanofl_engine_geom_BezierCurve.excludeDegenerated(curves), lines : nanofl_engine_geom_BezierCurve.excludeDegenerated(lines)};
		} else if(tt.length == 2) {
			var curves = this.split(tt);
			var m0 = curves[1].p1;
			var m1 = curves[1].p3;
			if(nanofl_engine_geom_PointTools.getSqrDist(line.x1,line.y1,m0.x,m0.y) < nanofl_engine_geom_PointTools.getSqrDist(line.x1,line.y1,m1.x,m1.y)) {
				var lines = [new nanofl_engine_geom_StraightLine(line.x1,line.y1,m0.x,m0.y),new nanofl_engine_geom_StraightLine(m0.x,m0.y,m1.x,m1.y),new nanofl_engine_geom_StraightLine(m1.x,m1.y,line.x2,line.y2)];
				return { curves : nanofl_engine_geom_BezierCurve.excludeDegenerated(curves), lines : nanofl_engine_geom_BezierCurve.excludeDegenerated(lines)};
			} else {
				var lines = [new nanofl_engine_geom_StraightLine(line.x1,line.y1,m1.x,m1.y),new nanofl_engine_geom_StraightLine(m1.x,m1.y,m0.x,m0.y),new nanofl_engine_geom_StraightLine(m0.x,m0.y,line.x2,line.y2)];
				return { curves : nanofl_engine_geom_BezierCurve.excludeDegenerated(curves), lines : nanofl_engine_geom_BezierCurve.excludeDegenerated(lines)};
			}
		}
		return null;
	}
	,getIntersection_straightSection_getT: function(line) {
		if(!nanofl_engine_geom_BoundsTools.isIntersect(this.getBounds(),line.getBounds())) {
			return null;
		}
		var dx = line.x2 - line.x1;
		var dy = line.y2 - line.y1;
		var len = Math.sqrt(dx * dx + dy * dy);
		var da = Math.atan2(dy,dx);
		var rotatedCurve = this.clone().translate(-line.x1,-line.y1).rotate(-da);
		var I = rotatedCurve.getIntersections_horizontalStraightSection(0,0,len);
		var _g = 0;
		while(_g < I.length) {
			var i = I[_g];
			++_g;
			var p = nanofl_engine_geom_PointTools.rotate(i.x,i.y,da);
			i.x = p.x + line.x1;
			i.y = p.y + line.y1;
		}
		if(I.length == 1) {
			return [I[0].t];
		} else if(I.length == 2) {
			return [I[0].t,I[1].t];
		}
		return null;
	}
	,getIntersection_bezierCurve: function(curve) {
		var r = nanofl_engine_geom_BezierCurve.getIntersection_bezierCurve_inner(this,curve);
		return r;
	}
	,isDegenerated: function() {
		if(nanofl_engine_geom_PointTools.equ(this.p1,this.p2)) {
			return nanofl_engine_geom_PointTools.equ(this.p2,this.p3);
		} else {
			return false;
		}
	}
	,getFirstPart: function(t) {
		var m = this.getPoint(t);
		return new nanofl_engine_geom_BezierCurve(this.p1.x,this.p1.y,this.p1.x + t * (this.p2.x - this.p1.x),this.p1.y + t * (this.p2.y - this.p1.y),m.x,m.y);
	}
	,getSecondPart: function(t) {
		var m = this.getPoint(t);
		return new nanofl_engine_geom_BezierCurve(m.x,m.y,this.p2.x + t * (this.p3.x - this.p2.x),this.p2.y + t * (this.p3.y - this.p2.y),this.p3.x,this.p3.y);
	}
	,getPart: function(t1,t2) {
		return this.getSecondPart(t1).getFirstPart((t2 - t1) / (1 - t1));
	}
	,split: function(tt) {
		if(tt.length == 0) {
			return [this.clone()];
		}
		if(tt.length == 1) {
			var m = this.getPoint(tt[0]);
			return [new nanofl_engine_geom_BezierCurve(this.p1.x,this.p1.y,this.p1.x + tt[0] * (this.p2.x - this.p1.x),this.p1.y + tt[0] * (this.p2.y - this.p1.y),m.x,m.y),new nanofl_engine_geom_BezierCurve(m.x,m.y,this.p2.x + tt[0] * (this.p3.x - this.p2.x),this.p2.y + tt[0] * (this.p3.y - this.p2.y),this.p3.x,this.p3.y)];
		}
		if(tt.length == 2) {
			var curves = this.split([tt[0]]);
			var r = [curves[0],curves[1].getFirstPart((tt[1] - tt[0]) / (1 - tt[0])),this.getSecondPart(tt[1])];
			stdlib_Debug.assert(r[0].p3.x == r[1].p1.x && r[0].p3.y == r[1].p1.y,null,{ fileName : "engine/nanofl/engine/geom/BezierCurve.hx", lineNumber : 632, className : "nanofl.engine.geom.BezierCurve", methodName : "split"});
			r[1].p3.x = r[2].p1.x;
			r[1].p3.y = r[2].p1.y;
			stdlib_Debug.assert(r[1].p3.x == r[2].p1.x && r[1].p3.y == r[2].p1.y,null,{ fileName : "engine/nanofl/engine/geom/BezierCurve.hx", lineNumber : 635, className : "nanofl.engine.geom.BezierCurve", methodName : "split"});
			return r;
		}
		var r = [];
		r.push(this.getFirstPart(tt[0]));
		var _g = 0;
		var _g1 = tt.length - 1;
		while(_g < _g1) {
			var i = _g++;
			r.push(this.getPart(tt[i],tt[i + 1]));
		}
		r.push(this.getSecondPart(tt[tt.length - 1]));
		var _g = 0;
		var _g1 = tt.length;
		while(_g < _g1) {
			var i = _g++;
			r[i].p3.x = r[i + 1].p1.x;
			r[i].p3.y = r[i + 1].p1.y;
		}
		return r;
	}
	,translate: function(dx,dy) {
		this.p1.x += dx;
		this.p1.y += dy;
		this.p2.x += dx;
		this.p2.y += dy;
		this.p3.x += dx;
		this.p3.y += dy;
		return this;
	}
	,rotate: function(da) {
		this.p1 = nanofl_engine_geom_PointTools.getRotated(this.p1,da);
		this.p2 = nanofl_engine_geom_PointTools.getRotated(this.p2,da);
		this.p3 = nanofl_engine_geom_PointTools.getRotated(this.p3,da);
		return this;
	}
	,clone: function() {
		return new nanofl_engine_geom_BezierCurve(this.p1.x,this.p1.y,this.p2.x,this.p2.y,this.p3.x,this.p3.y);
	}
	,isTiny: function() {
		if(Math.abs(this.p1.x - this.p2.x) < 0.01 && Math.abs(this.p1.y - this.p2.y) < 0.01 && Math.abs(this.p3.x - this.p2.x) < 0.01) {
			return Math.abs(this.p3.y - this.p2.y) < 0.01;
		} else {
			return false;
		}
	}
	,equ: function(curve) {
		if(nanofl_engine_geom_PointTools.equ(this.p2,curve.p2)) {
			if(!(nanofl_engine_geom_PointTools.equ(this.p1,curve.p1) && nanofl_engine_geom_PointTools.equ(this.p3,curve.p3))) {
				if(nanofl_engine_geom_PointTools.equ(this.p1,curve.p3)) {
					return nanofl_engine_geom_PointTools.equ(this.p3,curve.p1);
				} else {
					return false;
				}
			} else {
				return true;
			}
		} else {
			return false;
		}
	}
	,getReversed: function() {
		return new nanofl_engine_geom_BezierCurve(this.p3.x,this.p3.y,this.p2.x,this.p2.y,this.p1.x,this.p1.y);
	}
	,reverse: function() {
		var z = this.p1;
		this.p1 = this.p3;
		this.p3 = this.p1;
	}
	,getLength: function() {
		var Ax = this.p2.x - this.p1.x;
		var Ay = this.p2.y - this.p1.y;
		var Bx = this.p1.x - 2 * this.p2.x + this.p3.x;
		var By = this.p1.y - 2 * this.p2.y + this.p3.y;
		var ax2 = 2 * Ax;
		var ay2 = 2 * Ay;
		var a = 4 * (Bx * Bx + By * By);
		var b = 4 * (Bx * ax2 + By * ay2);
		var c = ax2 * ax2 + ay2 * ay2;
		var z1 = 2 * Math.sqrt(a + b + c);
		var z2 = Math.sqrt(a);
		var z3 = 2 * a * z2;
		var z4 = 2 * Math.sqrt(c);
		var z5 = b / z2;
		return (z3 * z1 + z2 * b * (z1 - z4) + (4 * c * a - b * b) * Math.log((2 * z2 + z5 + z1) / (z5 + z4))) / (4 * z3);
	}
	,getTangent: function(t) {
		var Cx = (this.p2.x - this.p1.x) * t + this.p1.x;
		var Cy = (this.p2.y - this.p1.y) * t + this.p1.y;
		var Dx = (this.p3.x - this.p2.x) * t + this.p2.x;
		var Dy = (this.p3.y - this.p2.y) * t + this.p2.y;
		return Math.atan2(Dy - Cy,Dx - Cx);
	}
	,getTriangle: function() {
		return [new nanofl_engine_geom_Edge(this.p1.x,this.p1.y,this.p2.x,this.p2.y),new nanofl_engine_geom_Edge(this.p2.x,this.p2.y,this.p3.x,this.p3.y),new nanofl_engine_geom_Edge(this.p3.x,this.p3.y,this.p1.x,this.p1.y)];
	}
	,toString: function() {
		return "curve(" + this.p1.x + ", " + this.p1.y + ", " + this.p2.x + ", " + this.p2.y + ", " + this.p3.x + ", " + this.p3.y + ")";
	}
	,getMonotoneT: function(k) {
		if(k == 0) {
			return 0;
		}
		if(k == 1) {
			return 1;
		}
		var eps = 0.005;
		var need = this.getLength() * k;
		var t = 0.5;
		var d = 0.5;
		while(true) {
			var part = this.getFirstPart(t);
			var len = part.getLength();
			if(Math.abs(need - len) < eps) {
				return t;
			}
			d /= 2;
			if(need < len) {
				t -= d;
			} else {
				t += d;
			}
		}
	}
	,__class__: nanofl_engine_geom_BezierCurve
};
var nanofl_engine_geom_BoundsTools = function() { };
nanofl_engine_geom_BoundsTools.__name__ = "nanofl.engine.geom.BoundsTools";
nanofl_engine_geom_BoundsTools.extendR = function(bounds,rect) {
	bounds.minX = Math.min(bounds.minX,rect.x);
	bounds.minY = Math.min(bounds.minY,rect.y);
	bounds.maxX = Math.max(bounds.maxX,rect.x + rect.width);
	bounds.maxY = Math.max(bounds.maxY,rect.y + rect.height);
	return bounds;
};
nanofl_engine_geom_BoundsTools.extend = function(bounds,b) {
	bounds.minX = Math.min(bounds.minX,b.minX);
	bounds.minY = Math.min(bounds.minY,b.minY);
	bounds.maxX = Math.max(bounds.maxX,b.maxX);
	bounds.maxY = Math.max(bounds.maxY,b.maxY);
	return bounds;
};
nanofl_engine_geom_BoundsTools.isIntersect = function(a,b,gap) {
	if(gap == null) {
		gap = 0.0;
	}
	if(a != null && b != null && a.maxX > b.minX - gap && a.maxY > b.minY - gap && b.maxX > a.minX - gap) {
		return b.maxY > a.minY - gap;
	} else {
		return false;
	}
};
nanofl_engine_geom_BoundsTools.isPointInside = function(bounds,x,y,gap) {
	if(gap == null) {
		gap = 0.0;
	}
	if(x > bounds.minX - gap && y > bounds.minY - gap && x < bounds.maxX + gap) {
		return y < bounds.maxY + gap;
	} else {
		return false;
	}
};
nanofl_engine_geom_BoundsTools.isPointInsideP = function(bounds,pt,gap) {
	if(gap == null) {
		gap = 0.0;
	}
	return nanofl_engine_geom_BoundsTools.isPointInside(bounds,pt.x,pt.y,gap);
};
nanofl_engine_geom_BoundsTools.getNearestPoint = function(bounds,pos) {
	if(nanofl_engine_geom_BoundsTools.isPointInsideP(bounds,pos)) {
		return nanofl_engine_geom_PointTools.clone(pos);
	}
	var points = [new nanofl_engine_geom_StraightLine(bounds.minX,bounds.minY,bounds.maxX,bounds.minY).getNearestPoint(pos.x,pos.y).point,new nanofl_engine_geom_StraightLine(bounds.maxX,bounds.minY,bounds.maxX,bounds.maxY).getNearestPoint(pos.x,pos.y).point,new nanofl_engine_geom_StraightLine(bounds.maxX,bounds.maxY,bounds.minX,bounds.maxY).getNearestPoint(pos.x,pos.y).point,new nanofl_engine_geom_StraightLine(bounds.minX,bounds.maxY,bounds.minX,bounds.minY).getNearestPoint(pos.x,pos.y).point];
	points.sort(function(a,b) {
		return Reflect.compare(nanofl_engine_geom_PointTools.getDist(pos.x,pos.y,a.x,a.y),nanofl_engine_geom_PointTools.getDist(pos.x,pos.y,b.x,b.y));
	});
	return points[0];
};
nanofl_engine_geom_BoundsTools.clone = function(bounds) {
	if(bounds == null) {
		return null;
	}
	return { minX : bounds.minX, minY : bounds.minY, maxX : bounds.maxX, maxY : bounds.maxY};
};
nanofl_engine_geom_BoundsTools.toBounds = function(rect) {
	return { minX : rect.x, minY : rect.y, maxX : rect.x + rect.width, maxY : rect.y + rect.height};
};
nanofl_engine_geom_BoundsTools.toString = function(bounds) {
	if(bounds == null) {
		return "null";
	}
	return bounds.minX + "," + bounds.minY + ", " + bounds.maxX + ", " + bounds.maxY;
};
nanofl_engine_geom_BoundsTools.toRectangle = function(bounds) {
	if(bounds == null) {
		return null;
	}
	return new createjs.Rectangle(bounds.minX,bounds.minY,bounds.maxX - bounds.minX,bounds.maxY - bounds.minY);
};
nanofl_engine_geom_BoundsTools.transform = function(bounds,matrix) {
	if(bounds == null) {
		return null;
	}
	var x_a = bounds.width * matrix.a;
	var x_b = bounds.width * matrix.b;
	var y_c = bounds.height * matrix.c;
	var y_d = bounds.height * matrix.d;
	var tx = matrix.tx + (bounds.x * matrix.a + bounds.y * matrix.c);
	var ty = matrix.ty + (bounds.x * matrix.b + bounds.y * matrix.d);
	var minX = tx;
	var minY = ty;
	var maxX = tx;
	var maxY = ty;
	var x = x_a + tx;
	if(x < minX) {
		minX = x;
	} else if(x > maxX) {
		maxX = x;
	}
	x = x_a + y_c + tx;
	if(x < minX) {
		minX = x;
	} else if(x > maxX) {
		maxX = x;
	}
	x = y_c + tx;
	if(x < minX) {
		minX = x;
	} else if(x > maxX) {
		maxX = x;
	}
	var y = x_b + ty;
	if(y < minY) {
		minY = y;
	} else if(y > maxY) {
		maxY = y;
	}
	y = x_b + y_d + ty;
	if(y < minY) {
		minY = y;
	} else if(y > maxY) {
		maxY = y;
	}
	y = y_d + ty;
	if(y < minY) {
		minY = y;
	} else if(y > maxY) {
		maxY = y;
	}
	bounds.x = minX;
	bounds.y = minY;
	bounds.width = maxX - minX;
	bounds.height = maxY - minY;
	return bounds;
};
var nanofl_engine_geom_Contour = function(edges) {
	this.edges = edges;
};
nanofl_engine_geom_Contour.__name__ = "nanofl.engine.geom.Contour";
nanofl_engine_geom_Contour.fromRectangle = function(rect) {
	return new nanofl_engine_geom_Contour([new nanofl_engine_geom_Edge(rect.x,rect.y,rect.x + rect.width,rect.y),new nanofl_engine_geom_Edge(rect.x + rect.width,rect.y,rect.x + rect.width,rect.y + rect.height),new nanofl_engine_geom_Edge(rect.x + rect.width,rect.y + rect.height,rect.x,rect.y + rect.height),new nanofl_engine_geom_Edge(rect.x,rect.y + rect.height,rect.x,rect.y)]);
};
nanofl_engine_geom_Contour.prototype = {
	save: function(out) {
		out.begin("contour");
		out.attr("edges",nanofl_engine_geom_Edges.save(this.edges));
		out.end();
	}
	,saveJson: function() {
		return { edges : nanofl_engine_geom_Edges.save(this.edges)};
	}
	,draw: function(g) {
		nanofl_engine_geom_Edges.draw(this.edges,g,false);
	}
	,translate: function(dx,dy) {
		var _g = 0;
		var _g1 = this.edges;
		while(_g < _g1.length) {
			var e = _g1[_g];
			++_g;
			e.translate(dx,dy);
		}
	}
	,transform: function(m) {
		var _g = 0;
		var _g1 = this.edges;
		while(_g < _g1.length) {
			var e = _g1[_g];
			++_g;
			e.transform(m);
		}
	}
	,isPointInside: function(px,py) {
		var _g = 0;
		var _g1 = this.edges;
		while(_g < _g1.length) {
			var e = _g1[_g];
			++_g;
			if(Math.abs(e.y3 - py) < nanofl_engine_geom_Contour.EPS) {
				return this.isPointInside(px,py + nanofl_engine_geom_Contour.EPS * 2);
			}
		}
		var counter = 0;
		var _g = 0;
		var _g1 = this.edges;
		while(_g < _g1.length) {
			var edge = _g1[_g];
			++_g;
			var c = edge.getIntersectionCount_rightRay(px,py);
			counter += c;
		}
		return counter % 2 != 0;
	}
	,isPointInsideP: function(p) {
		return this.isPointInside(p.x,p.y);
	}
	,hasPoint: function(px,py) {
		var _g = 0;
		var _g1 = this.edges;
		while(_g < _g1.length) {
			var edge = _g1[_g];
			++_g;
			if(edge.x1 == px && edge.y1 == py || edge.x3 == px && edge.y3 == py) {
				return true;
			}
		}
		return false;
	}
	,hasEdge: function(edge) {
		return edge.indexIn(this.edges) >= 0;
	}
	,isEdgeInside: function(edge) {
		if(!this.hasPoint(edge.x1,edge.y1) && !this.isPointInside(edge.x1,edge.y1)) {
			return false;
		}
		if(!this.hasPoint(edge.x3,edge.y3) && !this.isPointInside(edge.x3,edge.y3)) {
			return false;
		}
		return this.isPointInsideP(edge.getMiddlePoint());
	}
	,isNestedTo: function(outer) {
		stdlib_Debug.assert(outer != this,null,{ fileName : "engine/nanofl/engine/geom/Contour.hx", lineNumber : 102, className : "nanofl.engine.geom.Contour", methodName : "isNestedTo"});
		stdlib_Debug.assert(this.edges[0].x1 == this.edges[this.edges.length - 1].x3,null,{ fileName : "engine/nanofl/engine/geom/Contour.hx", lineNumber : 103, className : "nanofl.engine.geom.Contour", methodName : "isNestedTo"});
		stdlib_Debug.assert(this.edges[0].y1 == this.edges[this.edges.length - 1].y3,null,{ fileName : "engine/nanofl/engine/geom/Contour.hx", lineNumber : 104, className : "nanofl.engine.geom.Contour", methodName : "isNestedTo"});
		var _g = 0;
		var _g1 = this.edges;
		while(_g < _g1.length) {
			var edge = _g1[_g];
			++_g;
			if(!outer.hasPoint(edge.x3,edge.y3) && !outer.isPointInside(edge.x3,edge.y3)) {
				return false;
			}
		}
		var _g = 0;
		var _g1 = this.edges;
		while(_g < _g1.length) {
			var edge = _g1[_g];
			++_g;
			if(edge.indexIn(outer.edges) >= 0) {
				return false;
			}
			var pt = edge.getMiddlePoint();
			if(!outer.isPointInside(pt.x,pt.y)) {
				return false;
			}
		}
		return true;
	}
	,clone: function() {
		return new nanofl_engine_geom_Contour(datatools_ArrayTools.clone(this.edges));
	}
	,isClockwise: function() {
		return this.getClockwiseProduct() >= -nanofl_engine_geom_Contour.EPS;
	}
	,isCounterClockwise: function() {
		return this.getClockwiseProduct() <= nanofl_engine_geom_Contour.EPS;
	}
	,getClockwiseProduct: function() {
		var sum = 0.0;
		var _g = 0;
		var _g1 = this.edges;
		while(_g < _g1.length) {
			var edge = _g1[_g];
			++_g;
			sum += (edge.x2 - edge.x1) * (edge.y2 + edge.y1);
			sum += (edge.x3 - edge.x2) * (edge.y3 + edge.y2);
		}
		return sum;
	}
	,normalize: function() {
		nanofl_engine_geom_Edges.roundPoints(this.edges);
		nanofl_engine_geom_Edges.removeDegenerated(this.edges,true);
		var i = 0;
		while(i < this.edges.length) {
			var a = this.edges[i];
			var b = this.edges[(i + 1) % this.edges.length];
			if(a.x1 == b.x3 && a.y1 == b.y3 && (a.isStraight() && b.isStraight() || a.x2 == b.x2 && a.y2 == b.y2)) {
				if(i + 1 < this.edges.length) {
					this.edges.splice(i,2);
				} else {
					this.edges.splice(i,1);
					this.edges.splice(0,1);
					--i;
				}
			} else {
				++i;
			}
		}
	}
	,reverse: function() {
		this.edges.reverse();
		var _g = 0;
		var _g1 = this.edges.length;
		while(_g < _g1) {
			var i = _g++;
			this.edges[i] = this.edges[i].clone().reverse();
		}
		return this;
	}
	,indexIn: function(contours) {
		var _gthis = this;
		var _g = 0;
		var _g1 = contours.length;
		while(_g < _g1) {
			var i = _g++;
			if(contours[i].edges.length == this.edges.length) {
				if(Lambda.foreach(contours[i].edges,function(e) {
					return e.indexIn(_gthis.edges) >= 0;
				})) {
					return i;
				}
			}
		}
		return -1;
	}
	,equ: function(c) {
		return nanofl_engine_geom_Edges.equIgnoreOrder(this.edges,c.edges);
	}
	,toString: function() {
		return "new Contour(" + Std.string(this.edges) + ")";
	}
	,assertCorrect: function() {
	}
	,__class__: nanofl_engine_geom_Contour
};
var nanofl_engine_geom_Contours = function() { };
nanofl_engine_geom_Contours.__name__ = "nanofl.engine.geom.Contours";
nanofl_engine_geom_Contours.fromEdges = function(edges) {
	nanofl_engine_geom_Contours.log(function() {
		return "Contours.find(1): edges = " + edges.length;
	},{ fileName : "engine/nanofl/engine/geom/Contours.hx", lineNumber : 13, className : "nanofl.engine.geom.Contours", methodName : "fromEdges"});
	stdlib_Debug.assert(!nanofl_engine_geom_Edges.hasDegenerated(edges),"Degenerated edges detected.",{ fileName : "engine/nanofl/engine/geom/Contours.hx", lineNumber : 15, className : "nanofl.engine.geom.Contours", methodName : "fromEdges"});
	stdlib_Debug.assert(!nanofl_engine_geom_Edges.hasDuplicates(edges),"Duplicated edges detected.",{ fileName : "engine/nanofl/engine/geom/Contours.hx", lineNumber : 16, className : "nanofl.engine.geom.Contours", methodName : "fromEdges"});
	edges = edges.slice();
	nanofl_engine_geom_Contours.removeTailEdges(edges);
	nanofl_engine_geom_Contours.log(function() {
		return "Contours.find(2): edges = " + edges.length + "; " + Std.string(edges);
	},{ fileName : "engine/nanofl/engine/geom/Contours.hx", lineNumber : 22, className : "nanofl.engine.geom.Contours", methodName : "fromEdges"});
	var sequences = nanofl_engine_geom_Contours.getSequencesFromEdges(edges);
	var vectors = edges.slice();
	var _g = 0;
	while(_g < edges.length) {
		var e = edges[_g];
		++_g;
		vectors.push(e.clone().reverse());
	}
	var connections = nanofl_engine_geom_Contours.getConnections(vectors);
	var excludes = new Array(vectors.length);
	var r = [];
	var _g = 0;
	while(_g < sequences.length) {
		var sequence = sequences[_g];
		++_g;
		nanofl_engine_geom_Contours.find(sequence[0],vectors,connections,excludes,r);
		nanofl_engine_geom_Contours.find(sequence[0].clone().reverse(),vectors,connections,excludes,r);
		if(sequence.length > 1) {
			nanofl_engine_geom_Contours.find(sequence[sequence.length - 1],vectors,connections,excludes,r);
			nanofl_engine_geom_Contours.find(sequence[sequence.length - 1].clone().reverse(),vectors,connections,excludes,r);
		}
	}
	nanofl_engine_geom_Contours.log(function() {
		return "Contours.find(3): r =\n" + r.join("\n");
	},{ fileName : "engine/nanofl/engine/geom/Contours.hx", lineNumber : 47, className : "nanofl.engine.geom.Contours", methodName : "fromEdges"});
	var _g = 0;
	while(_g < r.length) {
		var contour = r[_g];
		++_g;
		stdlib_Debug.assert(contour.isClockwise(),null,{ fileName : "engine/nanofl/engine/geom/Contours.hx", lineNumber : 49, className : "nanofl.engine.geom.Contours", methodName : "fromEdges"});
	}
	return r;
};
nanofl_engine_geom_Contours.fromVectors = function(vectors) {
	vectors = vectors.slice();
	nanofl_engine_geom_Contours.removeTailEdges(vectors);
	var sequences = nanofl_engine_geom_Contours.getSequencesFromVectors(vectors);
	var connections = nanofl_engine_geom_Contours.getConnections(vectors);
	var excludes = new Array(vectors.length);
	var r = [];
	var _g = 0;
	while(_g < sequences.length) {
		var sequence = sequences[_g];
		++_g;
		nanofl_engine_geom_Contours.find(sequence[0],vectors,connections,excludes,r);
		if(sequence.length > 1) {
			nanofl_engine_geom_Contours.find(sequence[sequence.length - 1],vectors,connections,excludes,r);
		}
	}
	return r;
};
nanofl_engine_geom_Contours.find = function(start,vectors,connections,excludes,r) {
	var startIndex = stdlib_LambdaIterable.findIndex(vectors,function(x) {
		return x.equDirected(start);
	});
	if(excludes[startIndex]) {
		nanofl_engine_geom_Contours.log("exclude(1) " + startIndex,{ fileName : "engine/nanofl/engine/geom/Contours.hx", lineNumber : 86, className : "nanofl.engine.geom.Contours", methodName : "find"});
		return;
	}
	var indexes = [startIndex];
	nanofl_engine_geom_Contours.log(function() {
		return "!!!!!!!!!!! startIndex = " + startIndex + "; start = " + Std.string(start) + "; contours = " + r.length;
	},{ fileName : "engine/nanofl/engine/geom/Contours.hx", lineNumber : 92, className : "nanofl.engine.geom.Contours", methodName : "find"});
	var lastBestVectorIndex = null;
	while(true) {
		var nextIndex = [nanofl_engine_geom_Contours.findNext(indexes[indexes.length - 1],vectors,connections,excludes,lastBestVectorIndex)];
		if(nextIndex[0] == null) {
			break;
		}
		lastBestVectorIndex = null;
		nanofl_engine_geom_Contours.log((function(nextIndex) {
			return function() {
				return "\tnextIndex = " + nextIndex[0] + "; next = " + Std.string(vectors[nextIndex[0]]);
			};
		})(nextIndex),{ fileName : "engine/nanofl/engine/geom/Contours.hx", lineNumber : 100, className : "nanofl.engine.geom.Contours", methodName : "find"});
		stdlib_Debug.assert(indexes.indexOf(nextIndex[0]) < 0,null,{ fileName : "engine/nanofl/engine/geom/Contours.hx", lineNumber : 102, className : "nanofl.engine.geom.Contours", methodName : "find"});
		var next = [vectors[nextIndex[0]]];
		if(next[0].x3 == start.x1 && next[0].y3 == start.y1) {
			indexes.push(nextIndex[0]);
			nanofl_engine_geom_Contours.contourFound(indexes,vectors,excludes,r);
			break;
		} else {
			var n = [stdlib_LambdaIterable.findIndex(indexes,(function(next) {
				return function(x) {
					if(vectors[x].x1 == next[0].x3) {
						return vectors[x].y1 == next[0].y3;
					} else {
						return false;
					}
				};
			})(next))];
			if(n[0] >= 0) {
				stdlib_Debug.assert(n[0] >= 1,null,{ fileName : "engine/nanofl/engine/geom/Contours.hx", lineNumber : 117, className : "nanofl.engine.geom.Contours", methodName : "find"});
				indexes.push(nextIndex[0]);
				lastBestVectorIndex = indexes[n[0]];
				nanofl_engine_geom_Contours.contourFound(indexes.slice(n[0]),vectors,excludes,r);
				indexes = indexes.slice(0,n[0]);
				nanofl_engine_geom_Contours.log((function(n) {
					return function() {
						return "Found inner loop n = " + n[0] + "; lastBestVectorIndex = " + lastBestVectorIndex;
					};
				})(n),{ fileName : "engine/nanofl/engine/geom/Contours.hx", lineNumber : 122, className : "nanofl.engine.geom.Contours", methodName : "find"});
			} else {
				indexes.push(nextIndex[0]);
			}
		}
	}
};
nanofl_engine_geom_Contours.contourFound = function(indexes,vectors,excludes,r) {
	var result = new Array(indexes.length);
	var _g = 0;
	var _g1 = indexes.length;
	while(_g < _g1) {
		var i = _g++;
		result[i] = vectors[indexes[i]].clone();
	}
	var contour = new nanofl_engine_geom_Contour(result);
	if(contour.isClockwise() && !Lambda.exists(r,function(x) {
		return x.equ(contour);
	})) {
		r.push(contour);
		var _g = 0;
		while(_g < indexes.length) {
			var index = indexes[_g];
			++_g;
			excludes[index] = true;
		}
	}
};
nanofl_engine_geom_Contours.findNext = function(lastIndex,vectors,connections,excludes,lastBestVectorIndex) {
	var nexts = connections[lastIndex];
	stdlib_Debug.assert(nexts.length > 0,function() {
		return "nexts = " + Std.string(nexts) + "; vectors = " + Std.string(vectors);
	},{ fileName : "engine/nanofl/engine/geom/Contours.hx", lineNumber : 148, className : "nanofl.engine.geom.Contours", methodName : "findNext"});
	var last = vectors[lastIndex];
	var lastTangent = last.getTangent(1) + Math.PI;
	var _g = 0;
	while(_g < nexts.length) {
		var next = nexts[_g];
		++_g;
		var z = vectors[next].getTangent(0);
		while(z <= lastTangent) z += Math.PI * 2;
	}
	nexts.sort(function(a,b) {
		var tanA = vectors[a].getTangent(0);
		while(tanA <= lastTangent) tanA += Math.PI * 2;
		var tanB = vectors[b].getTangent(0);
		while(tanB <= lastTangent) tanB += Math.PI * 2;
		return Reflect.compare(tanA - lastTangent,tanB - lastTangent);
	});
	stdlib_Debug.assert(lastBestVectorIndex == null || nexts.indexOf(lastBestVectorIndex) >= 0,null,{ fileName : "engine/nanofl/engine/geom/Contours.hx", lineNumber : 169, className : "nanofl.engine.geom.Contours", methodName : "findNext"});
	var n = lastBestVectorIndex == null ? 0 : nexts.indexOf(lastBestVectorIndex) + 1;
	while(n < nexts.length && excludes[nexts[n]]) {
		nanofl_engine_geom_Contours.log("exclude(2) " + nexts[n],{ fileName : "engine/nanofl/engine/geom/Contours.hx", lineNumber : 174, className : "nanofl.engine.geom.Contours", methodName : "findNext"});
		++n;
	}
	return nexts[n];
};
nanofl_engine_geom_Contours.mergeByCommonEdges = function(contours,counterClockwise) {
	var i = 0;
	while(i < contours.length) {
		var j = i + 1;
		while(j < contours.length) {
			stdlib_Debug.assert(contours[i].edges.length > 0,null,{ fileName : "engine/nanofl/engine/geom/Contours.hx", lineNumber : 190, className : "nanofl.engine.geom.Contours", methodName : "mergeByCommonEdges"});
			stdlib_Debug.assert(contours[j].edges.length > 0,null,{ fileName : "engine/nanofl/engine/geom/Contours.hx", lineNumber : 191, className : "nanofl.engine.geom.Contours", methodName : "mergeByCommonEdges"});
			var commonEdges = nanofl_engine_geom_Edges.getCommon(contours[i].edges,contours[j].edges);
			if(commonEdges.length > 0) {
				var outerEdges = nanofl_engine_geom_Edges.exclude(nanofl_engine_geom_Edges.concatUnique(contours[i].edges,contours[j].edges),commonEdges);
				if(outerEdges.length > 0) {
					var newContours = nanofl_engine_geom_Contours.fromEdges(outerEdges);
					newContours.sort(function(x,y) {
						if(x.isNestedTo(y)) {
							return 1;
						} else {
							return -1;
						}
					});
					contours[i] = newContours[0];
					if(counterClockwise) {
						contours[i].reverse();
					}
				} else {
					stdlib_Debug.assert(false,"Two contours with same edges = " + Std.string(contours[i]),{ fileName : "engine/nanofl/engine/geom/Contours.hx", lineNumber : 207, className : "nanofl.engine.geom.Contours", methodName : "mergeByCommonEdges"});
				}
				contours.splice(j,1);
				--i;
				break;
			}
			++j;
		}
		++i;
	}
};
nanofl_engine_geom_Contours.removeNested = function(contours) {
	var i = 0;
	while(i < contours.length) {
		var j = 0;
		while(j < contours.length) if(i != j && contours[j].isNestedTo(contours[i])) {
			contours.splice(j,1);
			if(i > j) {
				--i;
			}
		} else {
			++j;
		}
		++i;
	}
};
nanofl_engine_geom_Contours.removeTailEdges = function(edges) {
	nanofl_engine_geom_Edges.removeDublicates(edges);
	nanofl_engine_geom_Edges.removeDegenerated(edges,true);
	while(true) {
		var count = edges.length;
		var i = 0;
		while(i < edges.length) {
			var edge = edges[i];
			if(nanofl_engine_geom_Edges.getPointUseCount(edges,edge.x1,edge.y1) == 1 || nanofl_engine_geom_Edges.getPointUseCount(edges,edge.x3,edge.y3) == 1) {
				edges.splice(i,1);
			} else {
				++i;
			}
		}
		if(edges.length == count) {
			break;
		}
	}
};
nanofl_engine_geom_Contours.getEdges = function(contours) {
	var r = [];
	var _g = 0;
	while(_g < contours.length) {
		var c = contours[_g];
		++_g;
		r = r.concat(c.edges);
	}
	return r;
};
nanofl_engine_geom_Contours.getTree = function(contours) {
	var _g = [];
	var _g1 = 0;
	var _g2 = contours;
	while(_g1 < _g2.length) {
		var v = _g2[_g1];
		++_g1;
		var a = [v];
		if(!Lambda.exists(contours,(function(a) {
			return function(b) {
				if(a[0] != b) {
					return a[0].isNestedTo(b);
				} else {
					return false;
				}
			};
		})(a))) {
			_g.push(v);
		}
	}
	var parents = _g;
	var _g = [];
	var _g1 = 0;
	var _g2 = contours;
	while(_g1 < _g2.length) {
		var v = _g2[_g1];
		++_g1;
		if(parents.indexOf(v) < 0) {
			_g.push(v);
		}
	}
	var allChildren = _g;
	var result = new Array(parents.length);
	var _g = 0;
	var _g1 = parents.length;
	while(_g < _g1) {
		var i = _g++;
		var p = parents[i];
		var _g2 = [];
		var _g3 = 0;
		var _g4 = allChildren;
		while(_g3 < _g4.length) {
			var v = _g4[_g3];
			++_g3;
			if(v.isNestedTo(p)) {
				_g2.push(v);
			}
		}
		result[i] = { parent : p, children : nanofl_engine_geom_Contours.getTree(_g2)};
	}
	return result;
};
nanofl_engine_geom_Contours.getConnections = function(vectors) {
	var r = [];
	var _g = 0;
	var _g1 = vectors.length;
	while(_g < _g1) {
		var i = _g++;
		var base = vectors[i];
		var dirs = [];
		var _g2 = 0;
		var _g3 = vectors.length;
		while(_g2 < _g3) {
			var j = _g2++;
			if(base.x3 == vectors[j].x1 && base.y3 == vectors[j].y1 && !base.equ(vectors[j])) {
				dirs.push(j);
			}
		}
		stdlib_Debug.assert(dirs.length > 0,function() {
			return "edges = " + Std.string(vectors.slice(0,vectors.length >> 1));
		},{ fileName : "engine/nanofl/engine/geom/Contours.hx", lineNumber : 311, className : "nanofl.engine.geom.Contours", methodName : "getConnections"});
		r.push(dirs);
	}
	return r;
};
nanofl_engine_geom_Contours.isPointUsed = function(vectors,indexes,x,y) {
	if(vectors[indexes[0]].x1 == x && vectors[indexes[0]].y1 == y) {
		return true;
	}
	var _g = 0;
	while(_g < indexes.length) {
		var n = indexes[_g];
		++_g;
		if(vectors[n].x3 == x && vectors[n].y3 == y) {
			return true;
		}
	}
	return false;
};
nanofl_engine_geom_Contours.getSequencesFromEdges = function(edges) {
	var r = [];
	var _g = [];
	var _g1 = 0;
	var _g2 = edges;
	while(_g1 < _g2.length) {
		var v = _g2[_g1];
		++_g1;
		if(!v.isDegenerated()) {
			_g.push(v);
		}
	}
	edges = _g;
	var ee = edges.slice();
	while(ee.length > 0) {
		var baseEdge = ee.pop();
		var equEdge = baseEdge.clone();
		var seqEdges = [baseEdge];
		var i = 0;
		while(i < ee.length) {
			var edge = ee[i];
			if(equEdge.x3 == edge.x1 && equEdge.y3 == edge.y1 && nanofl_engine_geom_Contours.isSimplePoint(edges,edge.x1,edge.y1)) {
				seqEdges.push(edge);
				equEdge.x3 = edge.x3;
				equEdge.y3 = edge.y3;
				ee.splice(i,1);
				i = 0;
			} else if(equEdge.x3 == edge.x3 && equEdge.y3 == edge.y3 && nanofl_engine_geom_Contours.isSimplePoint(edges,edge.x3,edge.y3)) {
				seqEdges.push(edge.clone().reverse());
				equEdge.x3 = edge.x1;
				equEdge.y3 = edge.y1;
				ee.splice(i,1);
				i = 0;
			} else if(equEdge.x1 == edge.x1 && equEdge.y1 == edge.y1 && nanofl_engine_geom_Contours.isSimplePoint(edges,edge.x1,edge.y1)) {
				seqEdges.unshift(edge.clone().reverse());
				equEdge.x1 = edge.x3;
				equEdge.y1 = edge.y3;
				ee.splice(i,1);
				i = 0;
			} else if(equEdge.x1 == edge.x3 && equEdge.y1 == edge.y3 && nanofl_engine_geom_Contours.isSimplePoint(edges,edge.x3,edge.y3)) {
				seqEdges.unshift(edge);
				equEdge.x1 = edge.x1;
				equEdge.y1 = edge.y1;
				ee.splice(i,1);
				i = 0;
			} else {
				++i;
			}
		}
		r.push(seqEdges);
	}
	return r;
};
nanofl_engine_geom_Contours.getSequencesFromVectors = function(edges) {
	var r = [];
	var _g = [];
	var _g1 = 0;
	var _g2 = edges;
	while(_g1 < _g2.length) {
		var v = _g2[_g1];
		++_g1;
		if(!v.isDegenerated()) {
			_g.push(v);
		}
	}
	edges = _g;
	var ee = edges.slice();
	while(ee.length > 0) {
		var baseEdge = ee.pop();
		var equEdge = baseEdge.clone();
		var seqEdges = [baseEdge];
		var i = 0;
		while(i < ee.length) {
			var edge = ee[i];
			if(equEdge.x3 == edge.x1 && equEdge.y3 == edge.y1 && nanofl_engine_geom_Contours.isSimplePoint(edges,edge.x1,edge.y1)) {
				seqEdges.push(edge);
				equEdge.x3 = edge.x3;
				equEdge.y3 = edge.y3;
				ee.splice(i,1);
				i = 0;
			} else if(equEdge.x1 == edge.x3 && equEdge.y1 == edge.y3 && nanofl_engine_geom_Contours.isSimplePoint(edges,edge.x3,edge.y3)) {
				seqEdges.unshift(edge);
				equEdge.x1 = edge.x1;
				equEdge.y1 = edge.y1;
				ee.splice(i,1);
				i = 0;
			} else {
				++i;
			}
		}
		r.push(seqEdges);
	}
	return r;
};
nanofl_engine_geom_Contours.isSimplePoint = function(edges,x,y) {
	var c = 0;
	var _g = 0;
	while(_g < edges.length) {
		var e = edges[_g];
		++_g;
		if(e.x1 == x && e.y1 == y) {
			++c;
			if(c > 2) {
				return false;
			}
		}
		if(e.x3 == x && e.y3 == y) {
			++c;
			if(c > 2) {
				return false;
			}
		}
	}
	return true;
};
nanofl_engine_geom_Contours.log = function(v,infos) {
};
var nanofl_engine_geom_Edge = function(x1,y1,x2,y2,x3,y3) {
	stdlib_Debug.assert(!isNaN(x1),null,{ fileName : "engine/nanofl/engine/geom/Edge.hx", lineNumber : 30, className : "nanofl.engine.geom.Edge", methodName : "new"});
	stdlib_Debug.assert(!isNaN(y1),null,{ fileName : "engine/nanofl/engine/geom/Edge.hx", lineNumber : 31, className : "nanofl.engine.geom.Edge", methodName : "new"});
	stdlib_Debug.assert(!isNaN(x2),null,{ fileName : "engine/nanofl/engine/geom/Edge.hx", lineNumber : 32, className : "nanofl.engine.geom.Edge", methodName : "new"});
	stdlib_Debug.assert(!isNaN(y2),null,{ fileName : "engine/nanofl/engine/geom/Edge.hx", lineNumber : 33, className : "nanofl.engine.geom.Edge", methodName : "new"});
	this.x1 = x1;
	this.y1 = y1;
	if(x3 == null) {
		this.x2 = (x1 + x2) / 2;
		this.y2 = (y1 + y2) / 2;
		this.x3 = x2;
		this.y3 = y2;
	} else {
		this.x2 = x2;
		this.y2 = y2;
		this.x3 = x3;
		this.y3 = y3;
	}
};
nanofl_engine_geom_Edge.__name__ = "nanofl.engine.geom.Edge";
nanofl_engine_geom_Edge.fromStraightLine = function(line) {
	return new nanofl_engine_geom_Edge(line.x1,line.y1,line.x2,line.y2);
};
nanofl_engine_geom_Edge.fromBezierCurve = function(curve) {
	return new nanofl_engine_geom_Edge(curve.p1.x,curve.p1.y,curve.p2.x,curve.p2.y,curve.p3.x,curve.p3.y);
};
nanofl_engine_geom_Edge.getIntersection = function(edgeA,edgeB) {
	if(!nanofl_engine_geom_BoundsTools.isIntersect(edgeA.getBoundsRO(),edgeB.getBoundsRO(),nanofl_engine_geom_Edge.GAP)) {
		return null;
	}
	if(edgeA.equ(edgeB)) {
		return null;
	}
	var I = nanofl_engine_geom_Edge.getIntersectionInner(edgeA,edgeB);
	if(I != null) {
		nanofl_engine_geom_Edges.normalize(I.a);
		nanofl_engine_geom_Edges.normalize(I.b);
		if(I.a.length == 1 && I.b.length == 1 && I.a[0].equ(edgeA) && I.b[0].equ(edgeB)) {
			I = null;
		}
	}
	return I;
};
nanofl_engine_geom_Edge.getIntersectionInner = function(edgeA,edgeB) {
	nanofl_engine_geom_Edge.log("Edge.getIntersection " + Std.string(edgeA) + " AND " + Std.string(edgeB),{ fileName : "engine/nanofl/engine/geom/Edge.hx", lineNumber : 305, className : "nanofl.engine.geom.Edge", methodName : "getIntersectionInner"});
	var straightA = edgeA.isStraight();
	var straightB = edgeB.isStraight();
	if(straightA && straightB) {
		nanofl_engine_geom_Edge.log("straightA && straightB",{ fileName : "engine/nanofl/engine/geom/Edge.hx", lineNumber : 312, className : "nanofl.engine.geom.Edge", methodName : "getIntersectionInner"});
		var p = edgeA.asStraightLine().getIntersection_straightSection(edgeB.asStraightLine());
		if(p == null) {
			return null;
		}
		return { a : [new nanofl_engine_geom_Edge(edgeA.x1,edgeA.y1,p.x,p.y),new nanofl_engine_geom_Edge(p.x,p.y,edgeA.x3,edgeA.y3)], b : [new nanofl_engine_geom_Edge(edgeB.x1,edgeB.y1,p.x,p.y),new nanofl_engine_geom_Edge(p.x,p.y,edgeB.x3,edgeB.y3)]};
	} else if(straightA && !straightB) {
		nanofl_engine_geom_Edge.log("straightA && !straightB",{ fileName : "engine/nanofl/engine/geom/Edge.hx", lineNumber : 324, className : "nanofl.engine.geom.Edge", methodName : "getIntersectionInner"});
		var p = edgeB.asBezierCurve().getIntersection_straightSection(edgeA.asStraightLine());
		nanofl_engine_geom_Edge.log("p = " + Std.string(p != null),{ fileName : "engine/nanofl/engine/geom/Edge.hx", lineNumber : 326, className : "nanofl.engine.geom.Edge", methodName : "getIntersectionInner"});
		if(p == null) {
			return null;
		}
		var _this = p.lines;
		var f = nanofl_engine_geom_Edge.fromStraightLine;
		var result = new Array(_this.length);
		var _g = 0;
		var _g1 = _this.length;
		while(_g < _g1) {
			var i = _g++;
			result[i] = f(_this[i]);
		}
		var tmp = result;
		var _this = p.curves;
		var f = nanofl_engine_geom_Edge.fromBezierCurve;
		var result = new Array(_this.length);
		var _g = 0;
		var _g1 = _this.length;
		while(_g < _g1) {
			var i = _g++;
			result[i] = f(_this[i]);
		}
		return { a : tmp, b : result};
	} else if(!straightA && straightB) {
		nanofl_engine_geom_Edge.log("!straightA && straightB",{ fileName : "engine/nanofl/engine/geom/Edge.hx", lineNumber : 337, className : "nanofl.engine.geom.Edge", methodName : "getIntersectionInner"});
		var p = edgeA.asBezierCurve().getIntersection_straightSection(edgeB.asStraightLine());
		nanofl_engine_geom_Edge.log("p = " + Std.string(p != null),{ fileName : "engine/nanofl/engine/geom/Edge.hx", lineNumber : 339, className : "nanofl.engine.geom.Edge", methodName : "getIntersectionInner"});
		if(p == null) {
			return null;
		}
		var _this = p.curves;
		var f = nanofl_engine_geom_Edge.fromBezierCurve;
		var result = new Array(_this.length);
		var _g = 0;
		var _g1 = _this.length;
		while(_g < _g1) {
			var i = _g++;
			result[i] = f(_this[i]);
		}
		var tmp = result;
		var _this = p.lines;
		var f = nanofl_engine_geom_Edge.fromStraightLine;
		var result = new Array(_this.length);
		var _g = 0;
		var _g1 = _this.length;
		while(_g < _g1) {
			var i = _g++;
			result[i] = f(_this[i]);
		}
		return { a : tmp, b : result};
	} else {
		nanofl_engine_geom_Edge.log("!straightA && !straightB",{ fileName : "engine/nanofl/engine/geom/Edge.hx", lineNumber : 349, className : "nanofl.engine.geom.Edge", methodName : "getIntersectionInner"});
		var p = edgeA.asBezierCurve().getIntersection_bezierCurve(edgeB.asBezierCurve());
		if(p == null) {
			return null;
		}
		var _this = p.a;
		var f = nanofl_engine_geom_Edge.fromBezierCurve;
		var result = new Array(_this.length);
		var _g = 0;
		var _g1 = _this.length;
		while(_g < _g1) {
			var i = _g++;
			result[i] = f(_this[i]);
		}
		var tmp = result;
		var _this = p.b;
		var f = nanofl_engine_geom_Edge.fromBezierCurve;
		var result = new Array(_this.length);
		var _g = 0;
		var _g1 = _this.length;
		while(_g < _g1) {
			var i = _g++;
			result[i] = f(_this[i]);
		}
		return { a : tmp, b : result};
	}
};
nanofl_engine_geom_Edge.loadFromJson = function(obj) {
	return new nanofl_engine_geom_Edge(obj.x1,obj.y1,obj.x2,obj.y2,obj.x3,obj.y3);
};
nanofl_engine_geom_Edge.log = function(v,infos) {
};
nanofl_engine_geom_Edge.prototype = {
	isStraight: function() {
		var pt = this.asStraightLine().getOrthogonalRayIntersection(this.x2,this.y2).point;
		return nanofl_engine_geom_PointTools.getSqrDist(pt.x,pt.y,this.x2,this.y2) < nanofl_engine_geom_Edge.GAP * nanofl_engine_geom_Edge.GAP;
	}
	,getIntersectionCount_rightRay: function(x,y) {
		if(this.isStraight()) {
			if(this.asStraightLine().isIntersect_rightRay(x,y)) {
				return 1;
			} else {
				return 0;
			}
		} else {
			return this.asBezierCurve().getIntersectionCount_rightRay(x,y);
		}
	}
	,getIntersectionDirectedCount_rightRay: function(x,y) {
		if(this.isStraight()) {
			if(this.y1 == this.y3 || this.asStraightLine().getIntersectionPointX_rightRay(x,y) == null) {
				return 0;
			}
			if(this.y1 < this.y3) {
				return 1;
			} else {
				return -1;
			}
		} else {
			var count = this.asBezierCurve().getIntersectionCount_rightRay(x,y);
			if(count == 0 || count == 2) {
				return 0;
			}
			if(this.y1 < y && this.y3 > y) {
				return 1;
			}
			if(this.y1 > y && this.y3 < y) {
				return -1;
			}
			if(this.y1 < y && this.y3 < y) {
				return -1;
			} else {
				return 1;
			}
		}
	}
	,getIntersectionPointsX_rightRay: function(x,y) {
		if(this.isStraight()) {
			var rX = this.asStraightLine().getIntersectionPointX_rightRay(x,y);
			if(rX != null) {
				return [rX];
			} else {
				return [];
			}
		} else {
			return this.asBezierCurve().getIntersectionPointsX_rightRay(x,y);
		}
	}
	,drawTo: function(g) {
		if(this.isStraight()) {
			g.lineTo(this.x3,this.y3);
		} else {
			g.curveTo(this.x2,this.y2,this.x3,this.y3);
		}
	}
	,equ: function(e) {
		if(e.x2 == this.x2 && e.y2 == this.y2) {
			if(!(e.x1 == this.x1 && e.y1 == this.y1 && e.x3 == this.x3 && e.y3 == this.y3)) {
				if(e.x1 == this.x3 && e.y1 == this.y3 && e.x3 == this.x1) {
					return e.y3 == this.y1;
				} else {
					return false;
				}
			} else {
				return true;
			}
		} else {
			return false;
		}
	}
	,equDirected: function(e) {
		if(e.x2 == this.x2 && e.y2 == this.y2 && e.x1 == this.x1 && e.y1 == this.y1 && e.x3 == this.x3) {
			return e.y3 == this.y3;
		} else {
			return false;
		}
	}
	,getNearestPoint: function(x,y) {
		var r = this.isStraight() ? this.asStraightLine().getNearestPoint(x,y) : this.asBezierCurve().getNearestPoint(x,y);
		stdlib_Debug.assert(r.point != null,this.toString() + "; x = " + x + ", y = " + y,{ fileName : "engine/nanofl/engine/geom/Edge.hx", lineNumber : 134, className : "nanofl.engine.geom.Edge", methodName : "getNearestPoint"});
		var f = r.point.x;
		stdlib_Debug.assert(!isNaN(f),this.toString() + "; x = " + x + ", y = " + y,{ fileName : "engine/nanofl/engine/geom/Edge.hx", lineNumber : 135, className : "nanofl.engine.geom.Edge", methodName : "getNearestPoint"});
		var f = r.point.y;
		stdlib_Debug.assert(!isNaN(f),this.toString() + "; x = " + x + ", y = " + y,{ fileName : "engine/nanofl/engine/geom/Edge.hx", lineNumber : 136, className : "nanofl.engine.geom.Edge", methodName : "getNearestPoint"});
		var f = r.t;
		stdlib_Debug.assert(!isNaN(f),this.toString() + "; x = " + x + ", y = " + y,{ fileName : "engine/nanofl/engine/geom/Edge.hx", lineNumber : 137, className : "nanofl.engine.geom.Edge", methodName : "getNearestPoint"});
		return r;
	}
	,translate: function(dx,dy) {
		this.x1 += dx;
		this.y1 += dy;
		this.x2 += dx;
		this.y2 += dy;
		this.x3 += dx;
		this.y3 += dy;
	}
	,translateVertex: function(point,dx,dy) {
		if(this.x1 == point.x && this.y1 == point.y) {
			this.translateStart(dx,dy);
		} else if(this.x3 == point.x && this.y3 == point.y) {
			this.translateEnd(dx,dy);
		}
	}
	,translateStart: function(dx,dy) {
		if(this.isStraight()) {
			this.x1 += dx;
			this.y1 += dy;
			this.x2 = (this.x1 + this.x3) / 2;
			this.y2 = (this.y1 + this.y3) / 2;
		} else {
			var a1 = Math.atan2(this.y1 - this.y3,this.x1 - this.x3);
			var l1 = this.asStraightLine().getLength();
			this.x1 += dx;
			this.y1 += dy;
			var a2 = Math.atan2(this.y1 - this.y3,this.x1 - this.x3);
			var l2 = this.asStraightLine().getLength();
			var p2 = nanofl_engine_geom_PointTools.rotate(this.x2 - this.x3,this.y2 - this.y3,a2 - a1);
			this.x2 = p2.x + this.x3;
			this.y2 = p2.y + this.y3;
		}
	}
	,translateEnd: function(dx,dy) {
		if(this.isStraight()) {
			this.x3 += dx;
			this.y3 += dy;
			this.x2 = (this.x1 + this.x3) / 2;
			this.y2 = (this.y1 + this.y3) / 2;
		} else {
			var a1 = Math.atan2(this.y3 - this.y1,this.x3 - this.x1);
			var l1 = this.asStraightLine().getLength();
			this.x3 += dx;
			this.y3 += dy;
			var a2 = Math.atan2(this.y3 - this.y1,this.x3 - this.x1);
			var l2 = this.asStraightLine().getLength();
			var p2 = nanofl_engine_geom_PointTools.rotate(this.x2 - this.x1,this.y2 - this.y1,a2 - a1);
			this.x2 = p2.x + this.x1;
			this.y2 = p2.y + this.y1;
		}
	}
	,reverse: function() {
		var z = this.x1;
		this.x1 = this.x3;
		this.x3 = z;
		z = this.y1;
		this.y1 = this.y3;
		this.y3 = z;
		return this;
	}
	,getBounds: function(bounds) {
		if(bounds == null) {
			return nanofl_engine_geom_BoundsTools.clone(this.getBoundsRO());
		} else {
			return nanofl_engine_geom_BoundsTools.extend(bounds,this.getBoundsRO());
		}
	}
	,getBoundsRO: function() {
		if(this.cachedBounds == null || !this.cachedBoundsEdge.equ(this)) {
			this.cachedBounds = this.isStraight() ? this.asStraightLine().getBounds() : this.asBezierCurve().getBounds();
			this.cachedBoundsEdge = this.clone();
		}
		return this.cachedBounds;
	}
	,toString: function() {
		if(this.isStraight()) {
			return "new Edge(" + this.x1 + "," + this.y1 + ", " + this.x3 + "," + this.y3 + ")";
		} else {
			return "new Edge(" + this.x1 + "," + this.y1 + ", " + this.x2 + "," + this.y2 + ", " + this.x3 + "," + this.y3 + ")";
		}
	}
	,getMiddlePoint: function() {
		if(this.isStraight()) {
			return { x : this.x2, y : this.y2};
		} else {
			return this.asBezierCurve().getPoint(0.5);
		}
	}
	,hasCommonVertices: function(edge) {
		if(!(this.x1 == edge.x1 && this.y1 == edge.y1 || this.x1 == edge.x3 && this.y1 == edge.y3 || this.x3 == edge.x1 && this.y3 == edge.y1)) {
			if(this.x3 == edge.x3) {
				return this.y3 == edge.y3;
			} else {
				return false;
			}
		} else {
			return true;
		}
	}
	,transform: function(m,applyToStroke) {
		if(applyToStroke == null) {
			applyToStroke = true;
		}
		var straight = this.isStraight();
		var p1 = m.transformPoint(this.x1,this.y1);
		this.x1 = nanofl_engine_geom_PointTools.roundGap(p1.x);
		this.y1 = nanofl_engine_geom_PointTools.roundGap(p1.y);
		var p3 = m.transformPoint(this.x3,this.y3);
		this.x3 = nanofl_engine_geom_PointTools.roundGap(p3.x);
		this.y3 = nanofl_engine_geom_PointTools.roundGap(p3.y);
		if(straight) {
			this.x2 = (this.x1 + this.x3) / 2;
			this.y2 = (this.y1 + this.y3) / 2;
		} else {
			var p2 = m.transformPoint(this.x2,this.y2);
			this.x2 = nanofl_engine_geom_PointTools.roundGap(p2.x);
			this.y2 = nanofl_engine_geom_PointTools.roundGap(p2.y);
		}
	}
	,splitByClosePoint: function(x,y) {
		var _gthis = this;
		if(this.x1 == x && this.y1 == y) {
			return null;
		}
		if(this.x3 == x && this.y3 == y) {
			return null;
		}
		if(!nanofl_engine_geom_BoundsTools.isPointInside(this.getBoundsRO(),x,y,nanofl_engine_geom_Edge.GAP)) {
			return null;
		}
		var np = this.getNearestPoint(x,y);
		var pt = nanofl_engine_geom_PointTools.roundGapP(np.point);
		if(pt.x == x && pt.y == y && (pt.x != this.x1 || pt.y != this.y1) && (pt.x != this.x3 || pt.y != this.y3)) {
			stdlib_Debug.assert(np.t > 0 && np.t < 1,function() {
				return "edge = " + _gthis.toString() + "\n\t(x,y) = (" + x + "," + y + ")" + "\n\tnp = " + nanofl_engine_geom_PointTools.toString(np.point) + "\n\tpt = " + nanofl_engine_geom_PointTools.toString(pt) + "\n\tt = " + np.t;
			},{ fileName : "engine/nanofl/engine/geom/Edge.hx", lineNumber : 373, className : "nanofl.engine.geom.Edge", methodName : "splitByClosePoint"});
			var r = this.split([np.t]);
			r[0].x3 = r[1].x1 = x;
			r[0].y3 = r[1].y1 = y;
			nanofl_engine_geom_Edges.normalize(r);
			stdlib_Debug.assert(r.length > 1,function() {
				return "edge = " + _gthis.toString() + "\n\t(x,y) = (" + x + "," + y + ")" + "\n\tnp = " + nanofl_engine_geom_PointTools.toString(np.point) + "\n\tpt = " + nanofl_engine_geom_PointTools.toString(pt) + "\n\tt = " + np.t + "\n\tr = " + Std.string(r);
			},{ fileName : "engine/nanofl/engine/geom/Edge.hx", lineNumber : 386, className : "nanofl.engine.geom.Edge", methodName : "splitByClosePoint"});
			return r;
		}
		return null;
	}
	,asStraightLine: function() {
		return new nanofl_engine_geom_StraightLine(this.x1,this.y1,this.x3,this.y3);
	}
	,asBezierCurve: function() {
		return new nanofl_engine_geom_BezierCurve(this.x1,this.y1,this.x2,this.y2,this.x3,this.y3);
	}
	,clone: function() {
		return new nanofl_engine_geom_Edge(this.x1,this.y1,this.x2,this.y2,this.x3,this.y3);
	}
	,duplicate: function(e) {
		return new nanofl_engine_geom_Edge(e.x1,e.y1,e.x2,e.y2,e.x3,e.y3);
	}
	,indexIn: function(edges) {
		var _g = 0;
		var _g1 = edges.length;
		while(_g < _g1) {
			var i = _g++;
			if(this.equ(edges[i])) {
				return i;
			}
		}
		return -1;
	}
	,isDegenerated: function() {
		if(this.x1 == this.x2 && this.x2 == this.x3 && this.y1 == this.y2) {
			return this.y2 == this.y3;
		} else {
			return false;
		}
	}
	,roundPoints: function() {
		var straight = this.isStraight();
		this.x1 = nanofl_engine_geom_PointTools.roundGap(this.x1);
		this.y1 = nanofl_engine_geom_PointTools.roundGap(this.y1);
		this.x3 = nanofl_engine_geom_PointTools.roundGap(this.x3);
		this.y3 = nanofl_engine_geom_PointTools.roundGap(this.y3);
		if(straight) {
			this.x2 = (this.x1 + this.x3) / 2;
			this.y2 = (this.y1 + this.y3) / 2;
		} else {
			this.x2 = nanofl_engine_geom_PointTools.roundGap(this.x2);
			this.y2 = nanofl_engine_geom_PointTools.roundGap(this.y2);
			if(this.isStraight()) {
				this.x2 = (this.x1 + this.x3) / 2;
				this.y2 = (this.y1 + this.y3) / 2;
			}
		}
	}
	,getLength: function() {
		if(this.isStraight()) {
			return this.asStraightLine().getLength();
		} else {
			return this.asBezierCurve().getLength();
		}
	}
	,getPart: function(t) {
		if(this.isStraight()) {
			return nanofl_engine_geom_Edge.fromStraightLine(this.asStraightLine().getFirstPart(t));
		} else {
			return nanofl_engine_geom_Edge.fromBezierCurve(this.asBezierCurve().getFirstPart(t));
		}
	}
	,getPoint: function(t) {
		if(this.isStraight()) {
			return this.asStraightLine().getPoint(t);
		} else {
			return this.asBezierCurve().getPoint(t);
		}
	}
	,getTangent: function(t) {
		if(this.isStraight()) {
			return this.asStraightLine().getTangent(t);
		} else {
			return this.asBezierCurve().getTangent(t);
		}
	}
	,split: function(tt) {
		if(this.isStraight()) {
			var _this = this.asStraightLine().split(tt);
			var f = nanofl_engine_geom_Edge.fromStraightLine;
			var result = new Array(_this.length);
			var _g = 0;
			var _g1 = _this.length;
			while(_g < _g1) {
				var i = _g++;
				result[i] = f(_this[i]);
			}
			return result;
		} else {
			var _this = this.asBezierCurve().split(tt);
			var f = nanofl_engine_geom_Edge.fromBezierCurve;
			var result = new Array(_this.length);
			var _g = 0;
			var _g1 = _this.length;
			while(_g < _g1) {
				var i = _g++;
				result[i] = f(_this[i]);
			}
			return result;
		}
	}
	,isInRectangle: function(x,y,width,height) {
		if(this.x1 >= x && this.y1 >= y && this.x1 <= x + width && this.y1 <= y + height && this.x3 >= x && this.y3 >= y && this.x3 <= x + width && this.y3 <= y + height) {
			if(this.isStraight()) {
				return true;
			}
			if(this.x2 >= x && this.y2 >= y && this.x2 <= x + width && this.y2 <= y + height) {
				return true;
			}
			var curve = this.asBezierCurve();
			if(curve.getIntersection_straightSection(new nanofl_engine_geom_StraightLine(x,y,x + width,y)) != null) {
				return false;
			}
			if(curve.getIntersection_straightSection(new nanofl_engine_geom_StraightLine(x,y,x,y + height)) != null) {
				return false;
			}
			if(curve.getIntersection_straightSection(new nanofl_engine_geom_StraightLine(x,y + height,x + width,y + height)) != null) {
				return false;
			}
			if(curve.getIntersection_straightSection(new nanofl_engine_geom_StraightLine(x + width,y,x + width,y + height)) != null) {
				return false;
			}
			return true;
		}
		return false;
	}
	,getMonotoneT: function(k) {
		if(this.isStraight()) {
			return k;
		} else {
			return this.asBezierCurve().getMonotoneT(k);
		}
	}
	,__class__: nanofl_engine_geom_Edge
};
var nanofl_engine_geom_Edges = function() { };
nanofl_engine_geom_Edges.__name__ = "nanofl.engine.geom.Edges";
nanofl_engine_geom_Edges.hasDuplicates = function(edges) {
	var _g = 0;
	var _g1 = edges.length;
	while(_g < _g1) {
		var i = _g++;
		var _g2 = i + 1;
		var _g3 = edges.length;
		while(_g2 < _g3) {
			var j = _g2++;
			if(edges[i].equ(edges[j])) {
				return true;
			}
		}
	}
	return false;
};
nanofl_engine_geom_Edges.removeDublicates = function(edges) {
	var i = 0;
	while(i < edges.length) {
		var j = i + 1;
		while(j < edges.length) if(edges[i].equ(edges[j])) {
			edges.splice(j,1);
		} else {
			++j;
		}
		++i;
	}
};
nanofl_engine_geom_Edges.concatUnique = function(edgesA,edgesB) {
	var r = edgesA.slice();
	var _g = 0;
	while(_g < edgesB.length) {
		var e = edgesB[_g];
		++_g;
		if(e.indexIn(edgesA) < 0) {
			r.push(e);
		}
	}
	return r;
};
nanofl_engine_geom_Edges.appendUnique = function(edgesA,edgesB) {
	var _g = 0;
	while(_g < edgesB.length) {
		var e = edgesB[_g];
		++_g;
		if(e.indexIn(edgesA) < 0) {
			edgesA.push(e);
		}
	}
	return edgesA;
};
nanofl_engine_geom_Edges.exclude = function(edges,exclude) {
	var _g = 0;
	while(_g < exclude.length) {
		var e = exclude[_g];
		++_g;
		var n = e.indexIn(edges);
		if(n >= 0) {
			edges.splice(n,1);
			stdlib_Debug.assert(e.indexIn(edges) < 0,null,{ fileName : "engine/nanofl/engine/geom/Edges.hx", lineNumber : 66, className : "nanofl.engine.geom.Edges", methodName : "exclude"});
		}
	}
	return edges;
};
nanofl_engine_geom_Edges.draw = function(edges,g,fixLineJoinsInClosedContours) {
	var x = 1e100;
	var y = 1e100;
	var startEdge = null;
	var _g = 0;
	while(_g < edges.length) {
		var e = edges[_g];
		++_g;
		if(e.x1 != x || e.y1 != y) {
			if(fixLineJoinsInClosedContours && startEdge != null) {
				if(startEdge.x1 == x && startEdge.y1 == y) {
					startEdge.drawTo(g);
				}
			}
			startEdge = e;
			g.moveTo(e.x1,e.y1);
		}
		e.drawTo(g);
		x = e.x3;
		y = e.y3;
	}
	if(fixLineJoinsInClosedContours && startEdge != null) {
		if(startEdge.x1 == x && startEdge.y1 == y) {
			startEdge.drawTo(g);
		}
	}
};
nanofl_engine_geom_Edges.getBounds = function(edges,bounds) {
	if(edges.length > 0) {
		if(bounds == null) {
			bounds = { minX : 1e100, minY : 1e100, maxX : -1e100, maxY : -1e100};
		}
		var _g = 0;
		while(_g < edges.length) {
			var e = edges[_g];
			++_g;
			e.getBounds(bounds);
		}
		return bounds;
	}
	return bounds;
};
nanofl_engine_geom_Edges.export = function(edges,out) {
	if(edges.length == 0) {
		return;
	}
	var x = null;
	var y = null;
	var _g = 0;
	while(_g < edges.length) {
		var e = edges[_g];
		++_g;
		if(e.x1 != x || e.y1 != y) {
			out.begin("move").attr("x",e.x1).attr("y",e.y1).end();
		}
		if(e.isStraight()) {
			out.begin("line").attr("x",e.x3).attr("y",e.y3).end();
		} else {
			out.begin("curve").attr("x1",e.x2).attr("y1",e.y2).attr("x2",e.x3).attr("y2",e.y3).end();
		}
		x = e.x3;
		y = e.y3;
	}
};
nanofl_engine_geom_Edges.exportStroked = function(edges,out) {
	if(edges.length == 0) {
		return;
	}
	var strokes = [];
	var edgesByFill = [];
	var _g = 0;
	while(_g < edges.length) {
		var e = edges[_g];
		++_g;
		var strokeIndex = -1;
		var _g1 = 0;
		var _g2 = strokes.length;
		while(_g1 < _g2) {
			var i = _g1++;
			if(strokes[i].equ(e.stroke)) {
				strokeIndex = i;
				break;
			}
		}
		if(strokeIndex == -1) {
			strokeIndex = strokes.length;
			strokes.push(e.stroke);
			edgesByFill.push([]);
		}
		edgesByFill[strokeIndex].push(e);
	}
	var _g = 0;
	var _g1 = edgesByFill.length;
	while(_g < _g1) {
		var i = _g++;
		out.begin("edges").attr("strokeIndex",i);
		nanofl_engine_geom_Edges.export(edgesByFill[i],out);
		out.end();
	}
};
nanofl_engine_geom_Edges.load = function(s) {
	var r = [];
	var x = 0.0;
	var y = 0.0;
	var i = 0;
	while(i < s.length) {
		var c = s.charAt(i);
		++i;
		if(c == "M") {
			if(!nanofl_engine_geom_Edges.reFloat2.matchSub(s,i)) {
				throw haxe_Exception.thrown("Cannot parse " + HxOverrides.substr(s,i,20) + "'.");
			}
			x = parseFloat(nanofl_engine_geom_Edges.reFloat2.matched(1));
			y = parseFloat(nanofl_engine_geom_Edges.reFloat2.matched(2));
			i += nanofl_engine_geom_Edges.reFloat2.matchedPos().len;
		} else if(c == "L") {
			if(!nanofl_engine_geom_Edges.reFloat2.matchSub(s,i)) {
				throw haxe_Exception.thrown("Cannot parse " + HxOverrides.substr(s,i,20) + "'.");
			}
			var newX = parseFloat(nanofl_engine_geom_Edges.reFloat2.matched(1));
			var newY = parseFloat(nanofl_engine_geom_Edges.reFloat2.matched(2));
			r.push(new nanofl_engine_geom_Edge(x,y,newX,newY));
			x = newX;
			y = newY;
			i += nanofl_engine_geom_Edges.reFloat2.matchedPos().len;
		} else if(c == "C") {
			if(!nanofl_engine_geom_Edges.reFloat4.matchSub(s,i)) {
				throw haxe_Exception.thrown("Cannot parse " + HxOverrides.substr(s,i,20) + "'.");
			}
			var newX1 = parseFloat(nanofl_engine_geom_Edges.reFloat4.matched(3));
			var newY1 = parseFloat(nanofl_engine_geom_Edges.reFloat4.matched(4));
			r.push(new nanofl_engine_geom_Edge(x,y,parseFloat(nanofl_engine_geom_Edges.reFloat4.matched(1)),parseFloat(nanofl_engine_geom_Edges.reFloat4.matched(2)),newX1,newY1));
			x = newX1;
			y = newY1;
			i += nanofl_engine_geom_Edges.reFloat4.matchedPos().len;
		} else {
			throw haxe_Exception.thrown("Unexpected command '" + c + "'.");
		}
	}
	return r;
};
nanofl_engine_geom_Edges.save = function(edges) {
	var r_b = "";
	var x = null;
	var y = null;
	var _g = 0;
	while(_g < edges.length) {
		var e = edges[_g];
		++_g;
		if(e.x1 != x || e.y1 != y) {
			r_b += Std.string("M" + e.x1 + "," + e.y1);
		}
		if(e.isStraight()) {
			r_b += Std.string("L" + e.x3 + "," + e.y3);
		} else {
			r_b += Std.string("C" + e.x2 + "," + e.y2 + "," + e.x3 + "," + e.y3);
		}
		x = e.x3;
		y = e.y3;
	}
	return r_b;
};
nanofl_engine_geom_Edges.replace = function(edges,search,replacement) {
	stdlib_Debug.assert(!nanofl_engine_geom_Edges.hasDuplicates(edges),"Edges must be unique.",{ fileName : "engine/nanofl/engine/geom/Edges.hx", lineNumber : 248, className : "nanofl.engine.geom.Edges", methodName : "replace"});
	stdlib_Debug.assert(edges.indexOf(null) < 0,null,{ fileName : "engine/nanofl/engine/geom/Edges.hx", lineNumber : 249, className : "nanofl.engine.geom.Edges", methodName : "replace"});
	stdlib_Debug.assert(replacement.indexOf(null) < 0,null,{ fileName : "engine/nanofl/engine/geom/Edges.hx", lineNumber : 250, className : "nanofl.engine.geom.Edges", methodName : "replace"});
	if(replacement.length == 1 && replacement[0].equ(search)) {
		return -1;
	}
	stdlib_Debug.assert(search.indexIn(replacement) < 0,null,{ fileName : "engine/nanofl/engine/geom/Edges.hx", lineNumber : 254, className : "nanofl.engine.geom.Edges", methodName : "replace"});
	var i = search.indexIn(edges);
	if(i >= 0) {
		var _g = 0;
		while(_g < replacement.length) {
			var e = replacement[_g];
			++_g;
			stdlib_Debug.assert(e.indexIn(edges) < 0,e.toString(),{ fileName : "engine/nanofl/engine/geom/Edges.hx", lineNumber : 259, className : "nanofl.engine.geom.Edges", methodName : "replace"});
		}
		var edge = edges[i];
		nanofl_engine_geom_Edges.replaceAt(edges,i,replacement,edge.x1 == search.x3 && edge.y1 == search.y3);
	}
	stdlib_Debug.assert(!nanofl_engine_geom_Edges.hasDuplicates(edges),"Edges must be unique.",{ fileName : "engine/nanofl/engine/geom/Edges.hx", lineNumber : 265, className : "nanofl.engine.geom.Edges", methodName : "replace"});
	return i;
};
nanofl_engine_geom_Edges.replaceAll = function(edges,search,replacement) {
	stdlib_Debug.assert(edges.indexOf(null) < 0,null,{ fileName : "engine/nanofl/engine/geom/Edges.hx", lineNumber : 272, className : "nanofl.engine.geom.Edges", methodName : "replaceAll"});
	stdlib_Debug.assert(replacement.indexOf(null) < 0,null,{ fileName : "engine/nanofl/engine/geom/Edges.hx", lineNumber : 273, className : "nanofl.engine.geom.Edges", methodName : "replaceAll"});
	stdlib_Debug.assert(search.indexIn(replacement) < 0,null,{ fileName : "engine/nanofl/engine/geom/Edges.hx", lineNumber : 274, className : "nanofl.engine.geom.Edges", methodName : "replaceAll"});
	var i = 0;
	while(i < edges.length) {
		var edge = edges[i];
		if(edge.equ(search)) {
			nanofl_engine_geom_Edges.replaceAt(edges,i,replacement,search.x1 == edge.x3 && search.y1 == edge.y3);
			i += replacement.length;
		} else {
			++i;
		}
	}
	stdlib_Debug.assert(edges.indexOf(null) < 0,null,{ fileName : "engine/nanofl/engine/geom/Edges.hx", lineNumber : 290, className : "nanofl.engine.geom.Edges", methodName : "replaceAll"});
};
nanofl_engine_geom_Edges.replaceAt = function(edges,n,replacement,reverse) {
	stdlib_Debug.assert(n >= 0 && n < edges.length,"n = " + n + "; edges.length = " + edges.length,{ fileName : "engine/nanofl/engine/geom/Edges.hx", lineNumber : 295, className : "nanofl.engine.geom.Edges", methodName : "replaceAt"});
	stdlib_Debug.assert(edges.indexOf(null) < 0,null,{ fileName : "engine/nanofl/engine/geom/Edges.hx", lineNumber : 296, className : "nanofl.engine.geom.Edges", methodName : "replaceAt"});
	stdlib_Debug.assert(replacement.indexOf(null) < 0,null,{ fileName : "engine/nanofl/engine/geom/Edges.hx", lineNumber : 297, className : "nanofl.engine.geom.Edges", methodName : "replaceAt"});
	var edge = edges[n];
	edges.splice(n,1);
	var result = new Array(replacement.length);
	var _g = 0;
	var _g1 = replacement.length;
	while(_g < _g1) {
		var i = _g++;
		var e = replacement[i];
		var r = edge.clone();
		r.x1 = e.x1;
		r.y1 = e.y1;
		r.x2 = e.x2;
		r.y2 = e.y2;
		r.x3 = e.x3;
		r.y3 = e.y3;
		result[i] = r;
	}
	replacement = result;
	if(reverse) {
		replacement.reverse();
		var _g = 0;
		while(_g < replacement.length) {
			var edge = replacement[_g];
			++_g;
			edge.reverse();
		}
	}
	stdlib_LambdaArray.insertRange(edges,n,replacement);
};
nanofl_engine_geom_Edges.intersect = function(edgesA,edgesB,onReplace) {
	nanofl_engine_geom_Edges.normalize(edgesA);
	nanofl_engine_geom_Edges.normalize(edgesB);
	stdlib_Debug.assert(edgesA != edgesB,"Must not be the same edges array.",{ fileName : "engine/nanofl/engine/geom/Edges.hx", lineNumber : 329, className : "nanofl.engine.geom.Edges", methodName : "intersect"});
	stdlib_Debug.assert(edgesA.indexOf(null) < 0,null,{ fileName : "engine/nanofl/engine/geom/Edges.hx", lineNumber : 330, className : "nanofl.engine.geom.Edges", methodName : "intersect"});
	stdlib_Debug.assert(edgesB.indexOf(null) < 0,null,{ fileName : "engine/nanofl/engine/geom/Edges.hx", lineNumber : 331, className : "nanofl.engine.geom.Edges", methodName : "intersect"});
	stdlib_Debug.assert(!nanofl_engine_geom_Edges.hasDuplicates(edgesA),"Must not have duplicated in edgesA.",{ fileName : "engine/nanofl/engine/geom/Edges.hx", lineNumber : 332, className : "nanofl.engine.geom.Edges", methodName : "intersect"});
	stdlib_Debug.assert(!nanofl_engine_geom_Edges.hasDuplicates(edgesB),"Must not have duplicated in edgesB.",{ fileName : "engine/nanofl/engine/geom/Edges.hx", lineNumber : 333, className : "nanofl.engine.geom.Edges", methodName : "intersect"});
	stdlib_Debug.assert(!nanofl_engine_geom_Edges.hasDegenerated(edgesA),"Must not have degenerated in edgesA.",{ fileName : "engine/nanofl/engine/geom/Edges.hx", lineNumber : 334, className : "nanofl.engine.geom.Edges", methodName : "intersect"});
	stdlib_Debug.assert(!nanofl_engine_geom_Edges.hasDegenerated(edgesB),"Must not have degenerated in edgesB.",{ fileName : "engine/nanofl/engine/geom/Edges.hx", lineNumber : 335, className : "nanofl.engine.geom.Edges", methodName : "intersect"});
	nanofl_engine_geom_Edges.intersectByClosePoints(edgesA,edgesB,onReplace);
	stdlib_Debug.assert(!nanofl_engine_geom_Edges.hasDuplicates(edgesA),"Must not have duplicated in edgesA.",{ fileName : "engine/nanofl/engine/geom/Edges.hx", lineNumber : 345, className : "nanofl.engine.geom.Edges", methodName : "intersect"});
	stdlib_Debug.assert(!nanofl_engine_geom_Edges.hasDuplicates(edgesB),"Must not have duplicated in edgesB.",{ fileName : "engine/nanofl/engine/geom/Edges.hx", lineNumber : 346, className : "nanofl.engine.geom.Edges", methodName : "intersect"});
	var i = 0;
	while(i < edgesA.length) {
		var j = [0];
		while(j[0] < edgesB.length) {
			stdlib_Debug.assert(i < edgesA.length,(function() {
				return function() {
					return "i = " + i + "; edgesA.length = " + edgesA.length;
				};
			})(),{ fileName : "engine/nanofl/engine/geom/Edges.hx", lineNumber : 354, className : "nanofl.engine.geom.Edges", methodName : "intersect"});
			stdlib_Debug.assert(j[0] < edgesB.length,(function(j) {
				return function() {
					return "j = " + j[0] + "; edgesB.length = " + edgesB.length;
				};
			})(j),{ fileName : "engine/nanofl/engine/geom/Edges.hx", lineNumber : 355, className : "nanofl.engine.geom.Edges", methodName : "intersect"});
			var edgeA = edgesA[i];
			var edgeB = edgesB[j[0]];
			var I = nanofl_engine_geom_Edge.getIntersection(edgeA,edgeB);
			if(I != null) {
				var decI = false;
				if(I.a.length != 1 || !I.a[0].equ(edgeA)) {
					if(onReplace != null) {
						onReplace(edgeA,I.a);
					}
					edgesA.splice(i,1);
					var _g = 0;
					var _g1 = I.a;
					while(_g < _g1.length) {
						var e = _g1[_g];
						++_g;
						if(e.indexIn(edgesA) < 0) {
							edgesA.push(edgeA.duplicate(e));
						}
					}
					i -= 1;
					decI = true;
					var n = edgeA.indexIn(edgesB);
					if(n >= 0) {
						edgesB.splice(n,1);
						var _g2 = 0;
						var _g3 = I.a;
						while(_g2 < _g3.length) {
							var e1 = _g3[_g2];
							++_g2;
							if(e1.indexIn(edgesB) < 0) {
								edgesB.push(edgeB.duplicate(e1));
							}
						}
						if(j[0] > n) {
							j[0]--;
						}
					}
				}
				if(I.b.length != 1 || !I.b[0].equ(edgeB)) {
					if(onReplace != null) {
						onReplace(edgeB,I.b);
					}
					edgesB.splice(j[0],1);
					var _g4 = 0;
					var _g5 = I.b;
					while(_g4 < _g5.length) {
						var e2 = _g5[_g4];
						++_g4;
						if(e2.indexIn(edgesB) < 0) {
							edgesB.push(edgeB.duplicate(e2));
						}
					}
					j[0]--;
					var n1 = edgeB.indexIn(edgesA);
					if(n1 >= 0) {
						edgesA.splice(n1,1);
						var _g6 = 0;
						var _g7 = I.b;
						while(_g6 < _g7.length) {
							var e3 = _g7[_g6];
							++_g6;
							if(e3.indexIn(edgesA) < 0) {
								edgesA.push(edgeA.duplicate(e3));
							}
						}
						if(i > n1) {
							i -= 1;
							decI = true;
						}
					}
				}
				if(decI) {
					break;
				}
			} else {
				j[0]++;
			}
		}
		i += 1;
	}
	stdlib_Debug.assert(edgesA != edgesB,"Must not be the same edges array.",{ fileName : "engine/nanofl/engine/geom/Edges.hx", lineNumber : 416, className : "nanofl.engine.geom.Edges", methodName : "intersect"});
	stdlib_Debug.assert(edgesA.indexOf(null) < 0,null,{ fileName : "engine/nanofl/engine/geom/Edges.hx", lineNumber : 417, className : "nanofl.engine.geom.Edges", methodName : "intersect"});
	stdlib_Debug.assert(edgesB.indexOf(null) < 0,null,{ fileName : "engine/nanofl/engine/geom/Edges.hx", lineNumber : 418, className : "nanofl.engine.geom.Edges", methodName : "intersect"});
	stdlib_Debug.assert(!nanofl_engine_geom_Edges.hasDuplicates(edgesA),"Must not have duplicated in edgesA.",{ fileName : "engine/nanofl/engine/geom/Edges.hx", lineNumber : 419, className : "nanofl.engine.geom.Edges", methodName : "intersect"});
	stdlib_Debug.assert(!nanofl_engine_geom_Edges.hasDuplicates(edgesB),"Must not have duplicated in edgesB.",{ fileName : "engine/nanofl/engine/geom/Edges.hx", lineNumber : 420, className : "nanofl.engine.geom.Edges", methodName : "intersect"});
	stdlib_Debug.assert(!nanofl_engine_geom_Edges.hasIntersections(edgesA,edgesB),"After intersection must not be intersections (" + nanofl_engine_geom_Edges.getFirstIntersectionString(edgesA,edgesB) + ").",{ fileName : "engine/nanofl/engine/geom/Edges.hx", lineNumber : 421, className : "nanofl.engine.geom.Edges", methodName : "intersect"});
	stdlib_Debug.assert(!nanofl_engine_geom_Edges.hasDegenerated(edgesA),"Must not have degenerated in edgesA.",{ fileName : "engine/nanofl/engine/geom/Edges.hx", lineNumber : 422, className : "nanofl.engine.geom.Edges", methodName : "intersect"});
	stdlib_Debug.assert(!nanofl_engine_geom_Edges.hasDegenerated(edgesB),"Must not have degenerated in edgesB.",{ fileName : "engine/nanofl/engine/geom/Edges.hx", lineNumber : 423, className : "nanofl.engine.geom.Edges", methodName : "intersect"});
};
nanofl_engine_geom_Edges.intersectByClosePoints = function(edgesA,edgesB,onReplace) {
	nanofl_engine_geom_Edges.intersectByClosePointsInner(edgesA,edgesB,onReplace);
	nanofl_engine_geom_Edges.intersectByClosePointsInner(edgesB,edgesA,onReplace);
};
nanofl_engine_geom_Edges.intersectByClosePointsInner = function(edgesA,edgesB,onReplace) {
	stdlib_Debug.assert(edgesA != edgesB,"Must not be the same edges array.",{ fileName : "engine/nanofl/engine/geom/Edges.hx", lineNumber : 435, className : "nanofl.engine.geom.Edges", methodName : "intersectByClosePointsInner"});
	stdlib_Debug.assert(edgesA.indexOf(null) < 0,null,{ fileName : "engine/nanofl/engine/geom/Edges.hx", lineNumber : 436, className : "nanofl.engine.geom.Edges", methodName : "intersectByClosePointsInner"});
	stdlib_Debug.assert(edgesB.indexOf(null) < 0,null,{ fileName : "engine/nanofl/engine/geom/Edges.hx", lineNumber : 437, className : "nanofl.engine.geom.Edges", methodName : "intersectByClosePointsInner"});
	stdlib_Debug.assert(!nanofl_engine_geom_Edges.hasDuplicates(edgesA),"Must not have duplicated in edgesA.",{ fileName : "engine/nanofl/engine/geom/Edges.hx", lineNumber : 438, className : "nanofl.engine.geom.Edges", methodName : "intersectByClosePointsInner"});
	stdlib_Debug.assert(!nanofl_engine_geom_Edges.hasDuplicates(edgesB),"Must not have duplicated in edgesB.",{ fileName : "engine/nanofl/engine/geom/Edges.hx", lineNumber : 439, className : "nanofl.engine.geom.Edges", methodName : "intersectByClosePointsInner"});
	stdlib_Debug.assert(!nanofl_engine_geom_Edges.hasDegenerated(edgesA),"Must not have degenerated in edgesA.",{ fileName : "engine/nanofl/engine/geom/Edges.hx", lineNumber : 440, className : "nanofl.engine.geom.Edges", methodName : "intersectByClosePointsInner"});
	stdlib_Debug.assert(!nanofl_engine_geom_Edges.hasDegenerated(edgesB),"Must not have degenerated in edgesB.",{ fileName : "engine/nanofl/engine/geom/Edges.hx", lineNumber : 441, className : "nanofl.engine.geom.Edges", methodName : "intersectByClosePointsInner"});
	var _g = 0;
	while(_g < edgesA.length) {
		var edgeA = edgesA[_g];
		++_g;
		var i = 0;
		while(i < edgesB.length) {
			var edgeB = edgesB[i];
			if(nanofl_engine_geom_BoundsTools.isIntersect(edgeA.getBoundsRO(),edgeB.getBoundsRO(),nanofl_engine_geom_Edges.GAP) && !edgeA.equ(edgeB)) {
				var r = edgeB.splitByClosePoint(edgeA.x1,edgeA.y1);
				if(r == null) {
					r = edgeB.splitByClosePoint(edgeA.x3,edgeA.y3);
				}
				if(r != null) {
					if(onReplace != null) {
						onReplace(edgeB,r);
					}
					edgesB.splice(i,1);
					var _g1 = 0;
					while(_g1 < r.length) {
						var e = r[_g1];
						++_g1;
						if(e.indexIn(edgesB) < 0) {
							edgesB.push(edgeB.duplicate(e));
						}
					}
					--i;
				}
			}
			++i;
		}
	}
	stdlib_Debug.assert(edgesA != edgesB,"Must not be the same edges array.",{ fileName : "engine/nanofl/engine/geom/Edges.hx", lineNumber : 468, className : "nanofl.engine.geom.Edges", methodName : "intersectByClosePointsInner"});
	stdlib_Debug.assert(edgesA.indexOf(null) < 0,null,{ fileName : "engine/nanofl/engine/geom/Edges.hx", lineNumber : 469, className : "nanofl.engine.geom.Edges", methodName : "intersectByClosePointsInner"});
	stdlib_Debug.assert(edgesB.indexOf(null) < 0,null,{ fileName : "engine/nanofl/engine/geom/Edges.hx", lineNumber : 470, className : "nanofl.engine.geom.Edges", methodName : "intersectByClosePointsInner"});
	stdlib_Debug.assert(!nanofl_engine_geom_Edges.hasDuplicates(edgesA),"Must not have duplicated in edgesA.",{ fileName : "engine/nanofl/engine/geom/Edges.hx", lineNumber : 471, className : "nanofl.engine.geom.Edges", methodName : "intersectByClosePointsInner"});
	stdlib_Debug.assert(!nanofl_engine_geom_Edges.hasDuplicates(edgesB),"Must not have duplicated in edgesB.",{ fileName : "engine/nanofl/engine/geom/Edges.hx", lineNumber : 472, className : "nanofl.engine.geom.Edges", methodName : "intersectByClosePointsInner"});
	stdlib_Debug.assert(!nanofl_engine_geom_Edges.hasDegenerated(edgesA),"Must not have degenerated in edgesA.",{ fileName : "engine/nanofl/engine/geom/Edges.hx", lineNumber : 473, className : "nanofl.engine.geom.Edges", methodName : "intersectByClosePointsInner"});
	stdlib_Debug.assert(!nanofl_engine_geom_Edges.hasDegenerated(edgesB),"Must not have degenerated in edgesB.",{ fileName : "engine/nanofl/engine/geom/Edges.hx", lineNumber : 474, className : "nanofl.engine.geom.Edges", methodName : "intersectByClosePointsInner"});
};
nanofl_engine_geom_Edges.intersectSelf = function(edges,onReplace) {
	nanofl_engine_geom_Edges.intersect(edges,edges.slice(),onReplace);
};
nanofl_engine_geom_Edges.normalize = function(edges) {
	nanofl_engine_geom_Edges.roundPoints(edges);
	nanofl_engine_geom_Edges.removeDegenerated(edges);
	nanofl_engine_geom_Edges.removeDublicates(edges);
	return edges;
};
nanofl_engine_geom_Edges.roundPoints = function(edges) {
	var _g = 0;
	while(_g < edges.length) {
		var edge = edges[_g];
		++_g;
		edge.roundPoints();
	}
	return edges;
};
nanofl_engine_geom_Edges.removeDegenerated = function(edges,removeAlsoCurvesWithStartAndEndEquals) {
	if(removeAlsoCurvesWithStartAndEndEquals == null) {
		removeAlsoCurvesWithStartAndEndEquals = false;
	}
	if(removeAlsoCurvesWithStartAndEndEquals) {
		var i = 0;
		while(i < edges.length) {
			var edge = edges[i];
			if(edge.x1 == edge.x3 && edge.y1 == edge.y3) {
				edges.splice(i,1);
			} else {
				++i;
			}
		}
	} else {
		var i = 0;
		while(i < edges.length) if(edges[i].isDegenerated()) {
			edges.splice(i,1);
		} else {
			++i;
		}
	}
	return edges;
};
nanofl_engine_geom_Edges.isPointInside = function(edges,x,y,fillEvenOdd) {
	if(fillEvenOdd) {
		var count = 0;
		var _g = 0;
		while(_g < edges.length) {
			var edge = edges[_g];
			++_g;
			count += edge.getIntersectionCount_rightRay(x,y);
		}
		return count % 2 == 1;
	}
	var count = 0;
	var _g = 0;
	while(_g < edges.length) {
		var edge = edges[_g];
		++_g;
		count += edge.getIntersectionDirectedCount_rightRay(x,y);
	}
	return count != 0;
};
nanofl_engine_geom_Edges.hasIntersections = function(edgesA,edgesB) {
	var _g = 0;
	while(_g < edgesA.length) {
		var a = edgesA[_g];
		++_g;
		var _g1 = 0;
		while(_g1 < edgesB.length) {
			var b = edgesB[_g1];
			++_g1;
			var I = nanofl_engine_geom_Edge.getIntersection(a,b);
			if(I != null) {
				return true;
			}
		}
	}
	return false;
};
nanofl_engine_geom_Edges.getFirstIntersectionString = function(edgesA,edgesB) {
	var _g = 0;
	while(_g < edgesA.length) {
		var a = edgesA[_g];
		++_g;
		var _g1 = 0;
		while(_g1 < edgesB.length) {
			var b = edgesB[_g1];
			++_g1;
			var I = nanofl_engine_geom_Edge.getIntersection(a,b);
			if(I != null) {
				return a.toString() + ", " + b.toString();
			}
		}
	}
	return "";
};
nanofl_engine_geom_Edges.isSequence = function(edges) {
	var _g = 1;
	var _g1 = edges.length;
	while(_g < _g1) {
		var i = _g++;
		if(edges[i - 1].x3 != edges[i].x1) {
			return false;
		}
		if(edges[i - 1].y3 != edges[i].y1) {
			return false;
		}
	}
	return true;
};
nanofl_engine_geom_Edges.hasDegenerated = function(edges) {
	var _g = 0;
	while(_g < edges.length) {
		var e = edges[_g];
		++_g;
		if(e.isDegenerated()) {
			return true;
		}
	}
	return false;
};
nanofl_engine_geom_Edges.getPointUseCount = function(edges,x,y) {
	var r = 0;
	var _g = 0;
	while(_g < edges.length) {
		var e = edges[_g];
		++_g;
		if(e.x1 == x && e.y1 == y) {
			++r;
		}
		if(e.x3 == x && e.y3 == y) {
			++r;
		}
	}
	return r;
};
nanofl_engine_geom_Edges.equIgnoreOrder = function(edgesA,edgesB) {
	if(edgesA.length != edgesB.length) {
		return false;
	}
	var _g = 0;
	while(_g < edgesA.length) {
		var edgeA = edgesA[_g];
		++_g;
		if(edgeA.indexIn(edgesB) < 0) {
			return false;
		}
	}
	return true;
};
nanofl_engine_geom_Edges.getCommon = function(edgesA,edgesB) {
	var r = [];
	var _g = 0;
	while(_g < edgesA.length) {
		var edge = edgesA[_g];
		++_g;
		if(edge.indexIn(edgesB) >= 0) {
			r.push(edge);
		}
	}
	return r;
};
nanofl_engine_geom_Edges.getDifferent = function(edgesA,edgesB) {
	var r = [];
	var _g = 0;
	while(_g < edgesA.length) {
		var edge = edgesA[_g];
		++_g;
		if(edge.indexIn(edgesB) < 0) {
			r.push(edge);
		}
	}
	var _g = 0;
	while(_g < edgesB.length) {
		var edge = edgesB[_g];
		++_g;
		if(edge.indexIn(edgesA) < 0) {
			r.push(edge);
		}
	}
	return r;
};
nanofl_engine_geom_Edges.getNearestVertex = function(edges,x,y) {
	var r = { x : -1e10, y : -1e10};
	var _g = 0;
	while(_g < edges.length) {
		var e = edges[_g];
		++_g;
		if(nanofl_engine_geom_PointTools.getSqrDist(r.x,r.y,x,y) > nanofl_engine_geom_PointTools.getSqrDist(e.x1,e.y1,x,y)) {
			r.x = e.x1;
			r.y = e.y1;
		}
		if(nanofl_engine_geom_PointTools.getSqrDist(r.x,r.y,x,y) > nanofl_engine_geom_PointTools.getSqrDist(e.x3,e.y3,x,y)) {
			r.x = e.x3;
			r.y = e.y3;
		}
	}
	return r;
};
nanofl_engine_geom_Edges.getTailPoints = function(edges) {
	var r = [];
	var _g = 0;
	while(_g < edges.length) {
		var e = [edges[_g]];
		++_g;
		if(nanofl_engine_geom_Edges.getPointUseCount(edges,e[0].x1,e[0].y1) == 1 && !Lambda.exists(r,(function(e) {
			return function(p) {
				if(p.x == e[0].x1) {
					return p.y == e[0].y1;
				} else {
					return false;
				}
			};
		})(e))) {
			r.push({ x : e[0].x1, y : e[0].y1});
		}
		if(nanofl_engine_geom_Edges.getPointUseCount(edges,e[0].x3,e[0].y3) == 1 && !Lambda.exists(r,(function(e) {
			return function(p) {
				if(p.x == e[0].x3) {
					return p.y == e[0].y3;
				} else {
					return false;
				}
			};
		})(e))) {
			r.push({ x : e[0].x3, y : e[0].y3});
		}
	}
	return r;
};
nanofl_engine_geom_Edges.smoothStraightLineSequence = function(edges,power) {
	var i = 0;
	while(i < edges.length) {
		var a = edges[i];
		var b = edges[(i + 1) % edges.length];
		if(a.x3 == b.x1 && a.y3 == b.y1) {
			var cc = a.split([1 - power / 2]);
			var dd = b.split([power / 2]);
			edges[i] = cc[0];
			edges[i + 1] = dd[1];
			cc[1].x2 = a.x3;
			cc[1].y2 = a.y3;
			cc[1].x3 = dd[0].x3;
			cc[1].y3 = dd[0].y3;
			edges.splice(i + 1,0,cc[1]);
			++i;
		}
		++i;
	}
};
nanofl_engine_geom_Edges.assertHasNoIntersections = function(edges) {
	var _g = 0;
	var _g1 = edges.length;
	while(_g < _g1) {
		var i = _g++;
		var _g2 = i + 1;
		var _g3 = edges.length;
		while(_g2 < _g3) {
			var j = _g2++;
			var hasCV = edges[i].hasCommonVertices(edges[j]);
			var I = nanofl_engine_geom_Edge.getIntersection(edges[i],edges[j]);
			stdlib_Debug.assert(hasCV || I == null || I.a.length == 1 || I.b.length == 1,"hasCV = " + (hasCV == null ? "null" : "" + hasCV) + "\n" + "I = " + Std.string(I != null) + "\n" + "edges[" + i + "] = " + Std.string(edges[i]) + "\n" + "edges[" + j + "] = " + Std.string(edges[j]),{ fileName : "engine/nanofl/engine/geom/Edges.hx", lineNumber : 745, className : "nanofl.engine.geom.Edges", methodName : "assertHasNoIntersections"});
		}
	}
};
nanofl_engine_geom_Edges.simplificate = function(sequence,eps) {
	if(sequence.length < 2) {
		return sequence.slice();
	}
	var eps2 = eps * eps;
	var r = [];
	r.push(sequence[0]);
	var _g = 1;
	var _g1 = sequence.length;
	while(_g < _g1) {
		var i = _g++;
		var edgeA = r[r.length - 1];
		var edgeB = sequence[i];
		var equal = true;
		var edgeC = nanofl_engine_geom_Edges.getAppoximated(edgeA,edgeB);
		var _g2 = 0;
		while(_g2 < 7) {
			var i1 = _g2++;
			var pt0 = edgeC.getPoint(i1 / 6);
			var b = edgeA.getNearestPoint(pt0.x,pt0.y).point;
			var d1 = nanofl_engine_geom_PointTools.getSqrDist(pt0.x,pt0.y,b.x,b.y);
			var b1 = edgeB.getNearestPoint(pt0.x,pt0.y).point;
			var d2 = nanofl_engine_geom_PointTools.getSqrDist(pt0.x,pt0.y,b1.x,b1.y);
			if(d1 > eps2 && d2 > eps2) {
				equal = false;
				break;
			}
		}
		if(equal) {
			r[r.length - 1] = edgeC;
		} else {
			r.push(edgeB);
		}
	}
	return r;
};
nanofl_engine_geom_Edges.getAppoximated = function(edgeA,edgeB) {
	stdlib_Debug.assert(edgeA.x3 == edgeB.x1 && edgeA.y3 == edgeB.y1,null,{ fileName : "engine/nanofl/engine/geom/Edges.hx", lineNumber : 798, className : "nanofl.engine.geom.Edges", methodName : "getAppoximated"});
	var lineA = new nanofl_engine_geom_StraightLine(edgeA.x1,edgeA.y1,edgeA.x2,edgeA.y2);
	var lineB = new nanofl_engine_geom_StraightLine(edgeB.x3,edgeB.y3,edgeB.x2,edgeB.y2);
	var I = lineA.getIntersection_infinityLine(lineB);
	var r = edgeA.clone();
	r.x3 = edgeB.x3;
	r.y3 = edgeB.y3;
	r.x2 = I == null ? (r.x1 + r.x3) / 2 : I.x;
	r.y2 = I == null ? (r.y1 + r.y3) / 2 : I.y;
	return r;
};
nanofl_engine_geom_Edges.log = function(v,infos) {
};
var nanofl_engine_geom_Equation = function() { };
nanofl_engine_geom_Equation.__name__ = "nanofl.engine.geom.Equation";
nanofl_engine_geom_Equation.solveCube = function(a,b,c,d) {
	if(Math.abs(a) < 1e-10) {
		return nanofl_engine_geom_Equation.solveQuadratic(b,c,d);
	}
	var z = a;
	a = b / z;
	b = c / z;
	c = d / z;
	var p = b - a * a / 3;
	var q = a * (2 * a * a - 9 * b) / 27 + c;
	var p3 = p * p * p;
	var D = q * q + 4 * p3 / 27;
	var offset = -a / 3;
	if(D > 1e-10) {
		z = Math.sqrt(D);
		var u = (-q + z) / 2;
		var v = (-q - z) / 2;
		u = u >= 0 ? Math.pow(u,0.33333333333333331) : -Math.pow(-u,0.33333333333333331);
		v = v >= 0 ? Math.pow(v,0.33333333333333331) : -Math.pow(-v,0.33333333333333331);
		return [u + v + offset];
	} else if(D < -1e-010) {
		var u = 2 * Math.sqrt(-p / 3);
		var v = Math.acos(-Math.sqrt(-27 / p3) * q / 2) / 3;
		return [u * Math.cos(v) + offset,u * Math.cos(v + 2 * Math.PI / 3) + offset,u * Math.cos(v + 4 * Math.PI / 3) + offset];
	} else {
		var u = q < 0 ? Math.pow(-q / 2,0.33333333333333331) : -Math.pow(q / 2,0.33333333333333331);
		return [2 * u + offset,-u + offset];
	}
};
nanofl_engine_geom_Equation.solveQuadratic = function(a,b,c) {
	if(Math.abs(a) <= 1e-10) {
		if(Math.abs(b) > 1e-10) {
			return [-c / b];
		} else {
			return [];
		}
	}
	var D = b * b - 4 * a * c;
	if(D > 1e-10) {
		D = Math.sqrt(D);
		return [(-b - D) / (2 * a),(-b + D) / (2 * a)];
	}
	if(D > -1e-010) {
		return [-b / (2 * a)];
	}
	return [];
};
var nanofl_engine_geom_Matrix = function(a,b,c,d,tx,ty) {
	if(ty == null) {
		ty = 0.0;
	}
	if(tx == null) {
		tx = 0.0;
	}
	if(d == null) {
		d = 1.0;
	}
	if(c == null) {
		c = 0.0;
	}
	if(b == null) {
		b = 0.0;
	}
	if(a == null) {
		a = 1.0;
	}
	this.a = a;
	this.b = b;
	this.c = c;
	this.d = d;
	this.tx = tx;
	this.ty = ty;
};
nanofl_engine_geom_Matrix.__name__ = "nanofl.engine.geom.Matrix";
nanofl_engine_geom_Matrix.load = function(node) {
	var coefs = htmlparser_HtmlParserTools.getAttr(node,"matrix",[0.0]);
	if(coefs != null) {
		return new nanofl_engine_geom_Matrix(coefs[0],coefs[1],coefs[2],coefs[3],htmlparser_HtmlParserTools.getAttr(node,"x",0.0),htmlparser_HtmlParserTools.getAttr(node,"y",0.0));
	} else {
		return new nanofl_engine_geom_Matrix(1.0,0.0,0.0,1.0,htmlparser_HtmlParserTools.getAttr(node,"x",0.0),htmlparser_HtmlParserTools.getAttr(node,"y",0.0));
	}
};
nanofl_engine_geom_Matrix.loadJson = function(obj) {
	if(obj.matrix != null) {
		var tmp = obj.x;
		var tmp1 = obj.y;
		return new nanofl_engine_geom_Matrix(obj.matrix[0],obj.matrix[1],obj.matrix[2],obj.matrix[3],tmp != null ? tmp : 0.0,tmp1 != null ? tmp1 : 0.0);
	} else {
		var tmp = obj.x;
		var tmp1 = obj.y;
		return new nanofl_engine_geom_Matrix(1.0,0.0,0.0,1.0,tmp != null ? tmp : 0.0,tmp1 != null ? tmp1 : 0.0);
	}
};
nanofl_engine_geom_Matrix.fromNative = function(m) {
	return new nanofl_engine_geom_Matrix(m.a,m.b,m.c,m.d,m.tx,m.ty);
};
nanofl_engine_geom_Matrix.prototype = {
	save: function(out) {
		if(this.tx != 0.0 || this.ty != 0.0) {
			out.attr("x",this.tx);
			out.attr("y",this.ty);
		}
		if(this.a != 1.0 || this.b != 0.0 || this.c != 0.0 || this.d != 1.0) {
			out.attr("matrix",[this.a,this.b,this.c,this.d].join(","));
		}
	}
	,saveJson: function(obj) {
		if(this.tx != 0.0 || this.ty != 0.0) {
			obj.x = this.tx;
			obj.y = this.ty;
		}
		if(this.a != 1.0 || this.b != 0.0 || this.c != 0.0 || this.d != 1.0) {
			obj.matrix = [this.a,this.b,this.c,this.d];
		}
	}
	,decompose: function() {
		var r = { };
		r.x = this.tx;
		r.y = this.ty;
		r.scaleX = Math.sqrt(this.a * this.a + this.b * this.b);
		r.scaleY = Math.sqrt(this.c * this.c + this.d * this.d);
		var skewX = Math.atan2(-this.c,this.d);
		var skewY = Math.atan2(this.b,this.a);
		if(skewX == skewY) {
			r.rotation = skewY * 180 / Math.PI;
			if(this.a < 0 && this.d >= 0) {
				r.rotation += r.rotation <= 0 ? 180 : -180;
			}
			r.skewX = r.skewY = 0;
		} else {
			r.rotation = 0;
			r.skewX = skewX * 180 / Math.PI;
			r.skewY = skewY * 180 / Math.PI;
		}
		return r;
	}
	,setMatrix: function(m) {
		this.a = m.a;
		this.b = m.b;
		this.c = m.c;
		this.d = m.d;
		this.tx = m.tx;
		this.ty = m.ty;
		return this;
	}
	,isIdentity: function() {
		if(this.a == 1.0 && this.b == 0.0 && this.c == 0.0 && this.d == 1.0 && this.tx == 0.0) {
			return this.ty == 0.0;
		} else {
			return false;
		}
	}
	,invert: function() {
		var a1 = this.a;
		var b1 = this.b;
		var c1 = this.c;
		var d1 = this.d;
		var tx1 = this.tx;
		var n = a1 * d1 - b1 * c1;
		this.a = d1 / n;
		this.b = -b1 / n;
		this.c = -c1 / n;
		this.d = a1 / n;
		this.tx = (c1 * this.ty - d1 * tx1) / n;
		this.ty = -(a1 * this.ty - b1 * tx1) / n;
		return this;
	}
	,transformPoint: function(x,y) {
		return { x : x * this.a + y * this.c + this.tx, y : x * this.b + y * this.d + this.ty};
	}
	,transformPointP: function(pos) {
		return { x : pos.x * this.a + pos.y * this.c + this.tx, y : pos.x * this.b + pos.y * this.d + this.ty};
	}
	,clone: function() {
		return new nanofl_engine_geom_Matrix(this.a,this.b,this.c,this.d,this.tx,this.ty);
	}
	,translate: function(tx,ty) {
		this.tx += tx;
		this.ty += ty;
		return this;
	}
	,equ: function(m) {
		if(m.a == this.a && m.b == this.b && m.c == this.c && m.d == this.d && m.tx == this.tx) {
			return m.ty == this.ty;
		} else {
			return false;
		}
	}
	,setTransform: function(x,y,scaleX,scaleY,rotation,skewX,skewY,regX,regY) {
		return this.setMatrix(new nanofl_engine_geom_Matrix().appendTransform(x,y,scaleX,scaleY,rotation,skewX,skewY,regX,regY));
	}
	,appendMatrix: function(m) {
		return this.append(m.a,m.b,m.c,m.d,m.tx,m.ty);
	}
	,prependMatrix: function(m) {
		return this.prepend(m.a,m.b,m.c,m.d,m.tx,m.ty);
	}
	,append: function(a,b,c,d,tx,ty) {
		var a1 = this.a;
		var b1 = this.b;
		var c1 = this.c;
		var d1 = this.d;
		this.a = a * a1 + b * c1;
		this.b = a * b1 + b * d1;
		this.c = c * a1 + d * c1;
		this.d = c * b1 + d * d1;
		this.tx = tx * a1 + ty * c1 + this.tx;
		this.ty = tx * b1 + ty * d1 + this.ty;
		return this;
	}
	,prepend: function(a,b,c,d,tx,ty) {
		var tx1 = this.tx;
		if(a != 1 || b != 0 || c != 0 || d != 1) {
			var a1 = this.a;
			var c1 = this.c;
			this.a = a1 * a + this.b * c;
			this.b = a1 * b + this.b * d;
			this.c = c1 * a + this.d * c;
			this.d = c1 * b + this.d * d;
		}
		this.tx = tx1 * a + this.ty * c + tx;
		this.ty = tx1 * b + this.ty * d + ty;
		return this;
	}
	,appendTransform: function(x,y,scaleX,scaleY,rotation,skewX,skewY,regX,regY) {
		if(regY == null) {
			regY = 0.0;
		}
		if(regX == null) {
			regX = 0.0;
		}
		if(skewY == null) {
			skewY = 0.0;
		}
		if(skewX == null) {
			skewX = 0.0;
		}
		if(rotation == null) {
			rotation = 0.0;
		}
		if(scaleY == null) {
			scaleY = 1.0;
		}
		if(scaleX == null) {
			scaleX = 1.0;
		}
		var sin;
		var cos;
		if(rotation % 360 != 0) {
			var r = rotation * nanofl_engine_geom_Matrix.DEG_TO_RAD;
			cos = Math.cos(r);
			sin = Math.sin(r);
		} else {
			cos = 1;
			sin = 0;
		}
		if(skewX != 0 || skewY != 0) {
			skewX *= nanofl_engine_geom_Matrix.DEG_TO_RAD;
			skewY *= nanofl_engine_geom_Matrix.DEG_TO_RAD;
			this.append(Math.cos(skewY),Math.sin(skewY),-Math.sin(skewX),Math.cos(skewX),x,y);
			this.append(cos * scaleX,sin * scaleX,-sin * scaleY,cos * scaleY,0,0);
		} else {
			this.append(cos * scaleX,sin * scaleX,-sin * scaleY,cos * scaleY,x,y);
		}
		if(regX != 0 || regY != 0) {
			this.tx -= regX * this.a + regY * this.c;
			this.ty -= regX * this.b + regY * this.d;
		}
		return this;
	}
	,prependTransform: function(x,y,scaleX,scaleY,rotation,skewX,skewY,regX,regY) {
		if(regY == null) {
			regY = 0.0;
		}
		if(regX == null) {
			regX = 0.0;
		}
		if(skewY == null) {
			skewY = 0.0;
		}
		if(skewX == null) {
			skewX = 0.0;
		}
		if(rotation == null) {
			rotation = 0.0;
		}
		if(scaleY == null) {
			scaleY = 1.0;
		}
		if(scaleX == null) {
			scaleX = 1.0;
		}
		var sin;
		var cos;
		if(rotation % 360 != 0) {
			var r = rotation * nanofl_engine_geom_Matrix.DEG_TO_RAD;
			cos = Math.cos(r);
			sin = Math.sin(r);
		} else {
			cos = 1;
			sin = 0;
		}
		this.tx -= regX;
		this.ty -= regY;
		if(skewX != 0 || skewY != 0) {
			skewX *= nanofl_engine_geom_Matrix.DEG_TO_RAD;
			skewY *= nanofl_engine_geom_Matrix.DEG_TO_RAD;
			this.prepend(cos * scaleX,sin * scaleX,-sin * scaleY,cos * scaleY,0,0);
			this.prepend(Math.cos(skewY),Math.sin(skewY),-Math.sin(skewX),Math.cos(skewX),x,y);
		} else {
			this.prepend(cos * scaleX,sin * scaleX,-sin * scaleY,cos * scaleY,x,y);
		}
		return this;
	}
	,rotate: function(angle) {
		var cos = Math.cos(angle);
		var sin = Math.sin(angle);
		var a1 = this.a;
		var c1 = this.c;
		var tx1 = this.tx;
		this.a = a1 * cos - this.b * sin;
		this.b = a1 * sin + this.b * cos;
		this.c = c1 * cos - this.d * sin;
		this.d = c1 * sin + this.d * cos;
		this.tx = tx1 * cos - this.ty * sin;
		this.ty = tx1 * sin + this.ty * cos;
		return this;
	}
	,skew: function(skewX,skewY) {
		skewX *= nanofl_engine_geom_Matrix.DEG_TO_RAD;
		skewY *= nanofl_engine_geom_Matrix.DEG_TO_RAD;
		this.append(Math.cos(skewY),Math.sin(skewY),-Math.sin(skewX),Math.cos(skewX),0,0);
		return this;
	}
	,scale: function(kx,ky) {
		this.a *= kx;
		this.d *= ky;
		this.c *= kx;
		this.b *= ky;
		this.tx *= kx;
		this.ty *= ky;
		return this;
	}
	,createGradientBox: function(width,height,rotation,tx,ty) {
		if(ty == null) {
			ty = 0.0;
		}
		if(tx == null) {
			tx = 0.0;
		}
		if(rotation == null) {
			rotation = 0.0;
		}
		this.a = width / 1638.4;
		this.d = height / 1638.4;
		if(rotation != 0) {
			var cos = Math.cos(rotation);
			var sin = Math.sin(rotation);
			this.b = sin * this.d;
			this.c = -sin * this.a;
			this.a *= cos;
			this.d *= cos;
		} else {
			this.b = 0;
			this.c = 0;
		}
		this.tx = tx + width / 2;
		this.ty = ty + height / 2;
		return this;
	}
	,getAverageScale: function() {
		return (Math.sqrt(this.a * this.a + this.c * this.c) + Math.sqrt(this.b * this.b + this.d * this.d)) / 2;
	}
	,toNative: function() {
		return new createjs.Matrix2D(this.a,this.b,this.c,this.d,this.tx,this.ty);
	}
	,toArray: function() {
		return [this.a,this.b,this.c,this.d,this.tx,this.ty];
	}
	,toString: function() {
		return "Matrix(" + this.a + ", " + this.b + ", " + this.c + ", " + this.d + ", " + this.tx + ", " + this.ty + ")";
	}
	,__class__: nanofl_engine_geom_Matrix
};
var nanofl_engine_geom_PointTools = function() { };
nanofl_engine_geom_PointTools.__name__ = "nanofl.engine.geom.PointTools";
nanofl_engine_geom_PointTools.half = function(pt) {
	var ix = pt.x | 0;
	pt.x = ix + (ix > pt.x ? -0.5 : 0.5);
	var iy = pt.y | 0;
	pt.y = iy + (iy > pt.y ? -0.5 : 0.5);
	return pt;
};
nanofl_engine_geom_PointTools.round = function(pt) {
	pt.x = Math.round(pt.x);
	pt.y = Math.round(pt.y);
	return pt;
};
nanofl_engine_geom_PointTools.normalize = function(pt) {
	var len = nanofl_engine_geom_PointTools.getLength(pt);
	if(len != 0) {
		pt.x /= len;
		pt.y /= len;
	}
	return pt;
};
nanofl_engine_geom_PointTools.getLength = function(pt) {
	return Math.sqrt(pt.x * pt.x + pt.y * pt.y);
};
nanofl_engine_geom_PointTools.getDist = function(x1,y1,x2,y2) {
	var dx = x2 - x1;
	var dy = y2 - y1;
	return Math.sqrt(dx * dx + dy * dy);
};
nanofl_engine_geom_PointTools.getSqrDist = function(x1,y1,x2,y2) {
	var dx = x2 - x1;
	var dy = y2 - y1;
	return dx * dx + dy * dy;
};
nanofl_engine_geom_PointTools.getDistP = function(a,b) {
	return nanofl_engine_geom_PointTools.getDist(a.x,a.y,b.x,b.y);
};
nanofl_engine_geom_PointTools.getSqrDistP = function(a,b) {
	return nanofl_engine_geom_PointTools.getSqrDist(a.x,a.y,b.x,b.y);
};
nanofl_engine_geom_PointTools.rotate = function(x,y,da) {
	return { x : x * Math.cos(da) - y * Math.sin(da), y : y * Math.cos(da) + x * Math.sin(da)};
};
nanofl_engine_geom_PointTools.getRotated = function(pt,da) {
	return nanofl_engine_geom_PointTools.rotate(pt.x,pt.y,da);
};
nanofl_engine_geom_PointTools.moveInDirection = function(start,endX,endY,len) {
	var v = { x : endX - start.x, y : endY - start.y};
	var l = nanofl_engine_geom_PointTools.getLength(v);
	nanofl_engine_geom_PointTools.normalize(v);
	var k = Math.min(len,l);
	start.x = v.x * k + start.x;
	start.y = v.y * k + start.y;
	return start;
};
nanofl_engine_geom_PointTools.equ = function(pt1,pt2) {
	if(pt1.x == pt2.x) {
		return pt1.y == pt2.y;
	} else {
		return false;
	}
};
nanofl_engine_geom_PointTools.clone = function(pt) {
	return { x : pt.x, y : pt.y};
};
nanofl_engine_geom_PointTools.roundGap = function(n) {
	return Math.round(n * 100) / 100;
};
nanofl_engine_geom_PointTools.roundGapP = function(pt) {
	pt.x = nanofl_engine_geom_PointTools.roundGap(pt.x);
	pt.y = nanofl_engine_geom_PointTools.roundGap(pt.y);
	return pt;
};
nanofl_engine_geom_PointTools.getNearest = function(pt,points) {
	if(points == null || points.length == 0) {
		return null;
	}
	var bestP = points[0];
	var bestD = nanofl_engine_geom_PointTools.getSqrDist(pt.x,pt.y,bestP.x,bestP.y);
	var _g = 0;
	while(_g < points.length) {
		var point = points[_g];
		++_g;
		var dist = nanofl_engine_geom_PointTools.getSqrDist(pt.x,pt.y,point.x,point.y);
		if(dist < bestD) {
			bestP = point;
			bestD = dist;
		}
	}
	return bestP;
};
nanofl_engine_geom_PointTools.toString = function(pt) {
	if(pt != null) {
		return pt.x + "," + pt.y;
	} else {
		return "null";
	}
};
var nanofl_engine_geom_Polygon = function(fill,contours,selected) {
	if(selected == null) {
		selected = false;
	}
	this.fill = fill;
	this.contours = contours != null ? contours : [];
	this.set_selected(selected);
};
nanofl_engine_geom_Polygon.__name__ = "nanofl.engine.geom.Polygon";
nanofl_engine_geom_Polygon.__interfaces__ = [nanofl_engine_ISelectable];
nanofl_engine_geom_Polygon.load = function(node,fills,version) {
	stdlib_Debug.assert(node.name == "polygon",null,{ fileName : "engine/nanofl/engine/geom/Polygon.hx", lineNumber : 37, className : "nanofl.engine.geom.Polygon", methodName : "load"});
	var fillIndex = htmlparser_HtmlParserTools.getAttr(node,"fillIndex",-1) | 0;
	stdlib_Debug.assert(fillIndex != null,null,{ fileName : "engine/nanofl/engine/geom/Polygon.hx", lineNumber : 40, className : "nanofl.engine.geom.Polygon", methodName : "load"});
	stdlib_Debug.assert(fillIndex >= 0,null,{ fileName : "engine/nanofl/engine/geom/Polygon.hx", lineNumber : 41, className : "nanofl.engine.geom.Polygon", methodName : "load"});
	stdlib_Debug.assert(fillIndex < fills.length,null,{ fileName : "engine/nanofl/engine/geom/Polygon.hx", lineNumber : 42, className : "nanofl.engine.geom.Polygon", methodName : "load"});
	var contours = [];
	var _g = 0;
	var _g1 = node.children;
	while(_g < _g1.length) {
		var node = _g1[_g];
		++_g;
		if(node.name == "contour") {
			contours.push(new nanofl_engine_geom_Contour(nanofl_engine_geom_Edges.load(htmlparser_HtmlParserTools.getAttr(node,"edges"))));
		}
	}
	return new nanofl_engine_geom_Polygon(fills[fillIndex],contours);
};
nanofl_engine_geom_Polygon.loadJson = function(obj,fills,version) {
	var tmp = obj.fillIndex;
	var fillIndex = (tmp != null ? tmp : -1) | 0;
	stdlib_Debug.assert(fillIndex != null,null,{ fileName : "engine/nanofl/engine/geom/Polygon.hx", lineNumber : 59, className : "nanofl.engine.geom.Polygon", methodName : "loadJson"});
	stdlib_Debug.assert(fillIndex >= 0,null,{ fileName : "engine/nanofl/engine/geom/Polygon.hx", lineNumber : 60, className : "nanofl.engine.geom.Polygon", methodName : "loadJson"});
	stdlib_Debug.assert(fillIndex < fills.length,null,{ fileName : "engine/nanofl/engine/geom/Polygon.hx", lineNumber : 61, className : "nanofl.engine.geom.Polygon", methodName : "loadJson"});
	var contours = [];
	var i = 0;
	while(i < obj.contours.length) contours.push(new nanofl_engine_geom_Contour(nanofl_engine_geom_Edges.load(obj.contours[i++].edges)));
	return new nanofl_engine_geom_Polygon(fills[fillIndex],contours);
};
nanofl_engine_geom_Polygon.prototype = {
	get_selected: function() {
		return this.selected;
	}
	,set_selected: function(v) {
		return this.selected = v;
	}
	,save: function(fills,out) {
		out.begin("polygon").attr("fillIndex",this.getFillIndex(fills));
		var _g = 0;
		var _g1 = this.contours;
		while(_g < _g1.length) {
			var c = _g1[_g];
			++_g;
			c.save(out);
		}
		out.end();
	}
	,saveJson: function(fills) {
		var tmp = this.getFillIndex(fills);
		var _this = this.contours;
		var result = new Array(_this.length);
		var _g = 0;
		var _g1 = _this.length;
		while(_g < _g1) {
			var i = _g++;
			result[i] = _this[i].saveJson();
		}
		return { fillIndex : tmp, contours : result};
	}
	,draw: function(g,scaleSelection) {
		this.fill.begin(g);
		var _g = 0;
		var _g1 = this.contours;
		while(_g < _g1.length) {
			var contour = _g1[_g];
			++_g;
			contour.draw(g);
		}
		g.endFill();
		if(nanofl_engine_geom_Polygon.showSelection && this.get_selected()) {
			new nanofl_engine_fills_SelectionFill(scaleSelection).begin(g);
			var _g = 0;
			var _g1 = this.contours;
			while(_g < _g1.length) {
				var contour = _g1[_g];
				++_g;
				contour.draw(g);
			}
			g.endFill();
		}
	}
	,translate: function(dx,dy) {
		if(this.fill != null) {
			this.fill = this.fill.getTransformed(new nanofl_engine_geom_Matrix(1,0,0,1,dx,dy));
		}
		var _g = 0;
		var _g1 = this.contours;
		while(_g < _g1.length) {
			var c = _g1[_g];
			++_g;
			c.translate(dx,dy);
		}
	}
	,isPointInside: function(px,py) {
		if(this.contours[0].isPointInside(px,py)) {
			return Lambda.foreach(this.contours.slice(1),function(x) {
				return !x.isPointInside(px,py);
			});
		} else {
			return false;
		}
	}
	,getFillIndex: function(fills) {
		var _gthis = this;
		var r = stdlib_LambdaIterable.findIndex(fills,function(f) {
			return f.equ(_gthis.fill);
		});
		if(r < 0) {
			r = fills.length;
			fills.push(this.fill);
		}
		return r;
	}
	,hasPoint: function(px,py) {
		var _g = 0;
		var _g1 = this.contours;
		while(_g < _g1.length) {
			var contour = _g1[_g];
			++_g;
			if(contour.hasPoint(px,py)) {
				return true;
			}
		}
		return false;
	}
	,hasEdge: function(edge) {
		var _g = 0;
		var _g1 = this.contours;
		while(_g < _g1.length) {
			var c = _g1[_g];
			++_g;
			if(c.hasEdge(edge)) {
				return true;
			}
		}
		return false;
	}
	,isEdgeInside: function(edge) {
		stdlib_Debug.assert(this.contours.length > 0,null,{ fileName : "engine/nanofl/engine/geom/Polygon.hx", lineNumber : 138, className : "nanofl.engine.geom.Polygon", methodName : "isEdgeInside"});
		if(this.contours[0].isEdgeInside(edge)) {
			return Lambda.foreach(this.contours.slice(1),function(c) {
				return !c.isEdgeInside(edge);
			});
		} else {
			return false;
		}
	}
	,isEdgeAtLeastPartiallyInside: function(edge) {
		var m = edge.getMiddlePoint();
		if(!(!this.hasPoint(m.x,m.y) && this.isPointInside(m.x,m.y) || !this.hasPoint(edge.x1,edge.y1) && this.isPointInside(edge.x1,edge.y1))) {
			if(!this.hasPoint(edge.x3,edge.y3)) {
				return this.isPointInside(edge.x3,edge.y3);
			} else {
				return false;
			}
		} else {
			return true;
		}
	}
	,isPolygonInside: function(p) {
		stdlib_Debug.assert(this.contours.length > 0,null,{ fileName : "engine/nanofl/engine/geom/Polygon.hx", lineNumber : 152, className : "nanofl.engine.geom.Polygon", methodName : "isPolygonInside"});
		stdlib_Debug.assert(p.contours.length > 0,null,{ fileName : "engine/nanofl/engine/geom/Polygon.hx", lineNumber : 153, className : "nanofl.engine.geom.Polygon", methodName : "isPolygonInside"});
		var _g = 0;
		var _g1 = p.contours[0].edges;
		while(_g < _g1.length) {
			var edge = _g1[_g];
			++_g;
			if(!this.isEdgeInside(edge)) {
				return false;
			}
		}
		var _g = 1;
		var _g1 = this.contours.length;
		while(_g < _g1) {
			var i = _g++;
			var _g2 = 0;
			var _g3 = this.contours[i].edges;
			while(_g2 < _g3.length) {
				var edge = _g3[_g2];
				++_g2;
				if(p.isEdgeInside(edge)) {
					return false;
				}
			}
		}
		return true;
	}
	,translateVertex: function(point,dx,dy) {
		var _g = 0;
		var _g1 = this.contours;
		while(_g < _g1.length) {
			var contour = _g1[_g];
			++_g;
			var _g2 = 0;
			var _g3 = contour.edges;
			while(_g2 < _g3.length) {
				var edge = _g3[_g2];
				++_g2;
				edge.translateVertex(point,dx,dy);
			}
		}
	}
	,getBounds: function(bounds) {
		if(this.contours.length > 0) {
			if(bounds == null) {
				bounds = { minX : 1e10, minY : 1e10, maxX : -1e10, maxY : -1e10};
			}
			var _g = 0;
			var _g1 = this.contours;
			while(_g < _g1.length) {
				var contour = _g1[_g];
				++_g;
				nanofl_engine_geom_Edges.getBounds(contour.edges,bounds);
			}
			return bounds;
		}
		if(bounds != null) {
			return bounds;
		} else {
			return { minX : 0.0, minY : 0.0, maxX : 0.0, maxY : 0.0};
		}
	}
	,applyFill: function(fill,x1,y1,x2,y2) {
		var _g = fill.getTyped();
		switch(_g._hx_index) {
		case 0:
			var fill = _g.fill;
			this.fill = fill.clone();
			break;
		case 1:
			var fill = _g.fill;
			fill = fill.clone();
			if(this.fill == null || this.fill.getTyped()._hx_index != fill.getTyped()._hx_index || x1 != null) {
				var len;
				if(x1 == null || x1 == x2 && y1 == y2) {
					var bounds = this.getBounds();
					len = bounds.maxX - bounds.minX;
					x1 = bounds.minX;
					x2 = bounds.maxX;
					y2 = bounds.minY;
					y1 = y2;
				} else {
					len = nanofl_engine_geom_PointTools.getDist(x1,y1,x2,y2);
				}
				fill.x0 = x1;
				fill.y0 = y1;
				fill.x1 = x2;
				fill.y1 = y2;
			} else {
				var t = js_Boot.__cast(this.fill , nanofl_engine_fills_LinearFill);
				fill.x0 = t.x0;
				fill.y0 = t.y0;
				fill.x1 = t.x1;
				fill.y1 = t.y1;
			}
			this.fill = fill;
			break;
		case 2:
			var fill = _g.fill;
			fill = fill.clone();
			if(this.fill == null || this.fill.getTyped()._hx_index != fill.getTyped()._hx_index || x1 != null) {
				var len;
				if(x1 == null || x1 == x2 && y1 == y2) {
					var bounds = this.getBounds();
					len = Math.max(bounds.maxX - bounds.minX,bounds.maxY - bounds.minY) / 2;
					x1 = (bounds.minX + bounds.maxX) / 2;
					y1 = (bounds.minY + bounds.maxY) / 2;
				} else {
					len = nanofl_engine_geom_PointTools.getDist(x1,y1,x2,y2);
				}
				fill.cx = x1;
				fill.cy = y1;
				fill.r = len;
				fill.fx = x1;
				fill.fy = y1;
			} else {
				var t = js_Boot.__cast(this.fill , nanofl_engine_fills_RadialFill);
				fill.cx = t.cx;
				fill.cy = t.cy;
				fill.r = t.r;
				fill.fx = t.fx;
				fill.fy = t.fy;
			}
			this.fill = fill;
			break;
		case 3:
			var fill = _g.fill;
			fill = fill.clone();
			var len;
			fill.repeat = x1 != null ? "repeat" : "no-repeat";
			var bitmapWidth = fill.getBitmapWidth();
			if(x1 == null || x1 == x2 && y1 == y2) {
				var bounds = this.getBounds();
				len = bounds.maxX - bounds.minX;
				x1 = bounds.minX;
				x2 = bounds.minX + bitmapWidth;
				y2 = bounds.minY;
				y1 = y2;
			} else {
				len = nanofl_engine_geom_PointTools.getDist(x1,y1,x2,y2);
			}
			fill.matrix = new nanofl_engine_geom_Matrix();
			fill.matrix.scale(len / bitmapWidth,len / bitmapWidth);
			if(x1 != x2 || y1 != y2) {
				fill.matrix.rotate(Math.atan2(y2 - y1,x2 - x1));
			}
			fill.matrix.translate(x1,y1);
			this.fill = fill;
			break;
		}
	}
	,transform: function(m,applyToFill) {
		if(applyToFill == null) {
			applyToFill = true;
		}
		var _g = 0;
		var _g1 = this.contours;
		while(_g < _g1.length) {
			var contour = _g1[_g];
			++_g;
			var _g2 = 0;
			var _g3 = contour.edges;
			while(_g2 < _g3.length) {
				var edge = _g3[_g2];
				++_g2;
				edge.transform(m);
			}
		}
		if(applyToFill && this.fill != null) {
			this.fill = this.fill.getTransformed(m);
		}
	}
	,getEdges: function(edges) {
		if(edges == null) {
			edges = [];
		}
		var _g = 0;
		var _g1 = this.contours;
		while(_g < _g1.length) {
			var contour = _g1[_g];
			++_g;
			nanofl_engine_geom_Edges.appendUnique(edges,contour.edges);
		}
		return edges;
	}
	,getPointInside: function() {
		var bounds = this.getBounds();
		var yy = [bounds.minY,bounds.maxY];
		var _g = 0;
		var _g1 = this.getEdges();
		while(_g < _g1.length) {
			var edge = _g1[_g];
			++_g;
			yy.push(edge.y1);
		}
		yy.sort(Reflect.compare);
		var maxDY = 0.0;
		var rY = yy[0];
		var _g = 1;
		var _g1 = yy.length;
		while(_g < _g1) {
			var i = _g++;
			if(yy[i] - yy[i - 1] > maxDY) {
				maxDY = yy[i] - yy[i - 1];
				rY = (yy[i] + yy[i - 1]) / 2;
			}
		}
		var xx = [];
		var _g = 0;
		var _g1 = this.contours;
		while(_g < _g1.length) {
			var contour = _g1[_g];
			++_g;
			var _g2 = 0;
			var _g3 = contour.edges;
			while(_g2 < _g3.length) {
				var edge = _g3[_g2];
				++_g2;
				var _g4 = 0;
				var _g5 = edge.getIntersectionPointsX_rightRay(-1.0e100,rY);
				while(_g4 < _g5.length) {
					var x = _g5[_g4];
					++_g4;
					xx.push(x);
				}
			}
			stdlib_Debug.assert(xx.length % 2 == 0,"Polygon.getPointInside() error\nxx = " + Std.string(xx) + "\nrY = " + rY + "\nedges = " + Std.string(contour.edges),{ fileName : "engine/nanofl/engine/geom/Polygon.hx", lineNumber : 357, className : "nanofl.engine.geom.Polygon", methodName : "getPointInside"});
		}
		xx.sort(Reflect.compare);
		var maxDX = 0.0;
		var rX = xx[0];
		var i = 1;
		while(i < xx.length) {
			if(xx[i] - xx[i - 1] > maxDX) {
				maxDX = xx[i] - xx[i - 1];
				rX = (xx[i] + xx[i - 1]) / 2;
			}
			i += 2;
		}
		return { x : rX, y : rY};
	}
	,clone: function() {
		return new nanofl_engine_geom_Polygon(this.fill.clone(),datatools_ArrayTools.clone(this.contours),this.get_selected());
	}
	,replaceEdge: function(search,replacement) {
		var _g = 0;
		var _g1 = this.contours;
		while(_g < _g1.length) {
			var contour = _g1[_g];
			++_g;
			nanofl_engine_geom_Edges.replaceAll(contour.edges,search,replacement);
		}
	}
	,'export': function(out,fills) {
		var fillIndex = -1;
		var _g = 0;
		var _g1 = fills.length;
		while(_g < _g1) {
			var i = _g++;
			if(fills[i].equ(this.fill)) {
				fillIndex = i;
				break;
			}
		}
		if(fillIndex == -1) {
			fillIndex = fills.length;
			fills.push(this.fill);
		}
		out.begin("polygon").attr("fillIndex",fillIndex);
		var _g = 0;
		var _g1 = this.contours;
		while(_g < _g1.length) {
			var c = _g1[_g];
			++_g;
			out.begin("contour");
			nanofl_engine_geom_Edges.export(c.edges,out);
			out.end();
		}
		out.end();
	}
	,split: function() {
		var outers = [];
		var _g = 0;
		var _g1 = this.contours;
		while(_g < _g1.length) {
			var contour = [_g1[_g]];
			++_g;
			if(Lambda.foreach(this.contours,(function(contour) {
				return function(c) {
					if(c != contour[0]) {
						return !contour[0].isNestedTo(c);
					} else {
						return true;
					}
				};
			})(contour))) {
				outers.push(contour[0]);
			}
		}
		if(outers.length == 1) {
			return [this];
		}
		var r = [];
		var _g = 0;
		while(_g < outers.length) {
			var outer = outers[_g];
			++_g;
			var _g1 = [];
			var _g2 = 0;
			var _g3 = this.contours;
			while(_g2 < _g3.length) {
				var v = _g3[_g2];
				++_g2;
				if(v != outer && v.isNestedTo(outer)) {
					_g1.push(v);
				}
			}
			var inners = _g1;
			inners.unshift(outer);
			r.push(new nanofl_engine_geom_Polygon(this.fill,inners));
		}
		return r;
	}
	,equ: function(p) {
		if(p.contours.length != this.contours.length) {
			return false;
		}
		return Lambda.foreach(this.contours,function(a) {
			return Lambda.exists(p.contours,function(b) {
				return a.equ(b);
			});
		});
	}
	,normalize: function() {
		var i = 0;
		while(i < this.contours.length) {
			this.contours[i].normalize();
			if(this.contours[i].edges.length <= 1) {
				this.contours.splice(i,1);
			} else {
				++i;
			}
		}
	}
	,isInRectangle: function(x,y,width,height) {
		var _g = 0;
		var _g1 = this.contours[0].edges;
		while(_g < _g1.length) {
			var edge = _g1[_g];
			++_g;
			if(!edge.isInRectangle(x,y,width,height)) {
				return false;
			}
		}
		return true;
	}
	,assertCorrect: function() {
	}
	,isContourOutside: function(c) {
		var allEdges = this.getEdges();
		var _g = 0;
		var _g1 = c.edges;
		while(_g < _g1.length) {
			var e = [_g1[_g]];
			++_g;
			if(!this.hasPoint(e[0].x3,e[0].y3) && !Lambda.exists(allEdges,(function(e) {
				return function(ee) {
					return ee.y3 == e[0].y3;
				};
			})(e)) && this.isPointInside(e[0].x3,e[0].y3)) {
				return false;
			}
		}
		return true;
	}
	,fixErrors: function() {
		var r = [];
		var tree = nanofl_engine_geom_Contours.getTree(this.contours);
		this.collectPolygonsByContourTree(tree,r);
		var _g = 0;
		while(_g < r.length) {
			var p = r[_g];
			++_g;
			p.fixContoursDirection();
		}
		return r;
	}
	,collectPolygonsByContourTree: function(tree,dest) {
		var _g = 0;
		while(_g < tree.length) {
			var p = tree[_g];
			++_g;
			var tmp = this.fill;
			var tmp1 = [p.parent];
			var _this = p.children;
			var result = new Array(_this.length);
			var _g1 = 0;
			var _g2 = _this.length;
			while(_g1 < _g2) {
				var i = _g1++;
				result[i] = _this[i].parent;
			}
			dest.push(new nanofl_engine_geom_Polygon(tmp,tmp1.concat(result)));
			var _g3 = 0;
			var _g4 = p.children;
			while(_g3 < _g4.length) {
				var c = _g4[_g3];
				++_g3;
				this.collectPolygonsByContourTree(c.children,dest);
			}
		}
	}
	,fixContoursDirection: function() {
		if(this.contours[0].getClockwiseProduct() < 0) {
			this.contours[0].reverse();
		}
		var _g = 0;
		var _g1 = this.contours.slice(1);
		while(_g < _g1.length) {
			var contour = _g1[_g];
			++_g;
			if(contour.getClockwiseProduct() > 0) {
				contour.reverse();
			}
		}
	}
	,toString: function() {
		return "new Polygon(" + Std.string(this.fill) + ", " + Std.string(this.contours) + ")";
	}
	,__class__: nanofl_engine_geom_Polygon
};
var nanofl_engine_geom_Polygons = function() { };
nanofl_engine_geom_Polygons.__name__ = "nanofl.engine.geom.Polygons";
nanofl_engine_geom_Polygons.findByPoint = function(polygons,x,y) {
	var _g = 0;
	while(_g < polygons.length) {
		var p = polygons[_g];
		++_g;
		if(p.isPointInside(x,y)) {
			return p;
		}
	}
	return null;
};
nanofl_engine_geom_Polygons.isEdgeInside = function(polygons,edge) {
	var _g = 0;
	while(_g < polygons.length) {
		var p = polygons[_g];
		++_g;
		if(p.isEdgeInside(edge)) {
			return true;
		}
	}
	return false;
};
nanofl_engine_geom_Polygons.mergeByCommonEdges = function(polygons,edges) {
	stdlib_Debug.assert(!nanofl_engine_geom_Polygons.hasDublicates(polygons),null,{ fileName : "engine/nanofl/engine/geom/Polygons.hx", lineNumber : 32, className : "nanofl.engine.geom.Polygons", methodName : "mergeByCommonEdges"});
	nanofl_engine_geom_Polygons.assertCorrect(polygons,false);
	nanofl_engine_geom_Polygons.log(function() {
		var result = new Array(polygons.length);
		var _g = 0;
		var _g1 = polygons.length;
		while(_g < _g1) {
			var i = _g++;
			result[i] = "\t" + Std.string(polygons[i]);
		}
		return "mergeByCommonEdges\npolygons =\n" + result.join("\n") + "\nedges = " + edges.join("; ");
	},{ fileName : "engine/nanofl/engine/geom/Polygons.hx", lineNumber : 35, className : "nanofl.engine.geom.Polygons", methodName : "mergeByCommonEdges"});
	var i = 0;
	while(i < polygons.length) {
		var j = [i + 1];
		while(j[0] < polygons.length) {
			nanofl_engine_geom_Polygons.log((function(j) {
				return function() {
					return "test i=" + i + " and j=" + j[0] + "\n\t\t" + polygons[i].toString() + "\n\t\t" + Std.string(polygons[j[0]]);
				};
			})(j),{ fileName : "engine/nanofl/engine/geom/Polygons.hx", lineNumber : 42, className : "nanofl.engine.geom.Polygons", methodName : "mergeByCommonEdges"});
			if(polygons[i].fill.equ(polygons[j[0]].fill)) {
				nanofl_engine_geom_Polygons.log((function() {
					return function() {
						return "\tfill match!";
					};
				})(),{ fileName : "engine/nanofl/engine/geom/Polygons.hx", lineNumber : 45, className : "nanofl.engine.geom.Polygons", methodName : "mergeByCommonEdges"});
				stdlib_Debug.assert(polygons[i].contours.length > 0,null,{ fileName : "engine/nanofl/engine/geom/Polygons.hx", lineNumber : 46, className : "nanofl.engine.geom.Polygons", methodName : "mergeByCommonEdges"});
				stdlib_Debug.assert(polygons[j[0]].contours.length > 0,null,{ fileName : "engine/nanofl/engine/geom/Polygons.hx", lineNumber : 47, className : "nanofl.engine.geom.Polygons", methodName : "mergeByCommonEdges"});
				var commonEdges = [nanofl_engine_geom_Edges.getCommon(polygons[i].contours[0].edges,polygons[j[0]].contours[0].edges)];
				nanofl_engine_geom_Polygons.log((function(commonEdges) {
					return function() {
						return "\tcommonEdges = " + Std.string(commonEdges[0]);
					};
				})(commonEdges),{ fileName : "engine/nanofl/engine/geom/Polygons.hx", lineNumber : 50, className : "nanofl.engine.geom.Polygons", methodName : "mergeByCommonEdges"});
				if(commonEdges[0].length > 0 && Lambda.foreach(commonEdges[0],(function() {
					return function(e) {
						return e.indexIn(edges) < 0;
					};
				})())) {
					var outerEdges = nanofl_engine_geom_Edges.exclude(nanofl_engine_geom_Edges.concatUnique(polygons[i].contours[0].edges,polygons[j[0]].contours[0].edges),commonEdges[0]);
					nanofl_engine_geom_Polygons.log("\tMERGE!",{ fileName : "engine/nanofl/engine/geom/Polygons.hx", lineNumber : 55, className : "nanofl.engine.geom.Polygons", methodName : "mergeByCommonEdges"});
					if(outerEdges.length > 0) {
						var outerContours = nanofl_engine_geom_Contours.fromEdges(outerEdges);
						outerContours.sort((function() {
							return function(a,b) {
								if(a.isNestedTo(b)) {
									return 1;
								} else {
									return -1;
								}
							};
						})());
						var _g = 1;
						var _g1 = outerContours.length;
						while(_g < _g1) {
							var k = _g++;
							outerContours[k].reverse();
						}
						var inners = outerContours.slice(1).concat(polygons[i].contours.slice(1)).concat(polygons[j[0]].contours.slice(1));
						nanofl_engine_geom_Contours.removeNested(inners);
						nanofl_engine_geom_Contours.mergeByCommonEdges(inners,true);
						polygons[i] = new nanofl_engine_geom_Polygon(polygons[i].fill,[outerContours[0]].concat(inners));
						polygons[i].assertCorrect();
					} else {
						stdlib_Debug.assert(false,(function() {
							return function() {
								return "Two polygons with same outer contour = " + Std.string(polygons[i].contours[0]);
							};
						})(),{ fileName : "engine/nanofl/engine/geom/Polygons.hx", lineNumber : 78, className : "nanofl.engine.geom.Polygons", methodName : "mergeByCommonEdges"});
					}
					nanofl_engine_geom_Polygons.log("\tRemove polygon " + j[0],{ fileName : "engine/nanofl/engine/geom/Polygons.hx", lineNumber : 82, className : "nanofl.engine.geom.Polygons", methodName : "mergeByCommonEdges"});
					polygons.splice(j[0],1);
					if(outerEdges.length > 0) {
						j[0] = i;
					} else {
						j[0]--;
					}
					nanofl_engine_geom_Polygons.log("\tj = " + j[0],{ fileName : "engine/nanofl/engine/geom/Polygons.hx", lineNumber : 88, className : "nanofl.engine.geom.Polygons", methodName : "mergeByCommonEdges"});
				}
			}
			j[0]++;
		}
		i += 1;
	}
	nanofl_engine_geom_Polygons.log("==================================== in the middle ==========================",{ fileName : "engine/nanofl/engine/geom/Polygons.hx", lineNumber : 96, className : "nanofl.engine.geom.Polygons", methodName : "mergeByCommonEdges"});
	nanofl_engine_geom_Polygons.log(function() {
		return "// SOURCE:\n\t" + polygons.join("\n\t");
	},{ fileName : "engine/nanofl/engine/geom/Polygons.hx", lineNumber : 97, className : "nanofl.engine.geom.Polygons", methodName : "mergeByCommonEdges"});
	nanofl_engine_geom_Polygons.assertCorrect(polygons,false);
	var i1 = 0;
	while(i1 < polygons.length) {
		var j1 = [0];
		while(j1[0] < polygons.length) {
			if(i1 != j1[0] && polygons[i1].fill.equ(polygons[j1[0]].fill)) {
				stdlib_Debug.assert(polygons[i1].contours.length > 0,null,{ fileName : "engine/nanofl/engine/geom/Polygons.hx", lineNumber : 108, className : "nanofl.engine.geom.Polygons", methodName : "mergeByCommonEdges"});
				stdlib_Debug.assert(polygons[j1[0]].contours.length > 0,null,{ fileName : "engine/nanofl/engine/geom/Polygons.hx", lineNumber : 109, className : "nanofl.engine.geom.Polygons", methodName : "mergeByCommonEdges"});
				var outerJ = polygons[j1[0]].contours[0];
				var _g = 1;
				var _g1 = polygons[i1].contours.length;
				while(_g < _g1) {
					var k = _g++;
					var innerI = polygons[i1].contours[k];
					var commonEdges1 = [nanofl_engine_geom_Edges.getCommon(innerI.edges,outerJ.edges)];
					nanofl_engine_geom_Polygons.log((function(commonEdges) {
						return function() {
							return "\tcommonEdges = " + Std.string(commonEdges[0]);
						};
					})(commonEdges1),{ fileName : "engine/nanofl/engine/geom/Polygons.hx", lineNumber : 118, className : "nanofl.engine.geom.Polygons", methodName : "mergeByCommonEdges"});
					if(commonEdges1[0].length > 0 && Lambda.foreach(commonEdges1[0],(function() {
						return function(e) {
							return e.indexIn(edges) < 0;
						};
					})())) {
						var innerEdges = [nanofl_engine_geom_Edges.exclude(nanofl_engine_geom_Edges.concatUnique(innerI.edges,outerJ.edges),commonEdges1[0])];
						nanofl_engine_geom_Polygons.log((function(innerEdges) {
							return function() {
								return "\tinnerEdges = " + Std.string(innerEdges[0]);
							};
						})(innerEdges),{ fileName : "engine/nanofl/engine/geom/Polygons.hx", lineNumber : 122, className : "nanofl.engine.geom.Polygons", methodName : "mergeByCommonEdges"});
						nanofl_engine_geom_Polygons.log((function(j) {
							return function() {
								return "// MERGE " + i1 + " and " + j[0] + "\n\t" + Std.string(polygons[i1]) + "\n\t" + Std.string(polygons[j[0]]);
							};
						})(j1),{ fileName : "engine/nanofl/engine/geom/Polygons.hx", lineNumber : 124, className : "nanofl.engine.geom.Polygons", methodName : "mergeByCommonEdges"});
						polygons[i1].contours.splice(k,1);
						if(innerEdges[0].length > 0) {
							var inners = nanofl_engine_geom_Contours.fromEdges(innerEdges[0]);
							var _g2 = 0;
							while(_g2 < inners.length) {
								var c = inners[_g2];
								++_g2;
								c.reverse();
							}
							inners = inners.concat(polygons[j1[0]].contours.slice(1));
							polygons[i1].contours = polygons[i1].contours.concat(inners);
							polygons[i1].assertCorrect();
						} else {
							var polygons1 = polygons[i1].contours;
							var tmp = polygons[j1[0]].contours.slice(1);
							polygons[i1].contours = polygons1.concat(tmp);
							polygons[i1].assertCorrect();
						}
						nanofl_engine_geom_Polygons.log((function() {
							return function() {
								return "// RESULT\n\t" + Std.string(polygons[i1]);
							};
						})(),{ fileName : "engine/nanofl/engine/geom/Polygons.hx", lineNumber : 142, className : "nanofl.engine.geom.Polygons", methodName : "mergeByCommonEdges"});
						polygons.splice(j1[0],1);
						if(i1 > j1[0]) {
							i1 -= 1;
						}
						j1[0] = -1;
						break;
					}
				}
			}
			j1[0]++;
		}
		i1 += 1;
	}
	nanofl_engine_geom_Polygons.assertCorrect(polygons,true);
};
nanofl_engine_geom_Polygons.removeDublicates = function(polygons) {
	var i = 0;
	while(i < polygons.length) {
		var j = i + 1;
		while(j < polygons.length) if(polygons[i].equ(polygons[j])) {
			polygons[i].fill = polygons[j].fill;
			polygons.splice(j,1);
		} else {
			++j;
		}
		++i;
	}
};
nanofl_engine_geom_Polygons.hasDublicates = function(polygons) {
	var _g = 0;
	var _g1 = polygons.length;
	while(_g < _g1) {
		var i = _g++;
		var _g2 = i + 1;
		var _g3 = polygons.length;
		while(_g2 < _g3) {
			var j = _g2++;
			if(polygons[i].equ(polygons[j])) {
				return true;
			}
		}
	}
	return false;
};
nanofl_engine_geom_Polygons.normalize = function(polygons) {
	var i = 0;
	while(i < polygons.length) {
		polygons[i].normalize();
		if(polygons[i].contours.length == 0) {
			polygons.splice(i,1);
		} else {
			++i;
		}
	}
	nanofl_engine_geom_Polygons.log("normalize > removeDublicates vvvvvvvvvvv",{ fileName : "engine/nanofl/engine/geom/Polygons.hx", lineNumber : 200, className : "nanofl.engine.geom.Polygons", methodName : "normalize"});
	nanofl_engine_geom_Polygons.removeDublicates(polygons);
	nanofl_engine_geom_Polygons.log("normalize > removeDublicates ^^^^^^^^^^^",{ fileName : "engine/nanofl/engine/geom/Polygons.hx", lineNumber : 202, className : "nanofl.engine.geom.Polygons", methodName : "normalize"});
	if(nanofl_engine_geom_Polygons.hasDublicates(polygons)) {
		haxe_Log.trace("normalize > DUPS DETECTED!!!!!!!",{ fileName : "engine/nanofl/engine/geom/Polygons.hx", lineNumber : 204, className : "nanofl.engine.geom.Polygons", methodName : "normalize"});
	}
};
nanofl_engine_geom_Polygons.getEdges = function(polygons) {
	var r = [];
	var _g = 0;
	while(_g < polygons.length) {
		var polygon = polygons[_g];
		++_g;
		var _g1 = 0;
		var _g2 = polygon.contours;
		while(_g1 < _g2.length) {
			var contour = _g2[_g1];
			++_g1;
			nanofl_engine_geom_Edges.appendUnique(r,contour.edges);
		}
	}
	return r;
};
nanofl_engine_geom_Polygons.getByPoint = function(polygons,pos) {
	var i = polygons.length - 1;
	while(i >= 0) {
		if(polygons[i].isPointInside(pos.x,pos.y)) {
			return polygons[i];
		}
		--i;
	}
	return null;
};
nanofl_engine_geom_Polygons.fromEdges = function(edges,strokeEdges,polygonsToDetectFill) {
	stdlib_Debug.assert(!nanofl_engine_geom_Edges.hasDegenerated(edges),"Degenerated edges detected.",{ fileName : "engine/nanofl/engine/geom/Polygons.hx", lineNumber : 234, className : "nanofl.engine.geom.Polygons", methodName : "fromEdges"});
	stdlib_Debug.assert(!nanofl_engine_geom_Edges.hasDuplicates(edges),"Duplicated edges detected.",{ fileName : "engine/nanofl/engine/geom/Polygons.hx", lineNumber : 235, className : "nanofl.engine.geom.Polygons", methodName : "fromEdges"});
	stdlib_Debug.assert(!nanofl_engine_geom_Edges.hasDuplicates(strokeEdges),"Duplicated strokeEdges detected.",{ fileName : "engine/nanofl/engine/geom/Polygons.hx", lineNumber : 236, className : "nanofl.engine.geom.Polygons", methodName : "fromEdges"});
	nanofl_engine_geom_Polygons.log(function() {
		return "Polygons.getReconstructed vvvvvvvvvvvvvvvvvvvvvvvv";
	},{ fileName : "engine/nanofl/engine/geom/Polygons.hx", lineNumber : 238, className : "nanofl.engine.geom.Polygons", methodName : "fromEdges"});
	var contours = nanofl_engine_geom_Contours.fromEdges(edges);
	var r = nanofl_engine_geom_Polygons.fromContours(contours,strokeEdges,function(polygon) {
		var pt = polygon.getPointInside();
		var original = nanofl_engine_geom_Polygons.getByPoint(polygonsToDetectFill,pt);
		if(original != null) {
			return original.fill;
		} else {
			return null;
		}
	});
	nanofl_engine_geom_Polygons.log(function() {
		return "Polygons.getReconstructed ^^^^^^^^^^^^^^^^^^^^^^^^ result =\n\t" + r.join(";\n\t");
	},{ fileName : "engine/nanofl/engine/geom/Polygons.hx", lineNumber : 249, className : "nanofl.engine.geom.Polygons", methodName : "fromEdges"});
	return r;
};
nanofl_engine_geom_Polygons.fromContours = function(contours,strokeEdges,getFill) {
	var r = [];
	var _g = 0;
	while(_g < contours.length) {
		var outer = contours[_g];
		++_g;
		var inners = [];
		var _g1 = 0;
		while(_g1 < contours.length) {
			var inner = contours[_g1];
			++_g1;
			if(inner != outer && inner.isNestedTo(outer)) {
				inners.push(inner.clone().reverse());
			}
		}
		nanofl_engine_geom_Contours.removeNested(inners);
		nanofl_engine_geom_Contours.mergeByCommonEdges(inners,true);
		var polygon = new nanofl_engine_geom_Polygon(null,[outer].concat(inners));
		polygon.assertCorrect();
		var fill = getFill(polygon);
		if(fill != null) {
			polygon.fill = fill;
			r.push(polygon);
		}
	}
	nanofl_engine_geom_Polygons.mergeByCommonEdges(r,strokeEdges);
	return r;
};
nanofl_engine_geom_Polygons.fromRawContours = function(originalContours,fill,fillEvenOdd) {
	return nanofl_engine_geom_Polygons.fromRawContoursInner(originalContours,fill,fillEvenOdd);
};
nanofl_engine_geom_Polygons.fromRawContoursInner = function(originalContours,fill,fillEvenOdd) {
	var edges = nanofl_engine_geom_Contours.getEdges(originalContours);
	nanofl_engine_geom_Polygons.log(function() {
		return "\n\nPolygons.fromContours vvvvvvvvvvvvvvvvvvvvvvvvv edges = " + edges.length;
	},{ fileName : "engine/nanofl/engine/geom/Polygons.hx", lineNumber : 312, className : "nanofl.engine.geom.Polygons", methodName : "fromRawContoursInner"});
	var originalContoursNormalized = new haxe_ds_ObjectMap();
	var _g = 0;
	while(_g < originalContours.length) {
		var c = originalContours[_g];
		++_g;
		var ee = c.edges.slice();
		nanofl_engine_geom_Edges.normalize(ee);
		nanofl_engine_geom_Edges.intersectSelf(ee);
		var value = nanofl_engine_geom_Contours.fromEdges(ee);
		originalContoursNormalized.set(c,value);
	}
	stdlib_Debug.assert(edges.indexOf(null) < 0,null,{ fileName : "engine/nanofl/engine/geom/Polygons.hx", lineNumber : 323, className : "nanofl.engine.geom.Polygons", methodName : "fromRawContoursInner"});
	nanofl_engine_geom_Edges.normalize(edges);
	nanofl_engine_geom_Edges.intersectSelf(edges);
	var contours = nanofl_engine_geom_Contours.fromEdges(edges);
	var r = nanofl_engine_geom_Polygons.fromContours(contours,[],function(polygon) {
		var pt = polygon.getPointInside();
		var edgesToTestFilling = [];
		var _g = 0;
		while(_g < originalContours.length) {
			var contour = originalContours[_g];
			++_g;
			if(Lambda.exists(originalContoursNormalized.h[contour.__id__],function(c) {
				return c.isPointInsideP(pt);
			})) {
				edgesToTestFilling = edgesToTestFilling.concat(contour.edges);
			}
		}
		if(nanofl_engine_geom_Edges.isPointInside(edgesToTestFilling,pt.x,pt.y,fillEvenOdd)) {
			return fill;
		} else {
			return null;
		}
	});
	nanofl_engine_geom_Polygons.log(function() {
		return "Polygons.fromContours ^^^^^^^^^^^^^^^^^^^^^^^^^";
	},{ fileName : "engine/nanofl/engine/geom/Polygons.hx", lineNumber : 348, className : "nanofl.engine.geom.Polygons", methodName : "fromRawContoursInner"});
	return r;
};
nanofl_engine_geom_Polygons.getEdgesToTestFilling = function(originals,edges) {
	var r = [];
	var _g = 0;
	while(_g < originals.length) {
		var edge = originals[_g];
		++_g;
		if(r.indexOf(edge) < 0 && edge.indexIn(edges) >= 0) {
			r.push(edge);
		}
	}
	return r;
};
nanofl_engine_geom_Polygons.assertCorrect = function(polygons,intergrityChecks,message) {
};
nanofl_engine_geom_Polygons.removeErased = function(polygons) {
	var i = 0;
	while(i < polygons.length) if(((polygons[i].fill) instanceof nanofl_engine_fills_EraseFill)) {
		polygons.splice(i,1);
	} else {
		++i;
	}
};
nanofl_engine_geom_Polygons.equ = function(a,b) {
	if(datatools_ArrayTools.equ(a,b)) {
		var result = new Array(a.length);
		var _g = 0;
		var _g1 = a.length;
		while(_g < _g1) {
			var i = _g++;
			result[i] = a[i].fill;
		}
		var tmp = result;
		var result = new Array(b.length);
		var _g = 0;
		var _g1 = b.length;
		while(_g < _g1) {
			var i = _g++;
			result[i] = b[i].fill;
		}
		return datatools_ArrayTools.equ(tmp,result);
	} else {
		return false;
	}
};
nanofl_engine_geom_Polygons.log = function(v,infos) {
};
var nanofl_engine_geom_StraightLine = function(x1,y1,x2,y2) {
	this.x1 = x1;
	this.y1 = y1;
	this.x2 = x2;
	this.y2 = y2;
};
nanofl_engine_geom_StraightLine.__name__ = "nanofl.engine.geom.StraightLine";
nanofl_engine_geom_StraightLine.prototype = {
	clone: function() {
		return new nanofl_engine_geom_StraightLine(this.x1,this.y1,this.x2,this.y2);
	}
	,getBounds: function() {
		return { minX : Math.min(this.x1,this.x2), maxX : Math.max(this.x1,this.x2), minY : Math.min(this.y1,this.y2), maxY : Math.max(this.y1,this.y2)};
	}
	,getNearestPoint: function(x,y) {
		var dx = this.x2 - this.x1;
		var dy = this.y2 - this.y1;
		if(dx == 0 && dy == 0) {
			return { t : 0, point : { x : this.x1, y : this.y1}};
		}
		var t = Math.min(1,Math.max(0,((x - this.x1) * dx + (y - this.y1) * dy) / (dx * dx + dy * dy)));
		if(t == 1) {
			return { t : 1, point : { x : this.x2, y : this.y2}};
		}
		return { t : t, point : { x : this.x1 + t * dx, y : this.y1 + t * dy}};
	}
	,getOrthogonalRayIntersection: function(x,y) {
		var dx = this.x2 - this.x1;
		var dy = this.y2 - this.y1;
		if(dx == 0 && dy == 0) {
			return { t : 0, point : { x : this.x1, y : this.y1}};
		}
		var t = ((x - this.x1) * dx + (y - this.y1) * dy) / (dx * dx + dy * dy);
		if(t == 1) {
			return { t : 1, point : { x : this.x2, y : this.y2}};
		}
		return { t : t, point : { x : this.x1 + t * dx, y : this.y1 + t * dy}};
	}
	,getOrthogonalVector: function() {
		return { x : this.y1 - this.y2, y : this.x2 - this.x1};
	}
	,getLength: function() {
		return nanofl_engine_geom_PointTools.getDist(this.x1,this.y1,this.x2,this.y2);
	}
	,getIntersectionPointX_rightRay: function(mx,my) {
		if(Math.max(this.y1,this.y2) >= my && Math.min(this.y1,this.y2) <= my) {
			var t = (my - this.y1) / (this.y2 - this.y1);
			if(this.y1 <= this.y2 && t >= 0 && t < 1 || this.y1 > this.y2 && t > 0 && t <= 1) {
				var x = this.x1 + (this.x2 - this.x1) * t;
				if(x > mx) {
					return x;
				}
			}
		}
		return null;
	}
	,isIntersect_rightRay: function(mx,my) {
		return this.getIntersectionPointX_rightRay(mx,my) != null;
	}
	,getIntersection_straightSection: function(line) {
		if(this.x1 == line.x1 && this.y1 == line.y1 || this.x1 == line.x2 && this.y1 == line.y2) {
			return null;
		}
		if(this.x2 == line.x1 && this.y2 == line.y1 || this.x2 == line.x2 && this.y2 == line.y2) {
			return null;
		}
		var dax = this.x1 - this.x2;
		var dbx = line.x1 - line.x2;
		var day = this.y1 - this.y2;
		var dby = line.y1 - line.y2;
		var den = dax * dby - day * dbx;
		if(Math.abs(den) < 1e-10) {
			return null;
		}
		var A = this.x1 * this.y2 - this.y1 * this.x2;
		var B = line.x1 * line.y2 - line.y1 * line.x2;
		var I = { x : (A * dbx - dax * B) / den, y : (A * dby - day * B) / den};
		if(this.inRect(I) && line.inRect(I)) {
			return I;
		}
		return null;
	}
	,getIntersection_infinityLine: function(line) {
		var dax = this.x1 - this.x2;
		var dbx = line.x1 - line.x2;
		var day = this.y1 - this.y2;
		var dby = line.y1 - line.y2;
		var den = dax * dby - day * dbx;
		if(Math.abs(den) < 1e-10) {
			return null;
		}
		var A = this.x1 * this.y2 - this.y1 * this.x2;
		var B = line.x1 * line.y2 - line.y1 * line.x2;
		return { x : (A * dbx - dax * B) / den, y : (A * dby - day * B) / den};
	}
	,inRect: function(p) {
		if(this.x1 == this.x2) {
			if(p.y >= Math.min(this.y1,this.y2)) {
				return p.y <= Math.max(this.y1,this.y2);
			} else {
				return false;
			}
		}
		if(this.y1 == this.y2) {
			if(p.x >= Math.min(this.x1,this.x2)) {
				return p.x <= Math.max(this.x1,this.x2);
			} else {
				return false;
			}
		}
		if(p.x >= Math.min(this.x1,this.x2) && p.x <= Math.max(this.x1,this.x2) && p.y >= Math.min(this.y1,this.y2)) {
			return p.y <= Math.max(this.y1,this.y2);
		} else {
			return false;
		}
	}
	,isDegenerated: function() {
		if(this.x1 == this.x2) {
			return this.y1 == this.y2;
		} else {
			return false;
		}
	}
	,getFirstPart: function(t) {
		return new nanofl_engine_geom_StraightLine(this.x1,this.y1,this.x1 + (this.x2 - this.x1) * t,this.y1 + (this.y2 - this.y1) * t);
	}
	,getSecondPart: function(t) {
		return new nanofl_engine_geom_StraightLine(this.x1 + (this.x2 - this.x1) * t,this.y1 + (this.y2 - this.y1) * t,this.x2,this.y2);
	}
	,split: function(tt) {
		var _g = 0;
		while(_g < tt.length) {
			var t = tt[_g];
			++_g;
			stdlib_Debug.assert(!isNaN(t),"t = " + t,{ fileName : "engine/nanofl/engine/geom/StraightLine.hx", lineNumber : 157, className : "nanofl.engine.geom.StraightLine", methodName : "split"});
		}
		if(tt.length == 0) {
			return [this.clone()];
		}
		if(tt.length == 1) {
			var m = this.getPoint(tt[0]);
			return [new nanofl_engine_geom_StraightLine(this.x1,this.y1,m.x,m.y),new nanofl_engine_geom_StraightLine(m.x,m.y,this.x2,this.y2)];
		}
		var r = [];
		var p = { x : this.x1, y : this.y1};
		var _g = 0;
		while(_g < tt.length) {
			var t = tt[_g];
			++_g;
			var m = this.getPoint(t);
			r.push(new nanofl_engine_geom_StraightLine(p.x,p.y,m.x,m.y));
			p = m;
		}
		r.push(new nanofl_engine_geom_StraightLine(p.x,p.y,this.x2,this.y2));
		return r;
	}
	,getPoint: function(t) {
		return { x : this.x1 + (this.x2 - this.x1) * t, y : this.y1 + (this.y2 - this.y1) * t};
	}
	,getTangent: function(t) {
		return Math.atan2(this.y2 - this.y1,this.x2 - this.x1);
	}
	,toString: function() {
		return "line(" + this.x1 + ", " + this.y1 + ", " + this.x2 + ", " + this.y2 + ")";
	}
	,__class__: nanofl_engine_geom_StraightLine
};
var nanofl_engine_geom_StrokeEdge = function(x1,y1,x2,y2,x3,y3,stroke,selected) {
	if(selected == null) {
		selected = false;
	}
	nanofl_engine_geom_Edge.call(this,x1,y1,x2,y2,x3,y3);
	this.stroke = stroke;
	this.set_selected(selected);
};
nanofl_engine_geom_StrokeEdge.__name__ = "nanofl.engine.geom.StrokeEdge";
nanofl_engine_geom_StrokeEdge.__interfaces__ = [nanofl_engine_ISelectable];
nanofl_engine_geom_StrokeEdge.fromEdge = function(edge,stroke,selected) {
	if(selected == null) {
		selected = false;
	}
	return new nanofl_engine_geom_StrokeEdge(edge.x1,edge.y1,edge.x2,edge.y2,edge.x3,edge.y3,stroke,selected);
};
nanofl_engine_geom_StrokeEdge.__super__ = nanofl_engine_geom_Edge;
nanofl_engine_geom_StrokeEdge.prototype = $extend(nanofl_engine_geom_Edge.prototype,{
	get_selected: function() {
		return this.selected;
	}
	,set_selected: function(v) {
		return this.selected = v;
	}
	,getNearestPointUseStrokeSize: function(x,y) {
		var pointAndT = this.getNearestPoint(x,y);
		nanofl_engine_geom_PointTools.moveInDirection(pointAndT.point,x,y,this.stroke != null ? this.stroke.thickness / 2 : 0);
		return pointAndT;
	}
	,addTo: function(edges) {
		var n = this.indexIn(edges);
		if(n >= 0) {
			edges[n].stroke = this.stroke;
		} else {
			edges.push(this);
		}
	}
	,transform: function(m,applyToStrokeThickness) {
		if(applyToStrokeThickness == null) {
			applyToStrokeThickness = true;
		}
		nanofl_engine_geom_Edge.prototype.transform.call(this,m);
		if(this.stroke != null) {
			this.stroke = this.stroke.getTransformed(m,applyToStrokeThickness);
		}
	}
	,translate: function(dx,dy) {
		nanofl_engine_geom_Edge.prototype.translate.call(this,dx,dy);
		if(this.stroke != null) {
			this.stroke = this.stroke.getTransformed(new nanofl_engine_geom_Matrix(1,0,0,1,dx,dy),false);
		}
	}
	,clone: function() {
		return new nanofl_engine_geom_StrokeEdge(this.x1,this.y1,this.x2,this.y2,this.x3,this.y3,this.stroke.clone(),this.get_selected());
	}
	,duplicate: function(e) {
		return new nanofl_engine_geom_StrokeEdge(e.x1,e.y1,e.x2,e.y2,e.x3,e.y3,this.stroke,this.get_selected());
	}
	,split: function(tt) {
		var _this = nanofl_engine_geom_Edge.prototype.split.call(this,tt);
		var stroke = this.stroke;
		var selected = this.get_selected();
		var f = function(edge) {
			return nanofl_engine_geom_StrokeEdge.fromEdge(edge,stroke,selected);
		};
		var result = new Array(_this.length);
		var _g = 0;
		var _g1 = _this.length;
		while(_g < _g1) {
			var i = _g++;
			result[i] = f(_this[i]);
		}
		return result;
	}
	,toString: function() {
		if(this.isStraight()) {
			return "new StrokeEdge(" + this.x1 + "," + this.y1 + ", " + this.x3 + "," + this.y3 + ", " + Std.string(this.stroke) + ", " + Std.string(this.get_selected()) + ")";
		} else {
			return "new StrokeEdge(" + this.x1 + "," + this.y1 + ", " + this.x2 + "," + this.y2 + ", " + this.x3 + "," + this.y3 + ", " + Std.string(this.stroke) + ", " + Std.string(this.get_selected()) + ")";
		}
	}
	,__class__: nanofl_engine_geom_StrokeEdge
});
var nanofl_engine_geom_StrokeEdges = function() { };
nanofl_engine_geom_StrokeEdges.__name__ = "nanofl.engine.geom.StrokeEdges";
nanofl_engine_geom_StrokeEdges.load = function(nodes,strokes,version) {
	var r = [];
	var _g = 0;
	while(_g < nodes.length) {
		var node = nodes[_g];
		++_g;
		stdlib_Debug.assert(node.name == "edge",null,{ fileName : "engine/nanofl/engine/geom/StrokeEdges.hx", lineNumber : 20, className : "nanofl.engine.geom.StrokeEdges", methodName : "load"});
		var strokeIndex = htmlparser_HtmlParserTools.getAttr(node,"strokeIndex",-1) | 0;
		stdlib_Debug.assert(strokeIndex >= 0,null,{ fileName : "engine/nanofl/engine/geom/StrokeEdges.hx", lineNumber : 22, className : "nanofl.engine.geom.StrokeEdges", methodName : "load"});
		stdlib_Debug.assert(strokeIndex < strokes.length,null,{ fileName : "engine/nanofl/engine/geom/StrokeEdges.hx", lineNumber : 23, className : "nanofl.engine.geom.StrokeEdges", methodName : "load"});
		var edges = nanofl_engine_geom_Edges.load(node.getAttribute("edges"));
		var result = new Array(edges.length);
		var _g1 = 0;
		var _g2 = edges.length;
		while(_g1 < _g2) {
			var i = _g1++;
			result[i] = nanofl_engine_geom_StrokeEdge.fromEdge(edges[i],strokes[strokeIndex]);
		}
		stdlib_LambdaArray.addRange(r,result);
	}
	return r;
};
nanofl_engine_geom_StrokeEdges.loadJson = function(objs,strokes,version) {
	var r = [];
	var _g = 0;
	while(_g < objs.length) {
		var obj = objs[_g];
		++_g;
		var tmp = obj.strokeIndex;
		var strokeIndex = tmp != null ? tmp : -1;
		stdlib_Debug.assert(strokeIndex >= 0,null,{ fileName : "engine/nanofl/engine/geom/StrokeEdges.hx", lineNumber : 40, className : "nanofl.engine.geom.StrokeEdges", methodName : "loadJson"});
		stdlib_Debug.assert(strokeIndex < strokes.length,null,{ fileName : "engine/nanofl/engine/geom/StrokeEdges.hx", lineNumber : 41, className : "nanofl.engine.geom.StrokeEdges", methodName : "loadJson"});
		var edges = nanofl_engine_geom_Edges.load(obj.edges);
		var result = new Array(edges.length);
		var _g1 = 0;
		var _g2 = edges.length;
		while(_g1 < _g2) {
			var i = _g1++;
			result[i] = nanofl_engine_geom_StrokeEdge.fromEdge(edges[i],strokes[strokeIndex]);
		}
		stdlib_LambdaArray.addRange(r,result);
	}
	return r;
};
nanofl_engine_geom_StrokeEdges.save = function(edges,strokes,out) {
	var groups = nanofl_engine_geom_StrokeEdges.getStrokeGroups(edges,strokes);
	var _g = 0;
	var _g1 = groups.length;
	while(_g < _g1) {
		var i = _g++;
		out.begin("edge").attr("strokeIndex",i);
		out.attr("edges",nanofl_engine_geom_Edges.save(groups[i]));
		out.end();
	}
};
nanofl_engine_geom_StrokeEdges.saveJson = function(edges,strokes) {
	var arr = [];
	var groups = nanofl_engine_geom_StrokeEdges.getStrokeGroups(edges,strokes);
	var _g = 0;
	var _g1 = groups.length;
	while(_g < _g1) {
		var i = _g++;
		arr.push({ strokeIndex : i, edges : nanofl_engine_geom_Edges.save(groups[i])});
	}
	return arr;
};
nanofl_engine_geom_StrokeEdges.getStrokeGroups = function(edges,strokes) {
	var groups = [];
	var _g = 0;
	var _g1 = strokes.length;
	while(_g < _g1) {
		var i = _g++;
		groups.push([]);
	}
	var _g = 0;
	while(_g < edges.length) {
		var e = [edges[_g]];
		++_g;
		var index = stdlib_LambdaIterable.findIndex(strokes,(function(e) {
			return function(stroke) {
				return stroke.equ(e[0].stroke);
			};
		})(e));
		groups[index].push(e[0]);
	}
	return groups;
};
nanofl_engine_geom_StrokeEdges.getBounds = function(edges,bounds) {
	if(edges.length > 0) {
		if(bounds == null) {
			bounds = { minX : 1e100, minY : 1e100, maxX : -1e100, maxY : -1e100};
		}
		var _g = 0;
		while(_g < edges.length) {
			var e = edges[_g];
			++_g;
			var b = e.getBounds();
			var r = e.stroke.thickness / 2;
			bounds.minX = Math.min(bounds.minX,b.minX - r);
			bounds.minY = Math.min(bounds.minY,b.minY - r);
			bounds.maxX = Math.max(bounds.maxX,b.maxX + r);
			bounds.maxY = Math.max(bounds.maxY,b.maxY + r);
		}
	}
	return bounds;
};
nanofl_engine_geom_StrokeEdges.duplicateStrokes = function(edges) {
	var processed = new haxe_ds_ObjectMap();
	var _g = 0;
	while(_g < edges.length) {
		var e = edges[_g];
		++_g;
		var stroke = processed.h[e.stroke.__id__];
		if(stroke == null) {
			stroke = e.stroke.clone();
			processed.set(e.stroke,stroke);
		}
		e.stroke = stroke;
	}
	return Lambda.array(processed);
};
nanofl_engine_geom_StrokeEdges.drawSorted = function(edges,g,scaleSelection) {
	nanofl_engine_geom_StrokeEdges.sort(edges);
	var i = 0;
	while(i < edges.length) {
		var j = i + 1;
		while(j < edges.length && edges[i].stroke.equ(edges[j].stroke)) ++j;
		edges[i].stroke.begin(g);
		nanofl_engine_geom_Edges.draw(edges.slice(i,j),g,true);
		g.endStroke();
		i = j;
	}
	if(nanofl_engine_geom_Edges.showSelection) {
		var _g = [];
		var _g1 = 0;
		var _g2 = edges;
		while(_g1 < _g2.length) {
			var v = _g2[_g1];
			++_g1;
			if(v.get_selected()) {
				_g.push(v);
			}
		}
		edges = _g;
		if(edges.length > 0) {
			var i = 0;
			while(i < edges.length) {
				var j = i + 1;
				while(j < edges.length && edges[i].stroke.equ(edges[j].stroke)) ++j;
				new nanofl_engine_strokes_SelectionStroke(edges[i].stroke,scaleSelection).begin(g);
				nanofl_engine_geom_Edges.draw(edges.slice(i,j),g,true);
				g.endStroke();
				i = j;
			}
		}
	}
};
nanofl_engine_geom_StrokeEdges.sort = function(edges) {
	var i = 1;
	while(i < edges.length) {
		while(i < edges.length && edges[i - 1].stroke.equ(edges[i].stroke)) ++i;
		var _g = i;
		var _g1 = edges.length;
		while(_g < _g1) {
			var j = _g++;
			if(edges[i].stroke.equ(edges[j].stroke)) {
				var z = edges[i];
				edges[i] = edges[j];
				edges[j] = z;
				++i;
			}
		}
		++i;
	}
	var i = 0;
	while(i < edges.length) {
		var j = i + 1;
		while(j < edges.length && edges[i].stroke.equ(edges[j].stroke)) ++j;
		nanofl_engine_geom_StrokeEdges.sortToProduceSequences(edges,i,j);
		i = j;
	}
};
nanofl_engine_geom_StrokeEdges.sortToProduceSequences = function(edges,from,to) {
	var lastSorted = from;
	var i = lastSorted + 1;
	while(i < to) if(lastSorted + 1 < to && edges[lastSorted].x3 == edges[i].x1 && edges[lastSorted].y3 == edges[i].y1) {
		datatools_ArrayTools.swap(edges,lastSorted + 1,i);
		++lastSorted;
		i = lastSorted + 1;
	} else if(lastSorted + 1 < to && edges[lastSorted].x3 == edges[i].x3 && edges[lastSorted].y3 == edges[i].y3) {
		edges[i].reverse();
		datatools_ArrayTools.swap(edges,lastSorted + 1,i);
		++lastSorted;
		i = lastSorted + 1;
	} else if(edges[from].x1 == edges[i].x3 && edges[from].y1 == edges[i].y3) {
		var z = edges[i];
		var k = i;
		while(k > from) {
			edges[k] = edges[k - 1];
			--k;
		}
		edges[from] = z;
		++lastSorted;
		i = lastSorted + 1;
	} else if(edges[i].x1 == edges[from].x1 && edges[i].y1 == edges[from].y1) {
		edges[i].reverse();
		var z1 = edges[i];
		var k1 = i;
		while(k1 > from) {
			edges[k1] = edges[k1 - 1];
			--k1;
		}
		edges[from] = z1;
		++lastSorted;
		i = lastSorted + 1;
	} else {
		++i;
	}
	if(lastSorted + 2 < to) {
		nanofl_engine_geom_StrokeEdges.sortToProduceSequences(edges,lastSorted + 1,to);
	}
};
nanofl_engine_geom_StrokeEdges.fromEdges = function(edges,stroke,selected) {
	if(selected == null) {
		selected = false;
	}
	var result = new Array(edges.length);
	var _g = 0;
	var _g1 = edges.length;
	while(_g < _g1) {
		var i = _g++;
		result[i] = nanofl_engine_geom_StrokeEdge.fromEdge(edges[i],stroke,selected);
	}
	return result;
};
nanofl_engine_geom_StrokeEdges.replace = function(edges,search,replacement) {
	var _g = [];
	var _g1 = 0;
	var _g2 = replacement;
	while(_g1 < _g2.length) {
		var v = _g2[_g1];
		++_g1;
		if(v.indexIn(edges) < 0) {
			_g.push(v);
		}
	}
	nanofl_engine_geom_Edges.replace(edges,search,_g);
};
nanofl_engine_geom_StrokeEdges.equ = function(a,b) {
	if(datatools_ArrayTools.equ(a,b)) {
		var result = new Array(a.length);
		var _g = 0;
		var _g1 = a.length;
		while(_g < _g1) {
			var i = _g++;
			result[i] = a[i].stroke;
		}
		var tmp = result;
		var result = new Array(b.length);
		var _g = 0;
		var _g1 = b.length;
		while(_g < _g1) {
			var i = _g++;
			result[i] = b[i].stroke;
		}
		return datatools_ArrayTools.equ(tmp,result);
	} else {
		return false;
	}
};
var nanofl_engine_libraryitems_LibraryItem = function(namePath) {
	this.namePath = namePath;
};
nanofl_engine_libraryitems_LibraryItem.__name__ = "nanofl.engine.libraryitems.LibraryItem";
nanofl_engine_libraryitems_LibraryItem.__interfaces__ = [nanofl_engine_ILibraryItem];
nanofl_engine_libraryitems_LibraryItem.loadFromJson = function(namePath,obj) {
	var item;
	switch(Type.createEnum(nanofl_engine_LibraryItemType,obj.type,null)._hx_index) {
	case 0:
		item = new nanofl_engine_libraryitems_BitmapItem(namePath,null);
		break;
	case 1:
		item = null;
		break;
	case 2:
		item = new nanofl_engine_libraryitems_FontItem(namePath);
		break;
	case 3:
		item = new nanofl_engine_libraryitems_MeshItem(namePath,null,null);
		break;
	case 4:
		item = new nanofl_engine_libraryitems_MovieClipItem(namePath);
		break;
	case 5:
		item = new nanofl_engine_libraryitems_SoundItem(namePath,null);
		break;
	case 6:
		item = new nanofl_engine_libraryitems_SpriteItem(namePath,null);
		break;
	}
	if(item == null) {
		return null;
	}
	item.loadPropertiesJson(obj);
	return item;
};
nanofl_engine_libraryitems_LibraryItem.prototype = {
	copyBaseProperties: function(obj) {
		obj.library = this.library;
		obj.namePath = this.namePath;
	}
	,setLibrary: function(library) {
		this.library = library;
	}
	,duplicate: function(newNamePath) {
		var item = this.clone();
		item.namePath = newNamePath;
		if(this.library != null) {
			this.library.addItem(item);
		}
		return item;
	}
	,remove: function() {
		if(this.library != null) {
			this.library.removeItem(this.namePath);
		}
	}
	,equ: function(item) {
		return this.namePath == item.namePath;
	}
	,getLibraryFileContent: function(path) {
		if(!window.nanofl) {
			throw new Error("Global `nanofl` is not found.");
		}
		if(!window.nanofl.libraryFiles) {
			throw new Error("Global `nanofl.libraryFiles` is not found.");
		}
		var libraryFiles = window.nanofl.libraryFiles;
		var r = libraryFiles[path];
		if(typeof(r) == "undefined") {
			throw new Error("Global `nanofl.libraryFiles[\"" + path + "\"]` is not found.");
		}
		return r;
	}
	,__class__: nanofl_engine_libraryitems_LibraryItem
};
var nanofl_engine_libraryitems_InstancableItem = function(namePath) {
	this.linkedClass = "";
	nanofl_engine_libraryitems_LibraryItem.call(this,namePath);
};
nanofl_engine_libraryitems_InstancableItem.__name__ = "nanofl.engine.libraryitems.InstancableItem";
nanofl_engine_libraryitems_InstancableItem.__super__ = nanofl_engine_libraryitems_LibraryItem;
nanofl_engine_libraryitems_InstancableItem.prototype = $extend(nanofl_engine_libraryitems_LibraryItem.prototype,{
	copyBaseProperties: function(obj) {
		nanofl_engine_libraryitems_LibraryItem.prototype.copyBaseProperties.call(this,obj);
		obj.linkedClass = this.linkedClass;
	}
	,newInstance: function() {
		stdlib_Debug.assert(this.library != null,"You must add symbol '" + this.namePath + "' to library before newInstance() call.",{ fileName : "engine/nanofl/engine/libraryitems/InstancableItem.hx", lineNumber : 27, className : "nanofl.engine.libraryitems.InstancableItem", methodName : "newInstance"});
		var r = new nanofl_engine_elements_Instance(this.namePath);
		r.setLibrary(this.library);
		return r;
	}
	,createDisplayObject: function(initFrameIndex,childFrameIndexes) {
		if(this.linkedClass != "") {
			var klass = window[this.linkedClass];
			if(klass != null) {
				return new klass(this);
			}
			haxe_Log.trace("Linkage class '" + this.linkedClass + "' is not found.",{ fileName : "engine/nanofl/engine/libraryitems/InstancableItem.hx", lineNumber : 43, className : "nanofl.engine.libraryitems.InstancableItem", methodName : "createDisplayObject"});
		}
		return null;
	}
	,getNearestPoint: function(pos) {
		return { x : 1e100, y : 1e100};
	}
	,equ: function(item) {
		if(((item) instanceof nanofl_engine_libraryitems_InstancableItem)) {
			return false;
		}
		if(!nanofl_engine_libraryitems_LibraryItem.prototype.equ.call(this,item)) {
			return false;
		}
		return this.linkedClass == item.linkedClass;
	}
	,loadPropertiesJson: function(obj) {
		var tmp = obj.linkedClass;
		this.linkedClass = tmp != null ? tmp : "";
	}
	,__class__: nanofl_engine_libraryitems_InstancableItem
});
var nanofl_engine_libraryitems_BitmapItem = function(namePath,ext) {
	nanofl_engine_libraryitems_InstancableItem.call(this,namePath);
	this.ext = ext;
};
nanofl_engine_libraryitems_BitmapItem.__name__ = "nanofl.engine.libraryitems.BitmapItem";
nanofl_engine_libraryitems_BitmapItem.__interfaces__ = [nanofl_engine_ITextureItem];
nanofl_engine_libraryitems_BitmapItem.log = function(v,infos) {
};
nanofl_engine_libraryitems_BitmapItem.__super__ = nanofl_engine_libraryitems_InstancableItem;
nanofl_engine_libraryitems_BitmapItem.prototype = $extend(nanofl_engine_libraryitems_InstancableItem.prototype,{
	get_type: function() {
		return nanofl_engine_LibraryItemType.bitmap;
	}
	,clone: function() {
		var obj = new nanofl_engine_libraryitems_BitmapItem(this.namePath,this.ext);
		obj.ext = this.ext;
		obj.textureAtlas = this.textureAtlas;
		obj.image = this.image;
		this.copyBaseProperties(obj);
		return obj;
	}
	,getIcon: function() {
		return "custom-icon-picture";
	}
	,getUrl: function() {
		return this.library.realUrl(this.namePath + "." + this.ext);
	}
	,preload: function() {
		stdlib_Debug.assert(this.library != null,"You need to add item '" + this.namePath + "' to the library before preload call.",{ fileName : "engine/nanofl/engine/libraryitems/BitmapItem.hx", lineNumber : 49, className : "nanofl.engine.libraryitems.BitmapItem", methodName : "preload"});
		if(nanofl_engine_TextureItemTools.getSpriteSheet(this) == null) {
			return this.preloadInner();
		} else {
			return nanofl_engine_TextureItemTools.preload(this);
		}
	}
	,preloadInner: function() {
		var _gthis = this;
		return nanofl_engine_Loader.loadJsScript(this.library.realUrl(this.namePath + ".js")).then(function(_) {
			return _gthis.loadImageFromBase64(_gthis.getLibraryFileContent(_gthis.namePath + "." + _gthis.ext));
		});
	}
	,loadImageFromBase64: function(imageDataBase64) {
		var _gthis = this;
		return new Promise(function(resolve,reject) {
			var tmp = window.document.createElement("img");
			_gthis.image = tmp;
			_gthis.image.onload = function() {
				resolve(null);
			};
			_gthis.image.onerror = function(e) {
				reject(e);
			};
			_gthis.image.src = "data:image/png;base64," + imageDataBase64;
		});
	}
	,createDisplayObject: function(initFrameIndex,childFrameIndexes) {
		var r = nanofl_engine_libraryitems_InstancableItem.prototype.createDisplayObject.call(this,initFrameIndex,childFrameIndexes);
		if(r == null) {
			var spriteSheet = nanofl_engine_TextureItemTools.getSpriteSheet(this);
			r = spriteSheet == null ? new nanofl_Bitmap(this) : new createjs.Sprite(spriteSheet);
		}
		r.setBounds(0,0,this.image.width,this.image.height);
		return r;
	}
	,updateDisplayObject: function(dispObj,childFrameIndexes) {
		stdlib_Debug.assert(((dispObj) instanceof createjs.Bitmap),null,{ fileName : "engine/nanofl/engine/libraryitems/BitmapItem.hx", lineNumber : 99, className : "nanofl.engine.libraryitems.BitmapItem", methodName : "updateDisplayObject"});
		dispObj.image = this.image;
		dispObj.setBounds(0,0,this.image.width,this.image.height);
	}
	,getDisplayObjectClassName: function() {
		return "nanofl.Bitmap";
	}
	,equ: function(item) {
		if(!((item) instanceof nanofl_engine_libraryitems_BitmapItem)) {
			return false;
		}
		if(!nanofl_engine_libraryitems_InstancableItem.prototype.equ.call(this,item)) {
			return false;
		}
		if(item.ext != this.ext) {
			return false;
		}
		if(item.textureAtlas != this.textureAtlas) {
			return false;
		}
		return true;
	}
	,getNearestPoint: function(pos) {
		var bounds = { minX : 0.0, minY : 0.0, maxX : this.image.width + 0.0, maxY : this.image.height + 0.0};
		return nanofl_engine_geom_BoundsTools.getNearestPoint(bounds,pos);
	}
	,loadPropertiesJson: function(obj) {
		if(obj.type != this.get_type()) {
			throw new Error("Type of item must be '" + Std.string(this.get_type()) + "', but '" + Std.string(obj.type) + "' found.");
		}
		nanofl_engine_libraryitems_InstancableItem.prototype.loadPropertiesJson.call(this,obj);
		var tmp = obj.ext;
		this.ext = tmp != null ? tmp : null;
		var tmp = obj.textureAtlas;
		this.textureAtlas = tmp != null ? tmp : null;
	}
	,toString: function() {
		return "BitmapItem(" + this.namePath + ")";
	}
	,__class__: nanofl_engine_libraryitems_BitmapItem
});
var nanofl_engine_libraryitems_FolderItem = function(namePath) {
	this.opened = false;
	nanofl_engine_libraryitems_LibraryItem.call(this,namePath);
};
nanofl_engine_libraryitems_FolderItem.__name__ = "nanofl.engine.libraryitems.FolderItem";
nanofl_engine_libraryitems_FolderItem.__super__ = nanofl_engine_libraryitems_LibraryItem;
nanofl_engine_libraryitems_FolderItem.prototype = $extend(nanofl_engine_libraryitems_LibraryItem.prototype,{
	get_type: function() {
		return nanofl_engine_LibraryItemType.folder;
	}
	,clone: function() {
		var obj = new nanofl_engine_libraryitems_FolderItem(this.namePath);
		obj.opened = this.opened;
		this.copyBaseProperties(obj);
		return obj;
	}
	,getIcon: function() {
		if(this.opened) {
			return "custom-icon-folder-open";
		} else {
			return "custom-icon-folder-close";
		}
	}
	,equ: function(item) {
		if(!((item) instanceof nanofl_engine_libraryitems_FolderItem)) {
			return false;
		}
		if(!nanofl_engine_libraryitems_LibraryItem.prototype.equ.call(this,item)) {
			return false;
		}
		return true;
	}
	,preload: function() {
		return Promise.resolve();
	}
	,loadPropertiesJson: function(obj) {
	}
	,toString: function() {
		return "FolderItem(" + this.namePath + ")";
	}
	,__class__: nanofl_engine_libraryitems_FolderItem
});
var nanofl_engine_libraryitems_FontItem = function(namePath,variants) {
	nanofl_engine_libraryitems_LibraryItem.call(this,namePath);
	var tmp = variants;
	this.variants = tmp != null ? tmp : [];
};
nanofl_engine_libraryitems_FontItem.__name__ = "nanofl.engine.libraryitems.FontItem";
nanofl_engine_libraryitems_FontItem.__super__ = nanofl_engine_libraryitems_LibraryItem;
nanofl_engine_libraryitems_FontItem.prototype = $extend(nanofl_engine_libraryitems_LibraryItem.prototype,{
	get_type: function() {
		return nanofl_engine_LibraryItemType.font;
	}
	,clone: function() {
		var obj = new nanofl_engine_libraryitems_FontItem(this.namePath,this.variants.slice());
		this.copyBaseProperties(obj);
		return obj;
	}
	,getIcon: function() {
		return "icon-font";
	}
	,toFont: function() {
		return { family : haxe_io_Path.withoutDirectory(this.namePath), fallbacks : [], variants : this.variants};
	}
	,preload: function() {
		var _gthis = this;
		stdlib_Debug.assert(this.library != null,"You need to add item '" + this.namePath + "' to the library before preload call.",{ fileName : "engine/nanofl/engine/libraryitems/FontItem.hx", lineNumber : 46, className : "nanofl.engine.libraryitems.FontItem", methodName : "preload"});
		var family = haxe_io_Path.withoutDirectory(this.namePath);
		var r = Promise.resolve();
		var _g = 0;
		var _g1 = this.variants;
		while(_g < _g1.length) {
			var variant = [_g1[_g]];
			++_g;
			r = r.then((function(variant) {
				return function(_) {
					return _gthis.getExistsSupportedFormat(variant[0]).then((function(variant) {
						return function(format) {
							if(format != null) {
								var font = new FontFace(family,"url(" + variant[0].urls.h[format] + ") format(\"" + format + "\")",{ style : variant[0].style, weight : Std.string(variant[0].weight)});
								return new Promise((function(variant) {
									return function(resolve,reject) {
										font.load().then((function() {
											return function(font) {
												window.document.fonts.add(font);
												resolve(null);
											};
										})(),(function(variant) {
											return function(e) {
												haxe_Log.trace("Font '" + family + "' loading error ('" + variant[0].urls.h[format] + "'):",{ fileName : "engine/nanofl/engine/libraryitems/FontItem.hx", lineNumber : 74, className : "nanofl.engine.libraryitems.FontItem", methodName : "preload"});
												haxe_Log.trace(e,{ fileName : "engine/nanofl/engine/libraryitems/FontItem.hx", lineNumber : 75, className : "nanofl.engine.libraryitems.FontItem", methodName : "preload"});
												resolve(null);
											};
										})(variant));
									};
								})(variant));
							} else {
								haxe_Log.trace("Can't found suitable font file format ('" + family + " " + variant[0].style + " " + variant[0].weight + "').",{ fileName : "engine/nanofl/engine/libraryitems/FontItem.hx", lineNumber : 83, className : "nanofl.engine.libraryitems.FontItem", methodName : "preload"});
								return null;
							}
						};
					})(variant));
				};
			})(variant));
		}
		return r;
	}
	,getExistsSupportedFormat: function(variant) {
		return new Promise(function(resolve,reject) {
			if(Object.prototype.hasOwnProperty.call(variant.urls.h,"woff2")) {
				resolve("woff2");
			} else if(Object.prototype.hasOwnProperty.call(variant.urls.h,"woff")) {
				resolve("woff");
			} else if(Object.prototype.hasOwnProperty.call(variant.urls.h,"truetype")) {
				resolve("truetype");
			} else if(Object.prototype.hasOwnProperty.call(variant.urls.h,"svg")) {
				resolve("svg");
			} else if(Object.prototype.hasOwnProperty.call(variant.urls.h,"eot")) {
				resolve("eot");
			} else {
				resolve(null);
			}
		});
	}
	,addVariant: function(v) {
		var origV = Lambda.find(this.variants,function(x) {
			if(v.style == x.style) {
				return v.weight == x.weight;
			} else {
				return false;
			}
		});
		if(origV != null) {
			var h = v.urls.h;
			var format_h = h;
			var format_keys = Object.keys(h);
			var format_length = format_keys.length;
			var format_current = 0;
			while(format_current < format_length) {
				var format = format_keys[format_current++];
				origV.urls.h[format] = v.urls.h[format];
			}
		} else {
			this.variants.push(v);
		}
	}
	,equ: function(item) {
		if(!((item) instanceof nanofl_engine_libraryitems_FontItem)) {
			return false;
		}
		if(!nanofl_engine_libraryitems_LibraryItem.prototype.equ.call(this,item)) {
			return false;
		}
		if(!datatools_ArrayTools.equ(item.variants,this.variants)) {
			return false;
		}
		return true;
	}
	,loadPropertiesJson: function(obj) {
		if(obj.type != this.get_type()) {
			throw new Error("Type of item must be '" + Std.string(this.get_type()) + "', but '" + Std.string(obj.type) + "' found.");
		}
		var _this = obj.variants;
		var result = new Array(_this.length);
		var _g = 0;
		var _g1 = _this.length;
		while(_g < _g1) {
			var i = _g++;
			var x = _this[i];
			result[i] = new nanofl_engine_FontVariant(x.style,x.weight,x.locals,datatools_MapTools.fromObject(x.files));
		}
		this.variants = result;
	}
	,toString: function() {
		return "FontItem(" + this.namePath + ")";
	}
	,__class__: nanofl_engine_libraryitems_FontItem
});
var nanofl_engine_libraryitems_MeshItem = function(namePath,ext,originalExt) {
	this.textureFiles = [];
	this.loadLights = false;
	this.renderAreaSize = 256;
	nanofl_engine_libraryitems_InstancableItem.call(this,namePath);
	this.ext = ext;
	this.originalExt = originalExt;
};
nanofl_engine_libraryitems_MeshItem.__name__ = "nanofl.engine.libraryitems.MeshItem";
nanofl_engine_libraryitems_MeshItem.__interfaces__ = [nanofl_engine_ITextureItem];
nanofl_engine_libraryitems_MeshItem.log = function(v,infos) {
};
nanofl_engine_libraryitems_MeshItem.__super__ = nanofl_engine_libraryitems_InstancableItem;
nanofl_engine_libraryitems_MeshItem.prototype = $extend(nanofl_engine_libraryitems_InstancableItem.prototype,{
	get_type: function() {
		return nanofl_engine_LibraryItemType.mesh;
	}
	,clone: function() {
		var obj = new nanofl_engine_libraryitems_MeshItem(this.namePath,this.ext,this.originalExt);
		obj.textureAtlas = this.textureAtlas;
		obj.renderAreaSize = this.renderAreaSize;
		obj.loadLights = this.loadLights;
		obj.scene = this.scene != null ? this.scene.clone(true) : null;
		obj.boundingRadius = this.boundingRadius;
		obj.textureFiles = this.textureFiles;
		this.copyBaseProperties(obj);
		return obj;
	}
	,getIcon: function() {
		return "custom-icon-cube";
	}
	,preload: function() {
		stdlib_Debug.assert(this.library != null,"You need to add item '" + this.namePath + "' to the library before preload call.",{ fileName : "engine/nanofl/engine/libraryitems/MeshItem.hx", lineNumber : 70, className : "nanofl.engine.libraryitems.MeshItem", methodName : "preload"});
		var spriteSheet = nanofl_engine_TextureItemTools.getSpriteSheet(this);
		if(spriteSheet == null) {
			return this.preloadInner();
		} else {
			return nanofl_engine_TextureItemTools.preload(this);
		}
	}
	,preloadInner: function() {
		var _gthis = this;
		return nanofl_engine_Loader.loadJsScript(this.library.realUrl(this.namePath + ".js")).then(function(_) {
			return _gthis.processPreloadedJson(_gthis.getLibraryFileContent(_gthis.namePath + ".gltf"));
		});
	}
	,processPreloadedJson: function(json) {
		var _gthis = this;
		nanofl_engine_libraryitems_MeshItem.log("processPreloadedJson",{ fileName : "engine/nanofl/engine/libraryitems/MeshItem.hx", lineNumber : 94, className : "nanofl.engine.libraryitems.MeshItem", methodName : "processPreloadedJson"});
		nanofl_engine_libraryitems_MeshItem.log(json,{ fileName : "engine/nanofl/engine/libraryitems/MeshItem.hx", lineNumber : 95, className : "nanofl.engine.libraryitems.MeshItem", methodName : "processPreloadedJson"});
		var loader = new GLTFLoader();
		return loader.parseAsync(json,this.library.realUrl("")).then(function(gltf) {
			if(gltf.scene.type == "Scene") {
				_gthis.scene = gltf.scene;
			} else {
				_gthis.scene = new THREE_Scene();
				_gthis.scene.add(gltf.scene);
			}
			_gthis.updateBoundingRadius();
			return null;
		});
	}
	,updateBoundingRadius: function() {
		var _gthis = this;
		this.boundingRadius = 0.0;
		this.scene.traverse(function(object) {
			nanofl_engine_libraryitems_MeshItem.log("MeshItem.updateBoundingRadius object " + object.type + " / " + object.name,{ fileName : "engine/nanofl/engine/libraryitems/MeshItem.hx", lineNumber : 131, className : "nanofl.engine.libraryitems.MeshItem", methodName : "updateBoundingRadius"});
			if(object.type == "Mesh") {
				var mesh = object;
				mesh.updateMatrixWorld(true);
				mesh.geometry.computeBoundingSphere();
				_gthis.boundingRadius = Math.max(_gthis.boundingRadius,mesh.geometry.boundingSphere.radius);
			}
		});
		this.boundingRadius = Math.sqrt(this.boundingRadius);
		nanofl_engine_libraryitems_MeshItem.log("MeshItem.updateBoundingRadius boundingRadius = " + this.boundingRadius,{ fileName : "engine/nanofl/engine/libraryitems/MeshItem.hx", lineNumber : 145, className : "nanofl.engine.libraryitems.MeshItem", methodName : "updateBoundingRadius"});
	}
	,createDisplayObject: function(initFrameIndex,childFrameIndexes) {
		var r = nanofl_engine_libraryitems_InstancableItem.prototype.createDisplayObject.call(this,initFrameIndex,childFrameIndexes);
		if(r == null) {
			var spriteSheet = nanofl_engine_TextureItemTools.getSpriteSheet(this);
			r = spriteSheet == null ? new nanofl_Mesh(this) : new createjs.Sprite(spriteSheet);
		}
		return r;
	}
	,updateDisplayObject: function(dispObj,childFrameIndexes) {
		stdlib_Debug.assert(((dispObj) instanceof nanofl_Mesh),null,{ fileName : "engine/nanofl/engine/libraryitems/MeshItem.hx", lineNumber : 167, className : "nanofl.engine.libraryitems.MeshItem", methodName : "updateDisplayObject"});
		var mesh = dispObj;
		mesh.scene = new THREE_Scene();
		mesh.scene.fog = datatools_NullTools.clone(this.scene.fog);
		mesh.scene.add(mesh.group = new THREE_Group());
		var _g = 0;
		var _g1 = this.scene.children;
		while(_g < _g1.length) {
			var object = _g1[_g];
			++_g;
			switch(object.type) {
			case "AmbientLight":case "DirectionalLight":case "HemisphereLight":case "PointLight":case "RectAreaLight":case "SpotLight":
				if(this.loadLights) {
					mesh.group.add(object.clone());
				}
				break;
			default:
				mesh.group.add(object.clone());
			}
		}
		mesh.update();
	}
	,get_renderer: function() {
		if(this._rendererLoadLights != this.loadLights) {
			this._renderer = null;
		}
		if(this._renderer != null) {
			if(!((this._renderer) instanceof THREE_WebGLRenderer)) {
				this._renderer = null;
			}
		}
		if(this._renderer == null) {
			var canvas = window.document.createElement("canvas");
			canvas.width = canvas.height = this.renderAreaSize;
			this._renderer = new THREE_WebGLRenderer({ canvas : canvas, alpha : true});
			this._renderer.setSize(this.renderAreaSize,this.renderAreaSize);
			this._rendererLoadLights = this.loadLights;
		}
		return this._renderer;
	}
	,getDisplayObjectClassName: function() {
		return "nanofl.Mesh";
	}
	,equ: function(item) {
		if(!((item) instanceof nanofl_engine_libraryitems_MeshItem)) {
			return false;
		}
		if(!nanofl_engine_libraryitems_InstancableItem.prototype.equ.call(this,item)) {
			return false;
		}
		if(item.ext != this.ext) {
			return false;
		}
		if(item.textureAtlas != this.textureAtlas) {
			return false;
		}
		if(item.renderAreaSize != this.renderAreaSize) {
			return false;
		}
		if(item.loadLights != this.loadLights) {
			return false;
		}
		return true;
	}
	,getNearestPoint: function(pos) {
		var d = this.renderAreaSize / 2;
		var bounds = { minX : -d, minY : -d, maxX : d, maxY : d};
		return nanofl_engine_geom_BoundsTools.getNearestPoint(bounds,pos);
	}
	,loadPropertiesJson: function(obj) {
		if(obj.type != this.get_type()) {
			throw new Error("Type of item must be '" + Std.string(this.get_type()) + "', but '" + Std.string(obj.type) + "' found.");
		}
		nanofl_engine_libraryitems_InstancableItem.prototype.loadPropertiesJson.call(this,obj);
		var tmp = obj.ext;
		this.ext = tmp != null ? tmp : null;
		var tmp = obj.originalExt;
		this.originalExt = tmp != null ? tmp : null;
		var tmp = obj.textureAtlas;
		this.textureAtlas = tmp != null ? tmp : null;
		var tmp = obj.renderAreaSize;
		this.renderAreaSize = tmp != null ? tmp : 256;
		var tmp = obj.loadLights;
		this.loadLights = tmp != null && tmp;
	}
	,toString: function() {
		return "MeshItem(" + this.namePath + ")";
	}
	,__class__: nanofl_engine_libraryitems_MeshItem
});
var nanofl_engine_libraryitems_MovieClipItem = function(namePath) {
	this.exportAsSpriteSheet = false;
	this.likeButton = false;
	this.loop = true;
	this.autoPlay = true;
	this._layers = [];
	nanofl_engine_libraryitems_InstancableItem.call(this,namePath);
};
nanofl_engine_libraryitems_MovieClipItem.__name__ = "nanofl.engine.libraryitems.MovieClipItem";
nanofl_engine_libraryitems_MovieClipItem.__interfaces__ = [nanofl_engine_IFramedItem,nanofl_engine_ISpriteSheetableItem,nanofl_engine_ITextureItem,nanofl_engine_ITimeline,nanofl_engine_ILayersContainer];
nanofl_engine_libraryitems_MovieClipItem.createWithFrame = function(namePath,elements,layerName) {
	if(layerName == null) {
		layerName = "Layer 0";
	}
	var item = new nanofl_engine_libraryitems_MovieClipItem(namePath);
	var layer = new nanofl_engine_movieclip_Layer(layerName);
	item.addLayer(layer);
	layer.addKeyFrame(new nanofl_engine_movieclip_KeyFrame(null,null,null,elements));
	return item;
};
nanofl_engine_libraryitems_MovieClipItem.loadFromJson = function(namePath,baseLibraryUrl) {
	return nanofl_engine_Loader.file(baseLibraryUrl + "/" + namePath + ".json").then(function(itemJsonStr) {
		var r = new nanofl_engine_libraryitems_MovieClipItem(namePath);
		r.loadPropertiesJson(JSON.parse(itemJsonStr));
		return r;
	});
};
nanofl_engine_libraryitems_MovieClipItem.__super__ = nanofl_engine_libraryitems_InstancableItem;
nanofl_engine_libraryitems_MovieClipItem.prototype = $extend(nanofl_engine_libraryitems_InstancableItem.prototype,{
	get_type: function() {
		return nanofl_engine_LibraryItemType.movieclip;
	}
	,get_layers: function() {
		return this._layers;
	}
	,addLayer: function(layer) {
		nanofl_engine_LayersTools.addLayer(this,layer);
	}
	,addLayersBlock: function(layersToAdd,index) {
		nanofl_engine_LayersTools.addLayersBlock(this,layersToAdd,index);
	}
	,removeLayer: function(index) {
		nanofl_engine_LayersTools.removeLayer(this,index);
	}
	,removeLayerWithChildren: function(index) {
		return nanofl_engine_LayersTools.removeLayerWithChildren(this,index);
	}
	,getFramesAt: function(frameIndex) {
		return nanofl_engine_LayersTools.getFramesAt(this,frameIndex);
	}
	,getTotalFrames: function() {
		return nanofl_engine_LayersTools.getTotalFrames(this);
	}
	,clone: function() {
		var obj = new nanofl_engine_libraryitems_MovieClipItem(this.namePath);
		this.copyBaseProperties(obj);
		this.copyProperties(obj);
		return obj;
	}
	,copyProperties: function(obj) {
		obj._layers = [];
		var _g = 0;
		var _g1 = this.get_layers();
		while(_g < _g1.length) {
			var layer = _g1[_g];
			++_g;
			obj.addLayer(layer.clone());
		}
		obj.likeButton = this.likeButton;
		obj.autoPlay = this.autoPlay;
		obj.loop = this.loop;
		obj.exportAsSpriteSheet = this.exportAsSpriteSheet;
		obj.textureAtlas = this.textureAtlas;
	}
	,getIcon: function() {
		if(this.namePath == nanofl_engine_Library.SCENE_NAME_PATH) {
			return "custom-icon-scene";
		}
		if(this.likeButton) {
			return "custom-icon-button";
		}
		return "custom-icon-film";
	}
	,createDisplayObject: function(initFrameIndex,childFrameIndexes) {
		var r = nanofl_engine_libraryitems_InstancableItem.prototype.createDisplayObject.call(this,initFrameIndex,childFrameIndexes);
		if(r != null) {
			return r;
		}
		var spriteSheet = nanofl_engine_TextureItemTools.getSpriteSheet(this);
		if(spriteSheet == null && this.exportAsSpriteSheet) {
			spriteSheet = this.asSpriteSheet();
		}
		if(spriteSheet == null) {
			if(!this.likeButton) {
				return new nanofl_MovieClip(this,initFrameIndex,childFrameIndexes);
			} else {
				return new nanofl_Button(this);
			}
		} else if(!this.likeButton) {
			return new createjs.Sprite(spriteSheet,initFrameIndex);
		} else {
			return new nanofl_SpriteButton(spriteSheet);
		}
	}
	,updateDisplayObject: function(dispObj,childFrameIndexes) {
		if(!this.exportAsSpriteSheet) {
			stdlib_Debug.assert(((dispObj) instanceof nanofl_MovieClip),null,{ fileName : "engine/nanofl/engine/libraryitems/MovieClipItem.hx", lineNumber : 124, className : "nanofl.engine.libraryitems.MovieClipItem", methodName : "updateDisplayObject"});
			var movieClip = dispObj;
			movieClip.removeAllChildren();
			movieClip.alpha = 1.0;
			var topElement = null;
			var topElementLayer = null;
			var i = this.get_layers().length - 1;
			while(i >= 0) {
				var _g = 0;
				var _g1 = this.get_layers()[i].getTweenedElements(movieClip.currentFrame);
				while(_g < _g1.length) {
					var tweenedElement = _g1[_g];
					++_g;
					if(childFrameIndexes == null || childFrameIndexes.length == 0 || childFrameIndexes[0].element != tweenedElement.original) {
						var obj = tweenedElement.current.createDisplayObject(childFrameIndexes);
						obj.visible = this.get_layers()[i].type == nanofl_engine_LayerType.normal;
						movieClip.addChildToLayer(obj,i);
					} else if(childFrameIndexes != null && childFrameIndexes.length != 0 && childFrameIndexes[0].element == tweenedElement.original) {
						topElement = tweenedElement.current;
						topElementLayer = i;
					}
				}
				--i;
			}
			if(topElement != null) {
				movieClip.addChildToLayer(topElement.createDisplayObject(childFrameIndexes),topElementLayer);
			}
		}
	}
	,asSpriteSheet: function() {
		if(this.spriteSheet == null) {
			var builder = new createjs.SpriteSheetBuilder();
			var t = this.exportAsSpriteSheet;
			this.exportAsSpriteSheet = false;
			var _g = 0;
			var _g1 = this.getTotalFrames();
			while(_g < _g1) {
				var i = _g++;
				var mc = new nanofl_MovieClip(this,i,null);
				builder.addFrame(mc);
			}
			this.exportAsSpriteSheet = t;
			this.spriteSheet = builder.build();
		}
		return this.spriteSheet;
	}
	,getDisplayObjectClassName: function() {
		if(!this.likeButton) {
			return "nanofl.MovieClip";
		} else {
			return "nanofl.Button";
		}
	}
	,preload: function() {
		return nanofl_engine_TextureItemTools.preload(this);
	}
	,equ: function(item) {
		if(item == this) {
			return true;
		}
		if(!((item) instanceof nanofl_engine_libraryitems_MovieClipItem)) {
			return false;
		}
		if(item.namePath != this.namePath) {
			return false;
		}
		var mc = item;
		if(mc.linkedClass != this.linkedClass) {
			return false;
		}
		if(mc.autoPlay != this.autoPlay) {
			return false;
		}
		if(mc.loop != this.loop) {
			return false;
		}
		if(!datatools_ArrayTools.equ(mc._layers,this._layers)) {
			return false;
		}
		if(item.likeButton != this.likeButton) {
			return false;
		}
		if(item.exportAsSpriteSheet != this.exportAsSpriteSheet) {
			return false;
		}
		if(item.textureAtlas != this.textureAtlas) {
			return false;
		}
		return true;
	}
	,getNearestPoint: function(pos) {
		var points = [];
		var _g = 0;
		var _g1 = this.get_layers();
		while(_g < _g1.length) {
			var layer = _g1[_g];
			++_g;
			if(layer._keyFrames.length > 0) {
				var _g2 = 0;
				var _g3 = layer._keyFrames[0].get_elements();
				while(_g2 < _g3.length) {
					var element = _g3[_g2];
					++_g2;
					points.push(element.getNearestPoint(pos));
				}
			}
		}
		points.sort(function(a,b) {
			return Reflect.compare(nanofl_engine_geom_PointTools.getDist(pos.x,pos.y,a.x,a.y),nanofl_engine_geom_PointTools.getDist(pos.x,pos.y,b.x,b.y));
		});
		if(points.length > 0) {
			return points[0];
		} else {
			return { x : 1e100, y : 1e100};
		}
	}
	,setLibrary: function(library) {
		nanofl_engine_libraryitems_InstancableItem.prototype.setLibrary.call(this,library);
		var _g = 0;
		var _g1 = this.get_layers();
		while(_g < _g1.length) {
			var layer = _g1[_g];
			++_g;
			layer.setLibrary(library);
		}
	}
	,transform: function(m) {
		var _g = 0;
		var _g1 = this.get_layers();
		while(_g < _g1.length) {
			var layer = _g1[_g];
			++_g;
			var _g2 = 0;
			var _g3 = layer._keyFrames;
			while(_g2 < _g3.length) {
				var keyFrame = _g3[_g2];
				++_g2;
				var _g4 = 0;
				var _g5 = keyFrame.get_elements();
				while(_g4 < _g5.length) {
					var element = _g5[_g4];
					++_g4;
					element.transform(m);
				}
			}
		}
	}
	,loadPropertiesJson: function(obj) {
		if(obj.type != this.get_type()) {
			throw new Error("Type of item must be '" + Std.string(this.get_type()) + "', but '" + Std.string(obj.type) + "' found.");
		}
		nanofl_engine_libraryitems_InstancableItem.prototype.loadPropertiesJson.call(this,obj);
		this.autoPlay = obj.autoPlay;
		this.loop = obj.loop;
		this.likeButton = obj.likeButton;
		this.exportAsSpriteSheet = obj.exportAsSpriteSheet;
		this.textureAtlas = obj.textureAtlas;
		var _this = obj.layers;
		var result = new Array(_this.length);
		var _g = 0;
		var _g1 = _this.length;
		while(_g < _g1) {
			var i = _g++;
			var layer = new nanofl_engine_movieclip_Layer("");
			layer.loadPropertiesJson(_this[i],obj.version);
			result[i] = layer;
		}
		this.addLayersBlock(result);
	}
	,toString: function() {
		return "MovieClipItem(" + this.namePath + ")";
	}
	,__class__: nanofl_engine_libraryitems_MovieClipItem
});
var nanofl_engine_libraryitems_SoundItem = function(namePath,ext) {
	this.linkage = "";
	nanofl_engine_libraryitems_LibraryItem.call(this,namePath);
	this.ext = ext;
};
nanofl_engine_libraryitems_SoundItem.__name__ = "nanofl.engine.libraryitems.SoundItem";
nanofl_engine_libraryitems_SoundItem.__super__ = nanofl_engine_libraryitems_LibraryItem;
nanofl_engine_libraryitems_SoundItem.prototype = $extend(nanofl_engine_libraryitems_LibraryItem.prototype,{
	get_type: function() {
		return nanofl_engine_LibraryItemType.sound;
	}
	,clone: function() {
		var obj = new nanofl_engine_libraryitems_SoundItem(this.namePath,this.ext);
		obj.linkage = this.linkage;
		this.copyBaseProperties(obj);
		return obj;
	}
	,getIcon: function() {
		return "custom-icon-sound";
	}
	,getUrl: function() {
		return this.library.realUrl(this.namePath + "." + this.ext);
	}
	,equ: function(item) {
		if(item.namePath != this.namePath) {
			return false;
		}
		if(!((item) instanceof nanofl_engine_libraryitems_SoundItem)) {
			return false;
		}
		if(item.ext != this.ext) {
			return false;
		}
		if(item.linkage != this.linkage) {
			return false;
		}
		return true;
	}
	,preload: function() {
		return Promise.resolve();
	}
	,loadPropertiesJson: function(obj) {
		var tmp = obj.linkage;
		this.linkage = tmp != null ? tmp : "";
		var tmp = obj.ext;
		this.ext = tmp != null ? tmp : "";
	}
	,toString: function() {
		return "SoundItem(" + this.namePath + ")";
	}
	,__class__: nanofl_engine_libraryitems_SoundItem
});
var nanofl_engine_libraryitems_SpriteItem = function(namePath,frames) {
	this.loop = true;
	this.autoPlay = true;
	this.likeButton = false;
	nanofl_engine_libraryitems_InstancableItem.call(this,namePath);
	this.frames = frames;
};
nanofl_engine_libraryitems_SpriteItem.__name__ = "nanofl.engine.libraryitems.SpriteItem";
nanofl_engine_libraryitems_SpriteItem.__interfaces__ = [nanofl_engine_ITextureItem,nanofl_engine_ILayersContainer];
nanofl_engine_libraryitems_SpriteItem.__super__ = nanofl_engine_libraryitems_InstancableItem;
nanofl_engine_libraryitems_SpriteItem.prototype = $extend(nanofl_engine_libraryitems_InstancableItem.prototype,{
	get_type: function() {
		return nanofl_engine_LibraryItemType.sprite;
	}
	,get_layers: function() {
		if(this._layers == null) {
			var layer = new nanofl_engine_movieclip_Layer("auto");
			layer.layersContainer = this;
			var _g = 0;
			var _g1 = this.frames.length;
			while(_g < _g1) {
				var i = _g++;
				layer.addKeyFrame(new nanofl_engine_movieclip_KeyFrame(null,1,null,[new nanofl_engine_elements_SpriteFrameElement(this,i)]));
			}
			this._layers = [layer];
		}
		return this._layers;
	}
	,clone: function() {
		var obj = new nanofl_engine_libraryitems_SpriteItem(this.namePath,this.frames);
		obj.likeButton = this.likeButton;
		obj.autoPlay = this.autoPlay;
		obj.loop = this.loop;
		obj.textureAtlas = this.textureAtlas;
		obj.spriteSheet = this.spriteSheet;
		this.copyBaseProperties(obj);
		return obj;
	}
	,getIcon: function() {
		return "custom-icon-picture";
	}
	,preload: function() {
		stdlib_Debug.assert(this.library != null,"You need to add item '" + this.namePath + "' to the library before preload call.",{ fileName : "engine/nanofl/engine/libraryitems/SpriteItem.hx", lineNumber : 85, className : "nanofl.engine.libraryitems.SpriteItem", methodName : "preload"});
		if(nanofl_engine_TextureItemTools.getSpriteSheet(this) == null) {
			return this.ensureSpriteSheet();
		} else {
			return nanofl_engine_TextureItemTools.preload(this);
		}
	}
	,createDisplayObject: function(initFrameIndex,childFrameIndexes) {
		var r = nanofl_engine_libraryitems_InstancableItem.prototype.createDisplayObject.call(this,initFrameIndex,childFrameIndexes);
		if(r != null) {
			return r;
		}
		var spriteSheet = nanofl_engine_TextureItemTools.getSpriteSheet(this);
		if(spriteSheet == null) {
			spriteSheet = this.spriteSheet;
		}
		stdlib_Debug.assert(spriteSheet != null,null,{ fileName : "engine/nanofl/engine/libraryitems/SpriteItem.hx", lineNumber : 99, className : "nanofl.engine.libraryitems.SpriteItem", methodName : "createDisplayObject"});
		stdlib_Debug.assert(spriteSheet.complete,null,{ fileName : "engine/nanofl/engine/libraryitems/SpriteItem.hx", lineNumber : 100, className : "nanofl.engine.libraryitems.SpriteItem", methodName : "createDisplayObject"});
		var sprite = new createjs.Sprite(spriteSheet);
		sprite.gotoAndStop(initFrameIndex);
		return sprite;
	}
	,updateDisplayObject: function(dispObj,childFrameIndexes) {
	}
	,ensureSpriteSheet: function() {
		var _gthis = this;
		if(this.spriteSheet == null) {
			var images = [];
			var _g = 0;
			var _g1 = this.frames;
			while(_g < _g1.length) {
				var f = _g1[_g];
				++_g;
				if(images.indexOf(f.image) < 0) {
					images.push(f.image);
				}
			}
			var result = new Array(images.length);
			var _g = 0;
			var _g1 = images.length;
			while(_g < _g1) {
				var i = _g++;
				result[i] = _gthis.library.realUrl(images[i]);
			}
			var data = result;
			var _this = this.frames;
			var result = new Array(_this.length);
			var _g = 0;
			var _g1 = _this.length;
			while(_g < _g1) {
				var i = _g++;
				var f = _this[i];
				result[i] = [f.x,f.y,f.width,f.height,images.indexOf(f.image),f.regX,f.regY];
			}
			var data1 = { images : data, frames : result};
			this.spriteSheet = new createjs.SpriteSheet(data1);
		}
		if(!this.spriteSheet.complete) {
			return new Promise(function(resolve,reject) {
				_gthis.spriteSheet.addEventListener("complete",function(_) {
					resolve(null);
				},null);
			});
		} else {
			return Promise.resolve(null);
		}
	}
	,getNearestPoint: function(pos) {
		if(this.frames.length == 0) {
			return { x : 1e100, y : 1e100};
		}
		var frame = this.frames[0];
		var bounds = { minX : -frame.regX, minY : -frame.regY, maxX : frame.width - frame.regX, maxY : frame.height - frame.regY};
		return nanofl_engine_geom_BoundsTools.getNearestPoint(bounds,pos);
	}
	,getDisplayObjectClassName: function() {
		if(!this.likeButton) {
			return "nanofl.Sprite";
		} else {
			return "nanofl.SpriteButton";
		}
	}
	,equ: function(item) {
		if(!((item) instanceof nanofl_engine_libraryitems_SpriteItem)) {
			return false;
		}
		if(!nanofl_engine_libraryitems_InstancableItem.prototype.equ.call(this,item)) {
			return false;
		}
		if(!datatools_ArrayTools.equByFunc(this.frames,item.frames,function(a,b) {
			return datatools_ObjectTools.equFast(a,b);
		})) {
			return false;
		}
		if(!datatools_ArrayTools.equ(this.get_layers(),item.get_layers())) {
			return false;
		}
		return true;
	}
	,loadPropertiesJson: function(obj) {
		nanofl_engine_libraryitems_InstancableItem.prototype.loadPropertiesJson.call(this,obj);
		var tmp = obj.likeButton;
		this.likeButton = tmp != null && tmp;
		var tmp = obj.autoPlay;
		this.autoPlay = tmp != null ? tmp : true;
		var tmp = obj.loop;
		this.loop = tmp != null ? tmp : true;
		var tmp = obj.textureAtlas;
		this.textureAtlas = tmp != null ? tmp : null;
		var _this = obj.frames;
		var result = new Array(_this.length);
		var _g = 0;
		var _g1 = _this.length;
		while(_g < _g1) {
			var i = _g++;
			var frameObj = _this[i];
			result[i] = { image : frameObj.image, x : frameObj.x, y : frameObj.y, width : frameObj.width, height : frameObj.height, regX : frameObj.regX, regY : frameObj.regY};
		}
		this.frames = result;
	}
	,toString: function() {
		return "SpriteItem(" + this.namePath + ")";
	}
	,__class__: nanofl_engine_libraryitems_SpriteItem
});
var nanofl_engine_movieclip_Guide = function(guideLine) {
	var tmp = guideLine;
	this.guideLine = tmp != null ? tmp : new nanofl_engine_movieclip_GuideLine();
};
nanofl_engine_movieclip_Guide.__name__ = "nanofl.engine.movieclip.Guide";
nanofl_engine_movieclip_Guide.log = function(v,infos) {
};
nanofl_engine_movieclip_Guide.prototype = {
	get: function(startProps,finishProps,orientToPath,t) {
		nanofl_engine_movieclip_Guide.log("Guide.getPos: " + startProps.x + ", " + startProps.y + " => " + finishProps.x + ", " + finishProps.y + "; t = " + t,{ fileName : "engine/nanofl/engine/movieclip/Guide.hx", lineNumber : 14, className : "nanofl.engine.movieclip.Guide", methodName : "get"});
		var path = this.guideLine.getPath(startProps,finishProps);
		nanofl_engine_movieclip_Guide.log("path = " + path.join("; "),{ fileName : "engine/nanofl/engine/movieclip/Guide.hx", lineNumber : 17, className : "nanofl.engine.movieclip.Guide", methodName : "get"});
		var result = new Array(path.length);
		var _g = 0;
		var _g1 = path.length;
		while(_g < _g1) {
			var i = _g++;
			result[i] = path[i].getLength();
		}
		var lens = result;
		var sumLen = 0.0;
		var _g = 0;
		while(_g < lens.length) {
			var len = lens[_g];
			++_g;
			sumLen += len;
		}
		if(sumLen == 0.0) {
			return { x : path[0].x1, y : path[0].y1, rotation : startProps.rotation};
		}
		var lenPos = sumLen * t;
		var curLen = 0.0;
		var _g = 0;
		var _g1 = path.length;
		while(_g < _g1) {
			var i = _g++;
			if(lens[i] == 0) {
				continue;
			}
			curLen += lens[i];
			if(curLen >= lenPos) {
				var dLen = lenPos - (curLen - lens[i]);
				var subT = dLen / lens[i];
				var point = path[i].getMonotoneT(subT);
				var point1 = path[i].getPoint(point);
				var rotation;
				if(!orientToPath) {
					rotation = startProps.rotation + (finishProps.rotation - startProps.rotation) * t;
				} else {
					var angleT = path[i].getTangent(subT) * 180 / Math.PI;
					var angleS = path[0].getTangent(0) * 180 / Math.PI;
					var angleF = path[path.length - 1].getTangent(1) * 180 / Math.PI;
					rotation = startProps.rotation + (angleT - angleS) + (finishProps.rotation - angleF - (startProps.rotation - angleS)) * t;
				}
				return { x : point1.x, y : point1.y, rotation : rotation};
			}
		}
		return Reflect.copy(finishProps);
	}
	,__class__: nanofl_engine_movieclip_Guide
};
var nanofl_engine_movieclip_GuideLine = function(shape) {
	var tmp = shape;
	this.shape = tmp != null ? tmp : new nanofl_engine_elements_ShapeElement();
	this.vectors = this.shape.edges.slice();
	var _g = 0;
	var _g1 = this.shape.edges;
	while(_g < _g1.length) {
		var edge = _g1[_g];
		++_g;
		this.vectors.push(edge.clone().reverse());
	}
	var _g = [];
	var _g1 = 0;
	var _g2 = this.vectors;
	while(_g1 < _g2.length) {
		var v = _g2[_g1];
		++_g1;
		if(v.x1 != v.x3 || v.y1 != v.y3) {
			_g.push(v);
		}
	}
	this.vectors = _g;
	this.connections = nanofl_engine_movieclip_GuideLine.getConnectionMatrix(this.vectors);
	this.used = [];
	var _g = 0;
	var _g1 = this.shape.edges.length;
	while(_g < _g1) {
		var i = _g++;
		this.used.push(false);
	}
};
nanofl_engine_movieclip_GuideLine.__name__ = "nanofl.engine.movieclip.GuideLine";
nanofl_engine_movieclip_GuideLine.getConnectionMatrix = function(vectors) {
	var r = [];
	var _g = 0;
	while(_g < vectors.length) {
		var a = vectors[_g];
		++_g;
		var line = [];
		var _g1 = 0;
		while(_g1 < vectors.length) {
			var b = vectors[_g1];
			++_g1;
			line.push(a.x3 == b.x1 && a.y3 == b.y1);
		}
		r.push(line);
	}
	return r;
};
nanofl_engine_movieclip_GuideLine.log = function(v,infos) {
};
nanofl_engine_movieclip_GuideLine.prototype = {
	getPath: function(startPos,finishPos) {
		var r = this.findPath(startPos,finishPos);
		if(r.length == 0) {
			r.push(new nanofl_engine_geom_Edge(startPos.x,startPos.y,finishPos.x,finishPos.y));
		}
		return r;
	}
	,findPath: function(startPos,finishPos) {
		var _gthis = this;
		if(this.vectors.length == 0) {
			return [];
		}
		var start = this.shape.getNearestStrokeEdge(startPos);
		var end = this.shape.getNearestStrokeEdge(finishPos);
		nanofl_engine_movieclip_GuideLine.log("Guide.findPath " + nanofl_engine_geom_PointTools.toString(startPos) + " (" + start.t + ") => " + nanofl_engine_geom_PointTools.toString(finishPos) + " (" + end.t + ")" + "\tend.edge = " + Std.string(end.edge),{ fileName : "engine/nanofl/engine/movieclip/GuideLine.hx", lineNumber : 75, className : "nanofl.engine.movieclip.GuideLine", methodName : "findPath"});
		var params = { counter : 0, endEdge : end.edge, bestLen : 1.0e100, bestPath : [], path : [], len : 0.0};
		var startEdgeIndex = stdlib_LambdaIterable.findIndex(this.shape.edges,function(e) {
			return e.equ(start.edge);
		});
		stdlib_Debug.assert(startEdgeIndex >= 0,"startEdgeIndex = " + startEdgeIndex,{ fileName : "engine/nanofl/engine/movieclip/GuideLine.hx", lineNumber : 90, className : "nanofl.engine.movieclip.GuideLine", methodName : "findPath"});
		this.findPathInner(params,startEdgeIndex);
		this.findPathInner(params,startEdgeIndex + this.shape.edges.length);
		var _this = params.bestPath;
		var result = new Array(_this.length);
		var _g = 0;
		var _g1 = _this.length;
		while(_g < _g1) {
			var i = _g++;
			result[i] = _gthis.vectors[_this[i]];
		}
		var path = result;
		if(path.length > 0) {
			var lastI = path.length - 1;
			var firstSameDir = path[0].x3 == start.edge.x3 && path[0].y3 == start.edge.y3;
			var lastSameDir = path[lastI].x1 == end.edge.x1 && path[lastI].y1 == end.edge.y1;
			path[0] = firstSameDir ? path[0].clone().reverse().getPart(1 - start.t).reverse() : path[0] = path[0].getPart(start.t);
			path[lastI] = lastSameDir ? path[lastI].getPart(end.t) : path[lastI].clone().reverse().getPart(1 - end.t).reverse();
		}
		return path;
	}
	,findPathInner: function(params,nextVectorIndex) {
		params.counter++;
		var nextVector = this.vectors[nextVectorIndex];
		var edgesCount = this.vectors.length >> 1;
		params.path.push(nextVectorIndex);
		this.used[nextVectorIndex % edgesCount] = true;
		params.len += nextVector.getLength();
		if(params.len < params.bestLen) {
			if(nextVector.equ(params.endEdge)) {
				params.bestLen = params.len;
				params.bestPath = params.path.slice();
			} else {
				var _g = 0;
				var _g1 = this.vectors.length;
				while(_g < _g1) {
					var i = _g++;
					if(!this.used[i % edgesCount] && this.connections[nextVectorIndex][i]) {
						this.findPathInner(params,i);
					}
				}
			}
		}
		params.len -= nextVector.getLength();
		this.used[nextVectorIndex % edgesCount] = false;
		params.path.pop();
	}
	,__class__: nanofl_engine_movieclip_GuideLine
};
var nanofl_engine_movieclip_Layer = function(name,type,visible,locked,parentIndex) {
	if(locked == null) {
		locked = false;
	}
	if(visible == null) {
		visible = true;
	}
	this.name = name;
	this.type = type != null ? type : nanofl_engine_LayerType.normal;
	this.visible = visible;
	this.locked = locked;
	this.parentIndex = parentIndex;
	this._keyFrames = [];
};
nanofl_engine_movieclip_Layer.__name__ = "nanofl.engine.movieclip.Layer";
nanofl_engine_movieclip_Layer.prototype = {
	get_parentLayer: function() {
		if(this.parentIndex != null) {
			return this.layersContainer.get_layers()[this.parentIndex];
		} else {
			return null;
		}
	}
	,get_keyFrames: function() {
		return this._keyFrames;
	}
	,getTotalFrames: function() {
		var r = 0;
		var _g = 0;
		var _g1 = this._keyFrames;
		while(_g < _g1.length) {
			var frame = _g1[_g];
			++_g;
			r += frame.duration;
		}
		return r;
	}
	,getFrame: function(frameIndex) {
		var indexes = this.getFrameIndexes(frameIndex);
		if(indexes != null) {
			return { keyFrame : this._keyFrames[indexes.keyIndex], subIndex : indexes.subIndex};
		} else {
			return null;
		}
	}
	,getFrameIndexes: function(frameIndex) {
		var start = 0;
		var _g = 0;
		var _g1 = this._keyFrames.length;
		while(_g < _g1) {
			var i = _g++;
			if(frameIndex >= start && frameIndex < start + this._keyFrames[i].duration) {
				return { keyIndex : i, subIndex : frameIndex - start};
			}
			start += this._keyFrames[i].duration;
		}
		return null;
	}
	,addKeyFrame: function(keyFrame) {
		this._keyFrames.push(keyFrame);
		keyFrame.layer = this;
	}
	,insertKeyFrame: function(keyIndex,keyFrame) {
		this._keyFrames.splice(keyIndex,0,keyFrame);
		keyFrame.layer = this;
	}
	,insertFrame: function(frameIndex) {
		if(this._keyFrames.length > 0) {
			var indexes = this.getFrameIndexes(frameIndex);
			if(indexes != null) {
				var fh = this._keyFrames[indexes.keyIndex];
				fh.duration++;
			} else {
				this._keyFrames[this._keyFrames.length - 1].duration += frameIndex - this.getTotalFrames() + 1;
			}
		} else {
			this.addKeyFrame(new nanofl_engine_movieclip_KeyFrame(null,frameIndex + 1));
		}
	}
	,convertToKeyFrame: function(frameIndex,blank) {
		if(blank == null) {
			blank = false;
		}
		if(this._keyFrames.length > 0) {
			var curFrameIndex = 0;
			var _g = 0;
			var _g1 = this._keyFrames.length;
			while(_g < _g1) {
				var i = _g++;
				var keyFrame = this._keyFrames[i];
				if(frameIndex >= curFrameIndex && frameIndex < curFrameIndex + keyFrame.duration) {
					if(curFrameIndex == frameIndex) {
						return false;
					}
					var tmp = i + 1;
					var tmp1 = keyFrame.duration - (frameIndex - curFrameIndex);
					var tmp2;
					if(blank) {
						tmp2 = [];
					} else {
						var _this = keyFrame.getTweenedElements(frameIndex - curFrameIndex);
						var result = new Array(_this.length);
						var _g2 = 0;
						var _g3 = _this.length;
						while(_g2 < _g3) {
							var i1 = _g2++;
							result[i1] = _this[i1].current;
						}
						tmp2 = result;
					}
					this.insertKeyFrame(tmp,keyFrame.duplicate("",tmp1,tmp2));
					keyFrame.duration = frameIndex - curFrameIndex;
					return true;
				}
				curFrameIndex += keyFrame.duration;
			}
			var lastKeyFrame = this._keyFrames[this._keyFrames.length - 1];
			lastKeyFrame.duration = frameIndex - curFrameIndex + lastKeyFrame.duration;
			this.addKeyFrame(lastKeyFrame.duplicate("",1));
			return true;
		} else {
			this.addKeyFrame(new nanofl_engine_movieclip_KeyFrame(null,frameIndex + 1));
			return true;
		}
	}
	,removeFrame: function(frameIndex) {
		var indexes = this.getFrameIndexes(frameIndex);
		if(indexes != null) {
			var fh = this._keyFrames[indexes.keyIndex];
			fh.duration--;
			if(this._keyFrames[indexes.keyIndex].duration == 0) {
				this._keyFrames.splice(indexes.keyIndex,1);
			}
			return true;
		}
		return false;
	}
	,getHumanType: function() {
		if(this.parentIndex != null && this.type == nanofl_engine_LayerType.normal) {
			var parent = this.layersContainer.get_layers()[this.parentIndex];
			if(parent.type == nanofl_engine_LayerType.mask) {
				return "masked";
			}
			if(parent.type == nanofl_engine_LayerType.guide) {
				return "guided";
			}
		}
		var e = this.type;
		return $hxEnums[e.__enum__].__constructs__[e._hx_index]._hx_name;
	}
	,getIcon: function() {
		switch(this.type._hx_index) {
		case 0:
			return "custom-icon-page-blank";
		case 1:
			return "custom-icon-mask";
		case 2:
			return "custom-icon-folder-close";
		case 3:
			return "custom-icon-layer-guide";
		}
	}
	,getNestLevel: function(layers) {
		var r = 0;
		var layer = this;
		while(layer.parentIndex != null) {
			++r;
			layer = layers[layer.parentIndex];
		}
		return r;
	}
	,getChildLayers: function() {
		var index = this.getIndex();
		var _g = [];
		var _g1 = 0;
		var _g2 = this.layersContainer.get_layers();
		while(_g1 < _g2.length) {
			var v = _g2[_g1];
			++_g1;
			if(v.parentIndex == index) {
				_g.push(v);
			}
		}
		return _g;
	}
	,getTweenedElements: function(frameIndex) {
		var frame = this.getFrame(frameIndex);
		if(frame != null) {
			return frame.keyFrame.getTweenedElements(frame.subIndex);
		}
		return [];
	}
	,loadPropertiesJson: function(obj,version) {
		var tmp = obj.name;
		this.name = tmp != null ? tmp : "";
		var tmp = obj.type;
		this.type = Type.createEnum(nanofl_engine_LayerType,tmp != null ? tmp : "normal",null);
		var tmp = obj.visible;
		this.visible = tmp != null ? tmp : true;
		var tmp = obj.locked;
		this.locked = tmp != null && tmp;
		this.parentIndex = obj.parentIndex;
		var _g = 0;
		var _g1 = obj.keyFrames;
		while(_g < _g1.length) {
			var kf = _g1[_g];
			++_g;
			this.addKeyFrame(nanofl_engine_movieclip_KeyFrame.parseJson(kf,version));
		}
	}
	,clone: function() {
		return this.duplicate(this._keyFrames,this.parentIndex);
	}
	,duplicate: function(keyFrames,parentIndex) {
		var r = new nanofl_engine_movieclip_Layer(this.name,this.type,this.visible,this.locked,parentIndex);
		var _g = 0;
		var _g1 = keyFrames;
		while(_g < _g1.length) {
			var keyFrame = _g1[_g];
			++_g;
			r.addKeyFrame(keyFrame.clone());
		}
		return r;
	}
	,getIndex: function() {
		return this.layersContainer.get_layers().indexOf(this);
	}
	,setLibrary: function(library) {
		var _g = 0;
		var _g1 = this._keyFrames;
		while(_g < _g1.length) {
			var keyFrame = _g1[_g];
			++_g;
			keyFrame.setLibrary(library);
		}
	}
	,equ: function(layer) {
		if(layer.name != this.name) {
			return false;
		}
		if(layer.type != this.type) {
			return false;
		}
		if(layer.visible != this.visible) {
			return false;
		}
		if(layer.locked != this.locked) {
			return false;
		}
		if(!datatools_ArrayTools.equ(layer._keyFrames,this._keyFrames)) {
			return false;
		}
		return true;
	}
	,toString: function() {
		return (this.layersContainer != null ? this.layersContainer.toString() + " / " : "") + "layer";
	}
	,__class__: nanofl_engine_movieclip_Layer
};
var nanofl_engine_movieclip_MotionTween = function(easing,orientToPath,rotateCount,rotateCountX,rotateCountY,directionalLightRotateCountX,directionalLightRotateCountY) {
	this.easing = easing;
	this.orientToPath = orientToPath;
	this.rotateCount = rotateCount;
	this.rotateCountX = rotateCountX;
	this.rotateCountY = rotateCountY;
	this.directionalLightRotateCountX = directionalLightRotateCountX;
	this.directionalLightRotateCountY = directionalLightRotateCountY;
};
nanofl_engine_movieclip_MotionTween.__name__ = "nanofl.engine.movieclip.MotionTween";
nanofl_engine_movieclip_MotionTween.__interfaces__ = [nanofl_engine_IMotionTween];
nanofl_engine_movieclip_MotionTween.loadJson = function(obj) {
	if((obj != null ? obj.tweenType : null) != "motion") {
		return null;
	}
	var tmp = obj.motionTweenEasing;
	var tmp1 = obj.motionTweenOrientToPath;
	var tmp2 = obj.motionTweenRotateCount;
	var tmp3 = obj.motionTweenRotateCountX;
	var tmp4 = obj.motionTweenRotateCountY;
	var tmp5 = obj.motionTweenDirectionalLightRotateCountX;
	var tmp6 = obj.motionTweenDirectionalLightRotateCountY;
	return new nanofl_engine_movieclip_MotionTween(tmp != null ? tmp : 0,tmp1 != null && tmp1,tmp2 != null ? tmp2 : 0,tmp3 != null ? tmp3 : 0,tmp4 != null ? tmp4 : 0,tmp5 != null ? tmp5 : 0,tmp6 != null ? tmp6 : 0);
};
nanofl_engine_movieclip_MotionTween.log = function(v,infos) {
};
nanofl_engine_movieclip_MotionTween.prototype = {
	getGuideLine: function(keyFrame,frameSubIndex) {
		if(keyFrame.layer.parentIndex == null) {
			return null;
		}
		var parentLayer = keyFrame.layer.get_parentLayer();
		if(parentLayer.type != nanofl_engine_LayerType.guide) {
			return null;
		}
		var frame = parentLayer.getFrame(keyFrame.getIndex() + frameSubIndex);
		return frame.keyFrame.getGuideLine();
	}
	,apply: function(frameSubIndex) {
		var startElements = this.keyFrame.get_elements();
		var nextKeyFrame = this.keyFrame.getNextKeyFrame();
		var finishElements = nextKeyFrame != null ? nextKeyFrame.get_elements() : null;
		var guideLine = this.getGuideLine(this.keyFrame,frameSubIndex);
		var guide = guideLine != null ? new nanofl_engine_movieclip_Guide(guideLine) : null;
		var t = frameSubIndex / this.keyFrame.duration;
		var r = [];
		if(finishElements != null) {
			var ease = createjs.Ease.get(this.easing / 100);
			var k = ease(t);
			var instancesMap = this.getInstancesMap(startElements,finishElements);
			var _g = 0;
			var _g1 = startElements;
			while(_g < _g1.length) {
				var startElement = _g1[_g];
				++_g;
				if(((startElement) instanceof nanofl_engine_elements_Instance) && instancesMap.h.__keys__[startElement.__id__] != null) {
					var startInstance = startElement;
					var finishInstance = instancesMap.h[startInstance.__id__];
					var targetInstance = this.getMovedInstance(startInstance,finishInstance,k,guide);
					var _g2 = [];
					var _g3 = 0;
					var _g4 = startInstance.getFilters();
					while(_g3 < _g4.length) {
						var v = _g4[_g3];
						++_g3;
						if(Object.prototype.hasOwnProperty.call(nanofl_engine_plugins_FilterPlugins.plugins.h,v.name)) {
							_g2.push(v);
						}
					}
					var startFilters = _g2;
					var _g5 = [];
					var _g6 = 0;
					var _g7 = finishInstance.getFilters();
					while(_g6 < _g7.length) {
						var v1 = _g7[_g6];
						++_g6;
						if(Object.prototype.hasOwnProperty.call(nanofl_engine_plugins_FilterPlugins.plugins.h,v1.name)) {
							_g5.push(v1);
						}
					}
					var finishFilters = _g5;
					this.fixFilterSequence(startFilters,finishFilters);
					this.fixFilterSequence(finishFilters,startFilters);
					stdlib_Debug.assert(startFilters.length == finishFilters.length,"startFilters.length = " + startFilters.length + " != finishFilters.length = " + finishFilters.length,{ fileName : "engine/nanofl/engine/movieclip/MotionTween.hx", lineNumber : 90, className : "nanofl.engine.movieclip.MotionTween", methodName : "apply"});
					var i = 0;
					var _g8 = [];
					var _g_current = 0;
					var _g_array = startFilters;
					while(_g_current < _g_array.length) {
						var x = _g_array[_g_current++];
						_g8.push(x.clone().tween(k,finishFilters[i++]));
					}
					targetInstance.setFilters(Lambda.array(_g8));
					r.push(new nanofl_engine_movieclip_TweenedElement(startElement,targetInstance));
				} else {
					r.push(new nanofl_engine_movieclip_TweenedElement(startElement,startElement));
				}
			}
		} else {
			var _g = 0;
			var _g1 = this.keyFrame.get_elements();
			while(_g < _g1.length) {
				var element = _g1[_g];
				++_g;
				r.push(new nanofl_engine_movieclip_TweenedElement(element,element));
			}
		}
		return r;
	}
	,fixFilterSequence: function(src,dst) {
		var _g = 0;
		var _g1 = src.length;
		while(_g < _g1) {
			var i = _g++;
			if(i >= dst.length || dst[i].name != src[i].name) {
				var x = src[i].clone().resetToNeutral();
				dst.splice(i,0,x);
			}
		}
	}
	,getInstancesMap: function(startElements,finishElements) {
		var r = new haxe_ds_ObjectMap();
		if(finishElements != null) {
			var startInstances = datatools_ArrayRO.filterByType(startElements,nanofl_engine_elements_Instance);
			var finishInstances = datatools_ArrayRO.filterByType(finishElements,nanofl_engine_elements_Instance);
			var _g = 0;
			while(_g < startInstances.length) {
				var instance = startInstances[_g];
				++_g;
				var _g1 = 0;
				while(_g1 < finishInstances.length) {
					var nextInstance = finishInstances[_g1];
					++_g1;
					if(nextInstance.namePath == instance.namePath) {
						r.set(instance,nextInstance);
						HxOverrides.remove(finishInstances,nextInstance);
						break;
					}
				}
			}
		}
		return r;
	}
	,isGood: function() {
		var startElements = this.keyFrame.get_elements();
		var nextKeyFrame = this.keyFrame.getNextKeyFrame();
		var finishElements = nextKeyFrame != null ? nextKeyFrame.get_elements() : null;
		return this.getInstancesMap(startElements,finishElements).iterator().hasNext();
	}
	,getMovedInstance: function(startInstance,finishInstance,k,guide) {
		if(guide == null) {
			guide = new nanofl_engine_movieclip_Guide(null);
		}
		var targetInstance = js_Boot.__cast(startInstance.clone() , nanofl_engine_elements_Instance);
		var startProps = this.translatedMatrixByLocalVector(startInstance.matrix.clone(),startInstance.regX,startInstance.regY).decompose();
		var finishProps = this.translatedMatrixByLocalVector(finishInstance.matrix.clone(),startInstance.regX,startInstance.regY).decompose();
		var props = guide.get(startProps,finishProps,this.orientToPath,k);
		targetInstance.matrix.setTransform(props.x,props.y,startProps.scaleX + (finishProps.scaleX - startProps.scaleX) * k,startProps.scaleY + (finishProps.scaleY - startProps.scaleY) * k,props.rotation + this.rotateCount * 360 * k,startProps.skewX + (finishProps.skewX - startProps.skewX) * k,startProps.skewY + (finishProps.skewY - startProps.skewY) * k);
		this.translatedMatrixByLocalVector(targetInstance.matrix,-startInstance.regX,-startInstance.regY);
		if(((startInstance.get_symbol()) instanceof nanofl_engine_libraryitems_MeshItem) && ((finishInstance.get_symbol()) instanceof nanofl_engine_libraryitems_MeshItem)) {
			targetInstance.meshParams.rotationX += (finishInstance.meshParams.rotationX - startInstance.meshParams.rotationX) * k + this.rotateCountX * 360 * k;
			targetInstance.meshParams.rotationY += (finishInstance.meshParams.rotationY - startInstance.meshParams.rotationY) * k + this.rotateCountY * 360 * k;
			targetInstance.meshParams.cameraFov += Math.round((finishInstance.meshParams.cameraFov - startInstance.meshParams.cameraFov) * k);
			targetInstance.meshParams.ambientLightColor = nanofl_engine_ColorTools.getTweened(startInstance.meshParams.ambientLightColor,k,finishInstance.meshParams.ambientLightColor);
			targetInstance.meshParams.directionalLightColor = nanofl_engine_ColorTools.getTweened(startInstance.meshParams.directionalLightColor,k,finishInstance.meshParams.directionalLightColor);
			targetInstance.meshParams.directionalLightRotationX += (finishInstance.meshParams.directionalLightRotationX - startInstance.meshParams.directionalLightRotationX) * k + this.directionalLightRotateCountX * 360 * k;
			targetInstance.meshParams.directionalLightRotationY += (finishInstance.meshParams.directionalLightRotationY - startInstance.meshParams.directionalLightRotationY) * k + this.directionalLightRotateCountY * 360 * k;
		}
		if(startInstance.colorEffect != null || finishInstance.colorEffect != null) {
			var startCE = startInstance.colorEffect != null ? startInstance.colorEffect : finishInstance.colorEffect.getNeutralClone();
			var finishCE = finishInstance.colorEffect != null ? finishInstance.colorEffect : startInstance.colorEffect.getNeutralClone();
			if(js_Boot.getClass(startCE) == js_Boot.getClass(finishCE)) {
				targetInstance.colorEffect = startCE.getTweened(k,finishCE);
			} else {
				targetInstance.colorEffect = new nanofl_engine_coloreffects_ColorEffectDouble(startCE.getTweened(k,startCE.getNeutralClone()),finishCE.getNeutralClone().getTweened(k,finishCE));
			}
		}
		return targetInstance;
	}
	,translatedMatrixByLocalVector: function(m,dx,dy) {
		var v = m.transformPoint(dx,dy);
		m.tx = v.x;
		m.ty = v.y;
		return m;
	}
	,clone: function() {
		return new nanofl_engine_movieclip_MotionTween(this.easing,this.orientToPath,this.rotateCount,this.rotateCountX,this.rotateCountY,this.directionalLightRotateCountX,this.directionalLightRotateCountY);
	}
	,equ: function(_motionTween) {
		stdlib_Debug.assert(((_motionTween) instanceof nanofl_engine_movieclip_MotionTween),null,{ fileName : "engine/nanofl/engine/movieclip/MotionTween.hx", lineNumber : 301, className : "nanofl.engine.movieclip.MotionTween", methodName : "equ"});
		var motionTween = _motionTween;
		if(motionTween.easing != this.easing) {
			return false;
		}
		if(motionTween.rotateCount != this.rotateCount) {
			return false;
		}
		if(motionTween.orientToPath != this.orientToPath) {
			return false;
		}
		if(motionTween.rotateCountX != this.rotateCountX) {
			return false;
		}
		if(motionTween.rotateCountY != this.rotateCountY) {
			return false;
		}
		if(motionTween.directionalLightRotateCountX != this.directionalLightRotateCountX) {
			return false;
		}
		if(motionTween.directionalLightRotateCountY != this.directionalLightRotateCountY) {
			return false;
		}
		return true;
	}
	,__class__: nanofl_engine_movieclip_MotionTween
};
var nanofl_engine_movieclip_TweenedElement = function(original,current) {
	this.original = original;
	this.current = current;
};
nanofl_engine_movieclip_TweenedElement.__name__ = "nanofl.engine.movieclip.TweenedElement";
nanofl_engine_movieclip_TweenedElement.prototype = {
	__class__: nanofl_engine_movieclip_TweenedElement
};
var nanofl_engine_plugins_FilterPlugins = $hx_exports["nanofl"]["engine"]["plugins"]["FilterPlugins"] = function() { };
nanofl_engine_plugins_FilterPlugins.__name__ = "nanofl.engine.plugins.FilterPlugins";
nanofl_engine_plugins_FilterPlugins.register = function(plugin) {
	nanofl_engine_plugins_FilterPlugins.plugins.h[plugin.name] = plugin;
};
var nanofl_engine_plugins_IFilterPlugin = $hx_exports["nanofl"]["engine"]["plugins"]["IFilterPlugin"] = function() { };
nanofl_engine_plugins_IFilterPlugin.__name__ = "nanofl.engine.plugins.IFilterPlugin";
nanofl_engine_plugins_IFilterPlugin.__isInterface__ = true;
nanofl_engine_plugins_IFilterPlugin.prototype = {
	__class__: nanofl_engine_plugins_IFilterPlugin
};
var nanofl_engine_strokes_BaseStroke = function(thickness,caps,joints,miterLimit,ignoreScale) {
	if(ignoreScale == null) {
		ignoreScale = false;
	}
	if(miterLimit == null) {
		miterLimit = 3.0;
	}
	if(joints == null) {
		joints = "round";
	}
	if(caps == null) {
		caps = "round";
	}
	if(thickness == null) {
		thickness = 1.0;
	}
	this.thickness = thickness;
	this.caps = caps;
	this.joints = joints;
	this.miterLimit = miterLimit;
	this.ignoreScale = ignoreScale;
};
nanofl_engine_strokes_BaseStroke.__name__ = "nanofl.engine.strokes.BaseStroke";
nanofl_engine_strokes_BaseStroke.load = function(node,version) {
	var r;
	switch(htmlparser_HtmlParserTools.getAttr(node,"type")) {
	case "bitmap":
		r = new nanofl_engine_strokes_BitmapStroke();
		break;
	case "linear":
		r = new nanofl_engine_strokes_LinearStroke([],[],0,0,0,0);
		break;
	case "radial":
		r = new nanofl_engine_strokes_RadialStroke([],[],0,0,0,0,0);
		break;
	case "solid":
		r = new nanofl_engine_strokes_SolidStroke();
		break;
	default:
		throw haxe_Exception.thrown("Unknow stroke type '" + Std.string(htmlparser_HtmlParserTools.getAttr(node,"type")) + "'.");
	}
	r.loadProperties(node);
	return r;
};
nanofl_engine_strokes_BaseStroke.loadJson = function(obj,version) {
	var r;
	switch(obj.type) {
	case "bitmap":
		r = new nanofl_engine_strokes_BitmapStroke();
		break;
	case "linear":
		r = new nanofl_engine_strokes_LinearStroke([],[],0,0,0,0);
		break;
	case "radial":
		r = new nanofl_engine_strokes_RadialStroke([],[],0,0,0,0,0);
		break;
	case "solid":
		r = new nanofl_engine_strokes_SolidStroke();
		break;
	default:
		throw haxe_Exception.thrown("Unknow stroke type '" + obj.type + "'.");
	}
	r.loadPropertiesJson(obj);
	return r;
};
nanofl_engine_strokes_BaseStroke.prototype = {
	save: function(out) {
		var tmp = out.begin("stroke");
		var e = this.getTyped();
		tmp.attr("type",$hxEnums[e.__enum__].__constructs__[e._hx_index]._hx_name);
		this.saveProperties(out);
		out.end();
	}
	,saveJson: function() {
		var e = this.getTyped();
		var obj = { type : $hxEnums[e.__enum__].__constructs__[e._hx_index]._hx_name};
		this.savePropertiesJson(obj);
		return obj;
	}
	,loadBaseProperties: function(node) {
		this.thickness = htmlparser_HtmlParserTools.getAttr(node,"thickness",1.0);
		this.caps = htmlparser_HtmlParserTools.getAttr(node,"caps","round");
		this.joints = htmlparser_HtmlParserTools.getAttr(node,"joints","round");
		this.miterLimit = htmlparser_HtmlParserTools.getAttr(node,"miterLimit",3.0);
		this.ignoreScale = htmlparser_HtmlParserTools.getAttr(node,"ignoreScale",false);
	}
	,loadBasePropertiesJson: function(obj) {
		var tmp = obj.thickness;
		this.thickness = tmp != null ? tmp : 1.0;
		var tmp = obj.caps;
		this.caps = tmp != null ? tmp : "round";
		var tmp = obj.joints;
		this.joints = tmp != null ? tmp : "round";
		var tmp = obj.miterLimit;
		this.miterLimit = tmp != null ? tmp : 3.0;
		var tmp = obj.ignoreScale;
		this.ignoreScale = tmp != null && tmp;
	}
	,saveBaseProperties: function(out) {
		out.attr("thickness",this.thickness,1.0);
		out.attr("caps",this.caps,"round");
		out.attr("joints",this.joints,"round");
		out.attr("miterLimit",this.miterLimit,3.0);
		out.attr("ignoreScale",this.ignoreScale,false);
	}
	,saveBasePropertiesJson: function(obj) {
		var tmp = this.thickness;
		obj.thickness = tmp != null ? tmp : 1.0;
		var tmp = this.caps;
		obj.caps = tmp != null ? tmp : "round";
		var tmp = this.joints;
		obj.joints = tmp != null ? tmp : "round";
		var tmp = this.miterLimit;
		obj.miterLimit = tmp != null ? tmp : 3.0;
		var tmp = this.ignoreScale;
		obj.ignoreScale = tmp != null && tmp;
	}
	,setStrokeStyle: function(g) {
		g.setStrokeStyle(this.thickness,this.caps,this.joints,this.miterLimit,this.ignoreScale);
	}
	,clone: function() {
		var c = js_Boot.getClass(this);
		throw haxe_Exception.thrown("Cloning of " + c.__name__ + " is not supported.");
	}
	,equ: function(e) {
		var ee = e;
		if(ee.thickness == this.thickness && ee.caps == this.caps && ee.joints == this.joints && ee.miterLimit == this.miterLimit) {
			return ee.ignoreScale == this.ignoreScale;
		} else {
			return false;
		}
	}
	,setLibrary: function(library) {
	}
	,getTransformed: function(m,applyToThickness) {
		var r = this.clone();
		if(applyToThickness) {
			r.thickness *= m.getAverageScale();
		}
		return r;
	}
	,__class__: nanofl_engine_strokes_BaseStroke
};
var nanofl_engine_strokes_IStroke = function() { };
nanofl_engine_strokes_IStroke.__name__ = "nanofl.engine.strokes.IStroke";
nanofl_engine_strokes_IStroke.__isInterface__ = true;
nanofl_engine_strokes_IStroke.prototype = {
	__class__: nanofl_engine_strokes_IStroke
};
var nanofl_engine_strokes_BitmapStroke = function(bitmapPath,repeat,thickness,caps,joints,miterLimit,ignoreScale) {
	if(ignoreScale == null) {
		ignoreScale = false;
	}
	if(miterLimit == null) {
		miterLimit = 3.0;
	}
	if(joints == null) {
		joints = "round";
	}
	if(caps == null) {
		caps = "round";
	}
	if(thickness == null) {
		thickness = 1.0;
	}
	if(repeat == null) {
		repeat = "repeat";
	}
	nanofl_engine_strokes_BaseStroke.call(this,thickness,caps,joints,miterLimit,ignoreScale);
	this.bitmapPath = bitmapPath;
	this.repeat = repeat;
};
nanofl_engine_strokes_BitmapStroke.__name__ = "nanofl.engine.strokes.BitmapStroke";
nanofl_engine_strokes_BitmapStroke.__interfaces__ = [nanofl_engine_strokes_IStroke];
nanofl_engine_strokes_BitmapStroke.__super__ = nanofl_engine_strokes_BaseStroke;
nanofl_engine_strokes_BitmapStroke.prototype = $extend(nanofl_engine_strokes_BaseStroke.prototype,{
	loadProperties: function(node) {
		this.loadBaseProperties(node);
		this.bitmapPath = htmlparser_HtmlParserTools.getAttr(node,"bitmapPath");
		this.repeat = htmlparser_HtmlParserTools.getAttr(node,"repeat");
	}
	,loadPropertiesJson: function(obj) {
		this.loadBasePropertiesJson(obj);
		this.bitmapPath = obj.bitmapPath;
		this.repeat = obj.repeat;
	}
	,saveProperties: function(out) {
		out.attr("bitmapPath",this.bitmapPath);
		out.attr("repeat",this.repeat,"repeat");
		this.saveBaseProperties(out);
	}
	,savePropertiesJson: function(obj) {
		obj.bitmapPath = this.bitmapPath;
		var tmp = this.repeat;
		obj.repeat = tmp != null ? tmp : "repeat";
		this.saveBasePropertiesJson(obj);
	}
	,begin: function(g) {
		if(this.library.hasItem(this.bitmapPath)) {
			var image = (js_Boot.__cast(this.library.getItem(this.bitmapPath) , nanofl_engine_libraryitems_BitmapItem)).image;
			g.beginBitmapStroke(image,this.repeat);
			this.setStrokeStyle(g);
		} else {
			g.beginStroke("rgba(0,0,0,0)");
		}
	}
	,clone: function() {
		var obj = new nanofl_engine_strokes_BitmapStroke(this.bitmapPath,this.repeat,this.thickness,this.caps,this.joints,this.miterLimit,this.ignoreScale);
		obj.library = this.library;
		return obj;
	}
	,equ: function(e) {
		if(e == this) {
			return true;
		}
		if(!((e) instanceof nanofl_engine_strokes_BitmapStroke) || !nanofl_engine_strokes_BaseStroke.prototype.equ.call(this,e)) {
			return false;
		}
		var ee = e;
		if(ee.bitmapPath == this.bitmapPath) {
			return ee.repeat == this.repeat;
		} else {
			return false;
		}
	}
	,swapInstance: function(oldNamePath,newNamePath) {
		if(this.bitmapPath == oldNamePath) {
			this.bitmapPath = newNamePath;
		}
	}
	,setLibrary: function(library) {
		this.library = library;
	}
	,applyAlpha: function(alpha) {
	}
	,getTyped: function() {
		return nanofl_engine_strokes_TypedStroke.bitmap(this);
	}
	,toString: function() {
		return "new BitmapStroke(\"" + this.bitmapPath + "\")";
	}
	,__class__: nanofl_engine_strokes_BitmapStroke
});
var nanofl_engine_strokes_LinearStroke = function(colors,ratios,x0,y0,x1,y1,thickness,caps,joints,miterLimit,ignoreScale) {
	if(ignoreScale == null) {
		ignoreScale = false;
	}
	if(miterLimit == null) {
		miterLimit = 3.0;
	}
	if(joints == null) {
		joints = "round";
	}
	if(caps == null) {
		caps = "round";
	}
	if(thickness == null) {
		thickness = 1.0;
	}
	nanofl_engine_strokes_BaseStroke.call(this,thickness,caps,joints,miterLimit,ignoreScale);
	this.colors = colors;
	this.ratios = ratios;
	this.x0 = x0;
	this.y0 = y0;
	this.x1 = x1;
	this.y1 = y1;
};
nanofl_engine_strokes_LinearStroke.__name__ = "nanofl.engine.strokes.LinearStroke";
nanofl_engine_strokes_LinearStroke.__interfaces__ = [nanofl_engine_strokes_IStroke];
nanofl_engine_strokes_LinearStroke.__super__ = nanofl_engine_strokes_BaseStroke;
nanofl_engine_strokes_LinearStroke.prototype = $extend(nanofl_engine_strokes_BaseStroke.prototype,{
	loadProperties: function(node) {
		this.loadBaseProperties(node);
		this.colors = htmlparser_HtmlParserTools.getAttr(node,"colors",[]);
		this.ratios = htmlparser_HtmlParserTools.getAttr(node,"ratios",[0.0]);
		this.x0 = htmlparser_HtmlParserTools.getAttr(node,"x0",0.0);
		this.y0 = htmlparser_HtmlParserTools.getAttr(node,"y0",0.0);
		this.x1 = htmlparser_HtmlParserTools.getAttr(node,"x1",0.0);
		this.y1 = htmlparser_HtmlParserTools.getAttr(node,"y1",0.0);
	}
	,loadPropertiesJson: function(obj) {
		this.loadBasePropertiesJson(obj);
		var tmp = obj.colors;
		this.colors = tmp != null ? tmp : [];
		var tmp = obj.ratios;
		this.ratios = tmp != null ? tmp : [0.0];
		var tmp = obj.x0;
		this.x0 = tmp != null ? tmp : 0.0;
		var tmp = obj.y0;
		this.y0 = tmp != null ? tmp : 0.0;
		var tmp = obj.x1;
		this.x1 = tmp != null ? tmp : 0.0;
		var tmp = obj.y1;
		this.y1 = tmp != null ? tmp : 0.0;
	}
	,saveProperties: function(out) {
		out.attr("colors",this.colors);
		out.attr("ratios",this.ratios);
		out.attr("x0",this.x0);
		out.attr("y0",this.y0);
		out.attr("x1",this.x1);
		out.attr("y1",this.y1);
		this.saveBaseProperties(out);
	}
	,savePropertiesJson: function(obj) {
		obj.colors = this.colors;
		obj.ratios = this.ratios;
		obj.x0 = this.x0;
		obj.y0 = this.y0;
		obj.x1 = this.x1;
		obj.y1 = this.y1;
		this.saveBasePropertiesJson(obj);
	}
	,begin: function(g) {
		g.beginLinearGradientStroke(this.colors,this.ratios,this.x0,this.y0,this.x1,this.y1);
		this.setStrokeStyle(g);
	}
	,clone: function() {
		return new nanofl_engine_strokes_LinearStroke(this.colors,this.ratios,this.x0,this.y0,this.x1,this.y1,this.thickness,this.caps,this.joints,this.miterLimit,this.ignoreScale);
	}
	,equ: function(e) {
		if(e == this) {
			return true;
		}
		if(!((e) instanceof nanofl_engine_strokes_LinearStroke) || !nanofl_engine_strokes_BaseStroke.prototype.equ.call(this,e)) {
			return false;
		}
		var ee = e;
		if(this.arrEqu(ee.colors,this.colors) && this.arrEqu(ee.ratios,this.ratios) && ee.x0 == this.x0 && ee.y0 == this.y0 && ee.x1 == this.x1) {
			return ee.y1 == this.y1;
		} else {
			return false;
		}
	}
	,swapInstance: function(oldNamePath,newNamePath) {
	}
	,applyAlpha: function(alpha) {
		var _g = 0;
		var _g1 = this.colors.length;
		while(_g < _g1) {
			var i = _g++;
			var rgba = nanofl_engine_ColorTools.parse(this.colors[i]);
			if(rgba == null) {
				throw new Error("Can't parse color '" + this.colors[i] + "'.");
			}
			rgba.a *= alpha;
			this.colors[i] = nanofl_engine_ColorTools.rgbaToString(rgba);
		}
	}
	,getTransformed: function(m,applyToThickness) {
		var r = nanofl_engine_strokes_BaseStroke.prototype.getTransformed.call(this,m,applyToThickness);
		var p0 = m.transformPoint(this.x0,this.y0);
		r.x0 = p0.x;
		r.y0 = p0.y;
		var p1 = m.transformPoint(this.x1,this.y1);
		r.x1 = p1.x;
		r.y1 = p1.y;
		return r;
	}
	,getTyped: function() {
		return nanofl_engine_strokes_TypedStroke.linear(this);
	}
	,toString: function() {
		var _this = this.colors;
		var result = new Array(_this.length);
		var _g = 0;
		var _g1 = _this.length;
		while(_g < _g1) {
			var i = _g++;
			result[i] = "\"" + _this[i] + "\"";
		}
		return "new LinearStroke(" + Std.string(result) + (", " + Std.string(this.ratios) + ", " + this.x0 + ", " + this.y0 + ", " + this.x1 + ", " + this.y1 + ")");
	}
	,arrEqu: function(a,b) {
		if(a.length != b.length) {
			return false;
		}
		var _g = 0;
		var _g1 = a.length;
		while(_g < _g1) {
			var i = _g++;
			if(a[i] != b[i]) {
				return false;
			}
		}
		return true;
	}
	,__class__: nanofl_engine_strokes_LinearStroke
});
var nanofl_engine_strokes_RadialStroke = function(colors,ratios,cx,cy,r,fx,fy,thickness,caps,joints,miterLimit,ignoreScale) {
	if(ignoreScale == null) {
		ignoreScale = false;
	}
	if(miterLimit == null) {
		miterLimit = 3.0;
	}
	if(joints == null) {
		joints = "round";
	}
	if(caps == null) {
		caps = "round";
	}
	if(thickness == null) {
		thickness = 1.0;
	}
	nanofl_engine_strokes_BaseStroke.call(this,thickness,caps,joints,miterLimit,ignoreScale);
	this.colors = colors;
	this.ratios = ratios;
	this.cx = cx;
	this.cy = cy;
	this.r = r;
	this.fx = fx;
	this.fy = fy;
};
nanofl_engine_strokes_RadialStroke.__name__ = "nanofl.engine.strokes.RadialStroke";
nanofl_engine_strokes_RadialStroke.__interfaces__ = [nanofl_engine_strokes_IStroke];
nanofl_engine_strokes_RadialStroke.__super__ = nanofl_engine_strokes_BaseStroke;
nanofl_engine_strokes_RadialStroke.prototype = $extend(nanofl_engine_strokes_BaseStroke.prototype,{
	loadProperties: function(node) {
		this.loadBaseProperties(node);
		this.colors = htmlparser_HtmlParserTools.getAttr(node,"colors",[]);
		this.ratios = htmlparser_HtmlParserTools.getAttr(node,"ratios",[0.0]);
		this.cx = htmlparser_HtmlParserTools.getAttr(node,"cx",0.0);
		this.cy = htmlparser_HtmlParserTools.getAttr(node,"cy",0.0);
		this.r = htmlparser_HtmlParserTools.getAttr(node,"r",0.0);
		this.fx = htmlparser_HtmlParserTools.getAttr(node,"fx",this.cx);
		this.fy = htmlparser_HtmlParserTools.getAttr(node,"fy",this.cy);
	}
	,loadPropertiesJson: function(obj) {
		this.loadBasePropertiesJson(obj);
		var tmp = obj.colors;
		this.colors = tmp != null ? tmp : [];
		var tmp = obj.ratios;
		this.ratios = tmp != null ? tmp : [0.0];
		var tmp = obj.cx;
		this.cx = tmp != null ? tmp : 0.0;
		var tmp = obj.cy;
		this.cy = tmp != null ? tmp : 0.0;
		var tmp = obj.r;
		this.r = tmp != null ? tmp : 0.0;
		var tmp = obj.fx;
		this.fx = tmp != null ? tmp : this.cx;
		var tmp = obj.fy;
		this.fy = tmp != null ? tmp : this.cy;
	}
	,saveProperties: function(out) {
		out.attr("colors",this.colors);
		out.attr("ratios",this.ratios);
		out.attr("cx",this.cx);
		out.attr("cy",this.cy);
		out.attr("r",this.r);
		out.attr("fx",this.fx,this.cx);
		out.attr("fy",this.fy,this.cy);
		nanofl_engine_strokes_BaseStroke.prototype.saveBaseProperties.call(this,out);
	}
	,savePropertiesJson: function(obj) {
		obj.colors = this.colors;
		obj.ratios = this.ratios;
		obj.cx = this.cx;
		obj.cy = this.cy;
		obj.r = this.r;
		var tmp = this.fx;
		obj.fx = tmp != null ? tmp : this.cx;
		var tmp = this.fy;
		obj.fy = tmp != null ? tmp : this.cy;
		this.saveBasePropertiesJson(obj);
	}
	,begin: function(g) {
		g.beginRadialGradientStroke(this.colors,this.ratios,this.fx,this.fy,0,this.cx,this.cy,this.r);
		this.setStrokeStyle(g);
	}
	,clone: function() {
		return new nanofl_engine_strokes_RadialStroke(this.colors,this.ratios,this.cx,this.cy,this.r,this.fx,this.fy,this.thickness,this.caps,this.joints,this.miterLimit,this.ignoreScale);
	}
	,equ: function(e) {
		if(e == this) {
			return true;
		}
		if(!((e) instanceof nanofl_engine_strokes_RadialStroke) || !nanofl_engine_strokes_BaseStroke.prototype.equ.call(this,e)) {
			return false;
		}
		var ee = e;
		if(this.arrEqu(ee.colors,this.colors) && this.arrEqu(ee.ratios,this.ratios) && ee.cx == this.cx && ee.cy == this.cy && ee.r == this.r && ee.fx == this.fx) {
			return ee.fy == this.fy;
		} else {
			return false;
		}
	}
	,swapInstance: function(oldNamePath,newNamePath) {
	}
	,applyAlpha: function(alpha) {
		var _g = 0;
		var _g1 = this.colors.length;
		while(_g < _g1) {
			var i = _g++;
			var rgba = nanofl_engine_ColorTools.parse(this.colors[i]);
			rgba.a *= alpha;
			this.colors[i] = nanofl_engine_ColorTools.rgbaToString(rgba);
		}
	}
	,getTransformed: function(m,applyToThickness) {
		var stroke = nanofl_engine_strokes_BaseStroke.prototype.getTransformed.call(this,m,applyToThickness);
		var c = m.transformPoint(this.cx,this.cy);
		stroke.cx = c.x;
		stroke.cy = c.y;
		var f = m.transformPoint(this.fx,this.fy);
		stroke.fx = f.x;
		stroke.fy = f.y;
		stroke.r *= m.getAverageScale();
		return stroke;
	}
	,getTyped: function() {
		return nanofl_engine_strokes_TypedStroke.radial(this);
	}
	,toString: function() {
		var _this = this.colors;
		var result = new Array(_this.length);
		var _g = 0;
		var _g1 = _this.length;
		while(_g < _g1) {
			var i = _g++;
			result[i] = "\"" + _this[i] + "\"";
		}
		return "new RadialStroke(" + Std.string(result) + (", " + Std.string(this.ratios) + ", " + this.cx + ", " + this.cy + ", " + this.r + ", " + this.fx + ", " + this.fy + ")");
	}
	,arrEqu: function(a,b) {
		if(a.length != b.length) {
			return false;
		}
		var _g = 0;
		var _g1 = a.length;
		while(_g < _g1) {
			var i = _g++;
			if(a[i] != b[i]) {
				return false;
			}
		}
		return true;
	}
	,__class__: nanofl_engine_strokes_RadialStroke
});
var nanofl_engine_strokes_SelectionStroke = function(base,scale) {
	if(nanofl_engine_strokes_SelectionStroke.pattern == null) {
		nanofl_engine_strokes_SelectionStroke.pattern = new createjs.Shape();
		nanofl_engine_strokes_SelectionStroke.pattern.graphics.beginFill("rgba(0,0,0,0.75)").rect(0,0,2,2).rect(2,2,2,2).endFill().beginFill("rgba(255,255,255,0.75)").rect(2,0,2,2).rect(0,2,2,2).endFill();
		nanofl_engine_strokes_SelectionStroke.pattern.cache(0,0,4,4);
	}
	nanofl_engine_strokes_BaseStroke.call(this,Math.max(4,base.ignoreScale ? base.thickness : base.thickness / scale),base.caps,base.joints,base.miterLimit,true);
};
nanofl_engine_strokes_SelectionStroke.__name__ = "nanofl.engine.strokes.SelectionStroke";
nanofl_engine_strokes_SelectionStroke.__interfaces__ = [nanofl_engine_strokes_IStroke];
nanofl_engine_strokes_SelectionStroke.__super__ = nanofl_engine_strokes_BaseStroke;
nanofl_engine_strokes_SelectionStroke.prototype = $extend(nanofl_engine_strokes_BaseStroke.prototype,{
	begin: function(g) {
		g.beginBitmapStroke(nanofl_engine_strokes_SelectionStroke.pattern.cacheCanvas,"repeat");
		this.setStrokeStyle(g);
	}
	,swapInstance: function(oldNamePath,newNamePath) {
	}
	,applyAlpha: function(alpha) {
	}
	,getTyped: function() {
		return null;
	}
	,toString: function() {
		return "new SelectionStroke()";
	}
	,loadProperties: function(node) {
		stdlib_Debug.methodNotSupported(this,{ fileName : "engine/nanofl/engine/strokes/SelectionStroke.hx", lineNumber : 39, className : "nanofl.engine.strokes.SelectionStroke", methodName : "loadProperties"});
	}
	,loadPropertiesJson: function(obj) {
		stdlib_Debug.methodNotSupported(this,{ fileName : "engine/nanofl/engine/strokes/SelectionStroke.hx", lineNumber : 41, className : "nanofl.engine.strokes.SelectionStroke", methodName : "loadPropertiesJson"});
	}
	,saveProperties: function(out) {
		stdlib_Debug.methodNotSupported(this,{ fileName : "engine/nanofl/engine/strokes/SelectionStroke.hx", lineNumber : 43, className : "nanofl.engine.strokes.SelectionStroke", methodName : "saveProperties"});
	}
	,savePropertiesJson: function(obj) {
		stdlib_Debug.methodNotSupported(this,{ fileName : "engine/nanofl/engine/strokes/SelectionStroke.hx", lineNumber : 45, className : "nanofl.engine.strokes.SelectionStroke", methodName : "savePropertiesJson"});
	}
	,__class__: nanofl_engine_strokes_SelectionStroke
});
var nanofl_engine_strokes_SolidStroke = function(color,thickness,caps,joints,miterLimit,ignoreScale) {
	if(ignoreScale == null) {
		ignoreScale = false;
	}
	if(miterLimit == null) {
		miterLimit = 3.0;
	}
	if(joints == null) {
		joints = "round";
	}
	if(caps == null) {
		caps = "round";
	}
	if(thickness == null) {
		thickness = 1.0;
	}
	if(color == null) {
		color = "black";
	}
	nanofl_engine_strokes_BaseStroke.call(this,thickness,caps,joints,miterLimit,ignoreScale);
	this.color = color;
};
nanofl_engine_strokes_SolidStroke.__name__ = "nanofl.engine.strokes.SolidStroke";
nanofl_engine_strokes_SolidStroke.__interfaces__ = [nanofl_engine_strokes_IStroke];
nanofl_engine_strokes_SolidStroke.__super__ = nanofl_engine_strokes_BaseStroke;
nanofl_engine_strokes_SolidStroke.prototype = $extend(nanofl_engine_strokes_BaseStroke.prototype,{
	loadProperties: function(node) {
		this.loadBaseProperties(node);
		this.color = htmlparser_HtmlParserTools.getAttr(node,"color","#000000");
	}
	,loadPropertiesJson: function(obj) {
		this.loadBasePropertiesJson(obj);
		var tmp = obj.color;
		this.color = tmp != null ? tmp : "#000000";
	}
	,saveProperties: function(out) {
		out.attr("color",this.color);
		this.saveBaseProperties(out);
	}
	,savePropertiesJson: function(obj) {
		obj.color = this.color;
		this.saveBasePropertiesJson(obj);
	}
	,begin: function(g) {
		g.beginStroke(this.color);
		this.setStrokeStyle(g);
	}
	,clone: function() {
		return new nanofl_engine_strokes_SolidStroke(this.color,this.thickness,this.caps,this.joints,this.miterLimit,this.ignoreScale);
	}
	,equ: function(e) {
		if(e == this) {
			return true;
		}
		if(!((e) instanceof nanofl_engine_strokes_SolidStroke) || !nanofl_engine_strokes_BaseStroke.prototype.equ.call(this,e)) {
			return false;
		}
		var ee = e;
		return ee.color == this.color;
	}
	,swapInstance: function(oldNamePath,newNamePath) {
	}
	,applyAlpha: function(alpha) {
		var rgba = nanofl_engine_ColorTools.parse(this.color);
		if(rgba == null) {
			throw new Error("Can't parse color '" + this.color + "'.");
		}
		rgba.a *= alpha;
		this.color = nanofl_engine_ColorTools.rgbaToString(rgba);
	}
	,getTyped: function() {
		return nanofl_engine_strokes_TypedStroke.solid(this);
	}
	,toString: function() {
		return "new SolidStroke(\"" + this.color + "\")";
	}
	,__class__: nanofl_engine_strokes_SolidStroke
});
var nanofl_engine_strokes_TypedStroke = $hxEnums["nanofl.engine.strokes.TypedStroke"] = { __ename__:"nanofl.engine.strokes.TypedStroke",__constructs__:null
	,solid: ($_=function(stroke) { return {_hx_index:0,stroke:stroke,__enum__:"nanofl.engine.strokes.TypedStroke",toString:$estr}; },$_._hx_name="solid",$_.__params__ = ["stroke"],$_)
	,linear: ($_=function(stroke) { return {_hx_index:1,stroke:stroke,__enum__:"nanofl.engine.strokes.TypedStroke",toString:$estr}; },$_._hx_name="linear",$_.__params__ = ["stroke"],$_)
	,radial: ($_=function(stroke) { return {_hx_index:2,stroke:stroke,__enum__:"nanofl.engine.strokes.TypedStroke",toString:$estr}; },$_._hx_name="radial",$_.__params__ = ["stroke"],$_)
	,bitmap: ($_=function(stroke) { return {_hx_index:3,stroke:stroke,__enum__:"nanofl.engine.strokes.TypedStroke",toString:$estr}; },$_._hx_name="bitmap",$_.__params__ = ["stroke"],$_)
};
nanofl_engine_strokes_TypedStroke.__constructs__ = [nanofl_engine_strokes_TypedStroke.solid,nanofl_engine_strokes_TypedStroke.linear,nanofl_engine_strokes_TypedStroke.radial,nanofl_engine_strokes_TypedStroke.bitmap];
var stdlib_Debug = function() { };
stdlib_Debug.__name__ = "stdlib.Debug";
stdlib_Debug.getDump = function(v,limit,level,prefix) {
	if(prefix == null) {
		prefix = "";
	}
	if(level == null) {
		level = 0;
	}
	if(limit == null) {
		limit = 10;
	}
	if(level >= limit) {
		return "...\n";
	}
	prefix += "\t";
	var s = "?\n";
	var _g = Type.typeof(v);
	switch(_g._hx_index) {
	case 0:
		s = "NULL\n";
		break;
	case 1:
		s = "INT(" + Std.string(v) + ")\n";
		break;
	case 2:
		s = "FLOAT(" + Std.string(v) + ")\n";
		break;
	case 3:
		s = "BOOL(" + (v ? "true" : "false") + ")\n";
		break;
	case 4:
		s = "OBJECT" + "\n" + stdlib_Debug.getObjectDump(v,limit,level + 1,prefix);
		break;
	case 5:
		s = "FUNCTION\n";
		break;
	case 6:
		var c = _g.c;
		if(c == String) {
			s = "STRING(" + Std.string(v) + ")\n";
		} else if(c == Array) {
			s = "ARRAY(" + Std.string(v.length) + ")\n";
			var _g1 = 0;
			var _g2 = js_Boot.__cast(v , Array);
			while(_g1 < _g2.length) {
				var item = _g2[_g1];
				++_g1;
				s += prefix + stdlib_Debug.getDump(item,limit,level + 1,prefix);
			}
		} else if(c == haxe_ds_List) {
			s = "LIST(" + Lambda.count(v) + ")\n";
			var _g_head = (js_Boot.__cast(v , haxe_ds_List)).h;
			while(_g_head != null) {
				var val = _g_head.item;
				_g_head = _g_head.next;
				var item = val;
				s += prefix + stdlib_Debug.getDump(item,limit,level + 1,prefix);
			}
		} else if(c == haxe_ds_StringMap) {
			s = "StringMap\n";
			var map = js_Boot.__cast(v , haxe_ds_StringMap);
			var h = map.h;
			var _g_h = h;
			var _g_keys = Object.keys(h);
			var _g_length = _g_keys.length;
			var _g_current = 0;
			while(_g_current < _g_length) {
				var key = _g_keys[_g_current++];
				s += prefix + key + " => " + stdlib_Debug.getDump(map.h[key],limit,level + 1,prefix);
			}
		} else {
			s = "CLASS(" + c.__name__ + ")\n" + stdlib_Debug.getObjectDump(v,limit,level + 1,prefix);
		}
		break;
	case 7:
		var e = _g.e;
		var e1 = v;
		s = "ENUM(" + e.__ename__ + ") = " + $hxEnums[e1.__enum__].__constructs__[e1._hx_index]._hx_name + "\n";
		break;
	case 8:
		s = "UNKNOW\n";
		break;
	}
	return s;
};
stdlib_Debug.getObjectDump = function(obj,limit,level,prefix) {
	var s = "";
	var _g = 0;
	var _g1 = Reflect.fields(obj);
	while(_g < _g1.length) {
		var fieldName = _g1[_g];
		++_g;
		s += prefix + fieldName + " : " + stdlib_Debug.getDump(Reflect.field(obj,fieldName),limit,level,prefix);
	}
	return s;
};
stdlib_Debug.assert = function(e,message,pos) {
	if(!e) {
		if(message == null) {
			message = "error";
		} else if(Reflect.isFunction(message)) {
			message = message();
		}
		var s = "ASSERT " + Std.string(message) + " in " + pos.fileName + " at line " + pos.lineNumber;
		throw new Error(s);
	}
};
stdlib_Debug.traceStack = function(v,pos) {
	var stack = stdlib_StringTools.trim(StringTools.replace(haxe_CallStack.toString(haxe_CallStack.callStack()),"prototype<.",""));
	var _g = [];
	var _g1 = 0;
	var _g2 = stack.split("\n");
	while(_g1 < _g2.length) {
		var v1 = _g2[_g1];
		++_g1;
		if(v1 != "Called from module") {
			_g.push(v1);
		}
	}
	var _this = _g;
	var result = new Array(_this.length);
	var _g = 0;
	var _g1 = _this.length;
	while(_g < _g1) {
		var i = _g++;
		var _this1 = _this[i].split("@");
		var result1 = new Array(_this1.length);
		var _g2 = 0;
		var _g3 = _this1.length;
		while(_g2 < _g3) {
			var i1 = _g2++;
			result1[i1] = stdlib_StringTools.rtrim(_this1[i1],"</");
		}
		result[i] = result1.join("@");
	}
	var lines = result;
	var len = 0;
	var _g = 0;
	while(_g < lines.length) {
		var line = lines[_g];
		++_g;
		var b = line.indexOf("@");
		if(len <= b) {
			len = b;
		}
	}
	var result = new Array(lines.length);
	var _g = 0;
	var _g1 = lines.length;
	while(_g < _g1) {
		var i = _g++;
		var ss = lines[i].split("@");
		result[i] = ss[0] + StringTools.rpad(""," ",len - ss[0].length + 1) + ss[1];
	}
	lines = result;
	stack = lines.slice(1).join("\n");
	haxe_Log.trace("TRACE " + (typeof(v) == "string" ? v : stdlib_StringTools.trim(stdlib_Debug.getDump(v))) + "\nStack trace:\n" + stack,{ fileName : "stdlib/Debug.hx", lineNumber : 189, className : "stdlib.Debug", methodName : "traceStack", customParams : [pos]});
};
stdlib_Debug.methodNotSupported = function(_this,pos) {
	var c = js_Boot.getClass(_this);
	throw new haxe_Exception("Method " + pos.methodName + "() is not supported by class " + c.__name__ + ".");
};
var stdlib_Event = function(target) {
	this.target = target;
	this.handlers = [];
};
stdlib_Event.__name__ = "stdlib.Event";
stdlib_Event.prototype = {
	bind: function(handler) {
		this.handlers.push(handler);
	}
	,unbind: function(handler) {
		while(HxOverrides.remove(this.handlers,handler)) {
		}
	}
	,unbindAll: function() {
		this.handlers = [];
	}
	,call: function(args) {
		var _g = 0;
		var _g1 = this.handlers;
		while(_g < _g1.length) {
			var handler = _g1[_g];
			++_g;
			handler.apply(null,[this.target,args]);
		}
	}
	,__class__: stdlib_Event
};
var stdlib_ExceptionTools = function() { };
stdlib_ExceptionTools.__name__ = "stdlib.ExceptionTools";
stdlib_ExceptionTools.string = function(e) {
	if(((e) instanceof haxe_Exception)) {
		return e.details();
	}
	return Std.string(e);
};
stdlib_ExceptionTools.rethrow = function(exception) {
	throw haxe_Exception.thrown(stdlib_ExceptionTools.wrap(exception));
};
stdlib_ExceptionTools.wrap = function(e) {
	if(!((e) instanceof haxe_Exception)) {
		return new haxe_Exception(Std.string(e));
	}
	return e;
};
var stdlib_LambdaArray = function() { };
stdlib_LambdaArray.__name__ = "stdlib.LambdaArray";
stdlib_LambdaArray.addRange = function(arr,range) {
	var _g = 0;
	while(_g < range.length) {
		var e = range[_g];
		++_g;
		arr.push(e);
	}
};
stdlib_LambdaArray.insertRange = function(arr,pos,range) {
	var _g = 0;
	while(_g < range.length) {
		var e = range[_g];
		++_g;
		arr.splice(pos++,0,e);
	}
};
stdlib_LambdaArray.extract = function(arr,f) {
	var r = [];
	var i = 0;
	while(i < arr.length) if(f(arr[i])) {
		r.push(arr[i]);
		arr.splice(i,1);
	} else {
		++i;
	}
	return r;
};
stdlib_LambdaArray.spliceEx = function(arr,pos,len,replacement) {
	var r = arr.splice(pos,len != null ? len : arr.length - pos);
	if(replacement != null) {
		stdlib_LambdaArray.insertRange(arr,pos,replacement);
	}
	return r;
};
stdlib_LambdaArray.filterByType = function(arr,klass) {
	var _g = [];
	var _g1 = 0;
	var _g2 = arr;
	while(_g1 < _g2.length) {
		var v = _g2[_g1];
		++_g1;
		if(js_Boot.__instanceof(v,klass)) {
			_g.push(v);
		}
	}
	return _g;
};
stdlib_LambdaArray.distinct = function(arr,equFunc) {
	var r = [];
	if(equFunc == null) {
		var _g = 0;
		while(_g < arr.length) {
			var x = arr[_g];
			++_g;
			if(r.indexOf(x) == -1) {
				r.push(x);
			}
		}
	} else {
		var _g = 0;
		while(_g < arr.length) {
			var x = [arr[_g]];
			++_g;
			if(!Lambda.exists(r,(function(x) {
				return function(y) {
					return equFunc(x[0],y);
				};
			})(x))) {
				r.push(x[0]);
			}
		}
	}
	return r;
};
var stdlib_LambdaIterable = function() { };
stdlib_LambdaIterable.__name__ = "stdlib.LambdaIterable";
stdlib_LambdaIterable.findIndex = function(it,f) {
	var n = 0;
	var x = $getIterator(it);
	while(x.hasNext()) {
		var x1 = x.next();
		if(f(x1)) {
			return n;
		}
		++n;
	}
	return -1;
};
stdlib_LambdaIterable.findLastIndex = function(it,f) {
	var r = -1;
	var n = 0;
	var x = $getIterator(it);
	while(x.hasNext()) {
		var x1 = x.next();
		if(f(x1)) {
			r = n;
		}
		++n;
	}
	return r;
};
stdlib_LambdaIterable.sorted = function(it,cmp) {
	var r = Lambda.array(it);
	r.sort(cmp != null ? cmp : Reflect.compare);
	return r;
};
stdlib_LambdaIterable.filterByType = function(it,klass) {
	var r = [];
	var x = $getIterator(it);
	while(x.hasNext()) {
		var x1 = x.next();
		if(js_Boot.__instanceof(x1,klass)) {
			r.push(x1);
		}
	}
	return r;
};
var stdlib_LambdaIterator = function() { };
stdlib_LambdaIterator.__name__ = "stdlib.LambdaIterator";
stdlib_LambdaIterator.array = function(it) {
	var r = [];
	var e = it;
	while(e.hasNext()) {
		var e1 = e.next();
		r.push(e1);
	}
	return r;
};
stdlib_LambdaIterator.indexOf = function(it,elem) {
	var r = 0;
	while(it.hasNext()) {
		if(it.next() == elem) {
			return r;
		}
		++r;
	}
	return -1;
};
stdlib_LambdaIterator.map = function(it,conv) {
	var r = [];
	var e = it;
	while(e.hasNext()) {
		var e1 = e.next();
		r.push(conv(e1));
	}
	return r;
};
stdlib_LambdaIterator.filter = function(it,pred) {
	var r = [];
	var e = it;
	while(e.hasNext()) {
		var e1 = e.next();
		if(pred(e1)) {
			r.push(e1);
		}
	}
	return r;
};
stdlib_LambdaIterator.exists = function(it,pred) {
	var e = it;
	while(e.hasNext()) {
		var e1 = e.next();
		if(pred(e1)) {
			return true;
		}
	}
	return false;
};
stdlib_LambdaIterator.count = function(it,pred) {
	var n = 0;
	if(pred == null) {
		var _ = it;
		while(_.hasNext()) {
			var _1 = _.next();
			++n;
		}
	} else {
		var x = it;
		while(x.hasNext()) {
			var x1 = x.next();
			if(pred(x1)) {
				++n;
			}
		}
	}
	return n;
};
stdlib_LambdaIterator.findIndex = function(it,f) {
	var n = 0;
	var x = it;
	while(x.hasNext()) {
		var x1 = x.next();
		if(f(x1)) {
			return n;
		}
		++n;
	}
	return -1;
};
stdlib_LambdaIterator.findLastIndex = function(it,f) {
	var r = -1;
	var n = 0;
	var x = it;
	while(x.hasNext()) {
		var x1 = x.next();
		if(f(x1)) {
			r = n;
		}
		++n;
	}
	return r;
};
stdlib_LambdaIterator.sorted = function(it,cmp) {
	var r = stdlib_LambdaIterator.array(it);
	r.sort(cmp != null ? cmp : Reflect.compare);
	return r;
};
stdlib_LambdaIterator.join = function(it,sep) {
	var r_b = "";
	var isFirst = true;
	var x = it;
	while(x.hasNext()) {
		var x1 = x.next();
		if(!isFirst) {
			r_b += sep == null ? "null" : "" + sep;
		} else {
			isFirst = false;
		}
		r_b += Std.string(Std.string(x1));
	}
	return r_b;
};
var stdlib_Std = function() { };
stdlib_Std.__name__ = "stdlib.Std";
stdlib_Std.isOfType = function(v,t) {
	return js_Boot.__instanceof(v,t);
};
stdlib_Std.string = function(s) {
	return Std.string(s);
};
stdlib_Std.int = function(x) {
	return x | 0;
};
stdlib_Std.random = function(x) {
	return Std.random(x);
};
stdlib_Std.parseInt = function(x,defaultValue) {
	if(x != null) {
		if(new EReg("^\\s*[+-]?\\s*((?:0x[0-9a-fA-F]{1,7})|(?:\\d{1,9}))\\s*$","").match(x)) {
			return Std.parseInt(x);
		} else {
			return defaultValue;
		}
	} else {
		return defaultValue;
	}
};
stdlib_Std.parseFloat = function(x,defaultValue) {
	if(x == null) {
		return defaultValue;
	}
	if(new EReg("^\\s*[+-]?\\s*\\d{1,20}(?:[.]\\d+)?(?:e[+-]?\\d{1,20})?\\s*$","").match(x)) {
		var r = parseFloat(x);
		if(!isNaN(r)) {
			return r;
		} else {
			return defaultValue;
		}
	}
	return defaultValue;
};
stdlib_Std.downcast = function(obj,_) {
	return obj;
};
stdlib_Std.bool = function(v) {
	if(v != false && v != null && v != 0 && v != "" && v != "0") {
		if(typeof(v) == "string") {
			if((js_Boot.__cast(v , String)).toLowerCase() != "false" && (js_Boot.__cast(v , String)).toLowerCase() != "off") {
				return (js_Boot.__cast(v , String)).toLowerCase() != "null";
			} else {
				return false;
			}
		} else {
			return true;
		}
	} else {
		return false;
	}
};
stdlib_Std.parseValue = function(x) {
	var value = x;
	var valueLC = value != null ? value.toLowerCase() : null;
	var parsedValue;
	if(valueLC == "true") {
		value = true;
	} else if(valueLC == "false") {
		value = false;
	} else if(valueLC == "null") {
		value = null;
	} else {
		parsedValue = stdlib_Std.parseInt(value);
		if(parsedValue != null) {
			value = parsedValue;
		} else {
			parsedValue = stdlib_Std.parseFloat(value);
			if(parsedValue != null) {
				value = parsedValue;
			}
		}
	}
	return value;
};
stdlib_Std.hash = function(obj) {
	var r = new haxe_ds_StringMap();
	var _g = 0;
	var _g1 = Reflect.fields(obj);
	while(_g < _g1.length) {
		var key = _g1[_g];
		++_g;
		r.h[key] = Reflect.field(obj,key);
	}
	return r;
};
stdlib_Std.min = function(a,b) {
	if(a < b) {
		return a;
	} else {
		return b;
	}
};
stdlib_Std.max = function(a,b) {
	if(a > b) {
		return a;
	} else {
		return b;
	}
};
stdlib_Std.abs = function(x) {
	if(x >= 0) {
		return x;
	} else {
		return -x;
	}
};
stdlib_Std.sign = function(n) {
	if(n > 0) {
		return 1;
	} else if(n < 0) {
		return -1;
	} else {
		return 0;
	}
};
var stdlib_StringTools = function() { };
stdlib_StringTools.__name__ = "stdlib.StringTools";
stdlib_StringTools.ltrim = function(s,chars) {
	if(chars == null) {
		return StringTools.ltrim(s);
	}
	while(s.length > 0 && chars.indexOf(HxOverrides.substr(s,0,1)) >= 0) s = HxOverrides.substr(s,1,null);
	return s;
};
stdlib_StringTools.rtrim = function(s,chars) {
	if(chars == null) {
		return StringTools.rtrim(s);
	}
	while(s.length > 0 && chars.indexOf(HxOverrides.substr(s,s.length - 1,1)) >= 0) s = HxOverrides.substr(s,0,s.length - 1);
	return s;
};
stdlib_StringTools.trim = function(s,chars) {
	if(chars == null) {
		return StringTools.trim(s);
	}
	return stdlib_StringTools.rtrim(stdlib_StringTools.ltrim(s,chars),chars);
};
stdlib_StringTools.hexdec = function(s) {
	return stdlib_Std.parseInt("0x" + s);
};
stdlib_StringTools.addcslashes = function(s) {
	return new EReg("['\"\t\r\n\\\\]","g").map(s,function(re) {
		return "\\" + re.matched(0);
	});
};
stdlib_StringTools.stripTags = function(str,allowedTags) {
	if(allowedTags == null) {
		allowedTags = "";
	}
	var allowedTagsArray = [];
	if(allowedTags != "") {
		var re = new EReg("[a-zA-Z0-9]+","i");
		var pos = 0;
		while(re.matchSub(allowedTags,pos)) {
			allowedTagsArray.push(re.matched(0));
			pos = re.matchedPos().pos + re.matchedPos().len;
		}
	}
	var re = new EReg("</?[\\S][^>]*>","g");
	str = re.map(str,function(_) {
		var html = re.matched(0);
		var allowed = false;
		if(allowedTagsArray.length > 0) {
			var htmlLC = html.toLowerCase();
			var _g = 0;
			while(_g < allowedTagsArray.length) {
				var allowedTag = allowedTagsArray[_g];
				++_g;
				if(StringTools.startsWith(htmlLC,"<" + allowedTag + ">") || StringTools.startsWith(htmlLC,"<" + allowedTag + " ") || StringTools.startsWith(htmlLC,"</" + allowedTag)) {
					allowed = true;
					break;
				}
			}
		}
		if(allowed) {
			return html;
		} else {
			return "";
		}
	});
	return str;
};
stdlib_StringTools.regexEscape = function(s) {
	var _this_r = new RegExp("([\\-\\[\\]/\\{\\}\\(\\)\\*\\+\\?\\.\\\\\\^\\$\\|])","g".split("u").join(""));
	return s.replace(_this_r,"\\$1");
};
stdlib_StringTools.jsonEscape = function(s) {
	if(s == null) {
		return "null";
	}
	var r = "\"";
	var _g_offset = 0;
	var _g_s = s;
	while(_g_offset < _g_s.length) {
		var s = _g_s;
		var index = _g_offset++;
		var c = s.charCodeAt(index);
		if(c >= 55296 && c <= 56319) {
			c = c - 55232 << 10 | s.charCodeAt(index + 1) & 1023;
		}
		var c1 = c;
		if(c1 >= 65536) {
			++_g_offset;
		}
		var c2 = c1;
		switch(c2) {
		case 9:
			r += "\\t";
			break;
		case 10:
			r += "\\n";
			break;
		case 13:
			r += "\\r";
			break;
		case 34:
			r += "\\\"";
			break;
		case 92:
			r += "\\\\";
			break;
		default:
			if(c2 < 32) {
				r += "\\u" + StringTools.hex(c2,4);
			} else {
				r += String.fromCodePoint(c2);
			}
		}
	}
	r += "\"";
	return r;
};
stdlib_StringTools.isNullOrEmpty = function(s) {
	if(s != null) {
		return s == "";
	} else {
		return true;
	}
};
stdlib_StringTools.capitalize = function(s) {
	if(s == "") {
		return s;
	} else {
		return HxOverrides.substr(s,0,1).toUpperCase() + HxOverrides.substr(s,1,null);
	}
};
stdlib_StringTools.urlEncode = function(s) {
	return encodeURIComponent(s);
};
stdlib_StringTools.urlDecode = function(s) {
	return decodeURIComponent(s.split("+").join(" "));
};
stdlib_StringTools.htmlEscape = function(s,quotes) {
	return StringTools.htmlEscape(s,quotes);
};
stdlib_StringTools.htmlUnescape = function(s) {
	return StringTools.htmlUnescape(s);
};
stdlib_StringTools.contains = function(s,value) {
	return s.indexOf(value) != -1;
};
stdlib_StringTools.startsWith = function(s,start) {
	return StringTools.startsWith(s,start);
};
stdlib_StringTools.endsWith = function(s,end) {
	return StringTools.endsWith(s,end);
};
stdlib_StringTools.isSpace = function(s,pos) {
	return StringTools.isSpace(s,pos);
};
stdlib_StringTools.lpad = function(s,c,l) {
	return StringTools.lpad(s,c,l);
};
stdlib_StringTools.rpad = function(s,c,l) {
	return StringTools.rpad(s,c,l);
};
stdlib_StringTools.replace = function(s,sub,by) {
	return StringTools.replace(s,sub,by);
};
stdlib_StringTools.hex = function(n,digits) {
	return StringTools.hex(n,digits);
};
stdlib_StringTools.fastCodeAt = function(s,index) {
	return s.charCodeAt(index);
};
stdlib_StringTools.unsafeCodeAt = function(s,index) {
	return s.charCodeAt(index);
};
stdlib_StringTools.iterator = function(s) {
	return new haxe_iterators_StringIterator(s);
};
stdlib_StringTools.keyValueIterator = function(s) {
	return new haxe_iterators_StringKeyValueIterator(s);
};
stdlib_StringTools.isEof = function(c) {
	return c != c;
};
stdlib_StringTools.quoteUnixArg = function(argument) {
	return StringTools.quoteUnixArg(argument);
};
stdlib_StringTools.quoteWinArg = function(argument,escapeMetaCharacters) {
	return StringTools.quoteWinArg(argument,escapeMetaCharacters);
};
function $iterator(o) { if( o instanceof Array ) return function() { return new haxe_iterators_ArrayIterator(o); }; return typeof(o.iterator) == 'function' ? $bind(o,o.iterator) : o.iterator; }
function $getIterator(o) { if( o instanceof Array ) return new haxe_iterators_ArrayIterator(o); else return o.iterator(); }
function $bind(o,m) { if( m == null ) return null; if( m.__id__ == null ) m.__id__ = $global.$haxeUID++; var f; if( o.hx__closures__ == null ) o.hx__closures__ = {}; else f = o.hx__closures__[m.__id__]; if( f == null ) { f = m.bind(o); o.hx__closures__[m.__id__] = f; } return f; }
$global.$haxeUID |= 0;
if(typeof(performance) != "undefined" ? typeof(performance.now) == "function" : false) {
	HxOverrides.now = performance.now.bind(performance);
}
if( String.fromCodePoint == null ) String.fromCodePoint = function(c) { return c < 0x10000 ? String.fromCharCode(c) : String.fromCharCode((c>>10)+0xD7C0)+String.fromCharCode((c&0x3FF)+0xDC00); }
Object.defineProperty(String.prototype,"__class__",{ value : String, enumerable : false, writable : true});
String.__name__ = "String";
Array.__name__ = "Array";
Date.prototype.__class__ = Date;
Date.__name__ = "Date";
var Int = { };
var Dynamic = { };
var Float = Number;
var Bool = Boolean;
var Class = { };
var Enum = { };
js_Boot.__toStr = ({ }).toString;
var q = window.jQuery;
var js = js || {}
js.JQuery = q;
haxe_SysTools.winMetaCharacters = [32,40,41,37,33,94,34,60,62,38,124,10,13,44,59];
haxe_Serializer.USE_CACHE = false;
haxe_Serializer.USE_ENUM_INDEX = false;
haxe_Serializer.BASE64 = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789%:";
htmlparser_CssSelector.reID = "[a-z](?:-?[_a-z0-9])*";
htmlparser_CssSelector.reNamespacedID = htmlparser_CssSelector.reID + "(?::" + htmlparser_CssSelector.reID + ")?";
htmlparser_CssSelector.reSelector = "(\\s*)((?:[>]\\s*)?)([.#]?)(" + htmlparser_CssSelector.reNamespacedID + "|[*])((?:\\[\\d+\\])?)";
htmlparser_HtmlParser.SELF_CLOSING_TAGS_HTML = { img : 1, br : 1, input : 1, meta : 1, link : 1, hr : 1, base : 1, embed : 1, spacer : 1, source : 1, param : 1};
htmlparser_HtmlParser.reID = "[a-z](?:-?[_a-z0-9])*";
htmlparser_HtmlParser.reNamespacedID = htmlparser_HtmlParser.reID + "(?::" + htmlparser_HtmlParser.reID + ")?";
htmlparser_HtmlParser.reCDATA = "[<]!\\[CDATA\\[[\\s\\S]*?\\]\\][>]";
htmlparser_HtmlParser.reScript = "[<]\\s*script\\s*([^>]*)>([\\s\\S]*?)<\\s*/\\s*script\\s*>";
htmlparser_HtmlParser.reStyle = "<\\s*style\\s*([^>]*)>([\\s\\S]*?)<\\s*/\\s*style\\s*>";
htmlparser_HtmlParser.reElementOpen = "<\\s*(" + htmlparser_HtmlParser.reNamespacedID + ")";
htmlparser_HtmlParser.reAttr = htmlparser_HtmlParser.reNamespacedID + "(?:\\s*=\\s*(?:'[^']*?'|\"[^\"]*?\"|[-_a-z0-9]+))?";
htmlparser_HtmlParser.reElementEnd = "(/)?\\s*>";
htmlparser_HtmlParser.reElementClose = "<\\s*/\\s*(" + htmlparser_HtmlParser.reNamespacedID + ")\\s*>";
htmlparser_HtmlParser.reComment = "<!--[\\s\\S]*?-->";
htmlparser_HtmlParser.reMain = new EReg("(" + htmlparser_HtmlParser.reCDATA + ")|(" + htmlparser_HtmlParser.reScript + ")|(" + htmlparser_HtmlParser.reStyle + ")|(" + htmlparser_HtmlParser.reElementOpen + "((?:\\s+" + htmlparser_HtmlParser.reAttr + ")*)\\s*" + htmlparser_HtmlParser.reElementEnd + ")|(" + htmlparser_HtmlParser.reElementClose + ")|(" + htmlparser_HtmlParser.reComment + ")","ig");
htmlparser_HtmlParser.reParseAttrs = new EReg("(" + htmlparser_HtmlParser.reNamespacedID + ")(?:\\s*=\\s*('[^']*'|\"[^\"]*\"|[-_a-z0-9]+))?","ig");
nanofl_DisplayObjectTools.autoHitArea = false;
nanofl_Mesh.DEG_TO_RAD = Math.PI / 180;
nanofl_Player.spriteSheets = { };
nanofl_TextField.PADDING = 2.0;
nanofl_TextField.fontHeightCache = new haxe_ds_StringMap();
nanofl_TextField.fontBaselineCoefCache = new haxe_ds_StringMap();
nanofl_TextField.editing = false;
nanofl_TextField.selectionStart = 0;
nanofl_TextField.selectionEnd = 0;
nanofl_engine_ColorTools.colors = { "aliceblue" : "#f0f8ff", "antiquewhite" : "#faebd7", "aqua" : "#00ffff", "aquamarine" : "#7fffd4", "azure" : "#f0ffff", "beige" : "#f5f5dc", "bisque" : "#ffe4c4", "black" : "#000000", "blanchedalmond" : "#ffebcd", "blue" : "#0000ff", "blueviolet" : "#8a2be2", "brown" : "#a52a2a", "burlywood" : "#deb887", "cadetblue" : "#5f9ea0", "chartreuse" : "#7fff00", "chocolate" : "#d2691e", "coral" : "#ff7f50", "cornflowerblue" : "#6495ed", "cornsilk" : "#fff8dc", "crimson" : "#dc143c", "cyan" : "#00ffff", "darkblue" : "#00008b", "darkcyan" : "#008b8b", "darkgoldenrod" : "#b8860b", "darkgray" : "#a9a9a9", "darkgreen" : "#006400", "darkkhaki" : "#bdb76b", "darkmagenta" : "#8b008b", "darkolivegreen" : "#556b2f", "darkorange" : "#ff8c00", "darkorchid" : "#9932cc", "darkred" : "#8b0000", "darksalmon" : "#e9967a", "darkseagreen" : "#8fbc8f", "darkslateblue" : "#483d8b", "darkslategray" : "#2f4f4f", "darkturquoise" : "#00ced1", "darkviolet" : "#9400d3", "deeppink" : "#ff1493", "deepskyblue" : "#00bfff", "dimgray" : "#696969", "dodgerblue" : "#1e90ff", "firebrick" : "#b22222", "floralwhite" : "#fffaf0", "forestgreen" : "#228b22", "fuchsia" : "#ff00ff", "gainsboro" : "#dcdcdc", "ghostwhite" : "#f8f8ff", "gold" : "#ffd700", "goldenrod" : "#daa520", "gray" : "#808080", "grey" : "#808080", "green" : "#008000", "greenyellow" : "#adff2f", "honeydew" : "#f0fff0", "hotpink" : "#ff69b4", "indianred " : "#cd5c5c", "indigo" : "#4b0082", "ivory" : "#fffff0", "khaki" : "#f0e68c", "lavender" : "#e6e6fa", "lavenderblush" : "#fff0f5", "lawngreen" : "#7cfc00", "lemonchiffon" : "#fffacd", "lightblue" : "#add8e6", "lightcoral" : "#f08080", "lightcyan" : "#e0ffff", "lightgoldenrodyellow" : "#fafad2", "lightgrey" : "#d3d3d3", "lightgreen" : "#90ee90", "lightpink" : "#ffb6c1", "lightsalmon" : "#ffa07a", "lightseagreen" : "#20b2aa", "lightskyblue" : "#87cefa", "lightslategray" : "#778899", "lightsteelblue" : "#b0c4de", "lightyellow" : "#ffffe0", "lime" : "#00ff00", "limegreen" : "#32cd32", "linen" : "#faf0e6", "magenta" : "#ff00ff", "maroon" : "#800000", "mediumaquamarine" : "#66cdaa", "mediumblue" : "#0000cd", "mediumorchid" : "#ba55d3", "mediumpurple" : "#9370d8", "mediumseagreen" : "#3cb371", "mediumslateblue" : "#7b68ee", "mediumspringgreen" : "#00fa9a", "mediumturquoise" : "#48d1cc", "mediumvioletred" : "#c71585", "midnightblue" : "#191970", "mintcream" : "#f5fffa", "mistyrose" : "#ffe4e1", "moccasin" : "#ffe4b5", "navajowhite" : "#ffdead", "navy" : "#000080", "oldlace" : "#fdf5e6", "olive" : "#808000", "olivedrab" : "#6b8e23", "orange" : "#ffa500", "orangered" : "#ff4500", "orchid" : "#da70d6", "palegoldenrod" : "#eee8aa", "palegreen" : "#98fb98", "paleturquoise" : "#afeeee", "palevioletred" : "#d87093", "papayawhip" : "#ffefd5", "peachpuff" : "#ffdab9", "peru" : "#cd853f", "pink" : "#ffc0cb", "plum" : "#dda0dd", "powderblue" : "#b0e0e6", "purple" : "#800080", "red" : "#ff0000", "rosybrown" : "#bc8f8f", "royalblue" : "#4169e1", "saddlebrown" : "#8b4513", "salmon" : "#fa8072", "sandybrown" : "#f4a460", "seagreen" : "#2e8b57", "seashell" : "#fff5ee", "sienna" : "#a0522d", "silver" : "#c0c0c0", "skyblue" : "#87ceeb", "slateblue" : "#6a5acd", "slategray" : "#708090", "snow" : "#fffafa", "springgreen" : "#00ff7f", "steelblue" : "#4682b4", "tan" : "#d2b48c", "teal" : "#008080", "thistle" : "#d8bfd8", "tomato" : "#ff6347", "turquoise" : "#40e0d0", "violet" : "#ee82ee", "wheat" : "#f5deb3", "white" : "#ffffff", "whitesmoke" : "#f5f5f5", "yellow" : "#ffff00", "yellowgreen" : "#9acd32", "transparent" : "rgba(0,0,0,0)"};
nanofl_engine_Debug.console = new nanofl_engine_Console();
nanofl_engine_movieclip_KeyFrame.__meta__ = { fields : { layer : { jsonIgnore : null}}};
nanofl_engine_ILibraryItem.__meta__ = { fields : { library : { jsonIgnore : null}}};
nanofl_engine_Library.SCENE_NAME_PATH = "scene";
nanofl_engine_ScaleMode.noScale = "noScale";
nanofl_engine_ScaleMode.fit = "fit";
nanofl_engine_ScaleMode.fill = "fill";
nanofl_engine_ScaleMode.stretch = "stretch";
nanofl_engine_ScaleMode.custom = "custom";
nanofl_engine_Version.ide = "5.0.0";
nanofl_engine_Version.player = "5.0.0";
nanofl_engine_Version.document = "2.3.0";
nanofl_engine_elements_Element.__meta__ = { fields : { parent : { jsonIgnore : null}}};
nanofl_engine_elements_Instance.__meta__ = { fields : { library : { jsonIgnore : null}}};
nanofl_engine_geom_BezierCurve.EPS = 1e-10;
nanofl_engine_geom_BezierCurve.GAP = 0.01;
nanofl_engine_geom_Contour.EPS = 1e-7;
nanofl_engine_geom_Edge.GAP = 0.01;
nanofl_engine_geom_Edges.GAP = 0.01;
nanofl_engine_geom_Edges.reFloat2 = new EReg("([-+0-9.]+),([-+0-9.]+)","");
nanofl_engine_geom_Edges.reFloat4 = new EReg("([-+0-9.]+),([-+0-9.]+),([-+0-9.]+),([-+0-9.]+)","");
nanofl_engine_geom_Edges.showSelection = true;
nanofl_engine_geom_Equation.EPS = 1e-10;
nanofl_engine_geom_Matrix.DEG_TO_RAD = Math.PI / 180;
nanofl_engine_geom_Polygon.showSelection = true;
nanofl_engine_geom_StraightLine.EPS = 1e-10;
nanofl_engine_libraryitems_LibraryItem.__meta__ = { fields : { library : { jsonIgnore : null}}};
nanofl_engine_libraryitems_MeshItem.DEFAULT_RENDER_AREA_SIZE = 256;
nanofl_engine_libraryitems_SpriteItem.__meta__ = { fields : { _layers : { jsonIgnore : null}, spriteSheet : { jsonIgnore : null}}};
nanofl_engine_movieclip_Layer.__meta__ = { fields : { layersContainer : { jsonIgnore : null}, parentLayer : { jsonIgnore : null}}};
nanofl_engine_movieclip_MotionTween.__meta__ = { fields : { keyFrame : { jsonIgnore : null}}};
nanofl_engine_plugins_FilterPlugins.plugins = new haxe_ds_StringMap();
})( true ? exports : 0, typeof window != "undefined" ? window : typeof __webpack_require__.g != "undefined" ? __webpack_require__.g : typeof self != "undefined" ? self : this);


/***/ }),

/***/ "three":
/*!************************!*\
  !*** external "three" ***!
  \************************/
/***/ ((module) => {

"use strict";
module.exports = three;

/***/ }),

/***/ "three/addons/loaders/GLTFLoader.js":
/*!***********************************!*\
  !*** external "three_GLTFLoader" ***!
  \***********************************/
/***/ ((module) => {

"use strict";
module.exports = three_GLTFLoader;

/***/ })

/******/ 	});
/************************************************************************/
/******/ 	// The module cache
/******/ 	var __webpack_module_cache__ = {};
/******/ 	
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/ 		// Check if module is in cache
/******/ 		var cachedModule = __webpack_module_cache__[moduleId];
/******/ 		if (cachedModule !== undefined) {
/******/ 			return cachedModule.exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = __webpack_module_cache__[moduleId] = {
/******/ 			// no module.id needed
/******/ 			// no module.loaded needed
/******/ 			exports: {}
/******/ 		};
/******/ 	
/******/ 		// Execute the module function
/******/ 		__webpack_modules__[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/ 	
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/ 	
/************************************************************************/
/******/ 	/* webpack/runtime/global */
/******/ 	(() => {
/******/ 		__webpack_require__.g = (function() {
/******/ 			if (typeof globalThis === 'object') return globalThis;
/******/ 			try {
/******/ 				return this || new Function('return this')();
/******/ 			} catch (e) {
/******/ 				if (typeof window === 'object') return window;
/******/ 			}
/******/ 		})();
/******/ 	})();
/******/ 	
/************************************************************************/
/******/ 	
/******/ 	// startup
/******/ 	// Load entry module and return exports
/******/ 	// This entry module is referenced by other modules so it can't be inlined
/******/ 	var __webpack_exports__ = __webpack_require__("./bin/nanofl-haxe.js");
/******/ 	var __webpack_export_target__ = (window = typeof window === "undefined" ? {} : window);
/******/ 	for(var i in __webpack_exports__) __webpack_export_target__[i] = __webpack_exports__[i];
/******/ 	if(__webpack_exports__.__esModule) Object.defineProperty(__webpack_export_target__, "__esModule", { value: true });
/******/ 	
/******/ })()
;// Generated by Haxe 4.3.3
(function ($hx_exports, $global) { "use strict";
$hx_exports["createjs"] = $hx_exports["createjs"] || {};
function $extend(from, fields) {
	var proto = Object.create(from);
	for (var name in fields) proto[name] = fields[name];
	if( fields.toString !== Object.prototype.toString ) proto.toString = fields.toString;
	return proto;
}
var AdjustColorFilterPlugin = function() {
	this.properties = [{ type : "int", name : "brightness", label : "Brightness", defaultValue : 0, minValue : -100, maxValue : 100, units : "%"},{ type : "int", name : "contrast", label : "Contrast", defaultValue : 0, minValue : -100, maxValue : 100, units : "%"},{ type : "int", name : "saturation", label : "Saturation", defaultValue : 0, minValue : -100, maxValue : 100, units : "%"},{ type : "int", name : "hue", label : "Hue", defaultValue : 0, minValue : -180, maxValue : 180, units : "deg"}];
	this.label = "Adjust Color";
	this.name = "AdjustColorFilter";
};
AdjustColorFilterPlugin.prototype = {
	getFilter: function(params) {
		return new createjs.ColorMatrixFilter(new createjs.ColorMatrix(Math.round(params.brightness / 100 * 255 * 0.4),params.contrast,params.saturation,params.hue).toArray());
	}
};
var BoxBlurFilterPlugin = function() {
	this.properties = [{ type : "float", name : "blurX", label : "Blur X", defaultValue : 10, neutralValue : 0, units : "px", minValue : 0},{ type : "float", name : "blurY", label : "Blur Y", defaultValue : 10, neutralValue : 0, units : "px", minValue : 0},{ type : "int", name : "quality", label : "Quality", defaultValue : 1, minValue : 1, maxValue : 3}];
	this.label = "Box Blur";
	this.name = "BoxBlurFilter";
};
BoxBlurFilterPlugin.prototype = {
	getFilter: function(params) {
		return new createjs.BlurFilter(params.blurX,params.blurY,params.quality);
	}
};
var DropShadowFilterPlugin = function() {
	this.properties = [{ type : "float", name : "blurX", label : "Blur X", defaultValue : 5, units : "px", minValue : 0},{ type : "float", name : "blurY", label : "Blur Y", defaultValue : 5, units : "px", minValue : 0},{ type : "int", name : "strength", label : "Strength", defaultValue : 100, units : "%", minValue : 0, maxValue : 100},{ type : "int", name : "quality", label : "Quality", defaultValue : 1, minValue : 1, maxValue : 3},{ type : "float", name : "angle", label : "Angle", defaultValue : 45, units : "deg", minValue : 0, maxValue : 360},{ type : "float", name : "distance", label : "Distance", defaultValue : 5, units : "px", minValue : 0},{ type : "bool", name : "knockout", label : "Knockout", defaultValue : false},{ type : "bool", name : "inner", label : "Inner shadow", defaultValue : false},{ type : "bool", name : "hideObject", label : "Hide object", defaultValue : false},{ type : "color", name : "color", label : "Color", defaultValue : "#000000"},{ type : "int", name : "alpha", label : "Alpha", defaultValue : 100, neutralValue : 0, units : "%", minValue : 0, maxValue : 100}];
	this.label = "Drop Shadow";
	this.name = "DropShadowFilter";
};
DropShadowFilterPlugin.prototype = {
	getFilter: function(params) {
		var rgb = nanofl.engine.ColorTools.parse(params.color);
		var color = rgb.r << 16 | rgb.g << 8 | rgb.b;
		return new createjs.DropShadowFilter(params.distance * 2,params.angle,color,params.alpha / 100 * (params.strength / 100),params.blurX * 2,params.blurY * 2,1,params.quality,params.inner,params.knockout,params.hideObject);
	}
};
var GaussianBlurFilterPlugin = function() {
	this.properties = [{ type : "int", name : "radius", label : "Radius", defaultValue : 10, neutralValue : 0, units : "px", minValue : 0}];
	this.label = "Gaussian Blur";
	this.name = "GaussianBlurFilterPlugin";
};
GaussianBlurFilterPlugin.prototype = {
	getFilter: function(params) {
		return new createjs_GaussianBlurFilter(params.radius);
	}
};
var GlowFilterPlugin = function() {
	this.properties = [{ type : "float", name : "blurX", label : "Blur X", defaultValue : 5, units : "px", minValue : 0},{ type : "float", name : "blurY", label : "Blur Y", defaultValue : 5, units : "px", minValue : 0},{ type : "int", name : "strength", label : "Strength", defaultValue : 100, units : "%", minValue : 0, maxValue : 100},{ type : "int", name : "quality", label : "Quality", defaultValue : 1, minValue : 1, maxValue : 3},{ type : "color", name : "color", label : "Color", defaultValue : "#000000"},{ type : "int", name : "alpha", label : "Alpha", defaultValue : 100, neutralValue : 0, units : "%", minValue : 0, maxValue : 100},{ type : "bool", name : "knockout", label : "Knockout", defaultValue : false},{ type : "bool", name : "inner", label : "Inner shadow", defaultValue : false}];
	this.label = "Glow";
	this.name = "GlowFilter";
};
GlowFilterPlugin.prototype = {
	getFilter: function(params) {
		var rgb = nanofl.engine.ColorTools.parse(params.color);
		var color = rgb.r << 16 | rgb.g << 8 | rgb.b;
		return new createjs.GlowFilter(color,params.alpha / 100 * (params.strength / 100),params.blurX * 2,params.blurY * 2,1,params.quality,params.inner,params.knockout);
	}
};
var StdFiltersPlugin = function() { };
StdFiltersPlugin.main = function() {
	nanofl.engine.plugins.FilterPlugins.register(new DropShadowFilterPlugin());
	nanofl.engine.plugins.FilterPlugins.register(new BoxBlurFilterPlugin());
	nanofl.engine.plugins.FilterPlugins.register(new GlowFilterPlugin());
	nanofl.engine.plugins.FilterPlugins.register(new AdjustColorFilterPlugin());
	nanofl.engine.plugins.FilterPlugins.register(new GaussianBlurFilterPlugin());
};
var createjs_GaussianBlurFilter = $hx_exports["createjs"]["GaussianBlurFilter"] = function(radius) {
	createjs.Filter.call(this);
	this.usesContext = true;
	this.radius = radius;
};
createjs_GaussianBlurFilter.__super__ = createjs.Filter;
createjs_GaussianBlurFilter.prototype = $extend(createjs.Filter.prototype,{
	applyFilter: function(ctx,x,y,width,height,targetCtx,targetX,targetY) {
		StackBlur.stackBlurCanvasRGBA(ctx.canvas,x,y,width,height,this.radius);
		return true;
	}
	,getBounds: function(rect) {
		if(rect != null) {
			rect.x -= this.radius;
			rect.y -= this.radius;
			rect.width += this.radius * 2;
			rect.height += this.radius * 2;
			return rect;
		}
		return new createjs.Rectangle(-this.radius,-this.radius,this.radius * 2,this.radius * 2);
	}
	,clone: function() {
		return new createjs_GaussianBlurFilter(this.radius);
	}
	,toString: function() {
		return "[GaussianBlurFilter]";
	}
});
var haxe_iterators_ArrayIterator = function(array) {
	this.current = 0;
	this.array = array;
};
haxe_iterators_ArrayIterator.prototype = {
	hasNext: function() {
		return this.current < this.array.length;
	}
	,next: function() {
		return this.array[this.current++];
	}
};
/*

StackBlur - a fast almost Gaussian Blur For Canvas

Version: 	0.5
Author:		Mario Klingemann
Contact: 	mario@quasimondo.com
Website:	http://www.quasimondo.com/StackBlurForCanvas
Twitter:	@quasimondo

In case you find this class useful - especially in commercial projects -
I am not totally unhappy for a small donation to my PayPal account
mario@quasimondo.de

Or support me on flattr: 
https://flattr.com/thing/72791/StackBlur-a-fast-almost-Gaussian-Blur-Effect-for-CanvasJavascript

Copyright (c) 2010 Mario Klingemann

Permission is hereby granted, free of charge, to any person
obtaining a copy of this software and associated documentation
files (the "Software"), to deal in the Software without
restriction, including without limitation the rights to use,
copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the
Software is furnished to do so, subject to the following
conditions:

The above copyright notice and this permission notice shall be
included in all copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES
OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT
HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY,
WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR
OTHER DEALINGS IN THE SOFTWARE.
*/

(function(window) {

var mul_table = [
        512,512,456,512,328,456,335,512,405,328,271,456,388,335,292,512,
        454,405,364,328,298,271,496,456,420,388,360,335,312,292,273,512,
        482,454,428,405,383,364,345,328,312,298,284,271,259,496,475,456,
        437,420,404,388,374,360,347,335,323,312,302,292,282,273,265,512,
        497,482,468,454,441,428,417,405,394,383,373,364,354,345,337,328,
        320,312,305,298,291,284,278,271,265,259,507,496,485,475,465,456,
        446,437,428,420,412,404,396,388,381,374,367,360,354,347,341,335,
        329,323,318,312,307,302,297,292,287,282,278,273,269,265,261,512,
        505,497,489,482,475,468,461,454,447,441,435,428,422,417,411,405,
        399,394,389,383,378,373,368,364,359,354,350,345,341,337,332,328,
        324,320,316,312,309,305,301,298,294,291,287,284,281,278,274,271,
        268,265,262,259,257,507,501,496,491,485,480,475,470,465,460,456,
        451,446,442,437,433,428,424,420,416,412,408,404,400,396,392,388,
        385,381,377,374,370,367,363,360,357,354,350,347,344,341,338,335,
        332,329,326,323,320,318,315,312,310,307,304,302,299,297,294,292,
        289,287,285,282,280,278,275,273,271,269,267,265,263,261,259];
        
   
var shg_table = [
	     9, 11, 12, 13, 13, 14, 14, 15, 15, 15, 15, 16, 16, 16, 16, 17, 
		17, 17, 17, 17, 17, 17, 18, 18, 18, 18, 18, 18, 18, 18, 18, 19, 
		19, 19, 19, 19, 19, 19, 19, 19, 19, 19, 19, 19, 19, 20, 20, 20,
		20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 21,
		21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21,
		21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 22, 22, 22, 22, 22, 22, 
		22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22,
		22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 23, 
		23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23,
		23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23,
		23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 
		23, 23, 23, 23, 23, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 
		24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24,
		24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24,
		24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24,
		24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24 ];

function premultiplyAlpha(imageData)
{
	var pixels = imageData.data;
	var size = imageData.width * imageData.height * 4;
	
	for (var i=0; i<size; i+=4)
	{
		var a = pixels[i+3] / 255;
		pixels[i  ] *= a;
		pixels[i+1] *= a;
		pixels[i+2] *= a;
	}
}

function unpremultiplyAlpha(imageData)
{
	var pixels = imageData.data;
	var size = imageData.width * imageData.height * 4;
	
	for (var i=0; i<size; i+=4)
	{
		var a = pixels[i+3];
		if (a != 0)
		{
			a = 255 / a;
			pixels[i  ] *= a;
			pixels[i+1] *= a;
			pixels[i+2] *= a;
		}
	}
}

function stackBlurCanvasRGBA( canvas, top_x, top_y, width, height, radius )
{
	if ( isNaN(radius) || radius < 1 ) return;
	radius |= 0;
	
	var context = canvas.getContext("2d");
	var imageData;
	
	try
	{
	  try
	  {
		imageData = context.getImageData( top_x, top_y, width, height );
	  }
	  catch(e)
	  {
		// NOTE: this part is supposedly only needed if you want to work with local files
		// so it might be okay to remove the whole try/catch block and just use
		// imageData = context.getImageData( top_x, top_y, width, height );
		try
		{
			netscape.security.PrivilegeManager.enablePrivilege("UniversalBrowserRead");
			imageData = context.getImageData( top_x, top_y, width, height );
		}
		catch(e)
		{
			alert("Cannot access local image");
			throw new Error("unable to access local image data: " + e);
			return;
		}
	  }
	}
	catch(e)
	{
	  alert("Cannot access image");
	  throw new Error("unable to access image data: " + e);
	}
	
	premultiplyAlpha(imageData);
	
	var pixels = imageData.data;
	
	var x, y, i, p, yp, yi, yw, r_sum, g_sum, b_sum, a_sum, 
	r_out_sum, g_out_sum, b_out_sum, a_out_sum,
	r_in_sum, g_in_sum, b_in_sum, a_in_sum, 
	pr, pg, pb, pa, rbs;
			
	var div = radius + radius + 1;
	var w4 = width << 2;
	var widthMinus1  = width - 1;
	var heightMinus1 = height - 1;
	var radiusPlus1  = radius + 1;
	var sumFactor = radiusPlus1 * ( radiusPlus1 + 1 ) / 2;
	
	var stackStart = new BlurStack();
	var stack = stackStart;
	for ( i = 1; i < div; i++ )
	{
		stack = stack.next = new BlurStack();
		if ( i == radiusPlus1 ) var stackEnd = stack;
	}
	stack.next = stackStart;
	var stackIn = null;
	var stackOut = null;
	
	yw = yi = 0;
	
	var mul_sum = mul_table[radius];
	var shg_sum = shg_table[radius];
	
	for ( y = 0; y < height; y++ )
	{
		r_in_sum = g_in_sum = b_in_sum = a_in_sum = r_sum = g_sum = b_sum = a_sum = 0;
		
		r_out_sum = radiusPlus1 * ( pr = pixels[yi] );
		g_out_sum = radiusPlus1 * ( pg = pixels[yi+1] );
		b_out_sum = radiusPlus1 * ( pb = pixels[yi+2] );
		a_out_sum = radiusPlus1 * ( pa = pixels[yi+3] );
		
		r_sum += sumFactor * pr;
		g_sum += sumFactor * pg;
		b_sum += sumFactor * pb;
		a_sum += sumFactor * pa;
		
		stack = stackStart;
		
		for( i = 0; i < radiusPlus1; i++ )
		{
			stack.r = pr;
			stack.g = pg;
			stack.b = pb;
			stack.a = pa;
			stack = stack.next;
		}
		
		for( i = 1; i < radiusPlus1; i++ )
		{
			p = yi + (( widthMinus1 < i ? widthMinus1 : i ) << 2 );
			rbs = radiusPlus1 - i;
			r_sum += ( stack.r = ( pr = pixels[p  ])) * rbs;
			g_sum += ( stack.g = ( pg = pixels[p+1])) * rbs;
			b_sum += ( stack.b = ( pb = pixels[p+2])) * rbs;
			a_sum += ( stack.a = ( pa = pixels[p+3])) * rbs;
			
			r_in_sum += pr;
			g_in_sum += pg;
			b_in_sum += pb;
			a_in_sum += pa;
			
			stack = stack.next;
		}
		
		
		stackIn = stackStart;
		stackOut = stackEnd;
		for ( x = 0; x < width; x++ )
		{
			pixels[yi]   = (r_sum * mul_sum) >> shg_sum;
			pixels[yi+1] = (g_sum * mul_sum) >> shg_sum;
			pixels[yi+2] = (b_sum * mul_sum) >> shg_sum;
			pixels[yi+3] = (a_sum * mul_sum) >> shg_sum;
			
			r_sum -= r_out_sum;
			g_sum -= g_out_sum;
			b_sum -= b_out_sum;
			a_sum -= a_out_sum;
			
			r_out_sum -= stackIn.r;
			g_out_sum -= stackIn.g;
			b_out_sum -= stackIn.b;
			a_out_sum -= stackIn.a;
			
			p =  ( yw + ( ( p = x + radius + 1 ) < widthMinus1 ? p : widthMinus1 ) ) << 2;
			
			r_in_sum += ( stackIn.r = pixels[p]);
			g_in_sum += ( stackIn.g = pixels[p+1]);
			b_in_sum += ( stackIn.b = pixels[p+2]);
			a_in_sum += ( stackIn.a = pixels[p+3]);
			
			r_sum += r_in_sum;
			g_sum += g_in_sum;
			b_sum += b_in_sum;
			a_sum += a_in_sum;
			
			stackIn = stackIn.next;
			
			r_out_sum += ( pr = stackOut.r );
			g_out_sum += ( pg = stackOut.g );
			b_out_sum += ( pb = stackOut.b );
			a_out_sum += ( pa = stackOut.a );
			
			r_in_sum -= pr;
			g_in_sum -= pg;
			b_in_sum -= pb;
			a_in_sum -= pa;
			
			stackOut = stackOut.next;
			
			yi += 4;
		}
		yw += width;
	}
	
	for ( x = 0; x < width; x++ )
	{
		g_in_sum = b_in_sum = a_in_sum = r_in_sum = g_sum = b_sum = a_sum = r_sum = 0;
		
		yi = x << 2;
		r_out_sum = radiusPlus1 * ( pr = pixels[yi]);
		g_out_sum = radiusPlus1 * ( pg = pixels[yi+1]);
		b_out_sum = radiusPlus1 * ( pb = pixels[yi+2]);
		a_out_sum = radiusPlus1 * ( pa = pixels[yi+3]);
		
		r_sum += sumFactor * pr;
		g_sum += sumFactor * pg;
		b_sum += sumFactor * pb;
		a_sum += sumFactor * pa;
		
		stack = stackStart;
		
		for( i = 0; i < radiusPlus1; i++ )
		{
			stack.r = pr;
			stack.g = pg;
			stack.b = pb;
			stack.a = pa;
			stack = stack.next;
		}
		
		yp = width;
		
		for( i = 1; i <= radius; i++ )
		{
			yi = ( yp + x ) << 2;
			rbs = radiusPlus1 - i;
			
			r_sum += ( stack.r = ( pr = pixels[yi  ])) * rbs;
			g_sum += ( stack.g = ( pg = pixels[yi+1])) * rbs;
			b_sum += ( stack.b = ( pb = pixels[yi+2])) * rbs;
			a_sum += ( stack.a = ( pa = pixels[yi+3])) * rbs;
		   
			r_in_sum += pr;
			g_in_sum += pg;
			b_in_sum += pb;
			a_in_sum += pa;
			
			stack = stack.next;
		
			if( i < heightMinus1 )
			{
				yp += width;
			}
		}
		
		yi = x;
		stackIn = stackStart;
		stackOut = stackEnd;
		for ( y = 0; y < height; y++ )
		{
			p = yi << 2;
			pixels[p]   = (r_sum * mul_sum) >> shg_sum;
			pixels[p+1] = (g_sum * mul_sum) >> shg_sum;
			pixels[p+2] = (b_sum * mul_sum) >> shg_sum;
			pixels[p+3] = (a_sum * mul_sum) >> shg_sum;
			
			r_sum -= r_out_sum;
			g_sum -= g_out_sum;
			b_sum -= b_out_sum;
			a_sum -= a_out_sum;
		   
			r_out_sum -= stackIn.r;
			g_out_sum -= stackIn.g;
			b_out_sum -= stackIn.b;
			a_out_sum -= stackIn.a;
			
			p = ( x + (( ( p = y + radiusPlus1) < heightMinus1 ? p : heightMinus1 ) * width )) << 2;
			
			r_sum += ( r_in_sum += ( stackIn.r = pixels[p]));
			g_sum += ( g_in_sum += ( stackIn.g = pixels[p+1]));
			b_sum += ( b_in_sum += ( stackIn.b = pixels[p+2]));
			a_sum += ( a_in_sum += ( stackIn.a = pixels[p+3]));
		   
			stackIn = stackIn.next;
			
			r_out_sum += ( pr = stackOut.r );
			g_out_sum += ( pg = stackOut.g );
			b_out_sum += ( pb = stackOut.b );
			a_out_sum += ( pa = stackOut.a );
			
			r_in_sum -= pr;
			g_in_sum -= pg;
			b_in_sum -= pb;
			a_in_sum -= pa;
			
			stackOut = stackOut.next;
			
			yi += width;
		}
	}
	
	unpremultiplyAlpha(imageData);
	
	context.putImageData( imageData, top_x, top_y );
}

function BlurStack()
{
	this.r = 0;
	this.g = 0;
	this.b = 0;
	this.a = 0;
	this.next = null;
}

window.StackBlur = {
	stackBlurCanvasRGBA: stackBlurCanvasRGBA
};

})(window);
/*
DropShadowFilter for EaselJS
GitHub : https://github.com/u-kudox/Filters_for_EaselJS
Contact and Bug reports : http://kudox.jp/contact or http://twitter.com/u_kudox
License : public domain
*/

/**
* @namespace createjs
**/

(function() {
	"use strict";

	/**
	* Applies a DropShadowFilter to DisplayObjects of EaselJS. This filter has inherited the Filter class of EaselJS and has used BlurFilter of EaselJS at the blurring process.
	* @class DropShadowFilter
	* @extends Filter
	* @constructor
	* @param [distance=4] {Number} The offset distance for the shadow. The default value is 4.
	* @param [angle=45] {Number} The angle of the shadow. Valid values are 0 to 360 degrees. The default value is 45.
	* @param [color=0x000000] {uint} The color of the shadow. The default value is 0x000000. Valid values are in the hexadecimal format 0xRRGGBB.
	* @param [alpha=1] {Number} The alpha transparency value for the shadow color. Valid values are 0 to 1. The default value is 1.
	* @param [blurX=0] {Number} The amount of horizontal blur. The default value is 0. This value is passed to BlurFilter of EaselJS.
	* @param [blurY=0] {Number} The amount of vertical blur. The default value is 0. This value is passed to BlurFilter of EaselJS.
	* @param [strength=1] {uint} The strength of the shadow. The default value is 1. Valid values are 0 to 255. But as for this value, a low value is more preferable.
	* @param [quality=1] {Number} The number of blur iterations. The default value is 1. This value is passed to BlurFilter of EaselJS.
	* @param [inner=false] {Boolean} Specifies whether or not the shadow is an inner shadow. The default value is false, expressing outer shadow.
	* @param [knockout=false] {Boolean} Specifies whether or not the object has a knockout effect. The default value is false, expressing no knockout effect.
	* @param [hideObject=false] {Boolean} Specifies whether or not the object is hidden. If the value is true, the object is hidden and only the shadow is visible. The default value is false, expressing the object is visible.
	* @example
	* <pre><code>_text = new createjs.Text("DropShadowFilter", "bold 64px Arial", "#CC0000");
_text.set({x:centerX, y:centerY, textAlign:"center", textBaseline:"middle"});
var distance = 3;
var angle = 90;
var color = 0x000000;
var alpha = 0.5;
var blurX = 4;
var blurY = 4;
var strength = 1;
var quality = 2;
var inner = false;
var knockout = false;
var hideObject = false;
_dropShadowFilter = new createjs.DropShadowFilter(distance, angle, color, alpha, blurX, blurY, strength, quality, inner, knockout, hideObject);
_text.filters = [_dropShadowFilter];
var bounds = _text.getBounds();
_text.cache(bounds.x, bounds.y, bounds.width, bounds.height);
_stage.addChild(_text);</code></pre>
	**/
	function DropShadowFilter(distance, angle, color, alpha, blurX, blurY, strength, quality, inner, knockout, hideObject) {
        this.Filter_constructor();
        this.usesContext = true; // say to BitmapCache to call `applyFilter()`, not `_applyFilter()`

		if (distance !== undefined) this._distance = distance;
		if (angle !== undefined) this._angle = (angle % 360 + 360) % 360;
		setOffset.call(this, this._distance, this._angle);
		if (!isNaN(color)) this.color = color;
		if (alpha !== undefined) this.alpha = alpha;
		this._blurFilter = new createjs.BlurFilter(blurX, blurY, quality);
		if (strength !== undefined) this.strength = strength >> 0;
		this.inner = !!inner;
		this.knockout = !!knockout;
		this.hideObject = !!hideObject;
	}

    var p = createjs.extend(DropShadowFilter, createjs.Filter);

	/**
	* The alpha transparency value for the shadow color. Valid values are 0 to 1. The default value is 1.
	* @property alpha
	* @type Number
	* @default 1
	**/
	p.alpha = 1;

	/**
	* The strength of the shadow. The default value is 1. Valid values are 0 to 255. But as for this value, a low value is more preferable.
	* @property strength
	* @type uint
	* @default 1
	**/
	p.strength = 1;

	/**
	* Specifies whether or not the shadow is an inner shadow. The default value is false, expressing outer shadow.
	* @property inner
	* @type Boolean
	* @default false
	**/
	p.inner = false;

	/**
	* Specifies whether or not the object has a knockout effect. The default value is false, expressing no knockout effect.
	* @property knockout
	* @type Boolean
	* @default false
	**/
	p.knockout = false;

	/**
	* Specifies whether or not the object is hidden. If the value is true, the object is hidden and only the shadow is visible. The default value is false, expressing the object is visible.
	* @property hideObject
	* @type Boolean
	* @default false
	**/
	p.hideObject = false;

	Object.defineProperties(p, {
		/**
		* The angle of the shadow. Valid values are 0 to 360 degrees. The default value is 45.
		* @property angle
		* @type Number
		* @default 45
		**/
		"angle" : {
			get : function() {
				return this._angle;
			},
			set : function(value) {
				value = (value % 360 + 360) % 360;
				setOffset.call(this, this._distance, value);
				return this._angle = value;
			},
			enumerable : true
		},

		/**
		* The offset distance for the shadow. The default value is 4.
		* @property distance
		* @type Number
		* @default 4
		**/
		"distance" : {
			get : function() {
				return this._distance;
			},
			set : function(value) {
				setOffset.call(this, value, this._angle);
				return this._distance = value;
			},
			enumerable : true
		},

		/**
		* The color of the shadow. The default value is 0x000000. Valid values are in the hexadecimal format 0xRRGGBB.
		* @property color
		* @type uint
		* @default 0x000000
		**/
		"color" : {
			get : function() {
				return this._red << 16 | this._green << 8 | this._blue;
			},
			set : function(value) {
				this._red = value >> 16 & 0xFF;
				this._green = value >> 8 & 0xFF;
				this._blue = value & 0xFF;
				return this.color;
			},
			enumerable : true
		},

		/**
		* The amount of horizontal blur. The default value is 0. This value is passed to BlurFilter of EaselJS.
		* @property blurX
		* @type Number
		* @default 0
		**/
		"blurX" : {
			get : function() {
				return this._blurFilter.blurX;
			},
			set : function(value) {
				return this._blurFilter.blurX = value;
			},
			enumerable : true
		},

		/**
		* The amount of vertical blur. The default value is 0. This value is passed to BlurFilter of EaselJS.
		* @property blurY
		* @type Number
		* @default 0
		**/
		"blurY" : {
			get : function() {
				return this._blurFilter.blurY;
			},
			set : function(value) {
				return this._blurFilter.blurY = value;
			},
			enumerable : true
		},

		/**
		* The number of blur iterations. The default value is 1. This value is passed to BlurFilter of EaselJS.
		* @property quality
		* @type Number
		* @default 1
		**/
		"quality" : {
			get : function() {
				return this._blurFilter.quality;
			},
			set : function(value) {
				return this._blurFilter.quality = value;
			},
			enumerable : true
		}
	});

	p._angle = 45;

	p._distance = 4;

	p._offsetX = 0;

	p._offsetY = 0;

	p._red = 0;

	p._green = 0;

	p._blue = 0;

	p._blurFilter = null;

	/**
	* Returns a rectangle with values indicating the margins required to draw the filter or null.
	* For example, a filter that will extend the drawing area 4 pixels to the left, and 7 pixels to the right
	* (but no pixels up or down) would return a rectangle with (x=-4, y=0, width=11, height=0).
	* @method getBounds
	* @return {Rectangle} a rectangle object indicating the margins required to draw the filter or null if the filter does not effect bounds.
	**/
	p.getBounds = function(rect) {
		rect = this._blurFilter.getBounds(rect) || new createjs.Rectangle();
		var ox = this._offsetX;
		var oy = this._offsetY;
		if (ox !== 0) {
			if (ox < 0) {
				rect.x += ox;
				rect.width += -ox;
			} else {
				rect.width += ox;
			}
		}
		if (oy !== 0) {
			if (oy < 0) {
				rect.y += oy;
				rect.height += -oy;
			} else {
				rect.height += oy;
			}
		}
		return rect;
	};

	/**
	* Applies the DropShadowFilter to the specified context.
	* @method applyFilter
	* @param ctx {CanvasRenderingContext2D} The 2D context to use as the source.
	* @param x {Number} The x position to use for the source rect.
	* @param y {Number} The y position to use for the source rect.
	* @param width {Number} The width to use for the source rect.
	* @param height {Number} The height to use for the source rect.
	* @param [targetCtx] {CanvasRenderingContext2D} The 2D context to draw the result to. Defaults to the context passed to ctx.
	* @param [targetX] {Number} The x position to draw the result to. Defaults to the value passed to x.
	* @param [targetY] {Number} The y position to draw the result to. Defaults to the value passed to y.
	* @return {Boolean} If the filter was applied successfully.
	**/
	p.applyFilter = function(ctx, x, y, width, height, targetCtx, targetX, targetY) {
		if ((this.alpha <= 0 || this.strength <= 0) && (!this.knockout && !this.hideObject)) {
			return true;
		}
		targetCtx = targetCtx || ctx;
		if (targetX === undefined) targetX = x;
		if (targetY === undefined) targetY = y;
		var tImgData = targetCtx.getImageData(targetX, targetY, width, height);
		var tData = tImgData.data;
		var dCvs = document.createElement("canvas");
		dCvs.width = width;
		dCvs.height = height;
		var dCtx = dCvs.getContext("2d");
		var dImgData = dCtx.getImageData(0, 0, width, height);
		var dData = dImgData.data;
		var inner = this.inner;
		var red = this._red;
		var green = this._green;
		var blue = this._blue;
		for (var i = 0, l = dData.length; i < l; i += 4) {
			var ia = i + 3;
			var alpha = tData[ia];
			if (!inner) {
				if (alpha !== 0) {
					dData[i] = red;
					dData[i + 1] = green;
					dData[i + 2] = blue;
					dData[ia] = alpha;
				}
			} else {
				if (alpha !== 255) {
					dData[i] = red;
					dData[i + 1] = green;
					dData[i + 2] = blue;
					dData[ia] = 255 - alpha;
				}
			}
		}
		dCtx.putImageData(dImgData, 0, 0);
		var strength = this.strength;
		if (0 < strength) {
			this._blurFilter.applyFilter(dCtx, 0, 0, width, height);
			if (255 < strength) strength = 255;
			for (var j = 1; j < strength; j++) {
				dCtx.drawImage(dCvs, 0, 0);
			}
		}
		var ga = this.alpha;
		if (ga < 0) ga = 0;
		else if (1 < ga) ga = 1;
		var gco;
		if (this.knockout) {
			if (inner) gco = "source-in";
			else gco = "source-out";
		} else {
			if (this.hideObject) {
				if (inner) gco = "source-in";
				else gco = "copy";
			} else {
				if (inner) gco = "source-atop";
				else gco = "destination-over";
			}
		}
		targetCtx.save();
		targetCtx.setTransform(1, 0, 0, 1, 0, 0);
		targetCtx.globalAlpha = ga;
		targetCtx.globalCompositeOperation = gco;
		targetCtx.drawImage(dCvs, targetX + this._offsetX, targetY + this._offsetY);
		targetCtx.restore();
		return true;
	};

	/**
	* Returns a clone of this DropShadowFilter instance.
	* @method clone
	* @return {DropShadowFilter} A clone of this DropShadowFilter instance.
	**/
	p.clone = function() {
		var f = this._blurFilter;
		return new createjs.DropShadowFilter(this._distance, this._angle, this.color, this.alpha, f.blurX, f.blurY, this.strength, f.quality, this.inner, this.knockout, this.hideObject);
	};

	/**
	* Returns a string representation of this filter.
	* @method toString
	* @return {String} A string representation of this filter.
	**/
	p.toString = function() {
		return "[DropShadowFilter]";
	};

	function setOffset(distance, angle) {
		var r = (angle) * createjs.Matrix2D.DEG_TO_RAD;
		this._offsetX = Math.cos(r) * distance;
		this._offsetY = Math.sin(r) * distance;
	}

    createjs.DropShadowFilter = createjs.promote(DropShadowFilter, "Filter");
}());
/*
GlowFilter for EaselJS
GitHub : https://github.com/u-kudox/Filters_for_EaselJS
Contact and Bug reports : http://kudox.jp/contact or http://twitter.com/u_kudox
License : public domain
*/

/**
* @namespace createjs
**/

(function() {
	"use strict";

	/**
	* Applies a GlowFilter to DisplayObjects of EaselJS. This filter has inherited the Filter class of EaselJS and has used BlurFilter of EaselJS at the blurring process.
	* @class GlowFilter
	* @extends Filter
	* @constructor
	* @param [color=0xFF0000] {uint} The color of the glow. The default value is 0xFF0000. Valid values are in the hexadecimal format 0xRRGGBB.
	* @param [alpha=1] {Number} The alpha transparency value for the glow color. Valid values are 0 to 1.
	* @param [blurX=0] {Number} The amount of horizontal blur. The default value is 0. This value is passed to BlurFilter of EaselJS.
	* @param [blurY=0] {Number} The amount of vertical blur. The default value is 0. This value is passed to BlurFilter of EaselJS.
	* @param [strength=1] {uint} The strength of the glow. The default value is 1. Valid values are 0 to 255. But as for this value, a low value is more preferable.
	* @param [quality=1] {Number} The number of blur iterations. The default value is 1. This value is passed to BlurFilter of EaselJS.
	* @param [inner=false] {Boolean} Specifies whether the glow is an inner glow. The default value is false, expressing outer glow.
	* @param [knockout=false] {Boolean} Specifies whether the object has a knockout effect. The default value is false, expressing no knockout effect.
	* @example
	* <pre><code>_shape = new createjs.Shape().set({x:centerX, y:centerY});
_shape.graphics.f("rgba(0,0,255,1)").dp(0, 0, 100, 5, 0.6, -90).ef();
var color = 0x00FFFF;
var alpha = 1;
var blurX = 32;
var blurY = 32;
var strength = 1;
var quality = 1;
var inner = false;
var knockout = false;
_glowFilter = new createjs.GlowFilter(color, alpha, blurX, blurY, strength, quality, inner, knockout);
_shape.filters = [_glowFilter];
_shape.cache(-100, -100, 200, 200);
_stage.addChild(_shape);</code></pre>
	**/
	function GlowFilter(color, alpha, blurX, blurY, strength, quality, inner, knockout) {
        this.Filter_constructor();
        this.usesContext = true; // say to BitmapCache to call `applyFilter()`, not `_applyFilter()`

		if (!isNaN(color)) this.color = color;
		if (alpha !== undefined) this.alpha = alpha;
		this._blurFilter = new createjs.BlurFilter(blurX, blurY, quality);
		if (strength !== undefined) this.strength = strength;
		this.inner = !!inner;
		this.knockout = !!knockout;
	}

    var p = createjs.extend(GlowFilter, createjs.Filter);

	/**
	* The alpha transparency value for the glow color. Valid values are 0 to 1.
	* @property alpha
	* @type Number
	* @default 1
	**/
	p.alpha = 1;

	/**
	* The strength of the glow. The default value is 1. Valid values are 0 to 255. But as for this value, a low value is more preferable.
	* @property strength
	* @type uint
	* @default 1
	**/
	p.strength = 1;

	/**
	* Specifies whether the glow is an inner glow. The default value is false, expressing outer glow.
	* @property inner
	* @type Boolean
	* @default false
	**/
	p.inner = false;

	/**
	* Specifies whether the object has a knockout effect. The default value is false, expressing no knockout effect.
	* @property knockout
	* @type Boolean
	* @default false
	**/
	p.knockout = false;

	Object.defineProperties(p, {
		/**
		* The color of the glow. The default value is 0xFF0000. Valid values are in the hexadecimal format 0xRRGGBB.
		* @property color
		* @type uint
		* @default 0xFF0000
		**/
		"color" : {
			get : function() {
				return this._red << 16 | this._green << 8 | this._blue;
			},
			set : function(value) {
				this._red = value >> 16 & 0xFF;
				this._green = value >> 8 & 0xFF;
				this._blue = value & 0xFF;
				return this.color;
			},
			enumerable : true
		},

		/**
		* The amount of horizontal blur. The default value is 0. This value is passed to BlurFilter of EaselJS.
		* @property blurX
		* @type Number
		* @default 0
		**/
		"blurX" : {
			get : function() {
				return this._blurFilter.blurX;
			},
			set : function(value) {
				return this._blurFilter.blurX = value;
			},
			enumerable : true
		},

		/**
		* The amount of vertical blur. The default value is 0. This value is passed to BlurFilter of EaselJS.
		* @property blurY
		* @type Number
		* @default 0
		**/
		"blurY" : {
			get : function() {
				return this._blurFilter.blurY;
			},
			set : function(value) {
				return this._blurFilter.blurY = value;
			},
			enumerable : true
		},

		/**
		* The number of blur iterations. The default value is 1. This value is passed to BlurFilter of EaselJS.
		* @property quality
		* @type Number
		* @default 1
		**/
		"quality" : {
			get : function() {
				return this._blurFilter.quality;
			},
			set : function(value) {
				return this._blurFilter.quality = value;
			},
			enumerable : true
		}
	});

	p._red = 255;

	p._green = 0;

	p._blue = 0;

	p._blurFilter = null;

	/**
	* Returns a rectangle with values indicating the margins required to draw the filter or null.
	* For example, a filter that will extend the drawing area 4 pixels to the left, and 7 pixels to the right
	* (but no pixels up or down) would return a rectangle with (x=-4, y=0, width=11, height=0).
	* @method getBounds
	* @return {Rectangle} a rectangle object indicating the margins required to draw the filter or null if the filter does not effect bounds.
	**/
	p.getBounds = function(rect) {
		if (this.inner) {
			return rect;
		} else {
			return this._blurFilter.getBounds(rect) || new createjs.Rectangle();
		}
	};

	/**
	* Applies the GlowFilter to the specified context.
	* @method applyFilter
	* @param ctx {CanvasRenderingContext2D} The 2D context to use as the source.
	* @param x {Number} The x position to use for the source rect.
	* @param y {Number} The y position to use for the source rect.
	* @param width {Number} The width to use for the source rect.
	* @param height {Number} The height to use for the source rect.
	* @param [targetCtx] {CanvasRenderingContext2D} The 2D context to draw the result to. Defaults to the context passed to ctx.
	* @param [targetX] {Number} The x position to draw the result to. Defaults to the value passed to x.
	* @param [targetY] {Number} The y position to draw the result to. Defaults to the value passed to y.
	* @return {Boolean} If the filter was applied successfully.
	**/
	p.applyFilter = function(ctx, x, y, width, height, targetCtx, targetX, targetY) {
		if ((this.alpha <= 0 || this.strength <= 0) && !this.knockout) {
			return true;
		}
		targetCtx = targetCtx || ctx;
		if (targetX === undefined) targetX = x;
		if (targetY === undefined) targetY = y;
		var tImgData = targetCtx.getImageData(targetX, targetY, width, height);
		var tData = tImgData.data;
		var dCvs = document.createElement("canvas");
		dCvs.width = width;
		dCvs.height = height;
		var dCtx = dCvs.getContext("2d");
		var dImgData = dCtx.getImageData(0, 0, width, height);
		var dData = dImgData.data;
		var inner = this.inner;
		var red = this._red;
		var green = this._green;
		var blue = this._blue;
		for (var i = 0, l = dData.length; i < l; i += 4) {
			var ia = i + 3;
			var alpha = tData[ia];
			if (!inner) {
				if (alpha !== 0) {
					dData[i] = red;
					dData[i + 1] = green;
					dData[i + 2] = blue;
					dData[ia] = alpha;
				}
			} else {
				if (alpha !== 255) {
					dData[i] = red;
					dData[i + 1] = green;
					dData[i + 2] = blue;
					dData[ia] = 255 - alpha;
				}
			}
		}
		dCtx.putImageData(dImgData, 0, 0);
		var strength = this.strength;
		if (0 < strength) {
			this._blurFilter.applyFilter(dCtx, 0, 0, width, height);
			if (255 < strength) strength = 255;
			for (var j = 1; j < strength; j++) {
				dCtx.drawImage(dCvs, 0, 0);
			}
		}
		var ga = this.alpha;
		if (ga < 0) ga = 0;
		else if (1 < ga) ga = 1;
		var gco;
		if (this.knockout) {
			if (inner) gco = "source-in";
			else gco = "source-out";
		} else {
			if (inner) gco = "source-atop";
			else gco = "destination-over";
		}
		targetCtx.save();
		targetCtx.setTransform(1, 0, 0, 1, 0, 0);
		targetCtx.globalAlpha = ga;
		targetCtx.globalCompositeOperation = gco;
		targetCtx.drawImage(dCvs, targetX, targetY);
		targetCtx.restore();
		return true;
	};

	/**
	* Returns a clone of this GlowFilter instance.
	* @method clone
	* @return {GlowFilter} A clone of this GlowFilter instance.
	**/
	p.clone = function() {
		var f = this._blurFilter;
		return new createjs.GlowFilter(this.color, this.alpha, f.blurX, f.blurY, this.strength, f.quality, this.inner, this.knockout);
	};

	/**
	* Returns a string representation of this filter.
	* @method toString
	* @return {String} A string representation of this filter.
	**/
	p.toString = function() {
		return "[GlowFilter]";
	};

	createjs.GlowFilter = createjs.promote(GlowFilter, "Filter");
}());
StdFiltersPlugin.main();
})(typeof exports != "undefined" ? exports : typeof window != "undefined" ? window : typeof self != "undefined" ? self : this, {});
