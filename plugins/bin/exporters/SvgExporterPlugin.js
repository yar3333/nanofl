// Generated by Haxe 4.3.3
(function ($global) { "use strict";
var $estr = function() { return js_Boot.__string_rec(this,''); },$hxEnums = $hxEnums || {};
function $extend(from, fields) {
	var proto = Object.create(from);
	for (var name in fields) proto[name] = fields[name];
	if( fields.toString !== Object.prototype.toString ) proto.toString = fields.toString;
	return proto;
}
var EReg = function(r,opt) {
	this.r = new RegExp(r,opt.split("u").join(""));
};
EReg.__name__ = true;
EReg.prototype = {
	match: function(s) {
		if(this.r.global) {
			this.r.lastIndex = 0;
		}
		this.r.m = this.r.exec(s);
		this.r.s = s;
		return this.r.m != null;
	}
	,__class__: EReg
};
var HxOverrides = function() { };
HxOverrides.__name__ = true;
HxOverrides.remove = function(a,obj) {
	var i = a.indexOf(obj);
	if(i == -1) {
		return false;
	}
	a.splice(i,1);
	return true;
};
HxOverrides.now = function() {
	return Date.now();
};
var Lambda = function() { };
Lambda.__name__ = true;
Lambda.array = function(it) {
	var a = [];
	var i = $getIterator(it);
	while(i.hasNext()) {
		var i1 = i.next();
		a.push(i1);
	}
	return a;
};
Lambda.exists = function(it,f) {
	var x = $getIterator(it);
	while(x.hasNext()) {
		var x1 = x.next();
		if(f(x1)) {
			return true;
		}
	}
	return false;
};
Math.__name__ = true;
var Reflect = function() { };
Reflect.__name__ = true;
Reflect.field = function(o,field) {
	try {
		return o[field];
	} catch( _g ) {
		return null;
	}
};
Reflect.fields = function(o) {
	var a = [];
	if(o != null) {
		var hasOwnProperty = Object.prototype.hasOwnProperty;
		for( var f in o ) {
		if(f != "__id__" && f != "hx__closures__" && hasOwnProperty.call(o,f)) {
			a.push(f);
		}
		}
	}
	return a;
};
Reflect.compare = function(a,b) {
	if(a == b) {
		return 0;
	} else if(a > b) {
		return 1;
	} else {
		return -1;
	}
};
var Std = function() { };
Std.__name__ = true;
Std.string = function(s) {
	return js_Boot.__string_rec(s,"");
};
Std.parseInt = function(x) {
	var v = parseInt(x);
	if(isNaN(v)) {
		return null;
	}
	return v;
};
Std.random = function(x) {
	if(x <= 0) {
		return 0;
	} else {
		return Math.floor(Math.random() * x);
	}
};
var nanofl_ide_plugins_IExporterPlugin = function() { };
nanofl_ide_plugins_IExporterPlugin.__name__ = true;
nanofl_ide_plugins_IExporterPlugin.__isInterface__ = true;
nanofl_ide_plugins_IExporterPlugin.prototype = {
	__class__: nanofl_ide_plugins_IExporterPlugin
};
var SvgExporterPlugin = function() {
	this.properties = null;
	this.fileFilterExtensions = ["svg"];
	this.fileFilterDescription = "Scalable Vector Graphics (*.svg)";
	this.menuItemIcon = "url(data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAA4AAAAOCAYAAAAfSC3RAAAACXBIWXMAAA3XAAAN1wFCKJt4AAAC5ElEQVQozz2LbUxbZQBGn7ctLVDpZQKi4KJjAYTGLBIEYU2gxTlKhAhZ0MQxZupMNoPBBbP5gX/QaKIGTDSaiM5snciHwB0lHTKENWxZMAxi1LBunSKDNh2jwAps7e199kPnv5Occ0ASqqoKkiIWi2lIoqev356akhJ4cFty8JSz6wWSuO/+a/E/THgmnz7cfLx1QB62PZmf+/tIaxbPt2XTnLvD2z/oqjjy5tvvjY5NlNyfQRKeyYuFaQ8I5WhlAh/dplVMRr0S6itVNwd3q6lSvJJu0igt9kSmGcGfz43vJgkNAJwZGrXWW5O0n31ftfXlG3lifSOi9c1viL9ubInltTvaz1/PFZ+csG81ViVDPjNSAeDfsbj4qdne8XW4v5qLr9mbLj4++DiUGBGJqmjb/xherH5EnPvGa3CeXcUzxQUzAIDu3p+qzE/s9D6UbFABsOPQTvK8jVHZwqhsIT02fn0kmwCYJhnU/JwdvpOnfqgVGRmZvvaXdFkFWYkcuxwQkiTBkmeEMcEAIQQ2Nu/g4pVN3AqFUL4rnVeWIuK1724vaQXUD2eurug12ytF7aEP8OPZWQSTrHBOLGPwchSRjGpc+OMmDhz9AkPTW6Ld6WFg5W68ABC2WCzGru5eDMgu7LFasBlew6h7COHwbdTVvwytzoBL07/heftzeNXxCtxut6IF8K61vDyupKQYDfvsmByToY1LQEFhISSThLsRBaYkI/bvq8HUr1NY8gcQDAYJvT4uLIRgT3cXSbLj049oNpu5eOMfeuf+ZMtbx3jpgofvNDtIkgcaGwkgCiFEODMzkznZ2Xw41US/389nK2y8dtVLv3+J9sq9vO7zEQBH3MNsbX2fACIA4CstLWUoFFI7O7/lwsICkyWJ47+McXZmhvEGPf+en6fz9Gn6/QHVZrMRwCI0Gs1BAKt1dXUxl8sVLSsrUwAoDodDaWpqUgAoRUVFiizL0YaGhhiAdZ1O57gHue+ALxPHGYEAAAAASUVORK5CYII=)";
	this.menuItemName = "Scalable Vector Graphics (*.svg)";
	this.name = "SvgExporter";
};
SvgExporterPlugin.__name__ = true;
SvgExporterPlugin.__interfaces__ = [nanofl_ide_plugins_IExporterPlugin];
SvgExporterPlugin.main = function() {
	nanofl.ide.plugins.ExporterPlugins.register(new SvgExporterPlugin());
};
SvgExporterPlugin.prototype = {
	exportDocument: function(api,args) {
		nanofl.engine.Debug.console.log("Plugin.exportDocument " + args.srcFilePath + " => " + args.destFilePath);
		var xml = new htmlparser.XmlBuilder();
		xml.begin("svg").attr("xmlns","http://www.w3.org/2000/svg").attr("width",args.documentProperties.width).attr("height",args.documentProperties.height).attr("xmlns:xlink","http://www.w3.org/1999/xlink");
		new svgexporter_SvgExporter(args.library).export(xml);
		xml.end();
		api.fileSystem.saveContent(args.destFilePath,xml.toString());
		return Promise.resolve(true);
	}
	,__class__: SvgExporterPlugin
};
var haxe_IMap = function() { };
haxe_IMap.__name__ = true;
haxe_IMap.__isInterface__ = true;
var haxe_Exception = function(message,previous,native) {
	Error.call(this,message);
	this.message = message;
	this.__previousException = previous;
	this.__nativeException = native != null ? native : this;
};
haxe_Exception.__name__ = true;
haxe_Exception.thrown = function(value) {
	if(((value) instanceof haxe_Exception)) {
		return value.get_native();
	} else if(((value) instanceof Error)) {
		return value;
	} else {
		var e = new haxe_ValueException(value);
		return e;
	}
};
haxe_Exception.__super__ = Error;
haxe_Exception.prototype = $extend(Error.prototype,{
	get_native: function() {
		return this.__nativeException;
	}
	,__class__: haxe_Exception
});
var haxe_ValueException = function(value,previous,native) {
	haxe_Exception.call(this,String(value),previous,native);
	this.value = value;
};
haxe_ValueException.__name__ = true;
haxe_ValueException.__super__ = haxe_Exception;
haxe_ValueException.prototype = $extend(haxe_Exception.prototype,{
	__class__: haxe_ValueException
});
var haxe_ds_ObjectMap = function() {
	this.h = { __keys__ : { }};
};
haxe_ds_ObjectMap.__name__ = true;
haxe_ds_ObjectMap.__interfaces__ = [haxe_IMap];
haxe_ds_ObjectMap.prototype = {
	set: function(key,value) {
		var id = key.__id__;
		if(id == null) {
			id = (key.__id__ = $global.$haxeUID++);
		}
		this.h[id] = value;
		this.h.__keys__[id] = key;
	}
	,__class__: haxe_ds_ObjectMap
};
var haxe_ds_StringMap = function() {
	this.h = Object.create(null);
};
haxe_ds_StringMap.__name__ = true;
haxe_ds_StringMap.__interfaces__ = [haxe_IMap];
haxe_ds_StringMap.prototype = {
	__class__: haxe_ds_StringMap
};
var haxe_io_Bytes = function() { };
haxe_io_Bytes.__name__ = true;
var haxe_iterators_ArrayIterator = function(array) {
	this.current = 0;
	this.array = array;
};
haxe_iterators_ArrayIterator.__name__ = true;
haxe_iterators_ArrayIterator.prototype = {
	hasNext: function() {
		return this.current < this.array.length;
	}
	,next: function() {
		return this.array[this.current++];
	}
	,__class__: haxe_iterators_ArrayIterator
};
var js_Boot = function() { };
js_Boot.__name__ = true;
js_Boot.getClass = function(o) {
	if(o == null) {
		return null;
	} else if(((o) instanceof Array)) {
		return Array;
	} else {
		var cl = o.__class__;
		if(cl != null) {
			return cl;
		}
		var name = js_Boot.__nativeClassName(o);
		if(name != null) {
			return js_Boot.__resolveNativeClass(name);
		}
		return null;
	}
};
js_Boot.__string_rec = function(o,s) {
	if(o == null) {
		return "null";
	}
	if(s.length >= 5) {
		return "<...>";
	}
	var t = typeof(o);
	if(t == "function" && (o.__name__ || o.__ename__)) {
		t = "object";
	}
	switch(t) {
	case "function":
		return "<function>";
	case "object":
		if(o.__enum__) {
			var e = $hxEnums[o.__enum__];
			var con = e.__constructs__[o._hx_index];
			var n = con._hx_name;
			if(con.__params__) {
				s = s + "\t";
				return n + "(" + ((function($this) {
					var $r;
					var _g = [];
					{
						var _g1 = 0;
						var _g2 = con.__params__;
						while(true) {
							if(!(_g1 < _g2.length)) {
								break;
							}
							var p = _g2[_g1];
							_g1 = _g1 + 1;
							_g.push(js_Boot.__string_rec(o[p],s));
						}
					}
					$r = _g;
					return $r;
				}(this))).join(",") + ")";
			} else {
				return n;
			}
		}
		if(((o) instanceof Array)) {
			var str = "[";
			s += "\t";
			var _g = 0;
			var _g1 = o.length;
			while(_g < _g1) {
				var i = _g++;
				str += (i > 0 ? "," : "") + js_Boot.__string_rec(o[i],s);
			}
			str += "]";
			return str;
		}
		var tostr;
		try {
			tostr = o.toString;
		} catch( _g ) {
			return "???";
		}
		if(tostr != null && tostr != Object.toString && typeof(tostr) == "function") {
			var s2 = o.toString();
			if(s2 != "[object Object]") {
				return s2;
			}
		}
		var str = "{\n";
		s += "\t";
		var hasp = o.hasOwnProperty != null;
		var k = null;
		for( k in o ) {
		if(hasp && !o.hasOwnProperty(k)) {
			continue;
		}
		if(k == "prototype" || k == "__class__" || k == "__super__" || k == "__interfaces__" || k == "__properties__") {
			continue;
		}
		if(str.length != 2) {
			str += ", \n";
		}
		str += s + k + " : " + js_Boot.__string_rec(o[k],s);
		}
		s = s.substring(1);
		str += "\n" + s + "}";
		return str;
	case "string":
		return o;
	default:
		return String(o);
	}
};
js_Boot.__interfLoop = function(cc,cl) {
	if(cc == null) {
		return false;
	}
	if(cc == cl) {
		return true;
	}
	var intf = cc.__interfaces__;
	if(intf != null) {
		var _g = 0;
		var _g1 = intf.length;
		while(_g < _g1) {
			var i = _g++;
			var i1 = intf[i];
			if(i1 == cl || js_Boot.__interfLoop(i1,cl)) {
				return true;
			}
		}
	}
	return js_Boot.__interfLoop(cc.__super__,cl);
};
js_Boot.__instanceof = function(o,cl) {
	if(cl == null) {
		return false;
	}
	switch(cl) {
	case Array:
		return ((o) instanceof Array);
	case Bool:
		return typeof(o) == "boolean";
	case Dynamic:
		return o != null;
	case Float:
		return typeof(o) == "number";
	case Int:
		if(typeof(o) == "number") {
			return ((o | 0) === o);
		} else {
			return false;
		}
		break;
	case String:
		return typeof(o) == "string";
	default:
		if(o != null) {
			if(typeof(cl) == "function") {
				if(js_Boot.__downcastCheck(o,cl)) {
					return true;
				}
			} else if(typeof(cl) == "object" && js_Boot.__isNativeObj(cl)) {
				if(((o) instanceof cl)) {
					return true;
				}
			}
		} else {
			return false;
		}
		if(cl == Class ? o.__name__ != null : false) {
			return true;
		}
		if(cl == Enum ? o.__ename__ != null : false) {
			return true;
		}
		return o.__enum__ != null ? $hxEnums[o.__enum__] == cl : false;
	}
};
js_Boot.__downcastCheck = function(o,cl) {
	if(!((o) instanceof cl)) {
		if(cl.__isInterface__) {
			return js_Boot.__interfLoop(js_Boot.getClass(o),cl);
		} else {
			return false;
		}
	} else {
		return true;
	}
};
js_Boot.__cast = function(o,t) {
	if(o == null || js_Boot.__instanceof(o,t)) {
		return o;
	} else {
		throw haxe_Exception.thrown("Cannot cast " + Std.string(o) + " to " + Std.string(t));
	}
};
js_Boot.__nativeClassName = function(o) {
	var name = js_Boot.__toStr.call(o).slice(8,-1);
	if(name == "Object" || name == "Function" || name == "Math" || name == "JSON") {
		return null;
	}
	return name;
};
js_Boot.__isNativeObj = function(o) {
	return js_Boot.__nativeClassName(o) != null;
};
js_Boot.__resolveNativeClass = function(name) {
	return $global[name];
};
var js_html_VideoFrameBufferInit = function() { };
js_html_VideoFrameBufferInit.__name__ = true;
js_html_VideoFrameBufferInit.__isInterface__ = true;
js_html_VideoFrameBufferInit.prototype = {
	__class__: js_html_VideoFrameBufferInit
};
var js_html_VideoColorSpaceInit = function() { };
js_html_VideoColorSpaceInit.__name__ = true;
js_html_VideoColorSpaceInit.__isInterface__ = true;
js_html_VideoColorSpaceInit.prototype = {
	__class__: js_html_VideoColorSpaceInit
};
var js_html_PlaneLayout = function() { };
js_html_PlaneLayout.__name__ = true;
js_html_PlaneLayout.__isInterface__ = true;
js_html_PlaneLayout.prototype = {
	__class__: js_html_PlaneLayout
};
var js_html_DOMRectInit = function() { };
js_html_DOMRectInit.__name__ = true;
js_html_DOMRectInit.__isInterface__ = true;
js_html_DOMRectInit.prototype = {
	__class__: js_html_DOMRectInit
};
var js_html_VideoFrameInit = function() { };
js_html_VideoFrameInit.__name__ = true;
js_html_VideoFrameInit.__isInterface__ = true;
js_html_VideoFrameInit.prototype = {
	__class__: js_html_VideoFrameInit
};
var js_injecting_InjectorRO = function() { };
js_injecting_InjectorRO.__name__ = true;
js_injecting_InjectorRO.__isInterface__ = true;
js_injecting_InjectorRO.prototype = {
	__class__: js_injecting_InjectorRO
};
var nanofl_IInstance = function() { };
nanofl_IInstance.__name__ = true;
nanofl_IInstance.__isInterface__ = true;
nanofl_IInstance.prototype = {
	__class__: nanofl_IInstance
};
var nanofl_engine_IElementsContainer = function() { };
nanofl_engine_IElementsContainer.__name__ = true;
nanofl_engine_IElementsContainer.__isInterface__ = true;
nanofl_engine_IElementsContainer.prototype = {
	__class__: nanofl_engine_IElementsContainer
};
var nanofl_engine_IFramedItem = function() { };
nanofl_engine_IFramedItem.__name__ = true;
nanofl_engine_IFramedItem.__isInterface__ = true;
nanofl_engine_IFramedItem.prototype = {
	__class__: nanofl_engine_IFramedItem
};
var nanofl_engine_IInstance = function() { };
nanofl_engine_IInstance.__name__ = true;
nanofl_engine_IInstance.__isInterface__ = true;
nanofl_engine_IInstance.prototype = {
	__class__: nanofl_engine_IInstance
};
var nanofl_engine_ILayersContainer = function() { };
nanofl_engine_ILayersContainer.__name__ = true;
nanofl_engine_ILayersContainer.__isInterface__ = true;
nanofl_engine_ILayersContainer.prototype = {
	__class__: nanofl_engine_ILayersContainer
};
var nanofl_engine_ILibraryItem = function() { };
nanofl_engine_ILibraryItem.__name__ = true;
nanofl_engine_ILibraryItem.__isInterface__ = true;
nanofl_engine_ILibraryItem.prototype = {
	__class__: nanofl_engine_ILibraryItem
};
var nanofl_engine_IMotionTween = function() { };
nanofl_engine_IMotionTween.__name__ = true;
nanofl_engine_IMotionTween.__isInterface__ = true;
nanofl_engine_IMotionTween.prototype = {
	__class__: nanofl_engine_IMotionTween
};
var nanofl_engine_IPathElement = function() { };
nanofl_engine_IPathElement.__name__ = true;
nanofl_engine_IPathElement.__isInterface__ = true;
nanofl_engine_IPathElement.__interfaces__ = [nanofl_engine_ILayersContainer];
nanofl_engine_IPathElement.prototype = {
	__class__: nanofl_engine_IPathElement
};
var nanofl_engine_ISelectable = function() { };
nanofl_engine_ISelectable.__name__ = true;
nanofl_engine_ISelectable.__isInterface__ = true;
nanofl_engine_ISelectable.prototype = {
	__class__: nanofl_engine_ISelectable
};
var nanofl_engine_ISpriteSheetableItem = function() { };
nanofl_engine_ISpriteSheetableItem.__name__ = true;
nanofl_engine_ISpriteSheetableItem.__isInterface__ = true;
nanofl_engine_ISpriteSheetableItem.prototype = {
	__class__: nanofl_engine_ISpriteSheetableItem
};
var nanofl_engine_ITextureItem = function() { };
nanofl_engine_ITextureItem.__name__ = true;
nanofl_engine_ITextureItem.__isInterface__ = true;
nanofl_engine_ITextureItem.prototype = {
	__class__: nanofl_engine_ITextureItem
};
var nanofl_engine_ITimeline = function() { };
nanofl_engine_ITimeline.__name__ = true;
nanofl_engine_ITimeline.__isInterface__ = true;
nanofl_engine_ITimeline.prototype = {
	__class__: nanofl_engine_ITimeline
};
var nanofl_engine_fills_IFill = function() { };
nanofl_engine_fills_IFill.__name__ = true;
nanofl_engine_fills_IFill.__isInterface__ = true;
nanofl_engine_fills_IFill.prototype = {
	__class__: nanofl_engine_fills_IFill
};
var nanofl_engine_strokes_IStroke = function() { };
nanofl_engine_strokes_IStroke.__name__ = true;
nanofl_engine_strokes_IStroke.__isInterface__ = true;
nanofl_engine_strokes_IStroke.prototype = {
	__class__: nanofl_engine_strokes_IStroke
};
var nanofl_ide_ISymbol = function() { };
nanofl_ide_ISymbol.__name__ = true;
nanofl_ide_ISymbol.__isInterface__ = true;
nanofl_ide_ISymbol.prototype = {
	__class__: nanofl_ide_ISymbol
};
var nanofl_ide_ITimeline = function() { };
nanofl_ide_ITimeline.__name__ = true;
nanofl_ide_ITimeline.__isInterface__ = true;
nanofl_ide_ITimeline.__interfaces__ = [nanofl_engine_ITimeline];
nanofl_ide_ITimeline.prototype = {
	__class__: nanofl_ide_ITimeline
};
var nanofl_ide_libraryitems_IIdeLibraryItem = function() { };
nanofl_ide_libraryitems_IIdeLibraryItem.__name__ = true;
nanofl_ide_libraryitems_IIdeLibraryItem.__isInterface__ = true;
nanofl_ide_libraryitems_IIdeLibraryItem.__interfaces__ = [nanofl_engine_ILibraryItem];
nanofl_ide_libraryitems_IIdeLibraryItem.prototype = {
	__class__: nanofl_ide_libraryitems_IIdeLibraryItem
};
var nanofl_ide_libraryitems_IIdeInstancableItem = function() { };
nanofl_ide_libraryitems_IIdeInstancableItem.__name__ = true;
nanofl_ide_libraryitems_IIdeInstancableItem.__isInterface__ = true;
nanofl_ide_libraryitems_IIdeInstancableItem.__interfaces__ = [nanofl_ide_libraryitems_IIdeLibraryItem,nanofl_ide_ISymbol];
nanofl_ide_libraryitems_IIdeInstancableItem.prototype = {
	__class__: nanofl_ide_libraryitems_IIdeInstancableItem
};
var nanofl_ide_sys_Environment = function() { };
nanofl_ide_sys_Environment.__name__ = true;
nanofl_ide_sys_Environment.__isInterface__ = true;
nanofl_ide_sys_Environment.prototype = {
	__class__: nanofl_ide_sys_Environment
};
var nanofl_ide_sys_FileSystem = function() { };
nanofl_ide_sys_FileSystem.__name__ = true;
nanofl_ide_sys_FileSystem.__isInterface__ = true;
nanofl_ide_sys_FileSystem.prototype = {
	__class__: nanofl_ide_sys_FileSystem
};
var nanofl_ide_sys_Folders = function() { };
nanofl_ide_sys_Folders.__name__ = true;
nanofl_ide_sys_Folders.__isInterface__ = true;
nanofl_ide_sys_Folders.prototype = {
	__class__: nanofl_ide_sys_Folders
};
var nanofl_ide_sys_Fonts = function() { };
nanofl_ide_sys_Fonts.__name__ = true;
nanofl_ide_sys_Fonts.__isInterface__ = true;
nanofl_ide_sys_Fonts.prototype = {
	__class__: nanofl_ide_sys_Fonts
};
var nanofl_ide_sys_ProcessManager = function() { };
nanofl_ide_sys_ProcessManager.__name__ = true;
nanofl_ide_sys_ProcessManager.__isInterface__ = true;
nanofl_ide_sys_ProcessManager.prototype = {
	__class__: nanofl_ide_sys_ProcessManager
};
var nanofl_ide_sys_Zip = function() { };
nanofl_ide_sys_Zip.__name__ = true;
nanofl_ide_sys_Zip.__isInterface__ = true;
nanofl_ide_sys_Zip.prototype = {
	__class__: nanofl_ide_sys_Zip
};
var stdlib_Event = function(target) {
	this.target = target;
	this.handlers = [];
};
stdlib_Event.__name__ = true;
stdlib_Event.prototype = {
	bind: function(handler) {
		this.handlers.push(handler);
	}
	,unbind: function(handler) {
		while(HxOverrides.remove(this.handlers,handler)) {
		}
	}
	,unbindAll: function() {
		this.handlers = [];
	}
	,call: function(args) {
		var _g = 0;
		var _g1 = this.handlers;
		while(_g < _g1.length) {
			var handler = _g1[_g];
			++_g;
			handler.apply(null,[this.target,args]);
		}
	}
	,__class__: stdlib_Event
};
var stdlib_LambdaArray = function() { };
stdlib_LambdaArray.__name__ = true;
stdlib_LambdaArray.addRange = function(arr,range) {
	var _g = 0;
	while(_g < range.length) {
		var e = range[_g];
		++_g;
		arr.push(e);
	}
};
stdlib_LambdaArray.insertRange = function(arr,pos,range) {
	var _g = 0;
	while(_g < range.length) {
		var e = range[_g];
		++_g;
		arr.splice(pos++,0,e);
	}
};
stdlib_LambdaArray.extract = function(arr,f) {
	var r = [];
	var i = 0;
	while(i < arr.length) if(f(arr[i])) {
		r.push(arr[i]);
		arr.splice(i,1);
	} else {
		++i;
	}
	return r;
};
stdlib_LambdaArray.spliceEx = function(arr,pos,len,replacement) {
	var r = arr.splice(pos,len != null ? len : arr.length - pos);
	if(replacement != null) {
		stdlib_LambdaArray.insertRange(arr,pos,replacement);
	}
	return r;
};
stdlib_LambdaArray.filterByType = function(arr,klass) {
	var _g = [];
	var _g1 = 0;
	var _g2 = arr;
	while(_g1 < _g2.length) {
		var v = _g2[_g1];
		++_g1;
		if(js_Boot.__instanceof(v,klass)) {
			_g.push(v);
		}
	}
	return _g;
};
stdlib_LambdaArray.distinct = function(arr,equFunc) {
	var r = [];
	if(equFunc == null) {
		var _g = 0;
		while(_g < arr.length) {
			var x = arr[_g];
			++_g;
			if(r.indexOf(x) == -1) {
				r.push(x);
			}
		}
	} else {
		var _g = 0;
		while(_g < arr.length) {
			var x = [arr[_g]];
			++_g;
			if(!Lambda.exists(r,(function(x) {
				return function(y) {
					return equFunc(x[0],y);
				};
			})(x))) {
				r.push(x[0]);
			}
		}
	}
	return r;
};
stdlib_LambdaArray.toMapManyInner = function(arr,keySelector,valueSelector) {
	var r = new Map();
	var _g = 0;
	while(_g < arr.length) {
		var item = arr[_g];
		++_g;
		var k = keySelector(item);
		if(r.has(k)) {
			r.get(k).push(valueSelector(item));
		} else {
			r.set(k,[valueSelector(item)]);
		}
	}
	return r;
};
stdlib_LambdaArray.toMapOneInner = function(arr,keySelector,valueSelector) {
	var r = new Map();
	var _g = 0;
	while(_g < arr.length) {
		var item = arr[_g];
		++_g;
		r.set(keySelector(item),valueSelector(item));
	}
	return r;
};
var stdlib_LambdaIterable = function() { };
stdlib_LambdaIterable.__name__ = true;
stdlib_LambdaIterable.findIndex = function(it,f) {
	var n = 0;
	var x = $getIterator(it);
	while(x.hasNext()) {
		var x1 = x.next();
		if(f(x1)) {
			return n;
		}
		++n;
	}
	return -1;
};
stdlib_LambdaIterable.findLastIndex = function(it,f) {
	var r = -1;
	var n = 0;
	var x = $getIterator(it);
	while(x.hasNext()) {
		var x1 = x.next();
		if(f(x1)) {
			r = n;
		}
		++n;
	}
	return r;
};
stdlib_LambdaIterable.sorted = function(it,cmp) {
	var r = Lambda.array(it);
	r.sort(cmp != null ? cmp : Reflect.compare);
	return r;
};
stdlib_LambdaIterable.filterByType = function(it,klass) {
	var r = [];
	var x = $getIterator(it);
	while(x.hasNext()) {
		var x1 = x.next();
		if(js_Boot.__instanceof(x1,klass)) {
			r.push(x1);
		}
	}
	return r;
};
var stdlib_LambdaIterator = function() { };
stdlib_LambdaIterator.__name__ = true;
stdlib_LambdaIterator.array = function(it) {
	var r = [];
	var e = it;
	while(e.hasNext()) {
		var e1 = e.next();
		r.push(e1);
	}
	return r;
};
stdlib_LambdaIterator.indexOf = function(it,elem) {
	var r = 0;
	while(it.hasNext()) {
		if(it.next() == elem) {
			return r;
		}
		++r;
	}
	return -1;
};
stdlib_LambdaIterator.map = function(it,conv) {
	var r = [];
	var e = it;
	while(e.hasNext()) {
		var e1 = e.next();
		r.push(conv(e1));
	}
	return r;
};
stdlib_LambdaIterator.filter = function(it,pred) {
	var r = [];
	var e = it;
	while(e.hasNext()) {
		var e1 = e.next();
		if(pred(e1)) {
			r.push(e1);
		}
	}
	return r;
};
stdlib_LambdaIterator.exists = function(it,pred) {
	var e = it;
	while(e.hasNext()) {
		var e1 = e.next();
		if(pred(e1)) {
			return true;
		}
	}
	return false;
};
stdlib_LambdaIterator.count = function(it,pred) {
	var n = 0;
	if(pred == null) {
		var _ = it;
		while(_.hasNext()) {
			var _1 = _.next();
			++n;
		}
	} else {
		var x = it;
		while(x.hasNext()) {
			var x1 = x.next();
			if(pred(x1)) {
				++n;
			}
		}
	}
	return n;
};
stdlib_LambdaIterator.findIndex = function(it,f) {
	var n = 0;
	var x = it;
	while(x.hasNext()) {
		var x1 = x.next();
		if(f(x1)) {
			return n;
		}
		++n;
	}
	return -1;
};
stdlib_LambdaIterator.findLastIndex = function(it,f) {
	var r = -1;
	var n = 0;
	var x = it;
	while(x.hasNext()) {
		var x1 = x.next();
		if(f(x1)) {
			r = n;
		}
		++n;
	}
	return r;
};
stdlib_LambdaIterator.sorted = function(it,cmp) {
	var r = stdlib_LambdaIterator.array(it);
	r.sort(cmp != null ? cmp : Reflect.compare);
	return r;
};
stdlib_LambdaIterator.join = function(it,sep) {
	var r_b = "";
	var isFirst = true;
	var x = it;
	while(x.hasNext()) {
		var x1 = x.next();
		if(!isFirst) {
			r_b += sep == null ? "null" : "" + sep;
		} else {
			isFirst = false;
		}
		r_b += Std.string(Std.string(x1));
	}
	return r_b;
};
var stdlib_Std = function() { };
stdlib_Std.__name__ = true;
stdlib_Std.isOfType = function(v,t) {
	return js_Boot.__instanceof(v,t);
};
stdlib_Std.string = function(s) {
	return Std.string(s);
};
stdlib_Std.int = function(x) {
	return x | 0;
};
stdlib_Std.random = function(x) {
	return Std.random(x);
};
stdlib_Std.parseInt = function(x,defaultValue) {
	if(x != null) {
		if(new EReg("^\\s*[+-]?\\s*((?:0x[0-9a-fA-F]{1,7})|(?:\\d{1,9}))\\s*$","").match(x)) {
			return Std.parseInt(x);
		} else {
			return defaultValue;
		}
	} else {
		return defaultValue;
	}
};
stdlib_Std.parseFloat = function(x,defaultValue) {
	if(x == null) {
		return defaultValue;
	}
	if(new EReg("^\\s*[+-]?\\s*\\d{1,20}(?:[.]\\d+)?(?:e[+-]?\\d{1,20})?\\s*$","").match(x)) {
		var r = parseFloat(x);
		if(!isNaN(r)) {
			return r;
		} else {
			return defaultValue;
		}
	}
	return defaultValue;
};
stdlib_Std.downcast = function(obj,_) {
	return obj;
};
stdlib_Std.bool = function(v) {
	if(v != false && v != null && v != 0 && v != "" && v != "0") {
		if(typeof(v) == "string") {
			if((js_Boot.__cast(v , String)).toLowerCase() != "false" && (js_Boot.__cast(v , String)).toLowerCase() != "off") {
				return (js_Boot.__cast(v , String)).toLowerCase() != "null";
			} else {
				return false;
			}
		} else {
			return true;
		}
	} else {
		return false;
	}
};
stdlib_Std.parseValue = function(x) {
	var value = x;
	var valueLC = value != null ? value.toLowerCase() : null;
	var parsedValue;
	if(valueLC == "true") {
		value = true;
	} else if(valueLC == "false") {
		value = false;
	} else if(valueLC == "null") {
		value = null;
	} else {
		parsedValue = stdlib_Std.parseInt(value);
		if(parsedValue != null) {
			value = parsedValue;
		} else {
			parsedValue = stdlib_Std.parseFloat(value);
			if(parsedValue != null) {
				value = parsedValue;
			}
		}
	}
	return value;
};
stdlib_Std.hash = function(obj) {
	var r = new haxe_ds_StringMap();
	var _g = 0;
	var _g1 = Reflect.fields(obj);
	while(_g < _g1.length) {
		var key = _g1[_g];
		++_g;
		r.h[key] = Reflect.field(obj,key);
	}
	return r;
};
stdlib_Std.min = function(a,b) {
	if(a < b) {
		return a;
	} else {
		return b;
	}
};
stdlib_Std.max = function(a,b) {
	if(a > b) {
		return a;
	} else {
		return b;
	}
};
stdlib_Std.abs = function(x) {
	if(x >= 0) {
		return x;
	} else {
		return -x;
	}
};
stdlib_Std.sign = function(n) {
	if(n > 0) {
		return 1;
	} else if(n < 0) {
		return -1;
	} else {
		return 0;
	}
};
var svgexporter_Gradient = function(tag,colors,ratios,attributes) {
	this.tag = tag;
	this.colors = colors;
	this.ratios = ratios;
	this.attributes = attributes;
};
svgexporter_Gradient.__name__ = true;
svgexporter_Gradient.fromStroke = function(stroke) {
	if(((stroke) instanceof nanofl.engine.strokes.LinearStroke)) {
		var data = stroke;
		return svgexporter_Gradient.createLinear(data.colors,data.ratios,data.x0,data.y0,data.x1,data.y1);
	} else if(((stroke) instanceof nanofl.engine.strokes.RadialStroke)) {
		var data = stroke;
		return svgexporter_Gradient.createRadial(data.colors,data.ratios,data.cx,data.cy,data.r,data.fx,data.fy);
	} else if(((stroke) instanceof nanofl.engine.strokes.BitmapStroke)) {
		nanofl.engine.Debug.console.warn("BitmapStroke is not supported.");
	}
	return null;
};
svgexporter_Gradient.fromFill = function(fill) {
	if(((fill) instanceof nanofl.engine.fills.LinearFill)) {
		var data = fill;
		return svgexporter_Gradient.createLinear(data.colors,data.ratios,data.x0,data.y0,data.x1,data.y1);
	} else if(((fill) instanceof nanofl.engine.fills.RadialFill)) {
		var data = fill;
		return svgexporter_Gradient.createRadial(data.colors,data.ratios,data.cx,data.cy,data.r,data.fx,data.fy);
	} else if(((fill) instanceof nanofl.engine.fills.BitmapFill)) {
		nanofl.engine.Debug.console.warn("BitmapFill is not supported.");
	}
	return null;
};
svgexporter_Gradient.createLinear = function(colors,ratios,x0,y0,x1,y1) {
	return new svgexporter_Gradient("linearGradient",colors,ratios,[{ name : "x1", value : x0},{ name : "y1", value : y0},{ name : "x2", value : x1},{ name : "y2", value : y1}]);
};
svgexporter_Gradient.createRadial = function(colors,ratios,cx,cy,r,fx,fy) {
	return new svgexporter_Gradient("radialGradient",colors,ratios,[{ name : "cx", value : cx},{ name : "cy", value : cy},{ name : "r", value : r},{ name : "fx", value : fx},{ name : "fy", value : fy}]);
};
svgexporter_Gradient.prototype = {
	equ: function(g) {
		if(g == this) {
			return true;
		}
		if(g.tag != this.tag) {
			return false;
		}
		if(g.colors.length != this.colors.length) {
			return false;
		}
		if(g.attributes.length != this.attributes.length) {
			return false;
		}
		var _g = 0;
		var _g1 = this.colors.length;
		while(_g < _g1) {
			var i = _g++;
			if(g.colors[i] != this.colors[i]) {
				return false;
			}
			if(g.ratios[i] != this.ratios[i]) {
				return false;
			}
		}
		var _g = 0;
		var _g1 = this.attributes.length;
		while(_g < _g1) {
			var i = _g++;
			if(g.attributes[i].name != this.attributes[i].name) {
				return false;
			}
			if(g.attributes[i].value != this.attributes[i].value) {
				return false;
			}
		}
		return true;
	}
	,write: function(id,xml) {
		xml.begin(this.tag);
		xml.attr("id","grad" + id);
		var _g = 0;
		var _g1 = this.attributes;
		while(_g < _g1.length) {
			var a = _g1[_g];
			++_g;
			xml.attr(a.name,a.value);
		}
		xml.attr("gradientUnits","userSpaceOnUse");
		var _g = 0;
		var _g1 = this.colors.length;
		while(_g < _g1) {
			var i = _g++;
			xml.begin("stop");
			xml.attr("stop-color",this.colors[i]);
			xml.attr("offset",this.ratios[i]);
			xml.end();
		}
		xml.end();
	}
	,__class__: svgexporter_Gradient
};
var svgexporter_ShapeExporter = function() {
	this.gradients = [];
	this.fills = [];
	this.strokes = [];
};
svgexporter_ShapeExporter.__name__ = true;
svgexporter_ShapeExporter.prototype = {
	exportGradients: function(shape,xml) {
		var _g = 0;
		var _g1 = shape.edges;
		while(_g < _g1.length) {
			var edge = [_g1[_g]];
			++_g;
			if(!Lambda.exists(this.strokes,(function(edge) {
				return function(x) {
					return x.equ(edge[0].stroke);
				};
			})(edge))) {
				var g = [svgexporter_Gradient.fromStroke(edge[0].stroke)];
				if(g[0] != null) {
					if(!Lambda.exists(this.gradients,(function(g) {
						return function(x) {
							return x.equ(g[0]);
						};
					})(g))) {
						g[0].write(this.gradients.length,xml);
						this.gradients.push(g[0]);
					}
					this.strokes.push(edge[0].stroke);
				}
			}
		}
		var _g = 0;
		var _g1 = shape.polygons;
		while(_g < _g1.length) {
			var polygon = [_g1[_g]];
			++_g;
			if(!Lambda.exists(this.fills,(function(polygon) {
				return function(x) {
					return x.equ(polygon[0].fill);
				};
			})(polygon))) {
				var g1 = [svgexporter_Gradient.fromFill(polygon[0].fill)];
				if(g1[0] != null) {
					if(!Lambda.exists(this.gradients,(function(g) {
						return function(x) {
							return x.equ(g[0]);
						};
					})(g1))) {
						g1[0].write(this.gradients.length,xml);
						this.gradients.push(g1[0]);
					}
					this.fills.push(polygon[0].fill);
				}
			}
		}
	}
	,'export': function(idPrefix,shape,xml) {
		var render = new svgexporter_ShapePathsRender(idPrefix,this.gradients,xml);
		shape.draw(render,null);
		return render.ids;
	}
	,__class__: svgexporter_ShapeExporter
};
var svgexporter_ShapePathsRender = function(idPrefix,gradients,xml) {
	this.ids = [];
	this.d = "";
	this.attributes = [];
	this.idPrefix = null;
	this.idPrefix = idPrefix;
	this.gradients = gradients;
	this.xml = xml;
};
svgexporter_ShapePathsRender.__name__ = true;
svgexporter_ShapePathsRender.prototype = {
	moveTo: function(x,y) {
		this.d += "M" + x + "," + y;
		return this;
	}
	,lineTo: function(x,y) {
		this.d += "L" + x + "," + y;
		return this;
	}
	,curveTo: function(x0,y0,x1,y1) {
		this.d += "Q" + x0 + "," + y0 + "," + x1 + "," + y1;
		return this;
	}
	,beginStroke: function(color) {
		this.attr("fill","none");
		this.attr("stroke",color);
		return this;
	}
	,beginLinearGradientStroke: function(colors,ratios,x0,y0,x1,y1) {
		this.attr("fill","none");
		var g = svgexporter_Gradient.createLinear(colors,ratios,x0,y0,x1,y1);
		this.attr("stroke","url(#grad" + stdlib_LambdaIterable.findIndex(this.gradients,function(x) {
			return x.equ(g);
		}) + ")");
		return this;
	}
	,beginRadialGradientStroke: function(colors,ratios,fx,fy,fr,cx,cy,cr) {
		this.attr("fill","none");
		var g = svgexporter_Gradient.createRadial(colors,ratios,cx,cy,cr,fx,fy);
		this.attributes.push({ name : "stroke", value : "url(#grad" + stdlib_LambdaIterable.findIndex(this.gradients,function(x) {
			return x.equ(g);
		}) + ")"});
		return this;
	}
	,beginBitmapStroke: function(image,repeat) {
		this.attr("fill","none");
		this.attr("stroke","#000000");
		return this;
	}
	,setStrokeStyle: function(thickness,caps,joints,miterLimit,ignoreScale) {
		this.attr("stroke-width",thickness);
		this.attr("stroke-linecap",caps);
		this.attr("stroke-linejoin",joints);
		this.attr("stroke-miterlimit",miterLimit);
		return this;
	}
	,endStroke: function() {
		this.finishPath();
		return this;
	}
	,beginFill: function(color) {
		this.attr("fill",color);
		return this;
	}
	,beginLinearGradientFill: function(colors,ratios,x0,y0,x1,y1) {
		var g = svgexporter_Gradient.createLinear(colors,ratios,x0,y0,x1,y1);
		this.attr("fill","url(#grad" + stdlib_LambdaIterable.findIndex(this.gradients,function(x) {
			return x.equ(g);
		}) + ")");
		return this;
	}
	,beginRadialGradientFill: function(colors,ratios,fx,fy,fr,cx,cy,cr) {
		var g = svgexporter_Gradient.createRadial(colors,ratios,cx,cy,cr,fx,fy);
		this.attr("fill","url(#grad" + stdlib_LambdaIterable.findIndex(this.gradients,function(x) {
			return x.equ(g);
		}) + ")");
		return this;
	}
	,beginBitmapFill: function(image,repeat,matrix) {
		this.attr("fill","#000000");
		return this;
	}
	,endFill: function() {
		this.finishPath();
		return this;
	}
	,finishPath: function() {
		if(this.d != "") {
			if(this.idPrefix != null) {
				var id = this.idPrefix + this.ids.length;
				this.ids.push(id);
				this.attributes.unshift({ name : "id", value : id});
			}
			this.xml.begin("path",this.attributes).attr("d",this.d).end();
		}
		this.attributes = [];
		this.d = "";
	}
	,attr: function(name,value,defaultValue) {
		if(value != defaultValue) {
			this.attributes.push({ name : name, value : value});
		}
	}
	,__class__: svgexporter_ShapePathsRender
};
var svgexporter_SvgExporter = function(library) {
	this.shapePaths = new haxe_ds_ObjectMap();
	this.layerItems = new haxe_ds_ObjectMap();
	this.shapeExporter = new svgexporter_ShapeExporter();
	this.library = library;
};
svgexporter_SvgExporter.__name__ = true;
svgexporter_SvgExporter.asInstance = function(element) {
	return element;
};
svgexporter_SvgExporter.prototype = {
	'export': function(xml) {
		var _gthis = this;
		var scene = this.library.getSceneItem();
		var _g = [];
		var _g1 = 0;
		var _g2 = this.library.getItems();
		while(_g1 < _g2.length) {
			var v = _g2[_g1];
			++_g1;
			if(((v) instanceof nanofl.ide.libraryitems.MovieClipItem)) {
				_g.push(v);
			}
		}
		var items = _g;
		var sceneWithItems = [scene].concat(items);
		xml.begin("defs");
		var _g = 0;
		while(_g < sceneWithItems.length) {
			var item = sceneWithItems[_g];
			++_g;
			var _g1 = 0;
			var _g2 = item.get_layers();
			while(_g1 < _g2.length) {
				var layer = _g2[_g1];
				++_g1;
				if(layer.get_keyFrames().length > 0) {
					var shape = layer.get_keyFrames()[0].getShape(false);
					if(shape != null) {
						this.shapeExporter.exportGradients(shape,xml);
					}
				}
			}
		}
		var _g = 0;
		while(_g < sceneWithItems.length) {
			var item = sceneWithItems[_g];
			++_g;
			nanofl.engine.MovieClipItemTools.findShapes(item,false,null,function(shape,e) {
				if(e.insideMask && _gthis.shapePaths.h.__keys__[shape.__id__] == null) {
					_gthis.shapePaths.set(shape,_gthis.shapeExporter.export(e.item.namePath + "_layer" + e.layerIndex + "_shape",shape,xml));
				}
			});
		}
		var _g = 0;
		while(_g < sceneWithItems.length) {
			var item = sceneWithItems[_g];
			++_g;
			this.exportMaskLayers(item,xml);
		}
		var _g = 0;
		while(_g < items.length) {
			var item = items[_g];
			++_g;
			this.exportSvgGroup(item,xml);
		}
		xml.end();
		this.exportMovieClipLayers(scene,xml);
	}
	,exportMaskLayers: function(item,xml) {
		var _gthis = this;
		var _g = 0;
		var _g1 = item.get_layers().length;
		while(_g < _g1) {
			var i = _g++;
			var layer = item.get_layers()[i];
			if(this.layerItems.h.__keys__[layer.__id__] == null && layer.type == nanofl.engine.LayerType.mask && layer.get_keyFrames().length > 0) {
				var layerID = item.namePath + "_layer" + i;
				this.layerItems.set(layer,layerID);
				xml.begin("clipPath").attr("id",layerID);
				var _g2 = 0;
				var _g3 = nanofl.engine.elements.Elements.expandGroups(layer.get_keyFrames()[0].get_elements());
				while(_g2 < _g3.length) {
					var element = _g3[_g2];
					++_g2;
					if(((element) instanceof nanofl.engine.elements.ShapeElement)) {
						this.exportExistShapeElement(element,null,xml);
					} else if(((element) instanceof nanofl.engine.elements.Instance) && ((element.get_symbol()) instanceof nanofl.ide.libraryitems.MovieClipItem)) {
						nanofl.engine.MovieClipItemTools.findShapes(element.get_symbol(),false,element.matrix,function(shape,e) {
							_gthis.exportExistShapeElement(shape,e.matrix,xml);
						});
					}
				}
				xml.end();
			}
		}
	}
	,exportSvgGroup: function(item,xml) {
		xml.begin("g").attr("id",item.namePath);
		this.exportMovieClipLayers(item,xml);
		xml.end();
	}
	,exportMovieClipLayers: function(item,xml) {
		var _g = 0;
		var _g1 = item.get_layers();
		while(_g < _g1.length) {
			var layer = _g1[_g];
			++_g;
			if(layer.type == nanofl.engine.LayerType.normal) {
				xml.begin("g").attr("title",layer.name);
				if(layer.get_keyFrames().length > 0) {
					if(layer.get_parentLayer() != null && layer.get_parentLayer().type == nanofl.engine.LayerType.mask) {
						var this1 = this.layerItems;
						var key = layer.get_parentLayer();
						xml.attr("clip-path","url(#" + this1.h[key.__id__] + ")");
					}
					var _g2 = 0;
					var _g3 = layer.get_keyFrames()[0].get_elements();
					while(_g2 < _g3.length) {
						var element = _g3[_g2];
						++_g2;
						this.exportElement(element,xml);
					}
				}
				xml.end();
			}
		}
	}
	,exportElement: function(element,xml) {
		if(((element) instanceof nanofl.engine.elements.Instance)) {
			var instance = element;
			xml.begin("use");
			xml.attr("xlink:href","#" + instance.get_symbol().namePath);
			this.exportMatrix(instance.matrix,xml);
			xml.end();
		} else if(((element) instanceof nanofl.engine.elements.GroupElement)) {
			var group = element;
			var _g = 0;
			var _g1 = group.getChildren();
			while(_g < _g1.length) {
				var e = _g1[_g];
				++_g;
				this.exportElement(e,xml);
			}
		} else if(((element) instanceof nanofl.engine.elements.ShapeElement)) {
			if(this.shapePaths.h.__keys__[element.__id__] != null) {
				this.exportExistShapeElement(element,null,xml);
			} else {
				this.shapeExporter.export(null,element,xml);
			}
		} else if(((element) instanceof nanofl.engine.elements.TextElement)) {
			this.exportTextElement(element,xml);
		} else {
			nanofl.engine.Debug.console.warn("Unsupported element: " + element.toString());
		}
	}
	,exportTextElement: function(text,xml) {
		var tf = text.createDisplayObject(null);
		tf.update();
		var y = nanofl.TextField.PADDING;
		var _g = 0;
		var _g1 = tf.getTextLines();
		while(_g < _g1.length) {
			var line = _g1[_g];
			++_g;
			xml.begin("text");
			var m = text.matrix.clone();
			switch(line.align) {
			case "center":
				xml.attr("text-anchor","middle");
				m.appendTransform(tf.width / 2,0);
				break;
			case "left":
				xml.attr("text-anchor","start");
				m.appendTransform(nanofl.TextField.PADDING,0);
				break;
			case "right":
				xml.attr("text-anchor","end");
				m.appendTransform(tf.width - nanofl.TextField.PADDING,0);
				break;
			}
			m.appendTransform(0,y - line.minY);
			this.exportMatrix(m,xml);
			var _g2 = 0;
			var _g3 = line.chunks;
			while(_g2 < _g3.length) {
				var chunk = _g3[_g2];
				++_g2;
				xml.begin("tspan");
				xml.attr("fill",chunk.format.fillColor,"#000000");
				xml.attr("stroke",chunk.format.strokeColor,"rgba(0,0,0,0)");
				xml.attr("stroke-width",chunk.format.strokeSize,1);
				xml.attr("font-family",chunk.format.family,"");
				xml.attr("font-size",chunk.format.size,16);
				xml.attr("font-style",chunk.format.style.indexOf("italic") >= 0 ? "italic" : "","");
				xml.attr("font-weight",chunk.format.style.indexOf("bold") >= 0 ? "bold" : "","");
				xml.attr("kerning",chunk.format.kerning ? "auto" : "0","auto");
				xml.attr("letter-spacing",chunk.format.letterSpacing,0);
				xml.content(chunk.format.characters);
				xml.end();
			}
			xml.end();
			y += line.maxY - line.minY + line.spacing;
		}
	}
	,exportExistShapeElement: function(shape,matrix,xml) {
		var _g = 0;
		var _g1 = this.shapePaths.h[shape.__id__];
		while(_g < _g1.length) {
			var pathID = _g1[_g];
			++_g;
			xml.begin("use");
			xml.attr("xlink:href","#" + pathID);
			if(matrix != null) {
				this.exportMatrix(matrix,xml);
			}
			xml.end();
		}
	}
	,exportMatrix: function(matrix,xml) {
		if(!matrix.isIdentity()) {
			if(matrix.a == 1 && matrix.b == 0 && matrix.c == 0 && matrix.d == 1) {
				xml.attr("x",matrix.tx);
				xml.attr("y",matrix.ty);
			} else {
				xml.attr("transform","matrix(" + matrix.toArray().join(",") + ")");
			}
		}
	}
	,__class__: svgexporter_SvgExporter
};
function $getIterator(o) { if( o instanceof Array ) return new haxe_iterators_ArrayIterator(o); else return o.iterator(); }
$global.$haxeUID |= 0;
if(typeof(performance) != "undefined" ? typeof(performance.now) == "function" : false) {
	HxOverrides.now = performance.now.bind(performance);
}
Object.defineProperty(String.prototype,"__class__",{ value : String, enumerable : false, writable : true});
String.__name__ = true;
Array.__name__ = true;
Date.prototype.__class__ = Date;
Date.__name__ = "Date";
var Int = { };
var Dynamic = { };
var Float = Number;
var Bool = Boolean;
var Class = { };
var Enum = { };
js_Boot.__toStr = ({ }).toString;
SvgExporterPlugin.main();
})(typeof window != "undefined" ? window : typeof global != "undefined" ? global : typeof self != "undefined" ? self : this);
