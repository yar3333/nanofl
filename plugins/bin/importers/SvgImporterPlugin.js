// Generated by Haxe 4.3.3
(function ($global) { "use strict";
var $estr = function() { return js_Boot.__string_rec(this,''); },$hxEnums = $hxEnums || {},$_;
function $extend(from, fields) {
	var proto = Object.create(from);
	for (var name in fields) proto[name] = fields[name];
	if( fields.toString !== Object.prototype.toString ) proto.toString = fields.toString;
	return proto;
}
var EReg = function(r,opt) {
	this.r = new RegExp(r,opt.split("u").join(""));
};
EReg.__name__ = "EReg";
EReg.prototype = {
	match: function(s) {
		if(this.r.global) {
			this.r.lastIndex = 0;
		}
		this.r.m = this.r.exec(s);
		this.r.s = s;
		return this.r.m != null;
	}
	,matched: function(n) {
		if(this.r.m != null && n >= 0 && n < this.r.m.length) {
			return this.r.m[n];
		} else {
			throw haxe_Exception.thrown("EReg::matched");
		}
	}
	,matchedRight: function() {
		if(this.r.m == null) {
			throw haxe_Exception.thrown("No string matched");
		}
		var sz = this.r.m.index + this.r.m[0].length;
		return HxOverrides.substr(this.r.s,sz,this.r.s.length - sz);
	}
	,matchedPos: function() {
		if(this.r.m == null) {
			throw haxe_Exception.thrown("No string matched");
		}
		return { pos : this.r.m.index, len : this.r.m[0].length};
	}
	,matchSub: function(s,pos,len) {
		if(len == null) {
			len = -1;
		}
		if(this.r.global) {
			this.r.lastIndex = pos;
			this.r.m = this.r.exec(len < 0 ? s : HxOverrides.substr(s,0,pos + len));
			var b = this.r.m != null;
			if(b) {
				this.r.s = s;
			}
			return b;
		} else {
			var b = this.match(len < 0 ? HxOverrides.substr(s,pos,null) : HxOverrides.substr(s,pos,len));
			if(b) {
				this.r.s = s;
				this.r.m.index += pos;
			}
			return b;
		}
	}
	,split: function(s) {
		var d = "#__delim__#";
		return s.replace(this.r,d).split(d);
	}
	,map: function(s,f) {
		var offset = 0;
		var buf_b = "";
		do {
			if(offset >= s.length) {
				break;
			} else if(!this.matchSub(s,offset)) {
				buf_b += Std.string(HxOverrides.substr(s,offset,null));
				break;
			}
			var p = this.matchedPos();
			buf_b += Std.string(HxOverrides.substr(s,offset,p.pos - offset));
			buf_b += Std.string(f(this));
			if(p.len == 0) {
				buf_b += Std.string(HxOverrides.substr(s,p.pos,1));
				offset = p.pos + 1;
			} else {
				offset = p.pos + p.len;
			}
		} while(this.r.global);
		if(!this.r.global && offset > 0 && offset < s.length) {
			buf_b += Std.string(HxOverrides.substr(s,offset,null));
		}
		return buf_b;
	}
	,__class__: EReg
};
var HxOverrides = function() { };
HxOverrides.__name__ = "HxOverrides";
HxOverrides.cca = function(s,index) {
	var x = s.charCodeAt(index);
	if(x != x) {
		return undefined;
	}
	return x;
};
HxOverrides.substr = function(s,pos,len) {
	if(len == null) {
		len = s.length;
	} else if(len < 0) {
		if(pos == 0) {
			len = s.length + len;
		} else {
			return "";
		}
	}
	return s.substr(pos,len);
};
HxOverrides.remove = function(a,obj) {
	var i = a.indexOf(obj);
	if(i == -1) {
		return false;
	}
	a.splice(i,1);
	return true;
};
HxOverrides.now = function() {
	return Date.now();
};
var Lambda = function() { };
Lambda.__name__ = "Lambda";
Lambda.array = function(it) {
	var a = [];
	var i = $getIterator(it);
	while(i.hasNext()) {
		var i1 = i.next();
		a.push(i1);
	}
	return a;
};
Lambda.count = function(it,pred) {
	var n = 0;
	if(pred == null) {
		var _ = $getIterator(it);
		while(_.hasNext()) {
			var _1 = _.next();
			++n;
		}
	} else {
		var x = $getIterator(it);
		while(x.hasNext()) {
			var x1 = x.next();
			if(pred(x1)) {
				++n;
			}
		}
	}
	return n;
};
Math.__name__ = "Math";
var Reflect = function() { };
Reflect.__name__ = "Reflect";
Reflect.field = function(o,field) {
	try {
		return o[field];
	} catch( _g ) {
		return null;
	}
};
Reflect.fields = function(o) {
	var a = [];
	if(o != null) {
		var hasOwnProperty = Object.prototype.hasOwnProperty;
		for( var f in o ) {
		if(f != "__id__" && f != "hx__closures__" && hasOwnProperty.call(o,f)) {
			a.push(f);
		}
		}
	}
	return a;
};
Reflect.isFunction = function(f) {
	if(typeof(f) == "function") {
		return !(f.__name__ || f.__ename__);
	} else {
		return false;
	}
};
var Std = function() { };
Std.__name__ = "Std";
Std.string = function(s) {
	return js_Boot.__string_rec(s,"");
};
Std.parseInt = function(x) {
	var v = parseInt(x);
	if(isNaN(v)) {
		return null;
	}
	return v;
};
Std.parseFloat = function(x) {
	return parseFloat(x);
};
Std.random = function(x) {
	if(x <= 0) {
		return 0;
	} else {
		return Math.floor(Math.random() * x);
	}
};
var StringBuf = function() {
	this.b = "";
};
StringBuf.__name__ = "StringBuf";
StringBuf.prototype = {
	__class__: StringBuf
};
var haxe_SysTools = function() { };
haxe_SysTools.__name__ = "haxe.SysTools";
var StringTools = function() { };
StringTools.__name__ = "StringTools";
StringTools.htmlEscape = function(s,quotes) {
	var buf_b = "";
	var _g_offset = 0;
	var _g_s = s;
	while(_g_offset < _g_s.length) {
		var s = _g_s;
		var index = _g_offset++;
		var c = s.charCodeAt(index);
		if(c >= 55296 && c <= 56319) {
			c = c - 55232 << 10 | s.charCodeAt(index + 1) & 1023;
		}
		var c1 = c;
		if(c1 >= 65536) {
			++_g_offset;
		}
		var code = c1;
		switch(code) {
		case 34:
			if(quotes) {
				buf_b += "&quot;";
			} else {
				buf_b += String.fromCodePoint(code);
			}
			break;
		case 38:
			buf_b += "&amp;";
			break;
		case 39:
			if(quotes) {
				buf_b += "&#039;";
			} else {
				buf_b += String.fromCodePoint(code);
			}
			break;
		case 60:
			buf_b += "&lt;";
			break;
		case 62:
			buf_b += "&gt;";
			break;
		default:
			buf_b += String.fromCodePoint(code);
		}
	}
	return buf_b;
};
StringTools.htmlUnescape = function(s) {
	return s.split("&gt;").join(">").split("&lt;").join("<").split("&quot;").join("\"").split("&#039;").join("'").split("&amp;").join("&");
};
StringTools.startsWith = function(s,start) {
	if(s.length >= start.length) {
		return s.lastIndexOf(start,0) == 0;
	} else {
		return false;
	}
};
StringTools.endsWith = function(s,end) {
	var elen = end.length;
	var slen = s.length;
	if(slen >= elen) {
		return s.indexOf(end,slen - elen) == slen - elen;
	} else {
		return false;
	}
};
StringTools.isSpace = function(s,pos) {
	var c = HxOverrides.cca(s,pos);
	if(!(c > 8 && c < 14)) {
		return c == 32;
	} else {
		return true;
	}
};
StringTools.ltrim = function(s) {
	var l = s.length;
	var r = 0;
	while(r < l && StringTools.isSpace(s,r)) ++r;
	if(r > 0) {
		return HxOverrides.substr(s,r,l - r);
	} else {
		return s;
	}
};
StringTools.rtrim = function(s) {
	var l = s.length;
	var r = 0;
	while(r < l && StringTools.isSpace(s,l - r - 1)) ++r;
	if(r > 0) {
		return HxOverrides.substr(s,0,l - r);
	} else {
		return s;
	}
};
StringTools.trim = function(s) {
	return StringTools.ltrim(StringTools.rtrim(s));
};
StringTools.lpad = function(s,c,l) {
	if(c.length <= 0) {
		return s;
	}
	var buf_b = "";
	l -= s.length;
	while(buf_b.length < l) buf_b += c == null ? "null" : "" + c;
	buf_b += s == null ? "null" : "" + s;
	return buf_b;
};
StringTools.rpad = function(s,c,l) {
	if(c.length <= 0) {
		return s;
	}
	var buf_b = "";
	buf_b += s == null ? "null" : "" + s;
	while(buf_b.length < l) buf_b += c == null ? "null" : "" + c;
	return buf_b;
};
StringTools.replace = function(s,sub,by) {
	return s.split(sub).join(by);
};
StringTools.hex = function(n,digits) {
	var s = "";
	var hexChars = "0123456789ABCDEF";
	do {
		s = hexChars.charAt(n & 15) + s;
		n >>>= 4;
	} while(n > 0);
	if(digits != null) {
		while(s.length < digits) s = "0" + s;
	}
	return s;
};
StringTools.quoteUnixArg = function(argument) {
	if(argument == "") {
		return "''";
	} else if(!new EReg("[^a-zA-Z0-9_@%+=:,./-]","").match(argument)) {
		return argument;
	} else {
		return "'" + StringTools.replace(argument,"'","'\"'\"'") + "'";
	}
};
StringTools.quoteWinArg = function(argument,escapeMetaCharacters) {
	var argument1 = argument;
	if(!new EReg("^(/)?[^ \t/\\\\\"]+$","").match(argument1)) {
		var result_b = "";
		var needquote = argument1.indexOf(" ") != -1 || argument1.indexOf("\t") != -1 || argument1 == "" || argument1.indexOf("/") > 0;
		if(needquote) {
			result_b += "\"";
		}
		var bs_buf = new StringBuf();
		var _g = 0;
		var _g1 = argument1.length;
		while(_g < _g1) {
			var i = _g++;
			var _g2 = HxOverrides.cca(argument1,i);
			if(_g2 == null) {
				var c = _g2;
				if(bs_buf.b.length > 0) {
					result_b += Std.string(bs_buf.b);
					bs_buf = new StringBuf();
				}
				result_b += String.fromCodePoint(c);
			} else {
				switch(_g2) {
				case 34:
					var bs = bs_buf.b;
					result_b += Std.string(bs);
					result_b += Std.string(bs);
					bs_buf = new StringBuf();
					result_b += "\\\"";
					break;
				case 92:
					bs_buf.b += "\\";
					break;
				default:
					var c1 = _g2;
					if(bs_buf.b.length > 0) {
						result_b += Std.string(bs_buf.b);
						bs_buf = new StringBuf();
					}
					result_b += String.fromCodePoint(c1);
				}
			}
		}
		result_b += Std.string(bs_buf.b);
		if(needquote) {
			result_b += Std.string(bs_buf.b);
			result_b += "\"";
		}
		argument1 = result_b;
	}
	if(escapeMetaCharacters) {
		var result_b = "";
		var _g = 0;
		var _g1 = argument1.length;
		while(_g < _g1) {
			var i = _g++;
			var c = HxOverrides.cca(argument1,i);
			if(haxe_SysTools.winMetaCharacters.indexOf(c) >= 0) {
				result_b += String.fromCodePoint(94);
			}
			result_b += String.fromCodePoint(c);
		}
		return result_b;
	} else {
		return argument1;
	}
};
var nanofl_ide_plugins_IImporterPlugin = function() { };
nanofl_ide_plugins_IImporterPlugin.__name__ = "nanofl.ide.plugins.IImporterPlugin";
nanofl_ide_plugins_IImporterPlugin.__isInterface__ = true;
nanofl_ide_plugins_IImporterPlugin.prototype = {
	__class__: nanofl_ide_plugins_IImporterPlugin
};
var SvgImporterPlugin = function() {
	this.properties = [{ type : "bool", name : "optimize", label : "Remove unused items and simplificate document after loading", defaultValue : true}];
	this.fileFilterExtensions = ["svg"];
	this.fileFilterDescription = "Scalable Vector Graphics (*.svg)";
	this.menuItemIcon = "url(data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAA4AAAAOCAYAAAAfSC3RAAAACXBIWXMAAA3XAAAN1wFCKJt4AAAC5ElEQVQozz2LbUxbZQBGn7ctLVDpZQKi4KJjAYTGLBIEYU2gxTlKhAhZ0MQxZupMNoPBBbP5gX/QaKIGTDSaiM5snciHwB0lHTKENWxZMAxi1LBunSKDNh2jwAps7e199kPnv5Occ0ASqqoKkiIWi2lIoqev356akhJ4cFty8JSz6wWSuO/+a/E/THgmnz7cfLx1QB62PZmf+/tIaxbPt2XTnLvD2z/oqjjy5tvvjY5NlNyfQRKeyYuFaQ8I5WhlAh/dplVMRr0S6itVNwd3q6lSvJJu0igt9kSmGcGfz43vJgkNAJwZGrXWW5O0n31ftfXlG3lifSOi9c1viL9ubInltTvaz1/PFZ+csG81ViVDPjNSAeDfsbj4qdne8XW4v5qLr9mbLj4++DiUGBGJqmjb/xherH5EnPvGa3CeXcUzxQUzAIDu3p+qzE/s9D6UbFABsOPQTvK8jVHZwqhsIT02fn0kmwCYJhnU/JwdvpOnfqgVGRmZvvaXdFkFWYkcuxwQkiTBkmeEMcEAIQQ2Nu/g4pVN3AqFUL4rnVeWIuK1724vaQXUD2eurug12ytF7aEP8OPZWQSTrHBOLGPwchSRjGpc+OMmDhz9AkPTW6Ld6WFg5W68ABC2WCzGru5eDMgu7LFasBlew6h7COHwbdTVvwytzoBL07/heftzeNXxCtxut6IF8K61vDyupKQYDfvsmByToY1LQEFhISSThLsRBaYkI/bvq8HUr1NY8gcQDAYJvT4uLIRgT3cXSbLj049oNpu5eOMfeuf+ZMtbx3jpgofvNDtIkgcaGwkgCiFEODMzkznZ2Xw41US/389nK2y8dtVLv3+J9sq9vO7zEQBH3MNsbX2fACIA4CstLWUoFFI7O7/lwsICkyWJ47+McXZmhvEGPf+en6fz9Gn6/QHVZrMRwCI0Gs1BAKt1dXUxl8sVLSsrUwAoDodDaWpqUgAoRUVFiizL0YaGhhiAdZ1O57gHue+ALxPHGYEAAAAASUVORK5CYII=)";
	this.menuItemName = "Scalable Vector Graphics (*.svg)";
	this.name = "SvgImporter";
};
SvgImporterPlugin.__name__ = "SvgImporterPlugin";
SvgImporterPlugin.__interfaces__ = [nanofl_ide_plugins_IImporterPlugin];
SvgImporterPlugin.main = function() {
	nanofl.ide.plugins.ImporterPlugins.register(new SvgImporterPlugin());
};
SvgImporterPlugin.prototype = {
	importDocument: function(api,args) {
		haxe_Log.trace("Load",{ fileName : "src/SvgImporterPlugin.hx", lineNumber : 42, className : "SvgImporterPlugin", methodName : "importDocument"});
		var xml = new htmlparser.XmlDocument(api.fileSystem.getContent(args.srcFilePath));
		haxe_Log.trace("Parse",{ fileName : "src/SvgImporterPlugin.hx", lineNumber : 46, className : "SvgImporterPlugin", methodName : "importDocument"});
		var svg = new svgimport_Svg(xml);
		args.documentProperties.width = Math.round(svg.width);
		args.documentProperties.height = Math.round(svg.height);
		if(svg.id != nanofl.ide.library.IdeLibrary.SCENE_NAME_PATH) {
			stdlib_Debug.assert(svg.id == "" || Object.prototype.hasOwnProperty.call(svg.elements.h,svg.id),null,{ fileName : "src/SvgImporterPlugin.hx", lineNumber : 55, className : "SvgImporterPlugin", methodName : "importDocument"});
			var key = svg.id;
			var _this = svg.elements;
			if(Object.prototype.hasOwnProperty.call(_this.h,key)) {
				delete(_this.h[key]);
			}
			svg.id = nanofl.ide.library.IdeLibrary.SCENE_NAME_PATH;
			svg.elements.h[nanofl.ide.library.IdeLibrary.SCENE_NAME_PATH] = svgimport_SvgElement.DisplayGroup(svg);
		}
		haxe_Log.trace("Convert",{ fileName : "src/SvgImporterPlugin.hx", lineNumber : 61, className : "SvgImporterPlugin", methodName : "importDocument"});
		var h = svg.elements.h;
		var elementID_h = h;
		var elementID_keys = Object.keys(h);
		var elementID_length = elementID_keys.length;
		var elementID_current = 0;
		while(elementID_current < elementID_length) {
			var elementID = elementID_keys[elementID_current++];
			if(!args.library.hasItem(elementID)) {
				var _g = svg.elements.h[elementID];
				if(_g == null) {
					var e = svg.elements.h[elementID];
					haxe_Log.trace("ID for item type '" + $hxEnums[e.__enum__].__constructs__[e._hx_index]._hx_name + "' is not supported.",{ fileName : "src/SvgImporterPlugin.hx", lineNumber : 76, className : "SvgImporterPlugin", methodName : "importDocument"});
				} else {
					switch(_g._hx_index) {
					case 0:
						var path = _g.path;
						new svgimport_SvgPathExporter(svg,args.library,path).exportToLibrary();
						break;
					case 1:
						var group = _g.group;
						new svgimport_SvgGroupExporter(svg,args.library,group).exportToLibrary();
						break;
					default:
						var e1 = svg.elements.h[elementID];
						haxe_Log.trace("ID for item type '" + $hxEnums[e1.__enum__].__constructs__[e1._hx_index]._hx_name + "' is not supported.",{ fileName : "src/SvgImporterPlugin.hx", lineNumber : 76, className : "SvgImporterPlugin", methodName : "importDocument"});
					}
				}
			}
		}
		if(args.params.optimize) {
			nanofl.ide.library.IdeLibraryTools.optimize(args.library);
		}
		return Promise.resolve(true);
	}
	,getPublishDirectoryBasePath: function(originalPath) {
		return haxe_io_Path.withoutExtension(originalPath);
	}
	,__class__: SvgImporterPlugin
};
var ValueType = $hxEnums["ValueType"] = { __ename__:"ValueType",__constructs__:null
	,TNull: {_hx_name:"TNull",_hx_index:0,__enum__:"ValueType",toString:$estr}
	,TInt: {_hx_name:"TInt",_hx_index:1,__enum__:"ValueType",toString:$estr}
	,TFloat: {_hx_name:"TFloat",_hx_index:2,__enum__:"ValueType",toString:$estr}
	,TBool: {_hx_name:"TBool",_hx_index:3,__enum__:"ValueType",toString:$estr}
	,TObject: {_hx_name:"TObject",_hx_index:4,__enum__:"ValueType",toString:$estr}
	,TFunction: {_hx_name:"TFunction",_hx_index:5,__enum__:"ValueType",toString:$estr}
	,TClass: ($_=function(c) { return {_hx_index:6,c:c,__enum__:"ValueType",toString:$estr}; },$_._hx_name="TClass",$_.__params__ = ["c"],$_)
	,TEnum: ($_=function(e) { return {_hx_index:7,e:e,__enum__:"ValueType",toString:$estr}; },$_._hx_name="TEnum",$_.__params__ = ["e"],$_)
	,TUnknown: {_hx_name:"TUnknown",_hx_index:8,__enum__:"ValueType",toString:$estr}
};
ValueType.__constructs__ = [ValueType.TNull,ValueType.TInt,ValueType.TFloat,ValueType.TBool,ValueType.TObject,ValueType.TFunction,ValueType.TClass,ValueType.TEnum,ValueType.TUnknown];
var Type = function() { };
Type.__name__ = "Type";
Type.typeof = function(v) {
	switch(typeof(v)) {
	case "boolean":
		return ValueType.TBool;
	case "function":
		if(v.__name__ || v.__ename__) {
			return ValueType.TObject;
		}
		return ValueType.TFunction;
	case "number":
		if(Math.ceil(v) == v % 2147483648.0) {
			return ValueType.TInt;
		}
		return ValueType.TFloat;
	case "object":
		if(v == null) {
			return ValueType.TNull;
		}
		var e = v.__enum__;
		if(e != null) {
			return ValueType.TEnum($hxEnums[e]);
		}
		var c = js_Boot.getClass(v);
		if(c != null) {
			return ValueType.TClass(c);
		}
		return ValueType.TObject;
	case "string":
		return ValueType.TClass(String);
	case "undefined":
		return ValueType.TNull;
	default:
		return ValueType.TUnknown;
	}
};
var haxe_StackItem = $hxEnums["haxe.StackItem"] = { __ename__:"haxe.StackItem",__constructs__:null
	,CFunction: {_hx_name:"CFunction",_hx_index:0,__enum__:"haxe.StackItem",toString:$estr}
	,Module: ($_=function(m) { return {_hx_index:1,m:m,__enum__:"haxe.StackItem",toString:$estr}; },$_._hx_name="Module",$_.__params__ = ["m"],$_)
	,FilePos: ($_=function(s,file,line,column) { return {_hx_index:2,s:s,file:file,line:line,column:column,__enum__:"haxe.StackItem",toString:$estr}; },$_._hx_name="FilePos",$_.__params__ = ["s","file","line","column"],$_)
	,Method: ($_=function(classname,method) { return {_hx_index:3,classname:classname,method:method,__enum__:"haxe.StackItem",toString:$estr}; },$_._hx_name="Method",$_.__params__ = ["classname","method"],$_)
	,LocalFunction: ($_=function(v) { return {_hx_index:4,v:v,__enum__:"haxe.StackItem",toString:$estr}; },$_._hx_name="LocalFunction",$_.__params__ = ["v"],$_)
};
haxe_StackItem.__constructs__ = [haxe_StackItem.CFunction,haxe_StackItem.Module,haxe_StackItem.FilePos,haxe_StackItem.Method,haxe_StackItem.LocalFunction];
var haxe_CallStack = {};
haxe_CallStack.callStack = function() {
	return haxe_NativeStackTrace.toHaxe(haxe_NativeStackTrace.callStack());
};
haxe_CallStack.toString = function(stack) {
	var b = new StringBuf();
	var _g = 0;
	var _g1 = stack;
	while(_g < _g1.length) {
		var s = _g1[_g];
		++_g;
		b.b += "\nCalled from ";
		haxe_CallStack.itemToString(b,s);
	}
	return b.b;
};
haxe_CallStack.itemToString = function(b,s) {
	switch(s._hx_index) {
	case 0:
		b.b += "a C function";
		break;
	case 1:
		var m = s.m;
		b.b += "module ";
		b.b += m == null ? "null" : "" + m;
		break;
	case 2:
		var s1 = s.s;
		var file = s.file;
		var line = s.line;
		var col = s.column;
		if(s1 != null) {
			haxe_CallStack.itemToString(b,s1);
			b.b += " (";
		}
		b.b += file == null ? "null" : "" + file;
		b.b += " line ";
		b.b += line == null ? "null" : "" + line;
		if(col != null) {
			b.b += " column ";
			b.b += col == null ? "null" : "" + col;
		}
		if(s1 != null) {
			b.b += ")";
		}
		break;
	case 3:
		var cname = s.classname;
		var meth = s.method;
		b.b += Std.string(cname == null ? "<unknown>" : cname);
		b.b += ".";
		b.b += meth == null ? "null" : "" + meth;
		break;
	case 4:
		var n = s.v;
		b.b += "local function #";
		b.b += n == null ? "null" : "" + n;
		break;
	}
};
var haxe_IMap = function() { };
haxe_IMap.__name__ = "haxe.IMap";
haxe_IMap.__isInterface__ = true;
var haxe_Exception = function(message,previous,native) {
	Error.call(this,message);
	this.message = message;
	this.__previousException = previous;
	this.__nativeException = native != null ? native : this;
};
haxe_Exception.__name__ = "haxe.Exception";
haxe_Exception.thrown = function(value) {
	if(((value) instanceof haxe_Exception)) {
		return value.get_native();
	} else if(((value) instanceof Error)) {
		return value;
	} else {
		var e = new haxe_ValueException(value);
		return e;
	}
};
haxe_Exception.__super__ = Error;
haxe_Exception.prototype = $extend(Error.prototype,{
	toString: function() {
		return this.get_message();
	}
	,get_message: function() {
		return this.message;
	}
	,get_native: function() {
		return this.__nativeException;
	}
	,__class__: haxe_Exception
});
var haxe_Log = function() { };
haxe_Log.__name__ = "haxe.Log";
haxe_Log.formatOutput = function(v,infos) {
	var str = Std.string(v);
	if(infos == null) {
		return str;
	}
	var pstr = infos.fileName + ":" + infos.lineNumber;
	if(infos.customParams != null) {
		var _g = 0;
		var _g1 = infos.customParams;
		while(_g < _g1.length) {
			var v = _g1[_g];
			++_g;
			str += ", " + Std.string(v);
		}
	}
	return pstr + ": " + str;
};
haxe_Log.trace = function(v,infos) {
	var str = haxe_Log.formatOutput(v,infos);
	if(typeof(console) != "undefined" && console.log != null) {
		console.log(str);
	}
};
var haxe_NativeStackTrace = function() { };
haxe_NativeStackTrace.__name__ = "haxe.NativeStackTrace";
haxe_NativeStackTrace.callStack = function() {
	var e = new Error("");
	var stack = haxe_NativeStackTrace.tryHaxeStack(e);
	if(typeof(stack) == "undefined") {
		try {
			throw e;
		} catch( _g ) {
		}
		stack = e.stack;
	}
	return haxe_NativeStackTrace.normalize(stack,2);
};
haxe_NativeStackTrace.toHaxe = function(s,skip) {
	if(skip == null) {
		skip = 0;
	}
	if(s == null) {
		return [];
	} else if(typeof(s) == "string") {
		var stack = s.split("\n");
		if(stack[0] == "Error") {
			stack.shift();
		}
		var m = [];
		var _g = 0;
		var _g1 = stack.length;
		while(_g < _g1) {
			var i = _g++;
			if(skip > i) {
				continue;
			}
			var line = stack[i];
			var matched = line.match(/^    at ([$A-Za-z0-9_. ]+) \(([^)]+):([0-9]+):([0-9]+)\)$/);
			if(matched != null) {
				var path = matched[1].split(".");
				if(path[0] == "$hxClasses") {
					path.shift();
				}
				var meth = path.pop();
				var file = matched[2];
				var line1 = Std.parseInt(matched[3]);
				var column = Std.parseInt(matched[4]);
				m.push(haxe_StackItem.FilePos(meth == "Anonymous function" ? haxe_StackItem.LocalFunction() : meth == "Global code" ? null : haxe_StackItem.Method(path.join("."),meth),file,line1,column));
			} else {
				m.push(haxe_StackItem.Module(StringTools.trim(line)));
			}
		}
		return m;
	} else if(skip > 0 && Array.isArray(s)) {
		return s.slice(skip);
	} else {
		return s;
	}
};
haxe_NativeStackTrace.tryHaxeStack = function(e) {
	if(e == null) {
		return [];
	}
	var oldValue = Error.prepareStackTrace;
	Error.prepareStackTrace = haxe_NativeStackTrace.prepareHxStackTrace;
	var stack = e.stack;
	Error.prepareStackTrace = oldValue;
	return stack;
};
haxe_NativeStackTrace.prepareHxStackTrace = function(e,callsites) {
	var stack = [];
	var _g = 0;
	while(_g < callsites.length) {
		var site = callsites[_g];
		++_g;
		if(haxe_NativeStackTrace.wrapCallSite != null) {
			site = haxe_NativeStackTrace.wrapCallSite(site);
		}
		var method = null;
		var fullName = site.getFunctionName();
		if(fullName != null) {
			var idx = fullName.lastIndexOf(".");
			if(idx >= 0) {
				var className = fullName.substring(0,idx);
				var methodName = fullName.substring(idx + 1);
				method = haxe_StackItem.Method(className,methodName);
			} else {
				method = haxe_StackItem.Method(null,fullName);
			}
		}
		var fileName = site.getFileName();
		var fileAddr = fileName == null ? -1 : fileName.indexOf("file:");
		if(haxe_NativeStackTrace.wrapCallSite != null && fileAddr > 0) {
			fileName = fileName.substring(fileAddr + 6);
		}
		stack.push(haxe_StackItem.FilePos(method,fileName,site.getLineNumber(),site.getColumnNumber()));
	}
	return stack;
};
haxe_NativeStackTrace.normalize = function(stack,skipItems) {
	if(skipItems == null) {
		skipItems = 0;
	}
	if(Array.isArray(stack) && skipItems > 0) {
		return stack.slice(skipItems);
	} else if(typeof(stack) == "string") {
		switch(stack.substring(0,6)) {
		case "Error\n":case "Error:":
			++skipItems;
			break;
		default:
		}
		return haxe_NativeStackTrace.skipLines(stack,skipItems);
	} else {
		return stack;
	}
};
haxe_NativeStackTrace.skipLines = function(stack,skip,pos) {
	if(pos == null) {
		pos = 0;
	}
	if(skip > 0) {
		pos = stack.indexOf("\n",pos);
		if(pos < 0) {
			return "";
		} else {
			return haxe_NativeStackTrace.skipLines(stack,--skip,pos + 1);
		}
	} else {
		return stack.substring(pos);
	}
};
var haxe_ValueException = function(value,previous,native) {
	haxe_Exception.call(this,String(value),previous,native);
	this.value = value;
};
haxe_ValueException.__name__ = "haxe.ValueException";
haxe_ValueException.__super__ = haxe_Exception;
haxe_ValueException.prototype = $extend(haxe_Exception.prototype,{
	__class__: haxe_ValueException
});
var haxe_ds_List = function() {
	this.length = 0;
};
haxe_ds_List.__name__ = "haxe.ds.List";
haxe_ds_List.prototype = {
	__class__: haxe_ds_List
};
var haxe_ds__$List_ListNode = function(item,next) {
	this.item = item;
	this.next = next;
};
haxe_ds__$List_ListNode.__name__ = "haxe.ds._List.ListNode";
haxe_ds__$List_ListNode.prototype = {
	__class__: haxe_ds__$List_ListNode
};
var haxe_ds_StringMap = function() {
	this.h = Object.create(null);
};
haxe_ds_StringMap.__name__ = "haxe.ds.StringMap";
haxe_ds_StringMap.__interfaces__ = [haxe_IMap];
haxe_ds_StringMap.prototype = {
	__class__: haxe_ds_StringMap
};
var haxe_io_Bytes = function() { };
haxe_io_Bytes.__name__ = "haxe.io.Bytes";
var haxe_io_Path = function(path) {
	switch(path) {
	case ".":case "..":
		this.dir = path;
		this.file = "";
		return;
	}
	var c1 = path.lastIndexOf("/");
	var c2 = path.lastIndexOf("\\");
	if(c1 < c2) {
		this.dir = HxOverrides.substr(path,0,c2);
		path = HxOverrides.substr(path,c2 + 1,null);
		this.backslash = true;
	} else if(c2 < c1) {
		this.dir = HxOverrides.substr(path,0,c1);
		path = HxOverrides.substr(path,c1 + 1,null);
	} else {
		this.dir = null;
	}
	var cp = path.lastIndexOf(".");
	if(cp != -1) {
		this.ext = HxOverrides.substr(path,cp + 1,null);
		this.file = HxOverrides.substr(path,0,cp);
	} else {
		this.ext = null;
		this.file = path;
	}
};
haxe_io_Path.__name__ = "haxe.io.Path";
haxe_io_Path.withoutExtension = function(path) {
	var s = new haxe_io_Path(path);
	s.ext = null;
	return s.toString();
};
haxe_io_Path.prototype = {
	toString: function() {
		return (this.dir == null ? "" : this.dir + (this.backslash ? "\\" : "/")) + this.file + (this.ext == null ? "" : "." + this.ext);
	}
	,__class__: haxe_io_Path
};
var haxe_iterators_ArrayIterator = function(array) {
	this.current = 0;
	this.array = array;
};
haxe_iterators_ArrayIterator.__name__ = "haxe.iterators.ArrayIterator";
haxe_iterators_ArrayIterator.prototype = {
	hasNext: function() {
		return this.current < this.array.length;
	}
	,next: function() {
		return this.array[this.current++];
	}
	,__class__: haxe_iterators_ArrayIterator
};
var haxe_iterators_StringIterator = function(s) {
	this.s = s;
};
haxe_iterators_StringIterator.__name__ = "haxe.iterators.StringIterator";
haxe_iterators_StringIterator.prototype = {
	__class__: haxe_iterators_StringIterator
};
var haxe_iterators_StringKeyValueIterator = function(s) {
	this.s = s;
};
haxe_iterators_StringKeyValueIterator.__name__ = "haxe.iterators.StringKeyValueIterator";
haxe_iterators_StringKeyValueIterator.prototype = {
	__class__: haxe_iterators_StringKeyValueIterator
};
var js_Boot = function() { };
js_Boot.__name__ = "js.Boot";
js_Boot.getClass = function(o) {
	if(o == null) {
		return null;
	} else if(((o) instanceof Array)) {
		return Array;
	} else {
		var cl = o.__class__;
		if(cl != null) {
			return cl;
		}
		var name = js_Boot.__nativeClassName(o);
		if(name != null) {
			return js_Boot.__resolveNativeClass(name);
		}
		return null;
	}
};
js_Boot.__string_rec = function(o,s) {
	if(o == null) {
		return "null";
	}
	if(s.length >= 5) {
		return "<...>";
	}
	var t = typeof(o);
	if(t == "function" && (o.__name__ || o.__ename__)) {
		t = "object";
	}
	switch(t) {
	case "function":
		return "<function>";
	case "object":
		if(o.__enum__) {
			var e = $hxEnums[o.__enum__];
			var con = e.__constructs__[o._hx_index];
			var n = con._hx_name;
			if(con.__params__) {
				s = s + "\t";
				return n + "(" + ((function($this) {
					var $r;
					var _g = [];
					{
						var _g1 = 0;
						var _g2 = con.__params__;
						while(true) {
							if(!(_g1 < _g2.length)) {
								break;
							}
							var p = _g2[_g1];
							_g1 = _g1 + 1;
							_g.push(js_Boot.__string_rec(o[p],s));
						}
					}
					$r = _g;
					return $r;
				}(this))).join(",") + ")";
			} else {
				return n;
			}
		}
		if(((o) instanceof Array)) {
			var str = "[";
			s += "\t";
			var _g = 0;
			var _g1 = o.length;
			while(_g < _g1) {
				var i = _g++;
				str += (i > 0 ? "," : "") + js_Boot.__string_rec(o[i],s);
			}
			str += "]";
			return str;
		}
		var tostr;
		try {
			tostr = o.toString;
		} catch( _g ) {
			return "???";
		}
		if(tostr != null && tostr != Object.toString && typeof(tostr) == "function") {
			var s2 = o.toString();
			if(s2 != "[object Object]") {
				return s2;
			}
		}
		var str = "{\n";
		s += "\t";
		var hasp = o.hasOwnProperty != null;
		var k = null;
		for( k in o ) {
		if(hasp && !o.hasOwnProperty(k)) {
			continue;
		}
		if(k == "prototype" || k == "__class__" || k == "__super__" || k == "__interfaces__" || k == "__properties__") {
			continue;
		}
		if(str.length != 2) {
			str += ", \n";
		}
		str += s + k + " : " + js_Boot.__string_rec(o[k],s);
		}
		s = s.substring(1);
		str += "\n" + s + "}";
		return str;
	case "string":
		return o;
	default:
		return String(o);
	}
};
js_Boot.__interfLoop = function(cc,cl) {
	if(cc == null) {
		return false;
	}
	if(cc == cl) {
		return true;
	}
	var intf = cc.__interfaces__;
	if(intf != null) {
		var _g = 0;
		var _g1 = intf.length;
		while(_g < _g1) {
			var i = _g++;
			var i1 = intf[i];
			if(i1 == cl || js_Boot.__interfLoop(i1,cl)) {
				return true;
			}
		}
	}
	return js_Boot.__interfLoop(cc.__super__,cl);
};
js_Boot.__instanceof = function(o,cl) {
	if(cl == null) {
		return false;
	}
	switch(cl) {
	case Array:
		return ((o) instanceof Array);
	case Bool:
		return typeof(o) == "boolean";
	case Dynamic:
		return o != null;
	case Float:
		return typeof(o) == "number";
	case Int:
		if(typeof(o) == "number") {
			return ((o | 0) === o);
		} else {
			return false;
		}
		break;
	case String:
		return typeof(o) == "string";
	default:
		if(o != null) {
			if(typeof(cl) == "function") {
				if(js_Boot.__downcastCheck(o,cl)) {
					return true;
				}
			} else if(typeof(cl) == "object" && js_Boot.__isNativeObj(cl)) {
				if(((o) instanceof cl)) {
					return true;
				}
			}
		} else {
			return false;
		}
		if(cl == Class ? o.__name__ != null : false) {
			return true;
		}
		if(cl == Enum ? o.__ename__ != null : false) {
			return true;
		}
		return o.__enum__ != null ? $hxEnums[o.__enum__] == cl : false;
	}
};
js_Boot.__downcastCheck = function(o,cl) {
	if(!((o) instanceof cl)) {
		if(cl.__isInterface__) {
			return js_Boot.__interfLoop(js_Boot.getClass(o),cl);
		} else {
			return false;
		}
	} else {
		return true;
	}
};
js_Boot.__cast = function(o,t) {
	if(o == null || js_Boot.__instanceof(o,t)) {
		return o;
	} else {
		throw haxe_Exception.thrown("Cannot cast " + Std.string(o) + " to " + Std.string(t));
	}
};
js_Boot.__nativeClassName = function(o) {
	var name = js_Boot.__toStr.call(o).slice(8,-1);
	if(name == "Object" || name == "Function" || name == "Math" || name == "JSON") {
		return null;
	}
	return name;
};
js_Boot.__isNativeObj = function(o) {
	return js_Boot.__nativeClassName(o) != null;
};
js_Boot.__resolveNativeClass = function(name) {
	return $global[name];
};
var js_html_VideoFrameBufferInit = function() { };
js_html_VideoFrameBufferInit.__name__ = "js.html.VideoFrameBufferInit";
js_html_VideoFrameBufferInit.__isInterface__ = true;
js_html_VideoFrameBufferInit.prototype = {
	__class__: js_html_VideoFrameBufferInit
};
var js_html_VideoColorSpaceInit = function() { };
js_html_VideoColorSpaceInit.__name__ = "js.html.VideoColorSpaceInit";
js_html_VideoColorSpaceInit.__isInterface__ = true;
js_html_VideoColorSpaceInit.prototype = {
	__class__: js_html_VideoColorSpaceInit
};
var js_html_PlaneLayout = function() { };
js_html_PlaneLayout.__name__ = "js.html.PlaneLayout";
js_html_PlaneLayout.__isInterface__ = true;
js_html_PlaneLayout.prototype = {
	__class__: js_html_PlaneLayout
};
var js_html_DOMRectInit = function() { };
js_html_DOMRectInit.__name__ = "js.html.DOMRectInit";
js_html_DOMRectInit.__isInterface__ = true;
js_html_DOMRectInit.prototype = {
	__class__: js_html_DOMRectInit
};
var js_html_VideoFrameInit = function() { };
js_html_VideoFrameInit.__name__ = "js.html.VideoFrameInit";
js_html_VideoFrameInit.__isInterface__ = true;
js_html_VideoFrameInit.prototype = {
	__class__: js_html_VideoFrameInit
};
var js_injecting_InjectorRO = function() { };
js_injecting_InjectorRO.__name__ = "js.injecting.InjectorRO";
js_injecting_InjectorRO.__isInterface__ = true;
js_injecting_InjectorRO.prototype = {
	__class__: js_injecting_InjectorRO
};
var nanofl_engine_InstanceDisplayObject = function() { };
nanofl_engine_InstanceDisplayObject.__name__ = "nanofl.engine.InstanceDisplayObject";
nanofl_engine_InstanceDisplayObject.__isInterface__ = true;
nanofl_engine_InstanceDisplayObject.prototype = {
	__class__: nanofl_engine_InstanceDisplayObject
};
var nanofl_engine_AdvancableDisplayObject = function() { };
nanofl_engine_AdvancableDisplayObject.__name__ = "nanofl.engine.AdvancableDisplayObject";
nanofl_engine_AdvancableDisplayObject.__isInterface__ = true;
nanofl_engine_AdvancableDisplayObject.prototype = {
	__class__: nanofl_engine_AdvancableDisplayObject
};
var nanofl_engine_ILibraryItem = function() { };
nanofl_engine_ILibraryItem.__name__ = "nanofl.engine.ILibraryItem";
nanofl_engine_ILibraryItem.__isInterface__ = true;
nanofl_engine_ILibraryItem.prototype = {
	__class__: nanofl_engine_ILibraryItem
};
var nanofl_engine_IMotionTween = function() { };
nanofl_engine_IMotionTween.__name__ = "nanofl.engine.IMotionTween";
nanofl_engine_IMotionTween.__isInterface__ = true;
nanofl_engine_IMotionTween.prototype = {
	__class__: nanofl_engine_IMotionTween
};
var nanofl_engine_ISelectable = function() { };
nanofl_engine_ISelectable.__name__ = "nanofl.engine.ISelectable";
nanofl_engine_ISelectable.__isInterface__ = true;
nanofl_engine_ISelectable.prototype = {
	__class__: nanofl_engine_ISelectable
};
var nanofl_engine_ITextureItem = function() { };
nanofl_engine_ITextureItem.__name__ = "nanofl.engine.ITextureItem";
nanofl_engine_ITextureItem.__isInterface__ = true;
nanofl_engine_ITextureItem.prototype = {
	__class__: nanofl_engine_ITextureItem
};
var nanofl_engine_fills_IFill = function() { };
nanofl_engine_fills_IFill.__name__ = "nanofl.engine.fills.IFill";
nanofl_engine_fills_IFill.__isInterface__ = true;
nanofl_engine_fills_IFill.prototype = {
	__class__: nanofl_engine_fills_IFill
};
var nanofl_engine_libraryitems_ISpritableItem = function() { };
nanofl_engine_libraryitems_ISpritableItem.__name__ = "nanofl.engine.libraryitems.ISpritableItem";
nanofl_engine_libraryitems_ISpritableItem.__isInterface__ = true;
nanofl_engine_libraryitems_ISpritableItem.prototype = {
	__class__: nanofl_engine_libraryitems_ISpritableItem
};
var nanofl_engine_libraryitems_IPlayableItem = function() { };
nanofl_engine_libraryitems_IPlayableItem.__name__ = "nanofl.engine.libraryitems.IPlayableItem";
nanofl_engine_libraryitems_IPlayableItem.__isInterface__ = true;
nanofl_engine_libraryitems_IPlayableItem.prototype = {
	__class__: nanofl_engine_libraryitems_IPlayableItem
};
var nanofl_engine_strokes_IStroke = function() { };
nanofl_engine_strokes_IStroke.__name__ = "nanofl.engine.strokes.IStroke";
nanofl_engine_strokes_IStroke.__isInterface__ = true;
nanofl_engine_strokes_IStroke.prototype = {
	__class__: nanofl_engine_strokes_IStroke
};
var nanofl_ide_ISymbol = function() { };
nanofl_ide_ISymbol.__name__ = "nanofl.ide.ISymbol";
nanofl_ide_ISymbol.__isInterface__ = true;
nanofl_ide_ISymbol.prototype = {
	__class__: nanofl_ide_ISymbol
};
var nanofl_ide_libraryitems_IIdeLibraryItem = function() { };
nanofl_ide_libraryitems_IIdeLibraryItem.__name__ = "nanofl.ide.libraryitems.IIdeLibraryItem";
nanofl_ide_libraryitems_IIdeLibraryItem.__isInterface__ = true;
nanofl_ide_libraryitems_IIdeLibraryItem.__interfaces__ = [nanofl_engine_ILibraryItem];
nanofl_ide_libraryitems_IIdeLibraryItem.prototype = {
	__class__: nanofl_ide_libraryitems_IIdeLibraryItem
};
var nanofl_ide_libraryitems_IIdeInstancableItem = function() { };
nanofl_ide_libraryitems_IIdeInstancableItem.__name__ = "nanofl.ide.libraryitems.IIdeInstancableItem";
nanofl_ide_libraryitems_IIdeInstancableItem.__isInterface__ = true;
nanofl_ide_libraryitems_IIdeInstancableItem.__interfaces__ = [nanofl_ide_libraryitems_IIdeLibraryItem,nanofl_ide_ISymbol];
nanofl_ide_libraryitems_IIdeInstancableItem.prototype = {
	__class__: nanofl_ide_libraryitems_IIdeInstancableItem
};
var nanofl_ide_sys_Environment = function() { };
nanofl_ide_sys_Environment.__name__ = "nanofl.ide.sys.Environment";
nanofl_ide_sys_Environment.__isInterface__ = true;
nanofl_ide_sys_Environment.prototype = {
	__class__: nanofl_ide_sys_Environment
};
var nanofl_ide_sys_FileSystem = function() { };
nanofl_ide_sys_FileSystem.__name__ = "nanofl.ide.sys.FileSystem";
nanofl_ide_sys_FileSystem.__isInterface__ = true;
nanofl_ide_sys_FileSystem.prototype = {
	__class__: nanofl_ide_sys_FileSystem
};
var nanofl_ide_sys_Folders = function() { };
nanofl_ide_sys_Folders.__name__ = "nanofl.ide.sys.Folders";
nanofl_ide_sys_Folders.__isInterface__ = true;
nanofl_ide_sys_Folders.prototype = {
	__class__: nanofl_ide_sys_Folders
};
var nanofl_ide_sys_Fonts = function() { };
nanofl_ide_sys_Fonts.__name__ = "nanofl.ide.sys.Fonts";
nanofl_ide_sys_Fonts.__isInterface__ = true;
nanofl_ide_sys_Fonts.prototype = {
	__class__: nanofl_ide_sys_Fonts
};
var nanofl_ide_sys_HttpUtils = function() { };
nanofl_ide_sys_HttpUtils.__name__ = "nanofl.ide.sys.HttpUtils";
nanofl_ide_sys_HttpUtils.__isInterface__ = true;
nanofl_ide_sys_HttpUtils.prototype = {
	__class__: nanofl_ide_sys_HttpUtils
};
var nanofl_ide_sys_MediaUtils = function() { };
nanofl_ide_sys_MediaUtils.__name__ = "nanofl.ide.sys.MediaUtils";
nanofl_ide_sys_MediaUtils.__isInterface__ = true;
nanofl_ide_sys_MediaUtils.prototype = {
	__class__: nanofl_ide_sys_MediaUtils
};
var nanofl_ide_sys_ProcessManager = function() { };
nanofl_ide_sys_ProcessManager.__name__ = "nanofl.ide.sys.ProcessManager";
nanofl_ide_sys_ProcessManager.__isInterface__ = true;
nanofl_ide_sys_ProcessManager.prototype = {
	__class__: nanofl_ide_sys_ProcessManager
};
var nanofl_ide_sys_Zip = function() { };
nanofl_ide_sys_Zip.__name__ = "nanofl.ide.sys.Zip";
nanofl_ide_sys_Zip.__isInterface__ = true;
nanofl_ide_sys_Zip.prototype = {
	__class__: nanofl_ide_sys_Zip
};
var stdlib_Debug = function() { };
stdlib_Debug.__name__ = "stdlib.Debug";
stdlib_Debug.getDump = function(v,limit,level,prefix) {
	if(prefix == null) {
		prefix = "";
	}
	if(level == null) {
		level = 0;
	}
	if(limit == null) {
		limit = 10;
	}
	if(level >= limit) {
		return "...\n";
	}
	prefix += "\t";
	var s = "?\n";
	var _g = Type.typeof(v);
	switch(_g._hx_index) {
	case 0:
		s = "NULL\n";
		break;
	case 1:
		s = "INT(" + Std.string(v) + ")\n";
		break;
	case 2:
		s = "FLOAT(" + Std.string(v) + ")\n";
		break;
	case 3:
		s = "BOOL(" + (v ? "true" : "false") + ")\n";
		break;
	case 4:
		s = "OBJECT" + "\n" + stdlib_Debug.getObjectDump(v,limit,level + 1,prefix);
		break;
	case 5:
		s = "FUNCTION\n";
		break;
	case 6:
		var c = _g.c;
		if(c == String) {
			s = "STRING(" + Std.string(v) + ")\n";
		} else if(c == Array) {
			s = "ARRAY(" + Std.string(v.length) + ")\n";
			var _g1 = 0;
			var _g2 = js_Boot.__cast(v , Array);
			while(_g1 < _g2.length) {
				var item = _g2[_g1];
				++_g1;
				s += prefix + stdlib_Debug.getDump(item,limit,level + 1,prefix);
			}
		} else if(c == haxe_ds_List) {
			s = "LIST(" + Lambda.count(v) + ")\n";
			var _g_head = (js_Boot.__cast(v , haxe_ds_List)).h;
			while(_g_head != null) {
				var val = _g_head.item;
				_g_head = _g_head.next;
				var item = val;
				s += prefix + stdlib_Debug.getDump(item,limit,level + 1,prefix);
			}
		} else if(c == haxe_ds_StringMap) {
			s = "StringMap\n";
			var map = js_Boot.__cast(v , haxe_ds_StringMap);
			var h = map.h;
			var _g_h = h;
			var _g_keys = Object.keys(h);
			var _g_length = _g_keys.length;
			var _g_current = 0;
			while(_g_current < _g_length) {
				var key = _g_keys[_g_current++];
				s += prefix + key + " => " + stdlib_Debug.getDump(map.h[key],limit,level + 1,prefix);
			}
		} else {
			s = "CLASS(" + c.__name__ + ")\n" + stdlib_Debug.getObjectDump(v,limit,level + 1,prefix);
		}
		break;
	case 7:
		var e = _g.e;
		var e1 = v;
		s = "ENUM(" + e.__ename__ + ") = " + $hxEnums[e1.__enum__].__constructs__[e1._hx_index]._hx_name + "\n";
		break;
	case 8:
		s = "UNKNOW\n";
		break;
	}
	return s;
};
stdlib_Debug.getObjectDump = function(obj,limit,level,prefix) {
	var s = "";
	var _g = 0;
	var _g1 = Reflect.fields(obj);
	while(_g < _g1.length) {
		var fieldName = _g1[_g];
		++_g;
		s += prefix + fieldName + " : " + stdlib_Debug.getDump(Reflect.field(obj,fieldName),limit,level,prefix);
	}
	return s;
};
stdlib_Debug.assert = function(e,message,pos) {
	if(!e) {
		if(message == null) {
			message = "error";
		} else if(Reflect.isFunction(message)) {
			message = message();
		}
		var s = "ASSERT " + Std.string(message) + " in " + pos.fileName + " at line " + pos.lineNumber;
		throw new Error(s);
	}
};
stdlib_Debug.traceStack = function(v,pos) {
	var stack = stdlib_StringTools.trim(StringTools.replace(haxe_CallStack.toString(haxe_CallStack.callStack()),"prototype<.",""));
	var _g = [];
	var _g1 = 0;
	var _g2 = stack.split("\n");
	while(_g1 < _g2.length) {
		var v1 = _g2[_g1];
		++_g1;
		if(v1 != "Called from module") {
			_g.push(v1);
		}
	}
	var _this = _g;
	var result = new Array(_this.length);
	var _g = 0;
	var _g1 = _this.length;
	while(_g < _g1) {
		var i = _g++;
		var _this1 = _this[i].split("@");
		var result1 = new Array(_this1.length);
		var _g2 = 0;
		var _g3 = _this1.length;
		while(_g2 < _g3) {
			var i1 = _g2++;
			result1[i1] = stdlib_StringTools.rtrim(_this1[i1],"</");
		}
		result[i] = result1.join("@");
	}
	var lines = result;
	var len = 0;
	var _g = 0;
	while(_g < lines.length) {
		var line = lines[_g];
		++_g;
		var b = line.indexOf("@");
		if(len <= b) {
			len = b;
		}
	}
	var result = new Array(lines.length);
	var _g = 0;
	var _g1 = lines.length;
	while(_g < _g1) {
		var i = _g++;
		var ss = lines[i].split("@");
		result[i] = ss[0] + StringTools.rpad(""," ",len - ss[0].length + 1) + ss[1];
	}
	lines = result;
	stack = lines.slice(1).join("\n");
	haxe_Log.trace("TRACE " + (typeof(v) == "string" ? v : stdlib_StringTools.trim(stdlib_Debug.getDump(v))) + "\nStack trace:\n" + stack,{ fileName : "stdlib/Debug.hx", lineNumber : 189, className : "stdlib.Debug", methodName : "traceStack", customParams : [pos]});
};
stdlib_Debug.methodNotSupported = function(_this,pos) {
	var c = js_Boot.getClass(_this);
	throw new haxe_Exception("Method " + pos.methodName + "() is not supported by class " + c.__name__ + ".");
};
var stdlib_Event = function(target) {
	this.target = target;
	this.handlers = [];
};
stdlib_Event.__name__ = "stdlib.Event";
stdlib_Event.prototype = {
	bind: function(handler) {
		this.handlers.push(handler);
	}
	,unbind: function(handler) {
		while(HxOverrides.remove(this.handlers,handler)) {
		}
	}
	,unbindAll: function() {
		this.handlers = [];
	}
	,call: function(args) {
		var _g = 0;
		var _g1 = this.handlers;
		while(_g < _g1.length) {
			var handler = _g1[_g];
			++_g;
			handler.apply(null,[this.target,args]);
		}
	}
	,__class__: stdlib_Event
};
var stdlib_Std = function() { };
stdlib_Std.__name__ = "stdlib.Std";
stdlib_Std.isOfType = function(v,t) {
	return js_Boot.__instanceof(v,t);
};
stdlib_Std.string = function(s) {
	return Std.string(s);
};
stdlib_Std.int = function(x) {
	return x | 0;
};
stdlib_Std.random = function(x) {
	return Std.random(x);
};
stdlib_Std.parseInt = function(x,defaultValue) {
	if(x != null) {
		if(new EReg("^\\s*[+-]?\\s*((?:0x[0-9a-fA-F]{1,7})|(?:\\d{1,9}))\\s*$","").match(x)) {
			return Std.parseInt(x);
		} else {
			return defaultValue;
		}
	} else {
		return defaultValue;
	}
};
stdlib_Std.parseFloat = function(x,defaultValue) {
	if(x == null) {
		return defaultValue;
	}
	if(new EReg("^\\s*[+-]?\\s*\\d{1,20}(?:[.]\\d+)?(?:e[+-]?\\d{1,20})?\\s*$","").match(x)) {
		var r = parseFloat(x);
		if(!isNaN(r)) {
			return r;
		} else {
			return defaultValue;
		}
	}
	return defaultValue;
};
stdlib_Std.downcast = function(obj,_) {
	return obj;
};
stdlib_Std.bool = function(v) {
	if(v != false && v != null && v != 0 && v != "" && v != "0") {
		if(typeof(v) == "string") {
			if((js_Boot.__cast(v , String)).toLowerCase() != "false" && (js_Boot.__cast(v , String)).toLowerCase() != "off") {
				return (js_Boot.__cast(v , String)).toLowerCase() != "null";
			} else {
				return false;
			}
		} else {
			return true;
		}
	} else {
		return false;
	}
};
stdlib_Std.parseValue = function(x) {
	var value = x;
	var valueLC = value != null ? value.toLowerCase() : null;
	var parsedValue;
	if(valueLC == "true") {
		value = true;
	} else if(valueLC == "false") {
		value = false;
	} else if(valueLC == "null") {
		value = null;
	} else {
		parsedValue = stdlib_Std.parseInt(value);
		if(parsedValue != null) {
			value = parsedValue;
		} else {
			parsedValue = stdlib_Std.parseFloat(value);
			if(parsedValue != null) {
				value = parsedValue;
			}
		}
	}
	return value;
};
stdlib_Std.hash = function(obj) {
	var r = new haxe_ds_StringMap();
	var _g = 0;
	var _g1 = Reflect.fields(obj);
	while(_g < _g1.length) {
		var key = _g1[_g];
		++_g;
		r.h[key] = Reflect.field(obj,key);
	}
	return r;
};
stdlib_Std.min = function(a,b) {
	if(a < b) {
		return a;
	} else {
		return b;
	}
};
stdlib_Std.max = function(a,b) {
	if(a > b) {
		return a;
	} else {
		return b;
	}
};
stdlib_Std.abs = function(x) {
	if(x >= 0) {
		return x;
	} else {
		return -x;
	}
};
stdlib_Std.sign = function(n) {
	if(n > 0) {
		return 1;
	} else if(n < 0) {
		return -1;
	} else {
		return 0;
	}
};
var stdlib_StringTools = function() { };
stdlib_StringTools.__name__ = "stdlib.StringTools";
stdlib_StringTools.ltrim = function(s,chars) {
	if(chars == null) {
		return StringTools.ltrim(s);
	}
	while(s.length > 0 && chars.indexOf(HxOverrides.substr(s,0,1)) >= 0) s = HxOverrides.substr(s,1,null);
	return s;
};
stdlib_StringTools.rtrim = function(s,chars) {
	if(chars == null) {
		return StringTools.rtrim(s);
	}
	while(s.length > 0 && chars.indexOf(HxOverrides.substr(s,s.length - 1,1)) >= 0) s = HxOverrides.substr(s,0,s.length - 1);
	return s;
};
stdlib_StringTools.trim = function(s,chars) {
	if(chars == null) {
		return StringTools.trim(s);
	}
	return stdlib_StringTools.rtrim(stdlib_StringTools.ltrim(s,chars),chars);
};
stdlib_StringTools.hexdec = function(s) {
	return stdlib_Std.parseInt("0x" + s);
};
stdlib_StringTools.addcslashes = function(s) {
	return new EReg("['\"\t\r\n\\\\]","g").map(s,function(re) {
		return "\\" + re.matched(0);
	});
};
stdlib_StringTools.stripTags = function(str,allowedTags) {
	if(allowedTags == null) {
		allowedTags = "";
	}
	var allowedTagsArray = [];
	if(allowedTags != "") {
		var re = new EReg("[a-zA-Z0-9]+","i");
		var pos = 0;
		while(re.matchSub(allowedTags,pos)) {
			allowedTagsArray.push(re.matched(0));
			pos = re.matchedPos().pos + re.matchedPos().len;
		}
	}
	var re = new EReg("</?[\\S][^>]*>","g");
	str = re.map(str,function(_) {
		var html = re.matched(0);
		var allowed = false;
		if(allowedTagsArray.length > 0) {
			var htmlLC = html.toLowerCase();
			var _g = 0;
			while(_g < allowedTagsArray.length) {
				var allowedTag = allowedTagsArray[_g];
				++_g;
				if(StringTools.startsWith(htmlLC,"<" + allowedTag + ">") || StringTools.startsWith(htmlLC,"<" + allowedTag + " ") || StringTools.startsWith(htmlLC,"</" + allowedTag)) {
					allowed = true;
					break;
				}
			}
		}
		if(allowed) {
			return html;
		} else {
			return "";
		}
	});
	return str;
};
stdlib_StringTools.regexEscape = function(s) {
	var _this_r = new RegExp("([\\-\\[\\]/\\{\\}\\(\\)\\*\\+\\?\\.\\\\\\^\\$\\|])","g".split("u").join(""));
	return s.replace(_this_r,"\\$1");
};
stdlib_StringTools.jsonEscape = function(s) {
	if(s == null) {
		return "null";
	}
	var r = "\"";
	var _g_offset = 0;
	var _g_s = s;
	while(_g_offset < _g_s.length) {
		var s = _g_s;
		var index = _g_offset++;
		var c = s.charCodeAt(index);
		if(c >= 55296 && c <= 56319) {
			c = c - 55232 << 10 | s.charCodeAt(index + 1) & 1023;
		}
		var c1 = c;
		if(c1 >= 65536) {
			++_g_offset;
		}
		var c2 = c1;
		switch(c2) {
		case 9:
			r += "\\t";
			break;
		case 10:
			r += "\\n";
			break;
		case 13:
			r += "\\r";
			break;
		case 34:
			r += "\\\"";
			break;
		case 92:
			r += "\\\\";
			break;
		default:
			if(c2 < 32) {
				r += "\\u" + StringTools.hex(c2,4);
			} else {
				r += String.fromCodePoint(c2);
			}
		}
	}
	r += "\"";
	return r;
};
stdlib_StringTools.isNullOrEmpty = function(s) {
	if(s != null) {
		return s == "";
	} else {
		return true;
	}
};
stdlib_StringTools.capitalize = function(s) {
	if(s == "") {
		return s;
	} else {
		return HxOverrides.substr(s,0,1).toUpperCase() + HxOverrides.substr(s,1,null);
	}
};
stdlib_StringTools.urlEncode = function(s) {
	return encodeURIComponent(s);
};
stdlib_StringTools.urlDecode = function(s) {
	return decodeURIComponent(s.split("+").join(" "));
};
stdlib_StringTools.htmlEscape = function(s,quotes) {
	return StringTools.htmlEscape(s,quotes);
};
stdlib_StringTools.htmlUnescape = function(s) {
	return StringTools.htmlUnescape(s);
};
stdlib_StringTools.contains = function(s,value) {
	return s.indexOf(value) != -1;
};
stdlib_StringTools.startsWith = function(s,start) {
	return StringTools.startsWith(s,start);
};
stdlib_StringTools.endsWith = function(s,end) {
	return StringTools.endsWith(s,end);
};
stdlib_StringTools.isSpace = function(s,pos) {
	return StringTools.isSpace(s,pos);
};
stdlib_StringTools.lpad = function(s,c,l) {
	return StringTools.lpad(s,c,l);
};
stdlib_StringTools.rpad = function(s,c,l) {
	return StringTools.rpad(s,c,l);
};
stdlib_StringTools.replace = function(s,sub,by) {
	return StringTools.replace(s,sub,by);
};
stdlib_StringTools.hex = function(n,digits) {
	return StringTools.hex(n,digits);
};
stdlib_StringTools.fastCodeAt = function(s,index) {
	return s.charCodeAt(index);
};
stdlib_StringTools.unsafeCodeAt = function(s,index) {
	return s.charCodeAt(index);
};
stdlib_StringTools.iterator = function(s) {
	return new haxe_iterators_StringIterator(s);
};
stdlib_StringTools.keyValueIterator = function(s) {
	return new haxe_iterators_StringKeyValueIterator(s);
};
stdlib_StringTools.isEof = function(c) {
	return c != c;
};
stdlib_StringTools.quoteUnixArg = function(argument) {
	return StringTools.quoteUnixArg(argument);
};
stdlib_StringTools.quoteWinArg = function(argument,escapeMetaCharacters) {
	return StringTools.quoteWinArg(argument,escapeMetaCharacters);
};
var svgimport_BaseExporter = function(svg,library) {
	this.svg = svg;
	this.library = library;
};
svgimport_BaseExporter.__name__ = "svgimport.BaseExporter";
svgimport_BaseExporter.prototype = {
	elementsToLibraryItem: function(elements,id) {
		stdlib_Debug.assert(id != null && id != "","ID must not be empty (" + id + ").",{ fileName : "src/svgimport/BaseExporter.hx", lineNumber : 33, className : "svgimport.BaseExporter", methodName : "elementsToLibraryItem"});
		var mc = nanofl.ide.libraryitems.MovieClipItem.createWithFrame(id,elements,"auto");
		this.library.addItem(mc);
		return mc;
	}
	,applyMaskToElement: function(element,matrix,maskID,prefixID) {
		if(element == null) {
			return null;
		}
		if(maskID != null) {
			element = this.elementsToLibraryItem([element],this.getNextFreeID(prefixID)).newInstance();
			stdlib_Debug.assert(((element) instanceof nanofl.engine.elements.Instance),null,{ fileName : "src/svgimport/BaseExporter.hx", lineNumber : 50, className : "svgimport.BaseExporter", methodName : "applyMaskToElement"});
			stdlib_Debug.assert(this.library.getItem((js_Boot.__cast(element , nanofl.engine.elements.Instance)).namePath) != null,null,{ fileName : "src/svgimport/BaseExporter.hx", lineNumber : 51, className : "svgimport.BaseExporter", methodName : "applyMaskToElement"});
			var item = js_Boot.__cast(this.library.getItem((js_Boot.__cast(element , nanofl.engine.elements.Instance)).namePath) , nanofl.ide.libraryitems.MovieClipItem);
			stdlib_Debug.assert(item != null,null,{ fileName : "src/svgimport/BaseExporter.hx", lineNumber : 54, className : "svgimport.BaseExporter", methodName : "applyMaskToElement"});
			this.addMaskItemLayerToMovieClipItem(item,matrix,maskID);
		}
		return element;
	}
	,applyFilterToElement: function(element,filterID,prefixID) {
		if(element == null) {
			return null;
		}
		if(filterID != null) {
			var filter = this.svg.filters.h[filterID];
			if(filter != null) {
				var filterDefs = filter.export();
				if(filterDefs.length > 0) {
					element = this.elementsToLibraryItem([element],this.getNextFreeID(prefixID)).newInstance();
					(js_Boot.__cast(element , nanofl.engine.elements.Instance)).filters = filterDefs;
					var displayObject = element.createDisplayObject();
					var elemBounds = displayObject.getBounds();
					if(elemBounds != null) {
						var maskBounds;
						if(filter.filterUnits == "userSpaceOnUse") {
							maskBounds = new createjs.Rectangle(elemBounds.x + (filter.x != null ? filter.x : -elemBounds.width * 0.1),elemBounds.y + (filter.y != null ? filter.y : -elemBounds.height * 0.1),filter.width != null ? filter.width : elemBounds.width * 1.2,filter.height != null ? filter.height : elemBounds.height * 1.2);
						} else {
							maskBounds = new createjs.Rectangle(elemBounds.x + (filter.x != null ? filter.x * elemBounds.width : -elemBounds.width * 0.1),elemBounds.y + (filter.y != null ? filter.y * elemBounds.height : -elemBounds.height * 0.1),(filter.width != null ? filter.width : 1.2) * elemBounds.width,(filter.height != null ? filter.height : 1.2) * elemBounds.height);
						}
						if(!this.isRectangleNested(nanofl.DisplayObjectTools.getOuterBounds(displayObject),maskBounds)) {
							var mask = new nanofl.engine.elements.ShapeElement(null,[new nanofl.engine.geom.Polygon(new nanofl.engine.fills.SolidFill("red"),[nanofl.engine.geom.Contour.fromRectangle(maskBounds)])]);
							var item = this.elementsToLibraryItem([element],this.getNextFreeID(prefixID));
							this.addMaskElementLayerToMovieClipItem(item,mask);
							element = item.newInstance();
						}
					}
				}
			} else {
				haxe_Log.trace("Filter reference '" + filterID + "' is not found.",{ fileName : "src/svgimport/BaseExporter.hx", lineNumber : 119, className : "svgimport.BaseExporter", methodName : "applyFilterToElement"});
			}
		}
		return element;
	}
	,wrapMovieClipItemWithMask: function(item,matrix,maskID,id) {
		if(maskID == null) {
			return item;
		}
		var r = this.elementsToLibraryItem([item.newInstance()],id);
		this.addMaskItemLayerToMovieClipItem(r,matrix,maskID);
		return r;
	}
	,wrapMovieClipItemWithFilter: function(item,filterID,id) {
		if(filterID == null) {
			return item;
		}
		var instance = item.newInstance();
		instance = this.applyFilterToElement(instance,filterID,id);
		return this.elementsToLibraryItem([instance],id);
	}
	,addMaskItemLayerToMovieClipItem: function(item,matrix,maskID) {
		if(maskID != null) {
			var maskItem = this.library.hasItem(maskID) ? this.library.getItem(maskID) : this.exportSvgElementToLibrary(this.svg.elements.h[maskID]);
			var mask = (js_Boot.__cast(maskItem , nanofl.ide.libraryitems.MovieClipItem)).newInstance();
			mask.matrix = matrix.clone();
			this.addMaskElementLayerToMovieClipItem(item,mask);
		}
	}
	,addMaskElementLayerToMovieClipItem: function(item,mask) {
		stdlib_Debug.assert(mask != null,null,{ fileName : "src/svgimport/BaseExporter.hx", lineNumber : 163, className : "svgimport.BaseExporter", methodName : "addMaskElementLayerToMovieClipItem"});
		var maskLayer = new nanofl.engine.movieclip.Layer("auto_clip-path",nanofl.engine.LayerType.mask,true,true);
		maskLayer.addKeyFrame(new nanofl.engine.movieclip.KeyFrame(null,null,null,[mask]));
		stdlib_Debug.assert(item.get_layers().length == 1,null,{ fileName : "src/svgimport/BaseExporter.hx", lineNumber : 168, className : "svgimport.BaseExporter", methodName : "addMaskElementLayerToMovieClipItem"});
		item.addLayersBlock([maskLayer],0);
		item.get_layers()[1].parentIndex = 0;
		item.get_layers()[1].locked = true;
	}
	,exportSvgElementToLibrary: function(element) {
		switch(element._hx_index) {
		case 0:
			var p = element.path;
			return new svgimport_SvgPathExporter(this.svg,this.library,p).exportToLibrary();
		case 1:
			var g = element.group;
			return new svgimport_SvgGroupExporter(this.svg,this.library,g).exportToLibrary();
		default:
			return null;
		}
	}
	,getNextFreeID: function(prefix) {
		if(prefix == null) {
			prefix = "";
		}
		if(prefix == "") {
			prefix = "auto";
		}
		prefix += "_";
		var i = -1;
		var s;
		do s = prefix + ++i; while(Object.prototype.hasOwnProperty.call(this.svg.elements.h,s) || this.library.hasItem(s) || this.svg.usedIDs.indexOf(s) >= 0);
		this.svg.usedIDs.push(s);
		return s;
	}
	,isRectangleNested: function(inner,outer) {
		if(inner.x >= outer.x && inner.x + inner.width <= outer.x + outer.width && inner.y >= outer.y) {
			return inner.y + inner.height <= outer.y + outer.height;
		} else {
			return false;
		}
	}
	,__class__: svgimport_BaseExporter
};
var svgimport_FillType = $hxEnums["svgimport.FillType"] = { __ename__:"svgimport.FillType",__constructs__:null
	,FillNone: {_hx_name:"FillNone",_hx_index:0,__enum__:"svgimport.FillType",toString:$estr}
	,FillSolid: ($_=function(color) { return {_hx_index:1,color:color,__enum__:"svgimport.FillType",toString:$estr}; },$_._hx_name="FillSolid",$_.__params__ = ["color"],$_)
	,FillGrad: ($_=function(gradType) { return {_hx_index:2,gradType:gradType,__enum__:"svgimport.FillType",toString:$estr}; },$_._hx_name="FillGrad",$_.__params__ = ["gradType"],$_)
};
svgimport_FillType.__constructs__ = [svgimport_FillType.FillNone,svgimport_FillType.FillSolid,svgimport_FillType.FillGrad];
var svgimport_Rectangle = function(x,y,width,height) {
	this.x = x;
	this.y = y;
	this.width = width;
	this.height = height;
};
svgimport_Rectangle.__name__ = "svgimport.Rectangle";
svgimport_Rectangle.prototype = {
	__class__: svgimport_Rectangle
};
var svgimport_SegmentType = $hxEnums["svgimport.SegmentType"] = { __ename__:"svgimport.SegmentType",__constructs__:null
	,MOVE: ($_=function(seg) { return {_hx_index:0,seg:seg,__enum__:"svgimport.SegmentType",toString:$estr}; },$_._hx_name="MOVE",$_.__params__ = ["seg"],$_)
	,DRAW: ($_=function(seg) { return {_hx_index:1,seg:seg,__enum__:"svgimport.SegmentType",toString:$estr}; },$_._hx_name="DRAW",$_.__params__ = ["seg"],$_)
	,CURVE: ($_=function(seg) { return {_hx_index:2,seg:seg,__enum__:"svgimport.SegmentType",toString:$estr}; },$_._hx_name="CURVE",$_.__params__ = ["seg"],$_)
	,CUBIC: ($_=function(seg) { return {_hx_index:3,seg:seg,__enum__:"svgimport.SegmentType",toString:$estr}; },$_._hx_name="CUBIC",$_.__params__ = ["seg"],$_)
	,ARC: ($_=function(seg) { return {_hx_index:4,seg:seg,__enum__:"svgimport.SegmentType",toString:$estr}; },$_._hx_name="ARC",$_.__params__ = ["seg"],$_)
};
svgimport_SegmentType.__constructs__ = [svgimport_SegmentType.MOVE,svgimport_SegmentType.DRAW,svgimport_SegmentType.CURVE,svgimport_SegmentType.CUBIC,svgimport_SegmentType.ARC];
var svgimport_SegmentsParser = function() {
	if(svgimport_SegmentsParser.sCommandArgs == null) {
		svgimport_SegmentsParser.sCommandArgs = [];
		var _g = 0;
		while(_g < 128) {
			var i = _g++;
			svgimport_SegmentsParser.sCommandArgs[i] = this.commandArgs(i);
		}
	}
};
svgimport_SegmentsParser.__name__ = "svgimport.SegmentsParser";
svgimport_SegmentsParser.run = function(pathToParse) {
	return new svgimport_SegmentsParser().parse(pathToParse);
};
svgimport_SegmentsParser.prototype = {
	parse: function(pathToParse) {
		if(pathToParse == null) {
			return [];
		}
		this.lastMoveX = this.lastMoveY = 0;
		var pos = 0;
		var args = [];
		var segments = [];
		var current_command_pos = 0;
		var current_command = -1;
		var current_args = -1;
		this.prev = null;
		var len = pathToParse.length;
		var finished = false;
		while(pos <= len) {
			var code = pos == len ? 32 : HxOverrides.cca(pathToParse,pos);
			var command = code > 0 && code < 128 ? svgimport_SegmentsParser.sCommandArgs[code] : svgimport_SegmentsParser.UNKNOWN;
			if(command == svgimport_SegmentsParser.UNKNOWN) {
				throw haxe_Exception.thrown("failed parsing path near '" + HxOverrides.substr(pathToParse,pos,null) + "'");
			}
			if(command == svgimport_SegmentsParser.SEPARATOR) {
				++pos;
			} else if(command <= svgimport_SegmentsParser.FLOAT) {
				var end = pos + 1;
				var e_pos = -1;
				var seen_dot = command == svgimport_SegmentsParser.FLOAT_DOT;
				if(command == svgimport_SegmentsParser.FLOAT_EXP) {
					e_pos = 0;
					seen_dot = true;
				}
				while(end < pathToParse.length) {
					var ch = HxOverrides.cca(pathToParse,end);
					var code1 = ch < 0 || ch > 127 ? svgimport_SegmentsParser.UNKNOWN : svgimport_SegmentsParser.sCommandArgs[ch];
					if(code1 > svgimport_SegmentsParser.FLOAT) {
						break;
					}
					if(code1 == svgimport_SegmentsParser.FLOAT_DOT && seen_dot) {
						break;
					}
					if(e_pos >= 0) {
						if(code1 == svgimport_SegmentsParser.FLOAT_SIGN) {
							if(e_pos != 0) {
								break;
							}
						} else if(code1 != svgimport_SegmentsParser.FLOAT) {
							break;
						}
						++e_pos;
					} else if(code1 == svgimport_SegmentsParser.FLOAT_EXP) {
						if(e_pos >= 0) {
							break;
						}
						e_pos = 0;
						seen_dot = true;
					} else if(code1 == svgimport_SegmentsParser.FLOAT_SIGN) {
						break;
					}
					++end;
				}
				if(current_command >= 0) {
					var f = parseFloat(HxOverrides.substr(pathToParse,pos,end - pos));
					args.push(f);
				}
				pos = end;
			} else {
				current_command = code;
				current_args = command;
				finished = false;
				current_command_pos = pos;
				args = [];
				++pos;
			}
			var px = 0.0;
			var py = 0.0;
			if(current_command >= 0) {
				if(current_args == args.length) {
					this.prev = this.createCommand(current_command,args);
					if(this.prev == null) {
						throw haxe_Exception.thrown("Unknown command " + String.fromCodePoint(current_command) + " near '" + HxOverrides.substr(pathToParse,current_command_pos,null) + "'");
					}
					segments.push(this.prev);
					finished = true;
					if(current_args == 0) {
						current_args = -1;
						current_command = -1;
					} else if(current_command == 77) {
						current_command = 76;
					} else if(current_command == 109) {
						current_command = 108;
					}
					current_command_pos = pos;
					args = [];
				}
			}
		}
		if(current_command >= 0 && !finished) {
			throw haxe_Exception.thrown("Unfinished command (" + args.length + "/" + current_args + ") near '" + HxOverrides.substr(pathToParse,current_command_pos,null) + "'");
		}
		return segments;
	}
	,commandArgs: function(code) {
		if(code == 10) {
			return svgimport_SegmentsParser.SEPARATOR;
		}
		var str = String.fromCodePoint(code).toUpperCase();
		if(str >= "0" && str <= "9") {
			return svgimport_SegmentsParser.FLOAT;
		}
		switch(str) {
		case "+":
			return svgimport_SegmentsParser.FLOAT_SIGN;
		case "\t":case "\n":case "\r":case " ":case ",":
			return svgimport_SegmentsParser.SEPARATOR;
		case "-":
			return svgimport_SegmentsParser.FLOAT_SIGN;
		case ".":
			return svgimport_SegmentsParser.FLOAT_DOT;
		case "A":
			return 7;
		case "C":
			return 6;
		case "Q":case "S":
			return 4;
		case "L":case "M":case "T":
			return 2;
		case "H":case "V":
			return 1;
		case "Z":
			return 0;
		case "E":case "e":
			return svgimport_SegmentsParser.FLOAT_EXP;
		}
		return svgimport_SegmentsParser.UNKNOWN;
	}
	,prevX: function() {
		if(this.prev != null) {
			return this.prev.prevX();
		} else {
			return 0;
		}
	}
	,prevY: function() {
		if(this.prev != null) {
			return this.prev.prevY();
		} else {
			return 0;
		}
	}
	,prevCX: function() {
		if(this.prev != null) {
			return this.prev.prevCX();
		} else {
			return 0;
		}
	}
	,prevCY: function() {
		if(this.prev != null) {
			return this.prev.prevCY();
		} else {
			return 0;
		}
	}
	,createCommand: function(code,a) {
		switch(code) {
		case 65:
			return new svgimport_segments_ArcSegment(this.prevX(),this.prevY(),a[0],a[1],a[2],a[3] != 0.,a[4] != 0.,a[5],a[6]);
		case 67:
			return new svgimport_segments_CubicSegment(a[0],a[1],a[2],a[3],a[4],a[5]);
		case 72:
			return new svgimport_segments_DrawSegment(a[0],this.prevY());
		case 76:
			return new svgimport_segments_DrawSegment(a[0],a[1]);
		case 77:
			this.lastMoveX = a[0];
			this.lastMoveY = a[1];
			return new svgimport_segments_MoveSegment(this.lastMoveX,this.lastMoveY);
		case 81:
			return new svgimport_segments_QuadraticSegment(a[0],a[1],a[2],a[3]);
		case 83:
			var rx = this.prevX();
			var ry = this.prevY();
			return new svgimport_segments_CubicSegment(rx * 2 - this.prevCX(),ry * 2 - this.prevCY(),a[0],a[1],a[2],a[3]);
		case 84:
			var rx = this.prevX();
			var ry = this.prevY();
			return new svgimport_segments_QuadraticSegment(rx * 2 - this.prevCX(),rx * 2 - this.prevCY(),a[2],a[3]);
		case 86:
			return new svgimport_segments_DrawSegment(this.prevX(),a[0]);
		case 97:
			var rx = this.prevX();
			var ry = this.prevY();
			return new svgimport_segments_ArcSegment(rx,ry,a[0],a[1],a[2],a[3] != 0.,a[4] != 0.,a[5] + rx,a[6] + ry);
		case 99:
			var rx = this.prevX();
			var ry = this.prevY();
			return new svgimport_segments_CubicSegment(a[0] + rx,a[1] + ry,a[2] + rx,a[3] + ry,a[4] + rx,a[5] + ry);
		case 104:
			return new svgimport_segments_DrawSegment(a[0] + this.prevX(),this.prevY());
		case 108:
			return new svgimport_segments_DrawSegment(a[0] + this.prevX(),a[1] + this.prevY());
		case 109:
			this.lastMoveX = a[0] + this.prevX();
			this.lastMoveY = a[1] + this.prevY();
			return new svgimport_segments_MoveSegment(this.lastMoveX,this.lastMoveY);
		case 113:
			var rx = this.prevX();
			var ry = this.prevY();
			return new svgimport_segments_QuadraticSegment(a[0] + rx,a[1] + ry,a[2] + rx,a[3] + ry);
		case 115:
			var rx = this.prevX();
			var ry = this.prevY();
			return new svgimport_segments_CubicSegment(rx * 2 - this.prevCX(),ry * 2 - this.prevCY(),a[0] + rx,a[1] + ry,a[2] + rx,a[3] + ry);
		case 116:
			var rx = this.prevX();
			var ry = this.prevY();
			return new svgimport_segments_QuadraticSegment(rx * 2 - this.prevCX(),ry * 2 - this.prevCY(),a[0] + rx,a[1] + ry);
		case 118:
			return new svgimport_segments_DrawSegment(this.prevX(),a[0] + this.prevY());
		case 90:case 122:
			return new svgimport_segments_DrawSegment(this.lastMoveX,this.lastMoveY);
		}
		return null;
	}
	,__class__: svgimport_SegmentsParser
};
var svgimport_StrokeType = $hxEnums["svgimport.StrokeType"] = { __ename__:"svgimport.StrokeType",__constructs__:null
	,StrokeNone: {_hx_name:"StrokeNone",_hx_index:0,__enum__:"svgimport.StrokeType",toString:$estr}
	,StrokeSolid: ($_=function(color) { return {_hx_index:1,color:color,__enum__:"svgimport.StrokeType",toString:$estr}; },$_._hx_name="StrokeSolid",$_.__params__ = ["color"],$_)
	,StrokeGrad: ($_=function(gradType) { return {_hx_index:2,gradType:gradType,__enum__:"svgimport.StrokeType",toString:$estr}; },$_._hx_name="StrokeGrad",$_.__params__ = ["gradType"],$_)
};
svgimport_StrokeType.__constructs__ = [svgimport_StrokeType.StrokeNone,svgimport_StrokeType.StrokeSolid,svgimport_StrokeType.StrokeGrad];
var svgimport_SvgDisplayObject = function(svg,node,baseStyles,id) {
	this.svg = svg;
	this.node = node;
	this.id = id != null ? id : htmlparser.HtmlParserTools.getAttr(node,"id","");
	this.matrix = svgimport_Transform.load(node.getAttribute("transform"));
	this.visible = svgimport_XmlTools.getStyle(node,"display",baseStyles,null) != "none";
	this.clipPathID = svgimport_XmlTools.getIdFromUrl(svgimport_XmlTools.getStyle(node,"clip-path",baseStyles,null));
	this.filterID = svgimport_XmlTools.getIdFromUrl(svgimport_XmlTools.getStyle(node,"filter",baseStyles,null));
};
svgimport_SvgDisplayObject.__name__ = "svgimport.SvgDisplayObject";
svgimport_SvgDisplayObject.prototype = {
	__class__: svgimport_SvgDisplayObject
};
var svgimport_SvgGroup = function(svg,node,baseStyles,id) {
	this.children = [];
	svgimport_SvgDisplayObject.call(this,svg,node,baseStyles,id);
	if(this.id != "") {
		svg.elements.h[this.id] = svgimport_SvgElement.DisplayGroup(this);
	}
	this.name = htmlparser.HtmlParserTools.getAttr(node,"inkscape:label",this.id);
	this.loadChildren(node,svgimport_XmlTools.getStyles(node,baseStyles));
};
svgimport_SvgGroup.__name__ = "svgimport.SvgGroup";
svgimport_SvgGroup.__super__ = svgimport_SvgDisplayObject;
svgimport_SvgGroup.prototype = $extend(svgimport_SvgDisplayObject.prototype,{
	loadChildren: function(xml,styles) {
		var _g = 0;
		var _g1 = xml.children;
		while(_g < _g1.length) {
			var child = _g1[_g];
			++_g;
			switch(svgimport_XmlTools.normalizeTag(child.name)) {
			case "a":
				this.loadChildren(child,styles);
				break;
			case "circle":case "ellipse":case "line":case "path":case "polygon":case "polyline":case "rect":
				this.children.push(svgimport_SvgElement.DisplayPath(new svgimport_SvgPath(this.svg,child,styles)));
				break;
			case "defs":
				this.loadDefs(child);
				break;
			case "g":
				this.children.push(svgimport_SvgElement.DisplayGroup(new svgimport_SvgGroup(this.svg,child,styles)));
				break;
			case "linearGradient":
				this.loadGradient(child);
				break;
			case "radialGradient":
				this.loadGradient(child);
				break;
			case "text":
				this.children.push(svgimport_SvgElement.DisplayText(new svgimport_SvgText(child,styles,this.svg.gradients)));
				break;
			case "use":
				var use = new svgimport_SvgUse(this.svg,child,styles);
				if(use.groupID != null) {
					this.children.push(svgimport_SvgElement.DisplayUse(use));
				}
				break;
			default:
				haxe_Log.trace("Unknown tag '" + child.name + "'.",{ fileName : "src/svgimport/SvgGroup.hx", lineNumber : 57, className : "svgimport.SvgGroup", methodName : "loadChildren"});
			}
		}
	}
	,loadDefs: function(defsNode) {
		var _g = 0;
		var _g1 = defsNode.children;
		while(_g < _g1.length) {
			var child = _g1[_g];
			++_g;
			switch(svgimport_XmlTools.normalizeTag(child.name)) {
			case "circle":case "ellipse":case "line":case "path":case "polygon":case "polyline":case "rect":
				new svgimport_SvgPath(this.svg,child,null);
				break;
			case "clipPath":
				var tmp = this.svg;
				var _g2 = new haxe_ds_StringMap();
				_g2.h["stroke"] = "none";
				_g2.h["fill"] = "red";
				new svgimport_SvgGroup(tmp,child,_g2);
				break;
			case "filter":
				new svgimport_SvgFilter(this.svg,child);
				break;
			case "g":
				new svgimport_SvgGroup(this.svg,child,null);
				break;
			case "linearGradient":
				this.loadGradient(child);
				break;
			case "radialGradient":
				this.loadGradient(child);
				break;
			default:
				haxe_Log.trace("Unknown tag '" + child.name + "'.",{ fileName : "src/svgimport/SvgGroup.hx", lineNumber : 74, className : "svgimport.SvgGroup", methodName : "loadDefs"});
			}
		}
		var _g = 0;
		var _g1 = defsNode.children;
		while(_g < _g1.length) {
			var child = _g1[_g];
			++_g;
			switch(svgimport_XmlTools.normalizeTag(child.name)) {
			case "linearGradient":
				this.loadGradient(child);
				break;
			case "radialGradient":
				this.loadGradient(child);
				break;
			default:
			}
		}
	}
	,loadGradient: function(node) {
		var baseID = svgimport_XmlTools.getIdFromXlink(node);
		if(baseID == null || Object.prototype.hasOwnProperty.call(this.svg.gradients.h,baseID)) {
			var id = node.getAttribute("id");
			if(!Object.prototype.hasOwnProperty.call(this.svg.gradients.h,id)) {
				var this1 = this.svg.gradients;
				var value = svgimport_gradients_Gradient.load(this.svg,node,baseID != null ? this.svg.gradients.h[baseID] : null);
				this1.h[id] = value;
			}
		}
	}
	,__class__: svgimport_SvgGroup
});
var svgimport_Svg = function(xml) {
	this.usedIDs = [];
	this.filters = new haxe_ds_StringMap();
	this.gradients = new haxe_ds_StringMap();
	this.elements = new haxe_ds_StringMap();
	var svg = xml.children.length > 0 ? xml.children[0] : null;
	if(svg == null || svg.name != "svg" && svg.name != "svg:svg") {
		throw haxe_Exception.thrown("Not an SVG file (" + (svg == null ? "null" : svg.name) + ")");
	}
	this.detectSize(svg);
	svgimport_SvgGroup.call(this,this,svg,new haxe_ds_StringMap());
};
svgimport_Svg.__name__ = "svgimport.Svg";
svgimport_Svg.__super__ = svgimport_SvgGroup;
svgimport_Svg.prototype = $extend(svgimport_SvgGroup.prototype,{
	detectSize: function(svg) {
		this.width = 400.0;
		this.height = 400.0;
		if(svg.hasAttribute("viewBox")) {
			var params = new EReg("\\s+","g").split(svg.getAttribute("viewBox"));
			if(params.length == 4) {
				this.viewBox = new svgimport_Rectangle(parseFloat(params[0]),parseFloat(params[1]),parseFloat(params[2]),parseFloat(params[3]));
			}
		}
		if(svg.hasAttribute("width") && !StringTools.endsWith(svg.getAttribute("width"),"%") && svg.hasAttribute("height") && !StringTools.endsWith(svg.getAttribute("height"),"%")) {
			this.width = svgimport_XmlTools.getFloatStyle(svg,"width",null,400.0);
			this.height = svgimport_XmlTools.getFloatStyle(svg,"height",null,400.0);
		} else if(this.viewBox != null) {
			this.width = this.viewBox.width;
			this.height = this.viewBox.height;
		}
	}
	,__class__: svgimport_Svg
});
var svgimport_SvgAttributes = function() { };
svgimport_SvgAttributes.__name__ = "svgimport.SvgAttributes";
var svgimport_SvgElement = $hxEnums["svgimport.SvgElement"] = { __ename__:"svgimport.SvgElement",__constructs__:null
	,DisplayPath: ($_=function(path) { return {_hx_index:0,path:path,__enum__:"svgimport.SvgElement",toString:$estr}; },$_._hx_name="DisplayPath",$_.__params__ = ["path"],$_)
	,DisplayGroup: ($_=function(group) { return {_hx_index:1,group:group,__enum__:"svgimport.SvgElement",toString:$estr}; },$_._hx_name="DisplayGroup",$_.__params__ = ["group"],$_)
	,DisplayText: ($_=function(text) { return {_hx_index:2,text:text,__enum__:"svgimport.SvgElement",toString:$estr}; },$_._hx_name="DisplayText",$_.__params__ = ["text"],$_)
	,DisplayUse: ($_=function(use) { return {_hx_index:3,use:use,__enum__:"svgimport.SvgElement",toString:$estr}; },$_._hx_name="DisplayUse",$_.__params__ = ["use"],$_)
};
svgimport_SvgElement.__constructs__ = [svgimport_SvgElement.DisplayPath,svgimport_SvgElement.DisplayGroup,svgimport_SvgElement.DisplayText,svgimport_SvgElement.DisplayUse];
var svgimport_SvgFilter = function(svg,node) {
	this.node = node;
	var id = node.getAttribute("id");
	if(id != null && id != "" && !Object.prototype.hasOwnProperty.call(svg.filters.h,id)) {
		svg.filters.h[id] = this;
	}
	this.filterUnits = node.getAttribute("filterUnits");
	this.x = svgimport_XmlTools.getFloatValue(node,"x",null);
	this.y = svgimport_XmlTools.getFloatValue(node,"y",null);
	this.width = svgimport_XmlTools.getFloatValue(node,"width",null);
	this.height = svgimport_XmlTools.getFloatValue(node,"height",null);
};
svgimport_SvgFilter.__name__ = "svgimport.SvgFilter";
svgimport_SvgFilter.prototype = {
	'export': function() {
		var r = [];
		var _g = 0;
		var _g1 = this.node.children;
		while(_g < _g1.length) {
			var child = _g1[_g];
			++_g;
			var f = this.exportChild(child);
			if(f == null) {
				return [];
			}
			r.push(f);
		}
		return r;
	}
	,exportChild: function(node) {
		var name = svgimport_XmlTools.normalizeTag(node.name);
		switch(name) {
		case "feBlend":
			haxe_Log.trace("Filter '" + name + "' is unsupported.",{ fileName : "src/svgimport/SvgFilter.hx", lineNumber : 91, className : "svgimport.SvgFilter", methodName : "exportChild"});
			break;
		case "feColorMatrix":
			haxe_Log.trace("Filter '" + name + "' is unsupported.",{ fileName : "src/svgimport/SvgFilter.hx", lineNumber : 82, className : "svgimport.SvgFilter", methodName : "exportChild"});
			break;
		case "feGaussianBlur":
			var input = htmlparser.HtmlParserTools.getAttr(node,"in","SourceGraphic");
			if(input != "SourceGraphic") {
				haxe_Log.trace("Filter '" + name + "': 'in' attribute value different to 'SourceGraphic' is not supported.",{ fileName : "src/svgimport/SvgFilter.hx", lineNumber : 67, className : "svgimport.SvgFilter", methodName : "exportChild"});
				return null;
			}
			var stdDeviation = this.getFloatParams(htmlparser.HtmlParserTools.getAttr(node,"stdDeviation"),[0]);
			return new nanofl.engine.FilterDef("GaussianBlurFilterPlugin",{ radius : (stdDeviation[0] + stdDeviation[stdDeviation.length > 1 ? 1 : 0]) / 2 | 0});
		case "feMerge":
			haxe_Log.trace("Filter '" + name + "' is unsupported.",{ fileName : "src/svgimport/SvgFilter.hx", lineNumber : 88, className : "svgimport.SvgFilter", methodName : "exportChild"});
			break;
		case "feOffset":
			haxe_Log.trace("Filter '" + name + "' is unsupported.",{ fileName : "src/svgimport/SvgFilter.hx", lineNumber : 85, className : "svgimport.SvgFilter", methodName : "exportChild"});
			break;
		case "feComponentTransfer":case "feComposite":case "feConvolveMatrix":case "feDiffuseLighting":case "feDisplacementMap":case "feDistantLight":case "feFlood":case "feImage":case "feMorphology":case "fePointLight":case "feSpecularLighting":case "feSpotLight":case "feTile":case "feTurbulence":
			haxe_Log.trace("Filter '" + name + "' is not supported.",{ fileName : "src/svgimport/SvgFilter.hx", lineNumber : 107, className : "svgimport.SvgFilter", methodName : "exportChild"});
			break;
		default:
			haxe_Log.trace("Unknow filter '" + name + "'.",{ fileName : "src/svgimport/SvgFilter.hx", lineNumber : 110, className : "svgimport.SvgFilter", methodName : "exportChild"});
		}
		return null;
	}
	,getFloatParams: function(s,defValue) {
		if(s == null) {
			return defValue;
		}
		s = StringTools.trim(s);
		if(s == "") {
			return defValue;
		}
		var _this = new EReg("[ \t\r\n,]+","g").split(s);
		var defaultValue = null;
		var f = function(s) {
			return svgimport_XmlTools.toFloat(s,defaultValue);
		};
		var result = new Array(_this.length);
		var _g = 0;
		var _g1 = _this.length;
		while(_g < _g1) {
			var i = _g++;
			result[i] = f(_this[i]);
		}
		var _g = [];
		var _g1 = 0;
		var _g2 = result;
		while(_g1 < _g2.length) {
			var v = _g2[_g1];
			++_g1;
			if(v != null) {
				_g.push(v);
			}
		}
		return _g;
	}
	,__class__: svgimport_SvgFilter
};
var svgimport_SvgGroupExporter = function(svg,library,group) {
	svgimport_BaseExporter.call(this,svg,library);
	this.group = group;
};
svgimport_SvgGroupExporter.__name__ = "svgimport.SvgGroupExporter";
svgimport_SvgGroupExporter.__super__ = svgimport_BaseExporter;
svgimport_SvgGroupExporter.prototype = $extend(svgimport_BaseExporter.prototype,{
	exportToLibrary: function() {
		haxe_Log.trace("SvgGroupExporter.exportToLibrary " + this.group.id,{ fileName : "src/svgimport/SvgGroupExporter.hx", lineNumber : 28, className : "svgimport.SvgGroupExporter", methodName : "exportToLibrary"});
		this.layers = [];
		var _g = 0;
		var _g1 = this.group.children;
		while(_g < _g1.length) {
			var child = _g1[_g];
			++_g;
			switch(child._hx_index) {
			case 0:
				var path = child.path;
				this.addElement(new svgimport_SvgPathExporter(this.svg,this.library,path).exportAsElement());
				break;
			case 1:
				var g = child.group;
				var item = !this.library.hasItem(g.id) ? new svgimport_SvgGroupExporter(this.svg,this.library,g).exportToLibrary() : this.library.getItem(g.id);
				if(item != null) {
					var instance = new nanofl.engine.elements.Instance(item.namePath);
					instance.matrix = g.matrix.clone();
					this.addElement(instance,g.visible);
				}
				break;
			case 2:
				var text = child.text;
				this.addElement(new svgimport_SvgTextExporter(this.svg,this.library,text).exportAsElement());
				break;
			case 3:
				var use = child.use;
				this.addElement(new svgimport_SvgUseExporter(this.svg,this.library,use).exportAsElement());
				break;
			}
		}
		var namePath = this.group.clipPathID == null ? this.group.id != "" ? this.group.id : this.getNextFreeID() : this.getNextFreeID(this.group.id);
		var mc = new nanofl.ide.libraryitems.MovieClipItem(namePath);
		this.layers.reverse();
		var _g = 0;
		var _g1 = this.layers;
		while(_g < _g1.length) {
			var layer = _g1[_g];
			++_g;
			mc.addLayer(layer);
		}
		this.library.addItem(mc);
		mc = this.wrapMovieClipItemWithFilter(mc,this.group.filterID,this.getNextFreeID(this.group.id));
		mc = this.wrapMovieClipItemWithMask(mc,new nanofl.engine.geom.Matrix(),this.group.clipPathID,this.getNextFreeID(this.group.id));
		return mc;
	}
	,addElement: function(element,visible) {
		if(visible == null) {
			visible = true;
		}
		if(element == null) {
			return;
		}
		if(this.layers.length == 0) {
			this.createLayerWithFrame("auto_" + this.layers.length);
		}
		var frame = this.layers[this.layers.length - 1].get_keyFrames()[0];
		if(frame.get_elements().length > 0 && ((element) instanceof nanofl.engine.elements.ShapeElement) || this.layers[this.layers.length - 1].visible != visible) {
			frame = this.createLayerWithFrame("auto_" + this.layers.length,visible);
		}
		frame.addElement(element);
	}
	,createLayerWithFrame: function(name,visible) {
		if(visible == null) {
			visible = true;
		}
		var layer = new nanofl.engine.movieclip.Layer(name,null,visible);
		var keyFrame = new nanofl.engine.movieclip.KeyFrame();
		layer.addKeyFrame(keyFrame);
		this.layers.push(layer);
		return keyFrame;
	}
	,__class__: svgimport_SvgGroupExporter
});
var svgimport_SvgPath = function(svg,node,baseStyles,id) {
	svgimport_SvgDisplayObject.call(this,svg,node,baseStyles,id);
	if(this.id != "") {
		svg.elements.h[this.id] = svgimport_SvgElement.DisplayPath(this);
	}
	var styles = svgimport_XmlTools.getStyles(node,baseStyles);
	this.alpha = svgimport_XmlTools.getFloatStyle(node,"opacity",styles,1.0);
	this.fill = svgimport_XmlTools.getFillStyle(node,"fill",styles,svg.gradients);
	this.fillAlpha = svgimport_XmlTools.getFloatStyle(node,"fill-opacity",styles,1.0);
	this.fillRuleEvenOdd = svgimport_XmlTools.getStyle(node,"fill-rule",styles,"nonzero") == "evenodd";
	this.stroke = svgimport_XmlTools.getStrokeStyle(node,"stroke",styles,svg.gradients);
	this.strokeAlpha = svgimport_XmlTools.getFloatStyle(node,"stroke-opacity",styles,1.0);
	this.strokeWidth = svgimport_XmlTools.getFloatStyle(node,"stroke-width",styles,1.0);
	this.strokeCaps = svgimport_XmlTools.getStyle(node,"stroke-linecap",styles,"butt");
	this.strokeJoints = svgimport_XmlTools.getStyle(node,"stroke-linejoin",styles,"miter");
	this.strokeMiterLimit = svgimport_XmlTools.getFloatStyle(node,"stroke-miterlimit",styles,4.0);
	this.segments = [];
	switch(svgimport_XmlTools.normalizeTag(node.name)) {
	case "circle":case "ellipse":
		var x = svgimport_XmlTools.getFloatValue(node,"cx",0);
		var y = svgimport_XmlTools.getFloatValue(node,"cy",0);
		var r = svgimport_XmlTools.getFloatValue(node,"r",0);
		var w = svgimport_XmlTools.getFloatValue(node,"rx",r);
		var w_ = w * svgimport_SvgPath.SIN45;
		var cw_ = w * svgimport_SvgPath.TAN22;
		var h = svgimport_XmlTools.getFloatValue(node,"ry",r);
		var h_ = h * svgimport_SvgPath.SIN45;
		var ch_ = h * svgimport_SvgPath.TAN22;
		this.segments.push(new svgimport_segments_MoveSegment(x + w,y));
		this.segments.push(new svgimport_segments_QuadraticSegment(x + w,y + ch_,x + w_,y + h_));
		this.segments.push(new svgimport_segments_QuadraticSegment(x + cw_,y + h,x,y + h));
		this.segments.push(new svgimport_segments_QuadraticSegment(x - cw_,y + h,x - w_,y + h_));
		this.segments.push(new svgimport_segments_QuadraticSegment(x - w,y + ch_,x - w,y));
		this.segments.push(new svgimport_segments_QuadraticSegment(x - w,y - ch_,x - w_,y - h_));
		this.segments.push(new svgimport_segments_QuadraticSegment(x - cw_,y - h,x,y - h));
		this.segments.push(new svgimport_segments_QuadraticSegment(x + cw_,y - h,x + w_,y - h_));
		this.segments.push(new svgimport_segments_QuadraticSegment(x + w,y - ch_,x + w,y));
		this.strokeCaps = "round";
		this.strokeJoints = "round";
		break;
	case "path":
		this.segments = this.segments.concat(svgimport_SegmentsParser.run(node.getAttribute("d")));
		break;
	case "polygon":
		this.segments = this.segments.concat(svgimport_SegmentsParser.run("M" + node.getAttribute("points") + "z"));
		break;
	case "polyline":
		this.segments = this.segments.concat(svgimport_SegmentsParser.run("M" + node.getAttribute("points")));
		break;
	case "rect":
		var x = svgimport_XmlTools.getFloatValue(node,"x",0);
		var y = svgimport_XmlTools.getFloatValue(node,"y",0);
		var w = svgimport_XmlTools.getFloatValue(node,"width",0);
		var h = svgimport_XmlTools.getFloatValue(node,"height",0);
		var rx = svgimport_XmlTools.getFloatValue(node,"rx",0);
		var ry = svgimport_XmlTools.getFloatValue(node,"ry",rx);
		if(rx == 0 || ry == 0) {
			this.segments.push(new svgimport_segments_MoveSegment(x,y));
			this.segments.push(new svgimport_segments_DrawSegment(x + w,y));
			this.segments.push(new svgimport_segments_DrawSegment(x + w,y + h));
			this.segments.push(new svgimport_segments_DrawSegment(x,y + h));
			this.segments.push(new svgimport_segments_DrawSegment(x,y));
		} else {
			this.segments.push(new svgimport_segments_MoveSegment(x + rx,y));
			this.segments.push(new svgimport_segments_DrawSegment(x + w - rx,y));
			this.segments.push(new svgimport_segments_QuadraticSegment(x + w,y,x + w,y + ry));
			this.segments.push(new svgimport_segments_DrawSegment(x + w,y + h - ry));
			this.segments.push(new svgimport_segments_QuadraticSegment(x + w,y + h,x + w - rx,y + h));
			this.segments.push(new svgimport_segments_DrawSegment(x + rx,y + h));
			this.segments.push(new svgimport_segments_QuadraticSegment(x,y + h,x,y + h - ry));
			this.segments.push(new svgimport_segments_DrawSegment(x,y + ry));
			this.segments.push(new svgimport_segments_QuadraticSegment(x,y,x + rx,y));
		}
		break;
	}
};
svgimport_SvgPath.__name__ = "svgimport.SvgPath";
svgimport_SvgPath.__super__ = svgimport_SvgDisplayObject;
svgimport_SvgPath.prototype = $extend(svgimport_SvgDisplayObject.prototype,{
	toElement: function() {
		if(this.segments.length == 0) {
			return null;
		}
		var convertor = new svgimport_SvgPathToShapeConvertor();
		if(this.fill != null && this.fill != svgimport_FillType.FillNone) {
			convertor.beginFill(this);
			var _g = 0;
			var _g1 = this.segments;
			while(_g < _g1.length) {
				var segment = _g1[_g];
				++_g;
				segment.export(convertor);
			}
			convertor.endFill();
		}
		if(this.stroke != null && this.stroke != svgimport_StrokeType.StrokeNone) {
			convertor.beginStroke(this);
			var _g = 0;
			var _g1 = this.segments;
			while(_g < _g1.length) {
				var segment = _g1[_g];
				++_g;
				segment.export(convertor);
			}
			convertor.endStroke();
		}
		var shape = convertor.convert();
		shape.applyStrokeAlpha(this.alpha * this.strokeAlpha);
		shape.applyFillAlpha(this.alpha * this.fillAlpha);
		if(shape.isEmpty()) {
			return null;
		}
		return { shape : shape, bounds : convertor.getBounds()};
	}
	,__class__: svgimport_SvgPath
});
var svgimport_SvgPathExporter = function(svg,library,path) {
	svgimport_BaseExporter.call(this,svg,library);
	this.path = path;
};
svgimport_SvgPathExporter.__name__ = "svgimport.SvgPathExporter";
svgimport_SvgPathExporter.__super__ = svgimport_BaseExporter;
svgimport_SvgPathExporter.prototype = $extend(svgimport_BaseExporter.prototype,{
	exportAsElement: function() {
		haxe_Log.trace("SvgPathExporter.exportAsElement " + this.path.id,{ fileName : "src/svgimport/SvgPathExporter.hx", lineNumber : 28, className : "svgimport.SvgPathExporter", methodName : "exportAsElement"});
		var r = this.exportAsElementInner();
		r = this.applyFilterToElement(r,this.path.filterID,this.path.id);
		r = this.applyMaskToElement(r,this.path.matrix,this.path.clipPathID,this.path.id);
		return r;
	}
	,exportAsElementInner: function() {
		var shapeAndBounds = this.path.toElement();
		if(shapeAndBounds == null) {
			return null;
		}
		var shape = shapeAndBounds.shape;
		var bounds = shapeAndBounds.bounds;
		var canIgnoreStroke = shape.edges.length == 0 || this.path.stroke == svgimport_StrokeType.StrokeNone || this.path.stroke._hx_index == 1;
		var canIgnoreFill = shape.polygons.length == 0 || this.path.fill == svgimport_FillType.FillNone || this.path.fill._hx_index == 1;
		var aspectRatio = 1.0;
		var strokeMatrix = new nanofl.engine.geom.Matrix();
		if(!canIgnoreStroke) {
			var _g = this.path.stroke;
			if(_g._hx_index == 2) {
				var gradType = _g.gradType;
				switch(gradType._hx_index) {
				case 0:
					var grad = gradType.grad;
					strokeMatrix = grad.matrix;
					aspectRatio = this.getApsectRatio(bounds,grad);
					break;
				case 1:
					var grad = gradType.grad;
					strokeMatrix = grad.matrix;
					aspectRatio = this.getApsectRatio(bounds,grad);
					break;
				}
			}
		}
		var fillMatrix = new nanofl.engine.geom.Matrix();
		if(!canIgnoreFill) {
			var _g = this.path.fill;
			if(_g._hx_index == 2) {
				var gradType = _g.gradType;
				switch(gradType._hx_index) {
				case 0:
					var grad = gradType.grad;
					fillMatrix = grad.matrix;
					aspectRatio = this.getApsectRatio(bounds,grad);
					break;
				case 1:
					var grad = gradType.grad;
					fillMatrix = grad.matrix;
					aspectRatio = this.getApsectRatio(bounds,grad);
					break;
				}
			}
		}
		if((canIgnoreStroke || strokeMatrix.isIdentity() && aspectRatio == 1.0) && (canIgnoreFill || fillMatrix.isIdentity() && aspectRatio == 1.0)) {
			if(this.path.matrix.isIdentity()) {
				return shape;
			}
			var item = this.elementsToLibraryItem([shape],this.getNextFreeID(this.path.id));
			var instance = item.newInstance();
			instance.matrix = this.path.matrix;
			return instance;
		} else if(canIgnoreStroke) {
			stdlib_Debug.assert(!fillMatrix.isIdentity() || aspectRatio != 1.0,null,{ fileName : "src/svgimport/SvgPathExporter.hx", lineNumber : 106, className : "svgimport.SvgPathExporter", methodName : "exportAsElementInner"});
			var instance = this.shapeToInstance(shape,bounds,fillMatrix,aspectRatio,this.getNextFreeID(this.path.id));
			if(!instance.matrix.isIdentity()) {
				instance = this.elementsToLibraryItem([instance],this.getNextFreeID(this.path.id)).newInstance();
			}
			instance.matrix.prependMatrix(this.path.matrix);
			return instance;
		} else if(canIgnoreFill) {
			stdlib_Debug.assert(!strokeMatrix.isIdentity() || aspectRatio != 1.0,null,{ fileName : "src/svgimport/SvgPathExporter.hx", lineNumber : 116, className : "svgimport.SvgPathExporter", methodName : "exportAsElementInner"});
			var instance = this.shapeToInstance(shape,bounds,strokeMatrix,aspectRatio,this.getNextFreeID(this.path.id));
			if(!instance.matrix.isIdentity()) {
				instance = this.elementsToLibraryItem([instance],this.getNextFreeID(this.path.id)).newInstance();
			}
			instance.matrix.prependMatrix(this.path.matrix);
			return instance;
		} else {
			var item = this.elementsToLibraryItem([this.shapeToInstance(new nanofl.engine.elements.ShapeElement(null,shape.polygons),bounds,fillMatrix,aspectRatio,this.getNextFreeID(this.path.id)),this.shapeToInstance(new nanofl.engine.elements.ShapeElement(shape.edges),bounds,strokeMatrix,aspectRatio,this.getNextFreeID(this.path.id))],this.getNextFreeID(this.path.id));
			var instance = item.newInstance();
			instance.matrix = this.path.matrix;
			return instance;
		}
	}
	,exportToLibrary: function() {
		stdlib_Debug.assert(this.path.id != null && this.path.id != "",null,{ fileName : "src/svgimport/SvgPathExporter.hx", lineNumber : 145, className : "svgimport.SvgPathExporter", methodName : "exportToLibrary"});
		stdlib_Debug.assert(!this.library.hasItem(this.path.id),null,{ fileName : "src/svgimport/SvgPathExporter.hx", lineNumber : 146, className : "svgimport.SvgPathExporter", methodName : "exportToLibrary"});
		var element = this.exportAsElement();
		if(element == null) {
			return null;
		}
		if(((element) instanceof nanofl.engine.elements.ShapeElement)) {
			return this.elementsToLibraryItem([element],this.path.id);
		} else {
			return js_Boot.__cast(this.library.getItem((js_Boot.__cast(element , nanofl.engine.elements.Instance)).namePath) , nanofl.ide.libraryitems.MovieClipItem);
		}
	}
	,shapeToInstance: function(shape,bounds,matrix,aspectRatio,id) {
		shape = shape.clone();
		matrix = matrix.clone();
		if(aspectRatio != 1.0) {
			matrix.translate(-bounds.minX,-bounds.minY);
			matrix.scale(1,aspectRatio);
			matrix.translate(bounds.minX,bounds.minY);
		}
		var invertMatrix = matrix.clone().invert();
		shape.transform(invertMatrix,false);
		var k = invertMatrix.getAverageScale();
		var _g = 0;
		var _g1 = nanofl.engine.geom.StrokeEdges.duplicateStrokes(shape.edges);
		while(_g < _g1.length) {
			var stroke = _g1[_g];
			++_g;
			stroke.thickness *= k;
		}
		var item = this.elementsToLibraryItem([shape],id);
		var instance = item.newInstance();
		instance.matrix = matrix.clone();
		return instance;
	}
	,getApsectRatio: function(bounds,grad) {
		if(grad.gradientUnits != "userSpaceOnUse" && bounds.maxX - bounds.minX > svgimport_SvgPathExporter.EPS) {
			return (bounds.maxY - bounds.minY) / (bounds.maxX - bounds.minX);
		}
		return 1.0;
	}
	,__class__: svgimport_SvgPathExporter
});
var svgimport_SvgPathToShapeConvertor = function() {
	this.y = null;
	this.x = null;
	this.fillPath = null;
	this.stroke = null;
	this.polygonAndFillRules = [];
	this.edges = [];
};
svgimport_SvgPathToShapeConvertor.__name__ = "svgimport.SvgPathToShapeConvertor";
svgimport_SvgPathToShapeConvertor.log = function(v,infos) {
};
svgimport_SvgPathToShapeConvertor.prototype = {
	beginFill: function(path) {
		this.fillPath = path.fill != svgimport_FillType.FillNone ? path : null;
		this.polygonAndFillRules.push({ polygon : new nanofl.engine.geom.Polygon(null), fillRuleEvenOdd : path.fillRuleEvenOdd});
	}
	,endFill: function() {
		if(this.fillPath != null) {
			this.closeContour();
			var polygon = this.polygonAndFillRules[this.polygonAndFillRules.length - 1].polygon;
			var _g = this.fillPath.fill;
			switch(_g._hx_index) {
			case 0:
				break;
			case 1:
				var color = _g.color;
				polygon.fill = new nanofl.engine.fills.SolidFill(color);
				break;
			case 2:
				var gradType = _g.gradType;
				var bounds = polygon.getBounds();
				var tmp;
				switch(gradType._hx_index) {
				case 0:
					var grad = gradType.grad;
					var params = grad.getAbsoluteParams(bounds);
					tmp = new nanofl.engine.fills.LinearFill(this.getGradientRgbaColors(grad),grad.ratios,params.x1,params.y1,params.x2,params.y2);
					break;
				case 1:
					var grad = gradType.grad;
					if(grad.spreadMethod != "" && grad.spreadMethod != "pad") {
						haxe_Log.trace("Radial spread method 'pad' is only supported ('" + grad.spreadMethod + "').",{ fileName : "src/svgimport/SvgPathToShapeConvertor.hx", lineNumber : 76, className : "svgimport.SvgPathToShapeConvertor", methodName : "endFill"});
					}
					var params = grad.getAbsoluteParams(bounds);
					tmp = new nanofl.engine.fills.RadialFill(this.getGradientRgbaColors(grad),grad.ratios,params.cx,params.cy,params.r,params.fx,params.fy);
					break;
				}
				polygon.fill = tmp;
				break;
			}
			this.fillPath = null;
		}
	}
	,beginStroke: function(path) {
		var _g = path.stroke;
		switch(_g._hx_index) {
		case 0:
			this.stroke = null;
			break;
		case 1:
			var color = _g.color;
			this.stroke = new nanofl.engine.strokes.SolidStroke(color,path.strokeWidth,path.strokeCaps,path.strokeJoints,path.strokeMiterLimit,false);
			break;
		case 2:
			var gradType = _g.gradType;
			switch(gradType._hx_index) {
			case 0:
				var grad = gradType.grad;
				this.stroke = new nanofl.engine.strokes.LinearStroke(this.getGradientRgbaColors(grad),grad.ratios,grad.x1,grad.y1,grad.x2,grad.y2,path.strokeWidth,path.strokeCaps,path.strokeJoints,path.strokeMiterLimit,false);
				break;
			case 1:
				var grad = gradType.grad;
				this.stroke = new nanofl.engine.strokes.RadialStroke(this.getGradientRgbaColors(grad),grad.ratios,grad.cx,grad.cy,grad.r,grad.fx,grad.fy,path.strokeWidth,path.strokeCaps,path.strokeJoints,path.strokeMiterLimit,false);
				break;
			}
			break;
		}
	}
	,endStroke: function() {
	}
	,moveTo: function(x,y) {
		if(this.fillPath != null) {
			this.closeContour();
			this.polygonAndFillRules[this.polygonAndFillRules.length - 1].polygon.contours.push(new nanofl.engine.geom.Contour([]));
		}
		this.x = x;
		this.y = y;
	}
	,lineTo: function(x,y) {
		if(this.fillPath != null) {
			var contours = this.polygonAndFillRules[this.polygonAndFillRules.length - 1].polygon.contours;
			contours[contours.length - 1].edges.push(new nanofl.engine.geom.Edge(this.x,this.y,x,y));
		} else if(this.stroke != null) {
			this.edges.push(new nanofl.engine.geom.StrokeEdge(this.x,this.y,x,y,null,null,this.stroke));
		}
		this.x = x;
		this.y = y;
	}
	,curveTo: function(controlX,controlY,anchorX,anchorY) {
		if(this.fillPath != null) {
			var contours = this.polygonAndFillRules[this.polygonAndFillRules.length - 1].polygon.contours;
			contours[contours.length - 1].edges.push(new nanofl.engine.geom.Edge(this.x,this.y,controlX,controlY,anchorX,anchorY));
		} else if(this.stroke != null) {
			this.edges.push(new nanofl.engine.geom.StrokeEdge(this.x,this.y,controlX,controlY,anchorX,anchorY,this.stroke));
		}
		this.x = anchorX;
		this.y = anchorY;
	}
	,convert: function() {
		svgimport_SvgPathToShapeConvertor.log("SvgPathExporter.export vvvvvvvvvvvvvvvvvvvvvvvvvvvv edges = " + (this.polygonAndFillRules.length > 0 ? this.polygonAndFillRules[0].polygon.getEdges().length : 0),{ fileName : "src/svgimport/SvgPathToShapeConvertor.hx", lineNumber : 204, className : "svgimport.SvgPathToShapeConvertor", methodName : "convert"});
		var shape = new nanofl.engine.elements.ShapeElement();
		var _g = 0;
		var _g1 = this.polygonAndFillRules;
		while(_g < _g1.length) {
			var pf = _g1[_g];
			++_g;
			svgimport_SvgPathToShapeConvertor.log("Polygons.fromEdges vvvvvvvvvvvvvvv contours.edges = " + nanofl.engine.geom.Contours.getEdges(pf.polygon.contours).length + "; fill = " + Std.string(pf.polygon.fill) + "; fillRuleEvenOdd = " + (pf.fillRuleEvenOdd == null ? "null" : "" + pf.fillRuleEvenOdd),{ fileName : "src/svgimport/SvgPathToShapeConvertor.hx", lineNumber : 209, className : "svgimport.SvgPathToShapeConvertor", methodName : "convert"});
			if(nanofl.engine.geom.Contours.getEdges(pf.polygon.contours).length >= 0) {
				svgimport_SvgPathToShapeConvertor.log("------------------- CONTOURS FOR Polygons.fromContours:\n" + pf.polygon.contours.join(",\n"),{ fileName : "src/svgimport/SvgPathToShapeConvertor.hx", lineNumber : 212, className : "svgimport.SvgPathToShapeConvertor", methodName : "convert"});
			}
			var polygons = nanofl.engine.geom.Polygons.fromRawContours(pf.polygon.contours,pf.polygon.fill,pf.fillRuleEvenOdd);
			var _g2 = 0;
			while(_g2 < polygons.length) {
				var p = polygons[_g2];
				++_g2;
				p.assertCorrect();
			}
			svgimport_SvgPathToShapeConvertor.log("Polygons.fromEdges ^^^^^^^^^^^^^^^ polygons = " + polygons.length,{ fileName : "src/svgimport/SvgPathToShapeConvertor.hx", lineNumber : 216, className : "svgimport.SvgPathToShapeConvertor", methodName : "convert"});
			var shape2 = new nanofl.engine.elements.ShapeElement([],polygons);
			svgimport_SvgPathToShapeConvertor.log("shape.combine vvvvvvvvvvvvvvvvv " + shape.getEdgeCount() + " + " + shape2.getEdgeCount(),{ fileName : "src/svgimport/SvgPathToShapeConvertor.hx", lineNumber : 220, className : "svgimport.SvgPathToShapeConvertor", methodName : "convert"});
			shape.combine(shape2);
			svgimport_SvgPathToShapeConvertor.log("shape.combine ^^^^^^^^^^^^^^^^^",{ fileName : "src/svgimport/SvgPathToShapeConvertor.hx", lineNumber : 222, className : "svgimport.SvgPathToShapeConvertor", methodName : "convert"});
		}
		svgimport_SvgPathToShapeConvertor.log("normalize vvvvvvvvvvvvvv",{ fileName : "src/svgimport/SvgPathToShapeConvertor.hx", lineNumber : 225, className : "svgimport.SvgPathToShapeConvertor", methodName : "convert"});
		var _g = 0;
		var _g1 = this.edges;
		while(_g < _g1.length) {
			var e = _g1[_g];
			++_g;
			stdlib_Debug.assert(e.stroke != null,"(1)",{ fileName : "src/svgimport/SvgPathToShapeConvertor.hx", lineNumber : 226, className : "svgimport.SvgPathToShapeConvertor", methodName : "convert"});
		}
		nanofl.engine.geom.Edges.normalize(this.edges);
		var _g = 0;
		var _g1 = this.edges;
		while(_g < _g1.length) {
			var e = _g1[_g];
			++_g;
			stdlib_Debug.assert(e.stroke != null,"(2)",{ fileName : "src/svgimport/SvgPathToShapeConvertor.hx", lineNumber : 228, className : "svgimport.SvgPathToShapeConvertor", methodName : "convert"});
		}
		svgimport_SvgPathToShapeConvertor.log("normalize ^^^^^^^^^^^^^^",{ fileName : "src/svgimport/SvgPathToShapeConvertor.hx", lineNumber : 229, className : "svgimport.SvgPathToShapeConvertor", methodName : "convert"});
		svgimport_SvgPathToShapeConvertor.log("intersectSelf vvvvvvvvvvvvvv",{ fileName : "src/svgimport/SvgPathToShapeConvertor.hx", lineNumber : 231, className : "svgimport.SvgPathToShapeConvertor", methodName : "convert"});
		var _g = 0;
		var _g1 = this.edges;
		while(_g < _g1.length) {
			var e = _g1[_g];
			++_g;
			stdlib_Debug.assert(e.stroke != null,"(3)",{ fileName : "src/svgimport/SvgPathToShapeConvertor.hx", lineNumber : 232, className : "svgimport.SvgPathToShapeConvertor", methodName : "convert"});
		}
		nanofl.engine.geom.Edges.intersectSelf(this.edges);
		var _g = 0;
		var _g1 = this.edges;
		while(_g < _g1.length) {
			var e = _g1[_g];
			++_g;
			stdlib_Debug.assert(e.stroke != null,"(4)",{ fileName : "src/svgimport/SvgPathToShapeConvertor.hx", lineNumber : 234, className : "svgimport.SvgPathToShapeConvertor", methodName : "convert"});
		}
		svgimport_SvgPathToShapeConvertor.log("intersectSelf ^^^^^^^^^^^^^^",{ fileName : "src/svgimport/SvgPathToShapeConvertor.hx", lineNumber : 235, className : "svgimport.SvgPathToShapeConvertor", methodName : "convert"});
		svgimport_SvgPathToShapeConvertor.log("shape.combine stroke vvvvvvvvvvvvvv",{ fileName : "src/svgimport/SvgPathToShapeConvertor.hx", lineNumber : 237, className : "svgimport.SvgPathToShapeConvertor", methodName : "convert"});
		var _g = 0;
		var _g1 = this.edges;
		while(_g < _g1.length) {
			var e = _g1[_g];
			++_g;
			stdlib_Debug.assert(e.stroke != null,"(5)",{ fileName : "src/svgimport/SvgPathToShapeConvertor.hx", lineNumber : 238, className : "svgimport.SvgPathToShapeConvertor", methodName : "convert"});
		}
		shape.combine(new nanofl.engine.elements.ShapeElement(this.edges));
		var _g = 0;
		var _g1 = this.edges;
		while(_g < _g1.length) {
			var e = _g1[_g];
			++_g;
			stdlib_Debug.assert(e.stroke != null,"(6)",{ fileName : "src/svgimport/SvgPathToShapeConvertor.hx", lineNumber : 240, className : "svgimport.SvgPathToShapeConvertor", methodName : "convert"});
		}
		svgimport_SvgPathToShapeConvertor.log("shape.combine stroke ^^^^^^^^^^^^^^",{ fileName : "src/svgimport/SvgPathToShapeConvertor.hx", lineNumber : 241, className : "svgimport.SvgPathToShapeConvertor", methodName : "convert"});
		svgimport_SvgPathToShapeConvertor.log("SvgPathExporter.export ^^^^^^^^^^^^^^^^^^^^^^^^^^^^",{ fileName : "src/svgimport/SvgPathToShapeConvertor.hx", lineNumber : 243, className : "svgimport.SvgPathToShapeConvertor", methodName : "convert"});
		return shape;
	}
	,getBounds: function() {
		if(this.boundsCache != null) {
			return this.boundsCache;
		}
		this.boundsCache = { minX : 1e100, minY : 1e100, maxX : -1e100, maxY : -1e100};
		nanofl.engine.geom.Edges.getBounds(this.edges,this.boundsCache);
		var _g = 0;
		var _g1 = this.polygonAndFillRules;
		while(_g < _g1.length) {
			var p = _g1[_g];
			++_g;
			p.polygon.getBounds(this.boundsCache);
		}
		return this.boundsCache;
	}
	,closeContour: function() {
		var contours = this.polygonAndFillRules[this.polygonAndFillRules.length - 1].polygon.contours;
		if(contours.length > 0) {
			var edges = contours[contours.length - 1].edges;
			if(edges.length > 0) {
				var edge1 = edges[0];
				var edge2 = edges[edges.length - 1];
				if(edge1.x1 != edge2.x3 || edge1.y1 != edge2.y3) {
					edges.push(new nanofl.engine.geom.Edge(edge2.x3,edge2.y3,edge1.x1,edge1.y1));
				}
			}
		}
	}
	,getGradientRgbaColors: function(grad) {
		var i = 0;
		var _g = [];
		var x = $getIterator(grad.colors);
		while(x.hasNext()) {
			var x1 = x.next();
			_g.push(nanofl.engine.ColorTools.joinStringAndAlpha(x1,grad.alphas[i++]));
		}
		return Lambda.array(_g);
	}
	,__class__: svgimport_SvgPathToShapeConvertor
};
var svgimport_SvgTextStyle = function(node,baseStyles,gradients) {
	var styles = svgimport_XmlTools.getStyles(node,baseStyles);
	this.fill = svgimport_XmlTools.getFillStyle(node,"fill",styles,gradients);
	this.fillAlpha = svgimport_XmlTools.getFloatStyle(node,"fill-opacity",styles,1);
	this.stroke = svgimport_XmlTools.getStrokeStyle(node,"stroke",styles,gradients);
	this.strokeAlpha = svgimport_XmlTools.getFloatStyle(node,"stroke-opacity",styles,1);
	this.strokeWidth = svgimport_XmlTools.getFloatStyle(node,"stroke-width",styles,1);
	this.fontFamily = svgimport_XmlTools.getStyle(node,"font-family",styles,"");
	this.fontSize = svgimport_XmlTools.getFloatStyle(node,"font-size",styles,16);
	this.fontStyle = svgimport_XmlTools.getStyle(node,"font-style",styles,"");
	this.fontWeight = svgimport_XmlTools.getStyle(node,"font-weight",styles,"");
	this.kerning = svgimport_XmlTools.getFloatStyle(node,"kerning",styles,0);
	this.letterSpacing = svgimport_XmlTools.getFloatStyle(node,"letter-spacing",styles,0);
};
svgimport_SvgTextStyle.__name__ = "svgimport.SvgTextStyle";
svgimport_SvgTextStyle.prototype = {
	__class__: svgimport_SvgTextStyle
};
var svgimport_SvgText = function(node,baseStyles,gradients) {
	this.spans = [];
	svgimport_SvgTextStyle.call(this,node,baseStyles,gradients);
	this.matrix = svgimport_Transform.load(node.getAttribute("transform"));
	var styles = svgimport_XmlTools.getStyles(node,baseStyles);
	this.name = htmlparser.HtmlParserTools.getAttr(node,"id","");
	var x = svgimport_XmlTools.getFloatValue(node,"x",0);
	var y = svgimport_XmlTools.getFloatValue(node,"y",0);
	if(x != 0 || y != 0) {
		this.matrix.appendTransform(x,y);
	}
	this.textAnchor = svgimport_XmlTools.getStyle(node,"text-anchor",styles,"left");
	this.loadFromChildrenNodes(node,styles,gradients);
};
svgimport_SvgText.__name__ = "svgimport.SvgText";
svgimport_SvgText.__super__ = svgimport_SvgTextStyle;
svgimport_SvgText.prototype = $extend(svgimport_SvgTextStyle.prototype,{
	loadFromChildrenNodes: function(base,styles,gradients) {
		var _g = 0;
		var _g1 = base.nodes;
		while(_g < _g1.length) {
			var node = _g1[_g];
			++_g;
			if(((node) instanceof htmlparser.HtmlNodeElement)) {
				if(node.name == "tspan") {
					this.spans.push(new svgimport_SvgTextSpan(node,styles,gradients));
				} else {
					this.loadFromChildrenNodes(node,styles,gradients);
				}
			} else if(((node) instanceof htmlparser.HtmlNodeText)) {
				var span = new htmlparser.HtmlNodeElement("tspan",[]);
				span.addChild(new htmlparser.HtmlNodeText(node.text));
				this.spans.push(new svgimport_SvgTextSpan(span,styles,gradients));
			}
		}
	}
	,__class__: svgimport_SvgText
});
var svgimport_SvgTextExporter = function(svg,library,text) {
	svgimport_BaseExporter.call(this,svg,library);
	this.text = text;
};
svgimport_SvgTextExporter.__name__ = "svgimport.SvgTextExporter";
svgimport_SvgTextExporter.__super__ = svgimport_BaseExporter;
svgimport_SvgTextExporter.prototype = $extend(svgimport_BaseExporter.prototype,{
	exportAsElement: function() {
		var fillColor;
		var _g = this.text.fill;
		switch(_g._hx_index) {
		case 0:
			fillColor = null;
			break;
		case 1:
			var color = _g.color;
			fillColor = color;
			break;
		case 2:
			var gradType = _g.gradType;
			haxe_Log.trace("Text gradients is not supported.",{ fileName : "src/svgimport/SvgTextExporter.hx", lineNumber : 29, className : "svgimport.SvgTextExporter", methodName : "exportAsElement"});
			fillColor = "#000000";
			break;
		}
		var color;
		var _g = this.text.stroke;
		switch(_g._hx_index) {
		case 0:
			color = null;
			break;
		case 1:
			var c = _g.color;
			color = c;
			break;
		default:
			color = "#000000";
		}
		var _this = this.text.spans;
		var f = $bind(this,this.exportSpan);
		var result = new Array(_this.length);
		var _g = 0;
		var _g1 = _this.length;
		while(_g < _g1) {
			var i = _g++;
			result[i] = f(_this[i]);
		}
		var runs = result;
		if(runs.length > 0) {
			runs[0].characters = StringTools.ltrim(runs[0].characters);
			runs[runs.length - 1].characters = StringTools.rtrim(runs[runs.length - 1].characters);
		}
		var r = this.text.name;
		var _g = [];
		var _g1 = 0;
		var _g2 = runs;
		while(_g1 < _g2.length) {
			var v = _g2[_g1];
			++_g1;
			if(v.characters != "") {
				_g.push(v);
			}
		}
		var r1 = new nanofl.engine.elements.TextElement(r,0,0,false,false,_g);
		r1.matrix = this.text.matrix.clone();
		var t = r1.createDisplayObject();
		var fontHeight = nanofl.TextField.measureFontHeight(this.text.fontFamily,this.text.fontStyle,this.text.fontSize);
		var fontBaselineCoef = nanofl.TextField.measureFontBaselineCoef(this.text.fontFamily,this.text.fontStyle);
		r1.matrix.appendTransform(0,-fontHeight * fontBaselineCoef - nanofl.TextField.PADDING);
		switch(this.text.textAnchor) {
		case "end":
			r1.matrix.appendTransform(-t.minWidth + nanofl.TextField.PADDING,0);
			break;
		case "middle":
			r1.matrix.appendTransform(-t.minWidth / 2,0);
			break;
		default:
			r1.matrix.appendTransform(-nanofl.TextField.PADDING,0);
		}
		return r1;
	}
	,exportSpan: function(span) {
		var _this_r = new RegExp("[\r\n\t ]+","g".split("u").join(""));
		return nanofl.TextRun.create(span.text.replace(_this_r," "),this.fillToColor(span.fill,span.fillAlpha),span.fontFamily,StringTools.trim(span.fontWeight + span.fontStyle),span.fontSize,"left",span.strokeWidth,this.strokeToColor(span.stroke,span.strokeWidth),span.kerning == 0 && span.letterSpacing == 0,span.kerning + span.letterSpacing,0);
	}
	,strokeToColor: function(strokeType,alpha) {
		switch(strokeType._hx_index) {
		case 0:
			return "rgba(0,0,0,0)";
		case 1:
			var color = strokeType.color;
			return nanofl.engine.ColorTools.joinStringAndAlpha(color,alpha);
		case 2:
			var grad = strokeType.gradType;
			return this.gradientToColor(grad);
		}
	}
	,fillToColor: function(fillType,alpha) {
		switch(fillType._hx_index) {
		case 0:
			return "rgba(0,0,0,0)";
		case 1:
			var color = fillType.color;
			return nanofl.engine.ColorTools.joinStringAndAlpha(color,alpha);
		case 2:
			var grad = fillType.gradType;
			return this.gradientToColor(grad);
		}
	}
	,gradientToColor: function(grad) {
		switch(grad._hx_index) {
		case 0:
			var grad1 = grad.grad;
			return nanofl.engine.ColorTools.joinStringAndAlpha(grad1.colors[0],grad1.alphas[0]);
		case 1:
			var grad1 = grad.grad;
			return nanofl.engine.ColorTools.joinStringAndAlpha(grad1.colors[0],grad1.alphas[0]);
		}
	}
	,__class__: svgimport_SvgTextExporter
});
var svgimport_SvgTextSpan = function(node,baseStyles,gradients) {
	svgimport_SvgTextStyle.call(this,node,baseStyles,gradients);
	this.text = node.innerText;
};
svgimport_SvgTextSpan.__name__ = "svgimport.SvgTextSpan";
svgimport_SvgTextSpan.__super__ = svgimport_SvgTextStyle;
svgimport_SvgTextSpan.prototype = $extend(svgimport_SvgTextStyle.prototype,{
	__class__: svgimport_SvgTextSpan
});
var svgimport_SvgUse = function(svg,node,baseStyles) {
	svgimport_SvgDisplayObject.call(this,svg,node,baseStyles,this.id);
	this.groupID = svgimport_XmlTools.getIdFromXlink(node);
	if(this.groupID == null) {
		haxe_Log.trace("Use: 'xlink:href' attribute must be specified.",{ fileName : "src/svgimport/SvgUse.hx", lineNumber : 20, className : "svgimport.SvgUse", methodName : "new"});
		return;
	}
	var x = svgimport_XmlTools.getFloatValue(node,"x",0);
	var y = svgimport_XmlTools.getFloatValue(node,"y",0);
	if(x != 0 || y != 0) {
		this.matrix.appendTransform(x,y);
	}
	this.styles = svgimport_XmlTools.getStyles(node,baseStyles);
};
svgimport_SvgUse.__name__ = "svgimport.SvgUse";
svgimport_SvgUse.__super__ = svgimport_SvgDisplayObject;
svgimport_SvgUse.prototype = $extend(svgimport_SvgDisplayObject.prototype,{
	__class__: svgimport_SvgUse
});
var svgimport_SvgUseExporter = function(svg,library,use) {
	svgimport_BaseExporter.call(this,svg,library);
	this.use = use;
};
svgimport_SvgUseExporter.__name__ = "svgimport.SvgUseExporter";
svgimport_SvgUseExporter.__super__ = svgimport_BaseExporter;
svgimport_SvgUseExporter.prototype = $extend(svgimport_BaseExporter.prototype,{
	exportAsElement: function() {
		return this.applyMaskToElement(this.exportAsElementInner(),this.use.matrix,this.use.clipPathID,this.getNextFreeID(this.use.groupID));
	}
	,exportAsElementInner: function() {
		var namePath = this.use.groupID;
		var h = this.use.styles.h;
		var inlStringMapKeyIterator_h = h;
		var inlStringMapKeyIterator_keys = Object.keys(h);
		var inlStringMapKeyIterator_length = inlStringMapKeyIterator_keys.length;
		var inlStringMapKeyIterator_current = 0;
		if(inlStringMapKeyIterator_current < inlStringMapKeyIterator_length) {
			var element = this.svg.elements.h[this.use.groupID];
			if(element != null) {
				if(element != null) {
					switch(element._hx_index) {
					case 0:
						var base = element.path;
						var p = new svgimport_SvgPath(this.svg,base.node,this.use.styles,this.getNextFreeID(base.id));
						var item = new svgimport_SvgPathExporter(this.svg,this.library,p).exportToLibrary();
						if(item == null) {
							return null;
						}
						namePath = item.namePath;
						break;
					case 1:
						var base = element.group;
						var g = new svgimport_SvgGroup(this.svg,base.node,this.use.styles,this.getNextFreeID(base.id));
						namePath = new svgimport_SvgGroupExporter(this.svg,this.library,g).exportToLibrary().namePath;
						break;
					default:
					}
				}
			} else {
				haxe_Log.trace("WARNING: Element '" + this.use.groupID + "' is not found.",{ fileName : "src/svgimport/SvgUseExporter.hx", lineNumber : 48, className : "svgimport.SvgUseExporter", methodName : "exportAsElementInner"});
			}
		}
		var instance = new nanofl.engine.elements.Instance(namePath);
		instance.matrix = this.use.matrix.clone().appendMatrix(this.getSvgElementMatrix(this.svg.elements.h[this.use.groupID]));
		return instance;
	}
	,getSvgElementMatrix: function(element) {
		if(element == null) {
			return new nanofl.engine.geom.Matrix();
		}
		switch(element._hx_index) {
		case 0:
			var p = element.path;
			return p.matrix;
		case 1:
			var g = element.group;
			return g.matrix;
		default:
			return new nanofl.engine.geom.Matrix();
		}
	}
	,__class__: svgimport_SvgUseExporter
});
var svgimport_Transform = function() { };
svgimport_Transform.__name__ = "svgimport.Transform";
svgimport_Transform.load = function(trans) {
	if(trans == null || trans == "") {
		return new nanofl.engine.geom.Matrix();
	}
	var matrix = new nanofl.engine.geom.Matrix();
	var re = new EReg("^\\s*([a-zA-Z]+)\\s*\\(([^)]*)\\)\\s*","");
	while(re.match(trans)) {
		var _this = new EReg("[ \t\r\n,]+","g").split(re.matched(2));
		var f = Std.parseFloat;
		var result = new Array(_this.length);
		var _g = 0;
		var _g1 = _this.length;
		while(_g < _g1) {
			var i = _g++;
			result[i] = f(_this[i]);
		}
		var params = result;
		switch(re.matched(1)) {
		case "matrix":
			if(params.length == 6) {
				matrix.append(params[0],params[1],params[2],params[3],params[4],params[5]);
			}
			break;
		case "rotate":
			if(params.length == 1) {
				matrix.appendTransform(0,0,1,1,params[0]);
			} else if(params.length == 2) {
				matrix.appendTransform(params[1],0,1,1,0);
				matrix.appendTransform(0,0,1,1,params[0]);
				matrix.appendTransform(-params[1],0);
			} else if(params.length == 3) {
				matrix.appendTransform(params[1],params[2],1,1,0);
				matrix.appendTransform(0,0,1,1,params[0]);
				matrix.appendTransform(-params[1],-params[2]);
			} else {
				haxe_Log.trace("Transform/rotate: invalid params '" + re.matched(2) + "'.",{ fileName : "src/svgimport/Transform.hx", lineNumber : 71, className : "svgimport.Transform", methodName : "load"});
			}
			break;
		case "scale":
			if(params.length == 2) {
				matrix.appendTransform(0,0,params[0],params[1]);
			} else if(params.length == 1) {
				matrix.appendTransform(0,0,params[0],params[0]);
			} else {
				haxe_Log.trace("Transform/scale: invalid params '" + re.matched(2) + "'.",{ fileName : "src/svgimport/Transform.hx", lineNumber : 47, className : "svgimport.Transform", methodName : "load"});
			}
			break;
		case "translate":
			if(params.length == 2) {
				matrix.appendTransform(params[0],params[1]);
			} else if(params.length == 1) {
				matrix.appendTransform(params[0],0);
			} else {
				haxe_Log.trace("Transform/translate: invalid params '" + re.matched(2) + "'.",{ fileName : "src/svgimport/Transform.hx", lineNumber : 32, className : "svgimport.Transform", methodName : "load"});
			}
			break;
		default:
			haxe_Log.trace("Unknow transform: '" + re.matched(1) + "'.",{ fileName : "src/svgimport/Transform.hx", lineNumber : 89, className : "svgimport.Transform", methodName : "load"});
		}
		trans = re.matchedRight();
	}
	return matrix;
};
var svgimport_XmlTools = function() { };
svgimport_XmlTools.__name__ = "svgimport.XmlTools";
svgimport_XmlTools.getStyles = function(node,baseStyles) {
	var styles = new haxe_ds_StringMap();
	if(baseStyles != null) {
		var h = baseStyles.h;
		var s_h = h;
		var s_keys = Object.keys(h);
		var s_length = s_keys.length;
		var s_current = 0;
		while(s_current < s_length) {
			var s = s_keys[s_current++];
			if(svgimport_SvgAttributes.presentationNoInherit.indexOf(s) < 0) {
				styles.h[s] = baseStyles.h[s];
			}
		}
	}
	var _g = 0;
	var _g1 = svgimport_SvgAttributes.presentation;
	while(_g < _g1.length) {
		var key = _g1[_g];
		++_g;
		if(node.hasAttribute(key)) {
			var value = node.getAttribute(key);
			styles.h[key] = value;
		}
	}
	svgimport_XmlTools.parseStyleAttr(node,styles);
	return styles;
};
svgimport_XmlTools.parseStyleAttr = function(node,r) {
	if(r == null) {
		r = new haxe_ds_StringMap();
	}
	if(node.hasAttribute("style")) {
		var _g = 0;
		var _g1 = node.getAttribute("style").split(";");
		while(_g < _g1.length) {
			var s = _g1[_g];
			++_g;
			if(svgimport_XmlTools.reStyleValue.match(s)) {
				var key = svgimport_XmlTools.reStyleValue.matched(1);
				var value = svgimport_XmlTools.reStyleValue.matched(2);
				r.h[key] = value;
			}
		}
	}
	return r;
};
svgimport_XmlTools.getFloatStyle = function(node,key,styles,defaultValue) {
	return svgimport_XmlTools.toFloat(svgimport_XmlTools.getStyle(node,key,styles,""),defaultValue);
};
svgimport_XmlTools.getFloatValue = function(node,key,defaultValue) {
	return svgimport_XmlTools.toFloat(node.getAttribute(key),defaultValue);
};
svgimport_XmlTools.toFloat = function(s,defaultValue) {
	if(s == null || s == "") {
		return defaultValue;
	}
	if(StringTools.startsWith(s,".")) {
		s = "0" + s;
	}
	if(StringTools.endsWith(s,"%")) {
		return parseFloat(s.substring(0,s.length - 1)) / 100;
	}
	if(StringTools.endsWith(s,"pt")) {
		return parseFloat(s.substring(0,s.length - 2)) * 1.25;
	}
	if(StringTools.endsWith(s,"pc")) {
		return parseFloat(s.substring(0,s.length - 2)) * 15;
	}
	if(StringTools.endsWith(s,"mm")) {
		return parseFloat(s.substring(0,s.length - 2)) * 3.543307;
	}
	if(StringTools.endsWith(s,"cm")) {
		return parseFloat(s.substring(0,s.length - 2)) * 35.43307;
	}
	if(StringTools.endsWith(s,"in")) {
		return parseFloat(s.substring(0,s.length - 2)) * 90;
	}
	var r = parseFloat(s);
	if(r != null && !isNaN(r)) {
		return r;
	} else {
		return defaultValue;
	}
};
svgimport_XmlTools.getStyle = function(node,key,styles,defaultValue) {
	if(node != null && node.hasAttribute(key)) {
		return node.getAttribute(key);
	}
	var t = svgimport_XmlTools.parseStyleAttr(node);
	if(Object.prototype.hasOwnProperty.call(t.h,key)) {
		return t.h[key];
	}
	if(styles != null && Object.prototype.hasOwnProperty.call(styles.h,key) && svgimport_SvgAttributes.presentationNoInherit.indexOf(key) < 0) {
		return styles.h[key];
	}
	return defaultValue;
};
svgimport_XmlTools.getColorStyle = function(node,key,styles,defaultValue) {
	var s = svgimport_XmlTools.getStyle(node,key,styles,defaultValue);
	return s;
};
svgimport_XmlTools.getFillStyle = function(node,key,styles,gradients) {
	var s = svgimport_XmlTools.getStyle(node,key,styles,"");
	if(s == "") {
		return svgimport_FillType.FillSolid("#000000");
	}
	if(s == "none") {
		return svgimport_FillType.FillNone;
	}
	if(svgimport_XmlTools.reURLMatch.match(s)) {
		var url = svgimport_XmlTools.reURLMatch.matched(1);
		if(Object.prototype.hasOwnProperty.call(gradients.h,url)) {
			return svgimport_FillType.FillGrad(gradients.h[url]);
		}
		haxe_Log.trace("WARNING: Unknown url('" + url + "').",{ fileName : "src/svgimport/XmlTools.hx", lineNumber : 104, className : "svgimport.XmlTools", methodName : "getFillStyle"});
		return svgimport_FillType.FillNone;
	}
	return svgimport_FillType.FillSolid(s);
};
svgimport_XmlTools.getStrokeStyle = function(node,key,styles,gradients) {
	var s = svgimport_XmlTools.getStyle(node,key,styles,"");
	if(s == "" || s == "none") {
		return svgimport_StrokeType.StrokeNone;
	}
	if(svgimport_XmlTools.reURLMatch.match(s)) {
		var url = svgimport_XmlTools.reURLMatch.matched(1);
		if(Object.prototype.hasOwnProperty.call(gradients.h,url)) {
			return svgimport_StrokeType.StrokeGrad(gradients.h[url]);
		}
		haxe_Log.trace("WARNING: Unknown url('" + url + "').",{ fileName : "src/svgimport/XmlTools.hx", lineNumber : 121, className : "svgimport.XmlTools", methodName : "getStrokeStyle"});
		return svgimport_StrokeType.StrokeNone;
	}
	return svgimport_StrokeType.StrokeSolid(s);
};
svgimport_XmlTools.normalizeTag = function(s) {
	if(StringTools.startsWith(s,"svg:")) {
		return s.substring("svg:".length);
	} else {
		return s;
	}
};
svgimport_XmlTools.getIdFromXlink = function(node) {
	var xlink = StringTools.trim(htmlparser.HtmlParserTools.getAttr(node,"xlink:href",""));
	if(xlink == "") {
		return null;
	}
	if(!StringTools.startsWith(xlink,"#")) {
		haxe_Log.trace("WARNING: Unkown xlink syntax ('" + xlink + "').",{ fileName : "src/svgimport/XmlTools.hx", lineNumber : 139, className : "svgimport.XmlTools", methodName : "getIdFromXlink"});
		return null;
	}
	return xlink.substring(1);
};
svgimport_XmlTools.getIdFromUrl = function(s) {
	if(s == null) {
		return null;
	}
	var s1 = StringTools.trim(s);
	if(s1 == "") {
		return null;
	}
	if(svgimport_XmlTools.reURLMatch.match(s1)) {
		return svgimport_XmlTools.reURLMatch.matched(1);
	}
	haxe_Log.trace("WARNING: Unkown url syntax ('" + s1 + "').",{ fileName : "src/svgimport/XmlTools.hx", lineNumber : 151, className : "svgimport.XmlTools", methodName : "getIdFromUrl"});
	return null;
};
var svgimport_gradients_Gradient = function(node,baseType) {
	var base = null;
	if(baseType != null) {
		switch(baseType._hx_index) {
		case 0:
			var grad = baseType.grad;
			base = grad;
			break;
		case 1:
			var grad = baseType.grad;
			base = grad;
			break;
		}
	}
	this.gradientUnits = node.hasAttribute("gradientUnits") ? node.getAttribute("gradientUnits") : base != null ? base.gradientUnits : "";
	this.colors = base != null ? base.colors.slice() : [];
	this.alphas = base != null ? base.alphas.slice() : [];
	this.ratios = base != null ? base.ratios.slice() : [];
	var _g = 0;
	var _g1 = node.children;
	while(_g < _g1.length) {
		var stop = _g1[_g];
		++_g;
		var styles = svgimport_XmlTools.getStyles(stop,null);
		this.colors.push(svgimport_XmlTools.getColorStyle(stop,"stop-color",styles,"#000000"));
		this.alphas.push(svgimport_XmlTools.getFloatStyle(stop,"stop-opacity",styles,1));
		this.ratios.push(svgimport_XmlTools.getFloatStyle(stop,"offset",null,0));
	}
	this.matrix = svgimport_Transform.load(node.getAttribute("gradientTransform"));
	if(base != null) {
		this.matrix.prependMatrix(base.matrix);
	}
};
svgimport_gradients_Gradient.__name__ = "svgimport.gradients.Gradient";
svgimport_gradients_Gradient.load = function(svg,node,baseType) {
	switch(svgimport_XmlTools.normalizeTag(node.name)) {
	case "linearGradient":
		return svgimport_gradients_GradientType.LINEAR(new svgimport_gradients_LinearGradient(node,baseType,svg.viewBox != null ? svg.viewBox.width : svg.width));
	case "radialGradient":
		return svgimport_gradients_GradientType.RADIAL(new svgimport_gradients_RadialGradient(node,baseType));
	default:
		throw haxe_Exception.thrown("Unknow gradient tag '" + node.name + "'.");
	}
};
svgimport_gradients_Gradient.prototype = {
	__class__: svgimport_gradients_Gradient
};
var svgimport_gradients_GradientType = $hxEnums["svgimport.gradients.GradientType"] = { __ename__:"svgimport.gradients.GradientType",__constructs__:null
	,LINEAR: ($_=function(grad) { return {_hx_index:0,grad:grad,__enum__:"svgimport.gradients.GradientType",toString:$estr}; },$_._hx_name="LINEAR",$_.__params__ = ["grad"],$_)
	,RADIAL: ($_=function(grad) { return {_hx_index:1,grad:grad,__enum__:"svgimport.gradients.GradientType",toString:$estr}; },$_._hx_name="RADIAL",$_.__params__ = ["grad"],$_)
};
svgimport_gradients_GradientType.__constructs__ = [svgimport_gradients_GradientType.LINEAR,svgimport_gradients_GradientType.RADIAL];
var svgimport_gradients_LinearGradient = function(node,baseType,svgWidth) {
	svgimport_gradients_Gradient.call(this,node,baseType);
	var base = null;
	if(baseType != null) {
		if(baseType._hx_index == 0) {
			var grad = baseType.grad;
			base = grad;
		}
	}
	this.x1 = svgimport_XmlTools.getFloatValue(node,"x1",base != null ? base.x1 : null);
	this.y1 = svgimport_XmlTools.getFloatValue(node,"y1",base != null ? base.y1 : null);
	this.x2 = svgimport_XmlTools.getFloatValue(node,"x2",base != null ? base.x2 : null);
	this.y2 = svgimport_XmlTools.getFloatValue(node,"y2",base != null ? base.y2 : null);
	if(this.gradientUnits == "userSpaceOnUse") {
		if(this.x1 == null) {
			this.x1 = 0;
		}
		if(this.y1 == null) {
			this.y1 = 0;
		}
		if(this.x2 == null) {
			this.x2 = svgWidth;
		}
		if(this.y2 == null) {
			this.y2 = 0;
		}
	} else if(this.x1 == null && this.y1 == null && this.x2 == null && this.y2 == null) {
		this.x1 = 0;
		this.y1 = 0;
		this.x2 = 1;
		this.y2 = 0;
	} else {
		if(this.x1 == null) {
			this.x1 = 0;
		}
		if(this.y1 == null) {
			this.y1 = 0;
		}
		if(this.x2 == null) {
			this.x2 = 0;
		}
		if(this.y2 == null) {
			this.y2 = 0;
		}
	}
	this.spreadMethod = htmlparser.HtmlParserTools.getAttr(node,"spreadMethod",base != null ? base.spreadMethod : "pad");
};
svgimport_gradients_LinearGradient.__name__ = "svgimport.gradients.LinearGradient";
svgimport_gradients_LinearGradient.__super__ = svgimport_gradients_Gradient;
svgimport_gradients_LinearGradient.prototype = $extend(svgimport_gradients_Gradient.prototype,{
	getAbsoluteParams: function(bounds) {
		if(this.gradientUnits == "userSpaceOnUse") {
			return this;
		} else {
			var w = bounds.maxX - bounds.minX;
			return { x1 : this.x1 * w + bounds.minX, y1 : this.y1 * w + bounds.minY, x2 : this.x2 * w + bounds.minX, y2 : this.y2 * w + bounds.minY};
		}
	}
	,__class__: svgimport_gradients_LinearGradient
});
var svgimport_gradients_RadialGradient = function(node,baseType) {
	svgimport_gradients_Gradient.call(this,node,baseType);
	var base = null;
	if(baseType != null) {
		if(baseType._hx_index == 1) {
			var grad = baseType.grad;
			base = grad;
		}
	}
	this.cx = svgimport_XmlTools.getFloatValue(node,"cx",base != null ? base.cx : 0.5);
	this.cy = svgimport_XmlTools.getFloatValue(node,"cy",base != null ? base.cy : 0.5);
	this.fx = svgimport_XmlTools.getFloatValue(node,"fx",base != null ? base.fx : this.cx);
	this.fy = svgimport_XmlTools.getFloatValue(node,"fy",base != null ? base.fy : this.cy);
	this.r = svgimport_XmlTools.getFloatValue(node,"r",base != null ? base.r : 0.5);
	this.spreadMethod = htmlparser.HtmlParserTools.getAttr(node,"spreadMethod",base != null ? base.spreadMethod : "pad");
};
svgimport_gradients_RadialGradient.__name__ = "svgimport.gradients.RadialGradient";
svgimport_gradients_RadialGradient.__super__ = svgimport_gradients_Gradient;
svgimport_gradients_RadialGradient.prototype = $extend(svgimport_gradients_Gradient.prototype,{
	getAbsoluteParams: function(bounds) {
		if(this.gradientUnits == "userSpaceOnUse") {
			return this;
		} else {
			var w = bounds.maxX - bounds.minX;
			return { cx : this.cx * w + bounds.minX, cy : this.cy * w + bounds.minY, fx : this.fx * w + bounds.minX, fy : this.fy * w + bounds.minY, r : this.r * w};
		}
	}
	,__class__: svgimport_gradients_RadialGradient
});
var svgimport_segments_Segment = function(inX,inY) {
	this.x = inX;
	this.y = inY;
};
svgimport_segments_Segment.__name__ = "svgimport.segments.Segment";
svgimport_segments_Segment.prototype = {
	getType: function() {
		return null;
	}
	,prevX: function() {
		return this.x;
	}
	,prevY: function() {
		return this.y;
	}
	,prevCX: function() {
		return this.x;
	}
	,prevCY: function() {
		return this.y;
	}
	,'export': function(exporter) {
		throw haxe_Exception.thrown("Segment.export() must be overriden.");
	}
	,toString: function() {
		return "Segment(" + this.prevX() + "," + this.prevY() + ", " + this.x + "," + this.y + ")";
	}
	,__class__: svgimport_segments_Segment
};
var svgimport_segments_ArcSegment = function(x0,y0,rx,ry,rotation,isLargeArc,isSweep,x,y) {
	this.x0 = x0;
	this.y0 = y0;
	svgimport_segments_Segment.call(this,x,y);
	this.rx = rx;
	this.ry = ry;
	this.rotation = rotation;
	this.isLargeArc = isLargeArc;
	this.isSweep = isSweep;
};
svgimport_segments_ArcSegment.__name__ = "svgimport.segments.ArcSegment";
svgimport_segments_ArcSegment.arcToCubicCurves = function(x1,y1,rx,ry,angle,isLargeArc,isSweep,x2,y2,recursive) {
	var rad = Math.PI / 180 * angle;
	var res = [];
	var f1;
	var f2;
	var cx;
	var cy;
	if(recursive == null) {
		var xy = svgimport_segments_ArcSegment.rotate(x1,y1,-rad);
		x1 = xy.x;
		y1 = xy.y;
		xy = svgimport_segments_ArcSegment.rotate(x2,y2,-rad);
		x2 = xy.x;
		y2 = xy.y;
		var x = (x1 - x2) / 2;
		var y = (y1 - y2) / 2;
		var h = x * x / (rx * rx) + y * y / (ry * ry);
		if(h > 1) {
			h = Math.sqrt(h);
			rx = h * rx;
			ry = h * ry;
		}
		var rx2 = rx * rx;
		var ry2 = ry * ry;
		var k = (isLargeArc == isSweep ? -1 : 1) * Math.sqrt(Math.abs((rx2 * ry2 - rx2 * y * y - ry2 * x * x) / (rx2 * y * y + ry2 * x * x)));
		cx = k * rx * y / ry + (x1 + x2) / 2;
		cy = k * -ry * x / rx + (y1 + y2) / 2;
		f1 = Math.asin((y1 - cy) / ry);
		f2 = Math.asin((y2 - cy) / ry);
		if(x1 < cx) {
			f1 = Math.PI - f1;
		}
		if(x2 < cx) {
			f2 = Math.PI - f2;
		}
		if(f1 < 0) {
			f1 = Math.PI * 2 + f1;
		}
		if(f2 < 0) {
			f2 = Math.PI * 2 + f2;
		}
		if(isSweep && f1 > f2) {
			f1 -= Math.PI * 2;
		}
		if(!isSweep && f2 > f1) {
			f2 -= Math.PI * 2;
		}
	} else {
		f1 = recursive.f1;
		f2 = recursive.f2;
		cx = recursive.cx;
		cy = recursive.cy;
	}
	var df = f2 - f1;
	if(Math.abs(df) > svgimport_segments_ArcSegment.RAD_120) {
		var f2old = f2;
		var x2old = x2;
		var y2old = y2;
		f2 = f1 + svgimport_segments_ArcSegment.RAD_120 * (isSweep && f2 > f1 ? 1 : -1);
		x2 = cx + rx * Math.cos(f2);
		y2 = cy + ry * Math.sin(f2);
		res = svgimport_segments_ArcSegment.arcToCubicCurves(x2,y2,rx,ry,angle,false,isSweep,x2old,y2old,{ f1 : f2, f2 : f2old, cx : cx, cy : cy});
	}
	df = f2 - f1;
	var c1 = Math.cos(f1);
	var s1 = Math.sin(f1);
	var c2 = Math.cos(f2);
	var s2 = Math.sin(f2);
	var t = Math.tan(df / 4);
	var hx = 1.3333333333333333 * rx * t;
	var hy = 1.3333333333333333 * ry * t;
	var m1_x = x1;
	var m1_y = y1;
	var m2 = { x : x1 + hx * s1, y : y1 - hy * c1};
	var m3 = { x : x2 + hx * s2, y : y2 - hy * c2};
	var m4 = { x : x2, y : y2};
	m2.x = 2 * m1_x - m2.x;
	m2.y = 2 * m1_y - m2.y;
	if(recursive != null) {
		return [m2,m3,m4].concat(res);
	} else {
		res = [m2,m3,m4].concat(res);
		var newres = [];
		var _g = 0;
		var _g1 = res.length;
		while(_g < _g1) {
			var i = _g++;
			newres.push(svgimport_segments_ArcSegment.rotate(res[i].x,res[i].y,rad));
		}
		return newres;
	}
};
svgimport_segments_ArcSegment.rotate = function(x,y,rad) {
	return { x : x * Math.cos(rad) - y * Math.sin(rad), y : x * Math.sin(rad) + y * Math.cos(rad)};
};
svgimport_segments_ArcSegment.__super__ = svgimport_segments_Segment;
svgimport_segments_ArcSegment.prototype = $extend(svgimport_segments_Segment.prototype,{
	'export': function(exporter) {
		if(this.x0 == this.x && this.y0 == this.y) {
			return;
		}
		if(this.rx == 0 || this.ry == 0) {
			exporter.lineTo(this.x,this.y);
			return;
		}
		var points = svgimport_segments_ArcSegment.arcToCubicCurves(this.x0,this.y0,Math.abs(this.rx),Math.abs(this.ry),this.rotation,this.isLargeArc,this.isSweep,this.x,this.y,null);
		var i = 0;
		while(i < points.length) {
			var curve = new svgimport_segments_CubicSegment(points[i].x,points[i].y,points[i + 1].x,points[i + 1].y,points[i + 2].x,points[i + 2].y);
			curve.export(exporter);
			i += 3;
		}
	}
	,__class__: svgimport_segments_ArcSegment
});
var svgimport_segments_CubicSegment = function(inCX1,inCY1,inCX2,inCY2,inX,inY) {
	svgimport_segments_Segment.call(this,inX,inY);
	this.cx1 = inCX1;
	this.cy1 = inCY1;
	this.cx2 = inCX2;
	this.cy2 = inCY2;
};
svgimport_segments_CubicSegment.__name__ = "svgimport.segments.CubicSegment";
svgimport_segments_CubicSegment.__super__ = svgimport_segments_Segment;
svgimport_segments_CubicSegment.prototype = $extend(svgimport_segments_Segment.prototype,{
	prevCX: function() {
		return this.cx2;
	}
	,prevCY: function() {
		return this.cy2;
	}
	,interp: function(a,b,frac) {
		return a + (b - a) * frac;
	}
	,'export': function(exporter) {
		var tx0 = exporter.x;
		var ty0 = exporter.y;
		var tx3 = this.x;
		var ty3 = this.y;
		var pa_x = this.interp(tx0,this.cx1,0.75);
		var pa_y = this.interp(ty0,this.cy1,0.75);
		var pb_x = this.interp(tx3,this.cx2,0.75);
		var pb_y = this.interp(ty3,this.cy2,0.75);
		var dx = (tx3 - tx0) / 16;
		var dy = (ty3 - ty0) / 16;
		var pcx_1 = this.interp(tx0,this.cx1,0.375);
		var pcy_1 = this.interp(ty0,this.cy1,0.375);
		var pcx_2 = this.interp(pa_x,pb_x,0.375) - dx;
		var pcy_2 = this.interp(pa_y,pb_y,0.375) - dy;
		var pcx_3 = this.interp(pb_x,pa_x,0.375) + dx;
		var pcy_3 = this.interp(pb_y,pa_y,0.375) + dy;
		var pcx_4 = this.interp(tx3,this.cx2,0.375);
		var pcy_4 = this.interp(ty3,this.cy2,0.375);
		var pax_1 = (pcx_1 + pcx_2) * 0.5;
		var pay_1 = (pcy_1 + pcy_2) * 0.5;
		var pax_2 = (pa_x + pb_x) * 0.5;
		var pay_2 = (pa_y + pb_y) * 0.5;
		var pax_3 = (pcx_3 + pcx_4) * 0.5;
		var pay_3 = (pcy_3 + pcy_4) * 0.5;
		exporter.curveTo(pcx_1,pcy_1,pax_1,pay_1);
		exporter.curveTo(pcx_2,pcy_2,pax_2,pay_2);
		exporter.curveTo(pcx_3,pcy_3,pax_3,pay_3);
		exporter.curveTo(pcx_4,pcy_4,tx3,ty3);
	}
	,getType: function() {
		return svgimport_SegmentType.CUBIC(this);
	}
	,__class__: svgimport_segments_CubicSegment
});
var svgimport_segments_DrawSegment = function(inX,inY) {
	svgimport_segments_Segment.call(this,inX,inY);
};
svgimport_segments_DrawSegment.__name__ = "svgimport.segments.DrawSegment";
svgimport_segments_DrawSegment.__super__ = svgimport_segments_Segment;
svgimport_segments_DrawSegment.prototype = $extend(svgimport_segments_Segment.prototype,{
	'export': function(exporter) {
		exporter.lineTo(this.x,this.y);
	}
	,getType: function() {
		return svgimport_SegmentType.DRAW(this);
	}
	,__class__: svgimport_segments_DrawSegment
});
var svgimport_segments_MoveSegment = function(inX,inY) {
	svgimport_segments_Segment.call(this,inX,inY);
};
svgimport_segments_MoveSegment.__name__ = "svgimport.segments.MoveSegment";
svgimport_segments_MoveSegment.__super__ = svgimport_segments_Segment;
svgimport_segments_MoveSegment.prototype = $extend(svgimport_segments_Segment.prototype,{
	'export': function(exporter) {
		exporter.moveTo(this.x,this.y);
	}
	,getType: function() {
		return svgimport_SegmentType.MOVE(this);
	}
	,__class__: svgimport_segments_MoveSegment
});
var svgimport_segments_QuadraticSegment = function(inCX,inCY,inX,inY) {
	svgimport_segments_Segment.call(this,inX,inY);
	this.cx = inCX;
	this.cy = inCY;
};
svgimport_segments_QuadraticSegment.__name__ = "svgimport.segments.QuadraticSegment";
svgimport_segments_QuadraticSegment.__super__ = svgimport_segments_Segment;
svgimport_segments_QuadraticSegment.prototype = $extend(svgimport_segments_Segment.prototype,{
	prevCX: function() {
		return this.cx;
	}
	,prevCY: function() {
		return this.cy;
	}
	,'export': function(exporter) {
		exporter.curveTo(this.cx,this.cy,this.x,this.y);
	}
	,getType: function() {
		return svgimport_SegmentType.CURVE(this);
	}
	,__class__: svgimport_segments_QuadraticSegment
});
function $getIterator(o) { if( o instanceof Array ) return new haxe_iterators_ArrayIterator(o); else return o.iterator(); }
function $bind(o,m) { if( m == null ) return null; if( m.__id__ == null ) m.__id__ = $global.$haxeUID++; var f; if( o.hx__closures__ == null ) o.hx__closures__ = {}; else f = o.hx__closures__[m.__id__]; if( f == null ) { f = m.bind(o); o.hx__closures__[m.__id__] = f; } return f; }
$global.$haxeUID |= 0;
if(typeof(performance) != "undefined" ? typeof(performance.now) == "function" : false) {
	HxOverrides.now = performance.now.bind(performance);
}
if( String.fromCodePoint == null ) String.fromCodePoint = function(c) { return c < 0x10000 ? String.fromCharCode(c) : String.fromCharCode((c>>10)+0xD7C0)+String.fromCharCode((c&0x3FF)+0xDC00); }
Object.defineProperty(String.prototype,"__class__",{ value : String, enumerable : false, writable : true});
String.__name__ = "String";
Array.__name__ = "Array";
Date.prototype.__class__ = Date;
Date.__name__ = "Date";
var Int = { };
var Dynamic = { };
var Float = Number;
var Bool = Boolean;
var Class = { };
var Enum = { };
js_Boot.__toStr = ({ }).toString;
haxe_SysTools.winMetaCharacters = [32,40,41,37,33,94,34,60,62,38,124,10,13,44,59];
svgimport_SegmentsParser.MOVE = 77;
svgimport_SegmentsParser.MOVER = 109;
svgimport_SegmentsParser.LINE = 76;
svgimport_SegmentsParser.LINER = 108;
svgimport_SegmentsParser.HLINE = 72;
svgimport_SegmentsParser.HLINER = 104;
svgimport_SegmentsParser.VLINE = 86;
svgimport_SegmentsParser.VLINER = 118;
svgimport_SegmentsParser.CUBIC = 67;
svgimport_SegmentsParser.CUBICR = 99;
svgimport_SegmentsParser.SCUBIC = 83;
svgimport_SegmentsParser.SCUBICR = 115;
svgimport_SegmentsParser.QUAD = 81;
svgimport_SegmentsParser.QUADR = 113;
svgimport_SegmentsParser.SQUAD = 84;
svgimport_SegmentsParser.SQUADR = 116;
svgimport_SegmentsParser.ARC = 65;
svgimport_SegmentsParser.ARCR = 97;
svgimport_SegmentsParser.CLOSE = 90;
svgimport_SegmentsParser.CLOSER = 122;
svgimport_SegmentsParser.UNKNOWN = -1;
svgimport_SegmentsParser.SEPARATOR = -2;
svgimport_SegmentsParser.FLOAT = -3;
svgimport_SegmentsParser.FLOAT_SIGN = -4;
svgimport_SegmentsParser.FLOAT_DOT = -5;
svgimport_SegmentsParser.FLOAT_EXP = -6;
svgimport_SvgAttributes.presentation = ["alignment-baseline","baseline-shift","clip","clip-path","clip-rule","color","color-interpolation","color-interpolation-filters","color-profile","color-rendering","cursor","direction","display","dominant-baseline","enable-background","fill","fill-opacity","fill-rule","filter","flood-color","flood-opacity","font-family","font-size","font-size-adjust","font-stretch","font-style","font-variant","font-weight","glyph-orientation-horizontal","glyph-orientation-vertical","image-rendering","kerning","letter-spacing","lighting-color","marker-end","marker-mid","marker-start","mask","opacity","overflow","pointer-events","shape-rendering","stop-color","stop-opacity","stroke","stroke-dasharray","stroke-dashoffset","stroke-linecap","stroke-linejoin","stroke-miterlimit","stroke-opacity","stroke-width","text-anchor","text-decoration","text-rendering","unicode-bidi","visibility","word-spacing","writing-mode"];
svgimport_SvgAttributes.presentationNoInherit = ["clip-path","filter"];
svgimport_SvgPath.SIN45 = 0.70710678118654752440084436210485;
svgimport_SvgPath.TAN22 = 0.4142135623730950488016887242097;
svgimport_SvgPathExporter.EPS = 1e-10;
svgimport_XmlTools.reStyleValue = new EReg("^\\s*(.+)\\s*:\\s*(.+)\\s*$","");
svgimport_XmlTools.reURLMatch = new EReg("^\\s*url\\(#([^)]*)\\)\\s*","");
svgimport_segments_ArcSegment.RAD_120 = Math.PI * 2 / 3;
SvgImporterPlugin.main();
})(typeof window != "undefined" ? window : typeof global != "undefined" ? global : typeof self != "undefined" ? self : this);
