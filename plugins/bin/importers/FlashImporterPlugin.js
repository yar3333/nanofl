// Generated by Haxe 4.3.3
(function ($global) { "use strict";
var $estr = function() { return js_Boot.__string_rec(this,''); },$hxEnums = $hxEnums || {},$_;
function $extend(from, fields) {
	var proto = Object.create(from);
	for (var name in fields) proto[name] = fields[name];
	if( fields.toString !== Object.prototype.toString ) proto.toString = fields.toString;
	return proto;
}
var EReg = function(r,opt) {
	this.r = new RegExp(r,opt.split("u").join(""));
};
EReg.__name__ = "EReg";
EReg.prototype = {
	match: function(s) {
		if(this.r.global) {
			this.r.lastIndex = 0;
		}
		this.r.m = this.r.exec(s);
		this.r.s = s;
		return this.r.m != null;
	}
	,matched: function(n) {
		if(this.r.m != null && n >= 0 && n < this.r.m.length) {
			return this.r.m[n];
		} else {
			throw haxe_Exception.thrown("EReg::matched");
		}
	}
	,matchedRight: function() {
		if(this.r.m == null) {
			throw haxe_Exception.thrown("No string matched");
		}
		var sz = this.r.m.index + this.r.m[0].length;
		return HxOverrides.substr(this.r.s,sz,this.r.s.length - sz);
	}
	,matchedPos: function() {
		if(this.r.m == null) {
			throw haxe_Exception.thrown("No string matched");
		}
		return { pos : this.r.m.index, len : this.r.m[0].length};
	}
	,matchSub: function(s,pos,len) {
		if(len == null) {
			len = -1;
		}
		if(this.r.global) {
			this.r.lastIndex = pos;
			this.r.m = this.r.exec(len < 0 ? s : HxOverrides.substr(s,0,pos + len));
			var b = this.r.m != null;
			if(b) {
				this.r.s = s;
			}
			return b;
		} else {
			var b = this.match(len < 0 ? HxOverrides.substr(s,pos,null) : HxOverrides.substr(s,pos,len));
			if(b) {
				this.r.s = s;
				this.r.m.index += pos;
			}
			return b;
		}
	}
	,split: function(s) {
		var d = "#__delim__#";
		return s.replace(this.r,d).split(d);
	}
	,map: function(s,f) {
		var offset = 0;
		var buf_b = "";
		do {
			if(offset >= s.length) {
				break;
			} else if(!this.matchSub(s,offset)) {
				buf_b += Std.string(HxOverrides.substr(s,offset,null));
				break;
			}
			var p = this.matchedPos();
			buf_b += Std.string(HxOverrides.substr(s,offset,p.pos - offset));
			buf_b += Std.string(f(this));
			if(p.len == 0) {
				buf_b += Std.string(HxOverrides.substr(s,p.pos,1));
				offset = p.pos + 1;
			} else {
				offset = p.pos + p.len;
			}
		} while(this.r.global);
		if(!this.r.global && offset > 0 && offset < s.length) {
			buf_b += Std.string(HxOverrides.substr(s,offset,null));
		}
		return buf_b;
	}
	,__class__: EReg
};
var nanofl_ide_plugins_IImporterPlugin = function() { };
nanofl_ide_plugins_IImporterPlugin.__name__ = "nanofl.ide.plugins.IImporterPlugin";
nanofl_ide_plugins_IImporterPlugin.__isInterface__ = true;
nanofl_ide_plugins_IImporterPlugin.prototype = {
	__class__: nanofl_ide_plugins_IImporterPlugin
};
var FlashImporterPlugin = function() {
	this.properties = [{ type : "bool", name : "importMedia", label : "Import media (Adobe Flash CS5+ must be installed)", defaultValue : true}];
	this.fileFilterExtensions = ["fla","xfl"];
	this.fileFilterDescription = "Adobe Flash Documents (*.fla;*.xfl)";
	this.menuItemIcon = "url(data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAA4AAAAOCAYAAAAfSC3RAAAACXBIWXMAAAsSAAALEgHS3X78AAACNUlEQVQoz21Qz0uUURQ997033zhjZvhjapps1RAkqYt0U1O4MAiLwUWEhEEQtKl2LdoEIkR/gFsX1S4iZgjbJiFEizSwTCgoYhgtSUTnm5nP+d47LWZGgzxwuffCORzOEZKYm5szw8PDvel0+nilUqEAAhIAAKUoIiYMwz/FYnEhl8v52WxWQBL5fB4jIyOTJFmtVnf4D6y1liQLhcLP0dHR6wAi+XweBgBmZ2fR0tIiALDt+64WBI5fv8FqjSB1FFok7O7u7pmenn5sjGE2m81hdXVVAODGxMQUSW5tbOxUnzzjzoP7LN+5xw3f59bmJq21oXOO6+vrhVQqdd6ICACA1tb38xeQd2/haiHcwQ5EvAjCIIDv+7pSqYSJRCKltT5k2ChB2tqAtd9QS4tgZxfkyhi8k2lY60BjEIYhrLUKAEjWDwBgtQosfEC4tAz2n4EaGoRKJqGVQiQSQTQaRSwWa9KVYq2mAcB8/uKwsgxvsI/hzAyCh5OAtVBKQWsNrTWMMU0hjBMJz7W2tt+OxQf4aQnOiWJnArrnWJ3R6EBEoJTaEyYXP2beDAxdCFKHLweVCvXYNR29OgZXKoEk6NyucLdIEsafevQyTCQ6zHZJSV8/vEsXQRFgL8++jspVgy7v+w8XP5Isyfg42HbA2XLZ0dVB0pHNr2EPULW/fnX2/a2bQ3d/rT2Nne4Fg8B68biKeJ7y9pmGO4Uk5ufnJZPJnEqn0yfK5bKVZpj/QRFhsVhc+QuQDi4zdLU6egAAAABJRU5ErkJggg==)";
	this.menuItemName = "Adobe Flash Document (*.fla;*.xfl)";
	this.name = "FlashImporter";
};
FlashImporterPlugin.__name__ = "FlashImporterPlugin";
FlashImporterPlugin.__interfaces__ = [nanofl_ide_plugins_IImporterPlugin];
FlashImporterPlugin.main = function() {
	nanofl.ide.plugins.ImporterPlugins.register(new FlashImporterPlugin());
};
FlashImporterPlugin.prototype = {
	importDocument: function(api,args) {
		if(haxe_io_Path.extension(args.srcFilePath) == "fla") {
			var dir = api.folders.get_temp() + "/unsaved/" + stdlib_Uuid.newUuid();
			api.zip.decompress(args.srcFilePath,dir);
			var _g = [];
			var _g1 = 0;
			var _g2 = api.fileSystem.readDirectory(dir);
			while(_g1 < _g2.length) {
				var v = _g2[_g1];
				++_g1;
				if(haxe_io_Path.extension(v).toLowerCase() == "xfl") {
					_g.push(v);
				}
			}
			var xflFiles = _g;
			if(xflFiles.length == 0) {
				throw haxe_Exception.thrown("XFL file is not found");
			}
			return flashimport_DocumentImporter.process(api,FlashImporterPlugin.IMPORT_MEDIA_SCRIPT_TEMPLATE,dir + "/" + xflFiles[0],args.destFilePath,args.documentProperties,args.library,args.params.importMedia).then(function(success) {
				api.fileSystem.deleteAny(dir);
				return success;
			});
		} else {
			return flashimport_DocumentImporter.process(api,FlashImporterPlugin.IMPORT_MEDIA_SCRIPT_TEMPLATE,args.srcFilePath,args.destFilePath,args.documentProperties,args.library,args.params.importMedia);
		}
	}
	,getPublishPath: function(originalPath) {
		switch(haxe_io_Path.extension(originalPath)) {
		case "fla":
			return haxe_io_Path.join([haxe_io_Path.directory(originalPath),haxe_io_Path.withoutDirectory(haxe_io_Path.withoutExtension(originalPath))]);
		case "xfl":
			return haxe_io_Path.directory(originalPath);
		default:
			return null;
		}
	}
	,__class__: FlashImporterPlugin
};
var HxOverrides = function() { };
HxOverrides.__name__ = "HxOverrides";
HxOverrides.cca = function(s,index) {
	var x = s.charCodeAt(index);
	if(x != x) {
		return undefined;
	}
	return x;
};
HxOverrides.substr = function(s,pos,len) {
	if(len == null) {
		len = s.length;
	} else if(len < 0) {
		if(pos == 0) {
			len = s.length + len;
		} else {
			return "";
		}
	}
	return s.substr(pos,len);
};
HxOverrides.remove = function(a,obj) {
	var i = a.indexOf(obj);
	if(i == -1) {
		return false;
	}
	a.splice(i,1);
	return true;
};
HxOverrides.now = function() {
	return Date.now();
};
var Lambda = function() { };
Lambda.__name__ = "Lambda";
Lambda.array = function(it) {
	var a = [];
	var i = $getIterator(it);
	while(i.hasNext()) {
		var i1 = i.next();
		a.push(i1);
	}
	return a;
};
Lambda.has = function(it,elt) {
	var x = $getIterator(it);
	while(x.hasNext()) {
		var x1 = x.next();
		if(x1 == elt) {
			return true;
		}
	}
	return false;
};
Lambda.exists = function(it,f) {
	var x = $getIterator(it);
	while(x.hasNext()) {
		var x1 = x.next();
		if(f(x1)) {
			return true;
		}
	}
	return false;
};
Lambda.count = function(it,pred) {
	var n = 0;
	if(pred == null) {
		var _ = $getIterator(it);
		while(_.hasNext()) {
			var _1 = _.next();
			++n;
		}
	} else {
		var x = $getIterator(it);
		while(x.hasNext()) {
			var x1 = x.next();
			if(pred(x1)) {
				++n;
			}
		}
	}
	return n;
};
Lambda.indexOf = function(it,v) {
	var i = 0;
	var v2 = $getIterator(it);
	while(v2.hasNext()) {
		var v21 = v2.next();
		if(v == v21) {
			return i;
		}
		++i;
	}
	return -1;
};
Lambda.find = function(it,f) {
	var v = $getIterator(it);
	while(v.hasNext()) {
		var v1 = v.next();
		if(f(v1)) {
			return v1;
		}
	}
	return null;
};
Math.__name__ = "Math";
var Reflect = function() { };
Reflect.__name__ = "Reflect";
Reflect.field = function(o,field) {
	try {
		return o[field];
	} catch( _g ) {
		return null;
	}
};
Reflect.fields = function(o) {
	var a = [];
	if(o != null) {
		var hasOwnProperty = Object.prototype.hasOwnProperty;
		for( var f in o ) {
		if(f != "__id__" && f != "hx__closures__" && hasOwnProperty.call(o,f)) {
			a.push(f);
		}
		}
	}
	return a;
};
Reflect.isFunction = function(f) {
	if(typeof(f) == "function") {
		return !(f.__name__ || f.__ename__);
	} else {
		return false;
	}
};
Reflect.compare = function(a,b) {
	if(a == b) {
		return 0;
	} else if(a > b) {
		return 1;
	} else {
		return -1;
	}
};
var Std = function() { };
Std.__name__ = "Std";
Std.string = function(s) {
	return js_Boot.__string_rec(s,"");
};
Std.parseInt = function(x) {
	var v = parseInt(x);
	if(isNaN(v)) {
		return null;
	}
	return v;
};
Std.random = function(x) {
	if(x <= 0) {
		return 0;
	} else {
		return Math.floor(Math.random() * x);
	}
};
var StringBuf = function() {
	this.b = "";
};
StringBuf.__name__ = "StringBuf";
StringBuf.prototype = {
	__class__: StringBuf
};
var haxe_SysTools = function() { };
haxe_SysTools.__name__ = "haxe.SysTools";
var StringTools = function() { };
StringTools.__name__ = "StringTools";
StringTools.htmlEscape = function(s,quotes) {
	var buf_b = "";
	var _g_offset = 0;
	var _g_s = s;
	while(_g_offset < _g_s.length) {
		var s = _g_s;
		var index = _g_offset++;
		var c = s.charCodeAt(index);
		if(c >= 55296 && c <= 56319) {
			c = c - 55232 << 10 | s.charCodeAt(index + 1) & 1023;
		}
		var c1 = c;
		if(c1 >= 65536) {
			++_g_offset;
		}
		var code = c1;
		switch(code) {
		case 34:
			if(quotes) {
				buf_b += "&quot;";
			} else {
				buf_b += String.fromCodePoint(code);
			}
			break;
		case 38:
			buf_b += "&amp;";
			break;
		case 39:
			if(quotes) {
				buf_b += "&#039;";
			} else {
				buf_b += String.fromCodePoint(code);
			}
			break;
		case 60:
			buf_b += "&lt;";
			break;
		case 62:
			buf_b += "&gt;";
			break;
		default:
			buf_b += String.fromCodePoint(code);
		}
	}
	return buf_b;
};
StringTools.htmlUnescape = function(s) {
	return s.split("&gt;").join(">").split("&lt;").join("<").split("&quot;").join("\"").split("&#039;").join("'").split("&amp;").join("&");
};
StringTools.startsWith = function(s,start) {
	if(s.length >= start.length) {
		return s.lastIndexOf(start,0) == 0;
	} else {
		return false;
	}
};
StringTools.endsWith = function(s,end) {
	var elen = end.length;
	var slen = s.length;
	if(slen >= elen) {
		return s.indexOf(end,slen - elen) == slen - elen;
	} else {
		return false;
	}
};
StringTools.isSpace = function(s,pos) {
	var c = HxOverrides.cca(s,pos);
	if(!(c > 8 && c < 14)) {
		return c == 32;
	} else {
		return true;
	}
};
StringTools.ltrim = function(s) {
	var l = s.length;
	var r = 0;
	while(r < l && StringTools.isSpace(s,r)) ++r;
	if(r > 0) {
		return HxOverrides.substr(s,r,l - r);
	} else {
		return s;
	}
};
StringTools.rtrim = function(s) {
	var l = s.length;
	var r = 0;
	while(r < l && StringTools.isSpace(s,l - r - 1)) ++r;
	if(r > 0) {
		return HxOverrides.substr(s,0,l - r);
	} else {
		return s;
	}
};
StringTools.trim = function(s) {
	return StringTools.ltrim(StringTools.rtrim(s));
};
StringTools.lpad = function(s,c,l) {
	if(c.length <= 0) {
		return s;
	}
	var buf_b = "";
	l -= s.length;
	while(buf_b.length < l) buf_b += c == null ? "null" : "" + c;
	buf_b += s == null ? "null" : "" + s;
	return buf_b;
};
StringTools.rpad = function(s,c,l) {
	if(c.length <= 0) {
		return s;
	}
	var buf_b = "";
	buf_b += s == null ? "null" : "" + s;
	while(buf_b.length < l) buf_b += c == null ? "null" : "" + c;
	return buf_b;
};
StringTools.replace = function(s,sub,by) {
	return s.split(sub).join(by);
};
StringTools.hex = function(n,digits) {
	var s = "";
	var hexChars = "0123456789ABCDEF";
	do {
		s = hexChars.charAt(n & 15) + s;
		n >>>= 4;
	} while(n > 0);
	if(digits != null) {
		while(s.length < digits) s = "0" + s;
	}
	return s;
};
StringTools.quoteUnixArg = function(argument) {
	if(argument == "") {
		return "''";
	} else if(!new EReg("[^a-zA-Z0-9_@%+=:,./-]","").match(argument)) {
		return argument;
	} else {
		return "'" + StringTools.replace(argument,"'","'\"'\"'") + "'";
	}
};
StringTools.quoteWinArg = function(argument,escapeMetaCharacters) {
	var argument1 = argument;
	if(!new EReg("^(/)?[^ \t/\\\\\"]+$","").match(argument1)) {
		var result_b = "";
		var needquote = argument1.indexOf(" ") != -1 || argument1.indexOf("\t") != -1 || argument1 == "" || argument1.indexOf("/") > 0;
		if(needquote) {
			result_b += "\"";
		}
		var bs_buf = new StringBuf();
		var _g = 0;
		var _g1 = argument1.length;
		while(_g < _g1) {
			var i = _g++;
			var _g2 = HxOverrides.cca(argument1,i);
			if(_g2 == null) {
				var c = _g2;
				if(bs_buf.b.length > 0) {
					result_b += Std.string(bs_buf.b);
					bs_buf = new StringBuf();
				}
				result_b += String.fromCodePoint(c);
			} else {
				switch(_g2) {
				case 34:
					var bs = bs_buf.b;
					result_b += Std.string(bs);
					result_b += Std.string(bs);
					bs_buf = new StringBuf();
					result_b += "\\\"";
					break;
				case 92:
					bs_buf.b += "\\";
					break;
				default:
					var c1 = _g2;
					if(bs_buf.b.length > 0) {
						result_b += Std.string(bs_buf.b);
						bs_buf = new StringBuf();
					}
					result_b += String.fromCodePoint(c1);
				}
			}
		}
		result_b += Std.string(bs_buf.b);
		if(needquote) {
			result_b += Std.string(bs_buf.b);
			result_b += "\"";
		}
		argument1 = result_b;
	}
	if(escapeMetaCharacters) {
		var result_b = "";
		var _g = 0;
		var _g1 = argument1.length;
		while(_g < _g1) {
			var i = _g++;
			var c = HxOverrides.cca(argument1,i);
			if(haxe_SysTools.winMetaCharacters.indexOf(c) >= 0) {
				result_b += String.fromCodePoint(94);
			}
			result_b += String.fromCodePoint(c);
		}
		return result_b;
	} else {
		return argument1;
	}
};
var ValueType = $hxEnums["ValueType"] = { __ename__:"ValueType",__constructs__:null
	,TNull: {_hx_name:"TNull",_hx_index:0,__enum__:"ValueType",toString:$estr}
	,TInt: {_hx_name:"TInt",_hx_index:1,__enum__:"ValueType",toString:$estr}
	,TFloat: {_hx_name:"TFloat",_hx_index:2,__enum__:"ValueType",toString:$estr}
	,TBool: {_hx_name:"TBool",_hx_index:3,__enum__:"ValueType",toString:$estr}
	,TObject: {_hx_name:"TObject",_hx_index:4,__enum__:"ValueType",toString:$estr}
	,TFunction: {_hx_name:"TFunction",_hx_index:5,__enum__:"ValueType",toString:$estr}
	,TClass: ($_=function(c) { return {_hx_index:6,c:c,__enum__:"ValueType",toString:$estr}; },$_._hx_name="TClass",$_.__params__ = ["c"],$_)
	,TEnum: ($_=function(e) { return {_hx_index:7,e:e,__enum__:"ValueType",toString:$estr}; },$_._hx_name="TEnum",$_.__params__ = ["e"],$_)
	,TUnknown: {_hx_name:"TUnknown",_hx_index:8,__enum__:"ValueType",toString:$estr}
};
ValueType.__constructs__ = [ValueType.TNull,ValueType.TInt,ValueType.TFloat,ValueType.TBool,ValueType.TObject,ValueType.TFunction,ValueType.TClass,ValueType.TEnum,ValueType.TUnknown];
var Type = function() { };
Type.__name__ = "Type";
Type.typeof = function(v) {
	switch(typeof(v)) {
	case "boolean":
		return ValueType.TBool;
	case "function":
		if(v.__name__ || v.__ename__) {
			return ValueType.TObject;
		}
		return ValueType.TFunction;
	case "number":
		if(Math.ceil(v) == v % 2147483648.0) {
			return ValueType.TInt;
		}
		return ValueType.TFloat;
	case "object":
		if(v == null) {
			return ValueType.TNull;
		}
		var e = v.__enum__;
		if(e != null) {
			return ValueType.TEnum($hxEnums[e]);
		}
		var c = js_Boot.getClass(v);
		if(c != null) {
			return ValueType.TClass(c);
		}
		return ValueType.TObject;
	case "string":
		return ValueType.TClass(String);
	case "undefined":
		return ValueType.TNull;
	default:
		return ValueType.TUnknown;
	}
};
var flashimport_DocumentImporter = function() { };
flashimport_DocumentImporter.__name__ = "flashimport.DocumentImporter";
flashimport_DocumentImporter.process = function(api,importMediaScriptTemplate,srcFilePath,destFilePath,destDocProp,destLibrary,runFlashToImportMedia) {
	flashimport_DocumentImporter.log("DocumentImporter.process",{ fileName : "src/flashimport/DocumentImporter.hx", lineNumber : 22, className : "flashimport.DocumentImporter", methodName : "process"});
	if(runFlashToImportMedia && flashimport_DocumentImporter.hasMedia(api,srcFilePath)) {
		return flashimport_DocumentImporter.importMedia(api,importMediaScriptTemplate,srcFilePath,destFilePath,destLibrary).then(function(success) {
			if(success) {
				return flashimport_DocumentImporter.importXmlFiles(api,srcFilePath,destDocProp,destLibrary);
			} else {
				return Promise.resolve(false);
			}
		});
	} else {
		return flashimport_DocumentImporter.importXmlFiles(api,srcFilePath,destDocProp,destLibrary);
	}
};
flashimport_DocumentImporter.hasMedia = function(api,srcFilePath) {
	var doc = new htmlparser_XmlDocument(api.fileSystem.getContent(haxe_io_Path.directory(srcFilePath) + "/DOMDocument.xml"));
	return htmlparser_HtmlParserTools.findOne(doc,">DOMDocument>media>*") != null;
};
flashimport_DocumentImporter.importMedia = function(api,importMediaScriptTemplate,srcFilePath,destFilePath,destLibrary) {
	flashimport_DocumentImporter.log("DocumentImporter.importMedia",{ fileName : "src/flashimport/DocumentImporter.hx", lineNumber : 47, className : "flashimport.DocumentImporter", methodName : "importMedia"});
	var destDir = haxe_io_Path.directory(destFilePath);
	var scriptFilePath = api.folders.get_temp() + "/flashImporter.jsfl";
	var script = StringTools.replace(StringTools.replace(importMediaScriptTemplate,"{SRC_FILE}",StringTools.replace(srcFilePath,"\\","/")),"{DEST_DIR}",StringTools.replace(destDir,"\\","/"));
	api.fileSystem.saveContent(scriptFilePath,script);
	var doneFile = destDir + "/.done-import-media";
	api.fileSystem.deleteFile(doneFile);
	api.processManager.run(scriptFilePath,[],false);
	return flashimport_DocumentImporter.waitFor(600,function() {
		return api.fileSystem.exists(doneFile);
	}).then(function(success) {
		if(success) {
			api.fileSystem.deleteFile(doneFile);
			destLibrary.loadItems();
			return true;
		} else {
			return false;
		}
	});
};
flashimport_DocumentImporter.importXmlFiles = function(api,srcFilePath,destDocProp,destLibrary) {
	flashimport_DocumentImporter.log("DocumentImporter.importXmlFiles BEGIN",{ fileName : "src/flashimport/DocumentImporter.hx", lineNumber : 80, className : "flashimport.DocumentImporter", methodName : "importXmlFiles"});
	var srcDir = haxe_io_Path.directory(srcFilePath);
	var srcDoc = new htmlparser_XmlDocument(api.fileSystem.getContent(srcDir + "/DOMDocument.xml"));
	var srcLibDir = srcDir + "/LIBRARY";
	var symbolLoader = new flashimport_SymbolLoader(api.fileSystem,api.fonts,srcDoc,srcLibDir,destLibrary);
	var docPropNode = htmlparser_HtmlParserTools.findOne(srcDoc,">DOMDocument");
	destDocProp.width = htmlparser_HtmlParserTools.getAttr(docPropNode,"width",550);
	destDocProp.height = htmlparser_HtmlParserTools.getAttr(docPropNode,"height",400);
	destDocProp.backgroundColor = htmlparser_HtmlParserTools.getAttr(docPropNode,"backgroundColor","#ffffff");
	destDocProp.framerate = htmlparser_HtmlParserTools.getAttr(docPropNode,"frameRate",24);
	flashimport_DocumentImporter.log("DocumentImporter.importXmlFiles load media",{ fileName : "src/flashimport/DocumentImporter.hx", lineNumber : 94, className : "flashimport.DocumentImporter", methodName : "importXmlFiles"});
	var _g = 0;
	var _g1 = docPropNode.find(">media>DOMSoundItem");
	while(_g < _g1.length) {
		var node = _g1[_g];
		++_g;
		var soundItem = destLibrary.getItem(htmlparser_HtmlParserTools.getAttr(node,"name"));
		if(((soundItem) instanceof nanofl.ide.libraryitems.SoundItem)) {
			if(htmlparser_HtmlParserTools.getAttr(node,"linkageExportForAS",false)) {
				soundItem.linkage = htmlparser_HtmlParserTools.getAttr(node,"linkageIdentifier");
			}
		}
	}
	flashimport_DocumentImporter.log("DocumentImporter.importXmlFiles load folders",{ fileName : "src/flashimport/DocumentImporter.hx", lineNumber : 107, className : "flashimport.DocumentImporter", methodName : "importXmlFiles"});
	var _g = 0;
	var _g1 = docPropNode.find(">folders>DOMFolderItem");
	while(_g < _g1.length) {
		var node = _g1[_g];
		++_g;
		if(node.hasAttribute("name")) {
			var namePath = htmlparser_HtmlParserTools.getAttr(node,"name","");
			if(namePath != "") {
				destLibrary.addItem(new nanofl.ide.libraryitems.FolderItem(namePath));
			}
		}
	}
	flashimport_DocumentImporter.log("DocumentImporter.importXmlFiles load document",{ fileName : "src/flashimport/DocumentImporter.hx", lineNumber : 120, className : "flashimport.DocumentImporter", methodName : "importXmlFiles"});
	symbolLoader.loadFromXml(nanofl.ide.library.IdeLibrary.SCENE_NAME_PATH,srcDoc);
	flashimport_DocumentImporter.log("DocumentImporter.importXmlFiles load symbols",{ fileName : "src/flashimport/DocumentImporter.hx", lineNumber : 123, className : "flashimport.DocumentImporter", methodName : "importXmlFiles"});
	var _this = docPropNode.find(">symbols>Include");
	var result = new Array(_this.length);
	var _g = 0;
	var _g1 = _this.length;
	while(_g < _g1) {
		var i = _g++;
		result[i] = htmlparser_HtmlParserTools.getAttrString(_this[i],"href");
	}
	var hrefs = result;
	flashimport_DocumentImporter.log("DocumentImporter.importXmlFiles load library",{ fileName : "src/flashimport/DocumentImporter.hx", lineNumber : 126, className : "flashimport.DocumentImporter", methodName : "importXmlFiles"});
	return new Promise(function(resolve,reject) {
		var loadNext = null;
		loadNext = function() {
			if(hrefs.length == 0) {
				flashimport_DocumentImporter.log("DocumentImporter.importXmlFiles END",{ fileName : "src/flashimport/DocumentImporter.hx", lineNumber : 133, className : "flashimport.DocumentImporter", methodName : "importXmlFiles"});
				resolve(true);
			} else {
				symbolLoader.loadFromFile(hrefs.shift());
				haxe_Timer.delay(loadNext,10);
			}
		};
		loadNext();
	});
};
flashimport_DocumentImporter.waitFor = function(maxSeconds,condition) {
	if(maxSeconds == null) {
		maxSeconds = 0;
	}
	return new Promise(function(resolve,reject) {
		if(condition()) {
			resolve(true);
		} else {
			var start = new Date().getTime();
			var timer = new haxe_Timer(200);
			timer.run = function() {
				if(condition()) {
					timer.stop();
					resolve(true);
				} else if(maxSeconds > 0 && new Date().getTime() - start > maxSeconds * 1000) {
					timer.stop();
					resolve(false);
				}
			};
		}
	});
};
flashimport_DocumentImporter.log = function(s,infos) {
};
var flashimport_DrawOp = $hxEnums["flashimport.DrawOp"] = { __ename__:"flashimport.DrawOp",__constructs__:null
	,move: ($_=function(x,y) { return {_hx_index:0,x:x,y:y,__enum__:"flashimport.DrawOp",toString:$estr}; },$_._hx_name="move",$_.__params__ = ["x","y"],$_)
	,line: ($_=function(x,y) { return {_hx_index:1,x:x,y:y,__enum__:"flashimport.DrawOp",toString:$estr}; },$_._hx_name="line",$_.__params__ = ["x","y"],$_)
	,curve: ($_=function(x1,y1,x2,y2) { return {_hx_index:2,x1:x1,y1:y1,x2:x2,y2:y2,__enum__:"flashimport.DrawOp",toString:$estr}; },$_._hx_name="curve",$_.__params__ = ["x1","y1","x2","y2"],$_)
};
flashimport_DrawOp.__constructs__ = [flashimport_DrawOp.move,flashimport_DrawOp.line,flashimport_DrawOp.curve];
var flashimport_EdgeData = function(edge) {
	this.strokeStyle = htmlparser_HtmlParserTools.getAttr(edge,"strokeStyle",0) | 0;
	this.fillStyle0 = htmlparser_HtmlParserTools.getAttr(edge,"fillStyle0",0) | 0;
	this.fillStyle1 = htmlparser_HtmlParserTools.getAttr(edge,"fillStyle1",0) | 0;
	this.drawOps = [];
	var drawStr = htmlparser_HtmlParserTools.getAttr(edge,"edges");
	if(drawStr == null) {
		return;
	}
	var reNumber = "(#?-?[0-9A-F]+(?:[.][0-9A-F]+)?)";
	var reXY = new EReg("^" + reNumber + "\\s+" + reNumber + "\\s*","i");
	var reX1Y1X2Y2 = new EReg("^" + reNumber + "\\s+" + reNumber + "\\s+" + reNumber + "\\s+" + reNumber + "\\s*","i");
	var lastX = 1.0e10;
	var lastY = 1.0e10;
	stdlib_Debug.assert(drawStr.length == 0 || StringTools.ltrim(drawStr).charAt(0) == "!","drawStr = " + drawStr,{ fileName : "src/flashimport/EdgeData.hx", lineNumber : 39, className : "flashimport.EdgeData", methodName : "new"});
	while(drawStr.length > 0) {
		var opCode = drawStr.charAt(0);
		drawStr = HxOverrides.substr(drawStr,1,null);
		if(opCode == "!") {
			if(reXY.match(drawStr)) {
				var x = this.parseNumber(reXY.matched(1));
				var y = this.parseNumber(reXY.matched(2));
				if(x != lastX || y != lastY) {
					this.drawOps.push(flashimport_DrawOp.move(x,y));
					lastX = x;
					lastY = y;
				}
				drawStr = reXY.matchedRight();
			} else {
				throw haxe_Exception.thrown("Expected (x, y).");
			}
		} else if(opCode == "|" || opCode == "/") {
			while(reXY.match(drawStr)) {
				var tmp = this.drawOps;
				lastX = this.parseNumber(reXY.matched(1));
				lastY = this.parseNumber(reXY.matched(2));
				tmp.push(flashimport_DrawOp.line(lastX,lastY));
				drawStr = reXY.matchedRight();
			}
		} else if(opCode == "[") {
			while(reX1Y1X2Y2.match(drawStr)) {
				var tmp1 = this.drawOps;
				var tmp2 = this.parseNumber(reX1Y1X2Y2.matched(1));
				var tmp3 = this.parseNumber(reX1Y1X2Y2.matched(2));
				lastX = this.parseNumber(reX1Y1X2Y2.matched(3));
				lastY = this.parseNumber(reX1Y1X2Y2.matched(4));
				tmp1.push(flashimport_DrawOp.curve(tmp2,tmp3,lastX,lastY));
				drawStr = reX1Y1X2Y2.matchedRight();
			}
		} else if(opCode == "S") {
			drawStr = HxOverrides.substr(drawStr,1,null);
		} else if(opCode == " " || opCode == "\r" || opCode == "\n") {
			drawStr = HxOverrides.substr(drawStr,1,null);
		} else {
			throw haxe_Exception.thrown("Unknow edges code = '" + opCode + "' near '" + drawStr + "'.");
		}
	}
};
flashimport_EdgeData.__name__ = "flashimport.EdgeData";
flashimport_EdgeData.prototype = {
	parseNumber: function(s) {
		if(StringTools.startsWith(s,"#")) {
			s = HxOverrides.substr(s,1,null);
			var n = s.indexOf(".");
			var high = HxOverrides.substr(s,0,n);
			var low = StringTools.rpad(HxOverrides.substr(s,n + 1,null),"0",2);
			var r = Std.parseInt("0x" + high + low);
			if(r >= -2147483648) {
				r = -(~r + 1);
			}
			return nanofl.engine.geom.PointTools.roundGap(r / 5120);
		}
		return nanofl.engine.geom.PointTools.roundGap(0.05 * parseFloat(s));
	}
	,__class__: flashimport_EdgeData
};
var flashimport_FontConvertor = function(fonts) {
	this.fonts = fonts;
};
flashimport_FontConvertor.__name__ = "flashimport.FontConvertor";
flashimport_FontConvertor.prototype = {
	convert: function(font) {
		var n = font.lastIndexOf("-");
		var face = n >= 0 ? font.substring(0,n) : font;
		face = this.convertFontFamily(face);
		var style = n >= 0 ? this.removeSuffixes(font.substring(n + 1)).toLowerCase() : "";
		if(style == "bolditalic") {
			style = "bold italic";
		}
		style = StringTools.replace(style,"regular","");
		style = StringTools.replace(style,"semibold","bold");
		return { face : face, style : style};
	}
	,convertFontFamily: function(s) {
		var _g = 0;
		var _g1 = this.fonts;
		while(_g < _g1.length) {
			var font = _g1[_g];
			++_g;
			if(StringTools.replace(font," ","") == s) {
				return font;
			}
		}
		s = this.removeSuffixes(s);
		var _g = 0;
		var _g1 = this.fonts;
		while(_g < _g1.length) {
			var font = _g1[_g];
			++_g;
			if(StringTools.replace(font," ","") == s) {
				return font;
			}
		}
		return s;
	}
	,removeSuffixes: function(s) {
		var changed = true;
		while(changed) {
			changed = false;
			var suffix = "MT";
			if(StringTools.endsWith(s,suffix)) {
				s = s.substring(0,s.length - suffix.length);
				changed = true;
			}
			var suffix1 = "PS";
			if(StringTools.endsWith(s,suffix1)) {
				s = s.substring(0,s.length - suffix1.length);
				changed = true;
			}
		}
		return s;
	}
	,__class__: flashimport_FontConvertor
};
var flashimport_Macro = function() { };
flashimport_Macro.__name__ = "flashimport.Macro";
var flashimport_MatrixMap = function() {
	this.values = [];
	this.kk = [];
};
flashimport_MatrixMap.__name__ = "flashimport.MatrixMap";
flashimport_MatrixMap.prototype = {
	exists: function(key) {
		var _g = 0;
		var _g1 = this.kk;
		while(_g < _g1.length) {
			var k = _g1[_g];
			++_g;
			if(k.equ(key)) {
				return true;
			}
		}
		return false;
	}
	,set: function(key,value) {
		var _g = 0;
		var _g1 = this.kk.length;
		while(_g < _g1) {
			var i = _g++;
			if(this.kk[i].equ(key)) {
				this.values[i] = value;
				return;
			}
		}
		this.kk.push(key);
		this.values.push(value);
	}
	,get: function(key) {
		var _g = 0;
		var _g1 = this.kk.length;
		while(_g < _g1) {
			var i = _g++;
			if(this.kk[i].equ(key)) {
				return this.values[i];
			}
		}
		return null;
	}
	,keys: function() {
		return new haxe_iterators_ArrayIterator(this.kk);
	}
	,__class__: flashimport_MatrixMap
};
var flashimport_MatrixParser = function() { };
flashimport_MatrixParser.__name__ = "flashimport.MatrixParser";
flashimport_MatrixParser.load = function(node,divider,dx,dy) {
	if(dy == null) {
		dy = 0.0;
	}
	if(dx == null) {
		dx = 0.0;
	}
	if(divider == null) {
		divider = 1.0;
	}
	if(node != null) {
		return new nanofl.engine.geom.Matrix(htmlparser_HtmlParserTools.getAttr(node,"a",1.0) / divider,htmlparser_HtmlParserTools.getAttr(node,"b",0.0) / divider,htmlparser_HtmlParserTools.getAttr(node,"c",0.0) / divider,htmlparser_HtmlParserTools.getAttr(node,"d",1.0) / divider,htmlparser_HtmlParserTools.getAttr(node,"tx",0.0) + dx,htmlparser_HtmlParserTools.getAttr(node,"ty",0.0) + dy);
	}
	return new nanofl.engine.geom.Matrix();
};
var flashimport_PathTools = function() { };
flashimport_PathTools.__name__ = "flashimport.PathTools";
flashimport_PathTools.unescape = function(s) {
	return new EReg("&#(\\d\\d\\d)","g").map(s,function(re) {
		var code = Std.parseInt(re.matched(1));
		return String.fromCodePoint(code);
	});
};
var flashimport_ShapeConvertor = function(stokes,fills,edgeDatas) {
	this.stokes = stokes;
	this.fills = fills;
	this.edgeDatas = edgeDatas;
};
flashimport_ShapeConvertor.__name__ = "flashimport.ShapeConvertor";
flashimport_ShapeConvertor.log = function(v,infos) {
};
flashimport_ShapeConvertor.prototype = {
	convert: function() {
		var strokeAndFillEdges = this.parseEdges();
		var fillContours = this.findFillContours(strokeAndFillEdges.fillEdges);
		flashimport_ShapeConvertor.log(function() {
			var result = new Array(fillContours.length);
			var _g = 0;
			var _g1 = fillContours.length;
			while(_g < _g1) {
				var i = _g++;
				var fc = fillContours[i];
				result[i] = StringTools.rpad(Std.string(fc.fill)," ",35) + " / " + fc.contour.getClockwiseProduct() + " / " + Std.string(fc.contour);
			}
			return "EdgeDataConvertor.convert(1) fillContours =\n\t" + result.join("\n\t");
		},{ fileName : "src/flashimport/ShapeConvertor.hx", lineNumber : 34, className : "flashimport.ShapeConvertor", methodName : "convert"});
		return { edges : strokeAndFillEdges.strokeEdges, polygons : this.polygonsFromFillContours(fillContours)};
	}
	,parseEdges: function() {
		var strokeEdges = [];
		var fillEdges = [];
		var posX = 0.0;
		var posY = 0.0;
		var _g = 0;
		var _g1 = this.edgeDatas;
		while(_g < _g1.length) {
			var edgeData = _g1[_g];
			++_g;
			var stroke = edgeData.strokeStyle != 0 ? this.stokes[edgeData.strokeStyle - 1] : null;
			var fill0 = edgeData.fillStyle0 != 0 ? this.fills[edgeData.fillStyle0 - 1] : null;
			var fill1 = edgeData.fillStyle1 != 0 ? this.fills[edgeData.fillStyle1 - 1] : null;
			var _g2 = 0;
			var _g3 = edgeData.drawOps;
			while(_g2 < _g3.length) {
				var drawOp = _g3[_g2];
				++_g2;
				switch(drawOp._hx_index) {
				case 0:
					var x = drawOp.x;
					var y = drawOp.y;
					posX = x;
					posY = y;
					break;
				case 1:
					var x1 = drawOp.x;
					var y1 = drawOp.y;
					var edge = new nanofl.engine.geom.Edge(posX,posY,x1,y1);
					if(stroke != null) {
						strokeEdges.push(nanofl.engine.geom.StrokeEdge.fromEdge(edge,stroke));
					}
					if(fill0 != null || fill1 != null) {
						fillEdges.push({ edge : edge, fill : fill0});
						fillEdges.push({ edge : edge.clone().reverse(), fill : fill1});
					}
					posX = x1;
					posY = y1;
					break;
				case 2:
					var x11 = drawOp.x1;
					var y11 = drawOp.y1;
					var x2 = drawOp.x2;
					var y2 = drawOp.y2;
					var edge1 = new nanofl.engine.geom.Edge(posX,posY,x11,y11,x2,y2);
					if(stroke != null) {
						strokeEdges.push(nanofl.engine.geom.StrokeEdge.fromEdge(edge1,stroke));
					}
					if(fill0 != null || fill1 != null) {
						fillEdges.push({ edge : edge1, fill : fill0});
						fillEdges.push({ edge : edge1.clone().reverse(), fill : fill1});
					}
					posX = x2;
					posY = y2;
					break;
				}
			}
		}
		flashimport_ShapeConvertor.log(function() {
			var result = new Array(fillEdges.length);
			var _g = 0;
			var _g1 = fillEdges.length;
			while(_g < _g1) {
				var i = _g++;
				var fe = fillEdges[i];
				result[i] = StringTools.rpad(Std.string(fe.fill)," ",35) + " / " + Std.string(fe.edge);
			}
			return "EdgeDataConvertor.parseEdges fillEdges =\n\t" + result.join("\n\t");
		},{ fileName : "src/flashimport/ShapeConvertor.hx", lineNumber : 95, className : "flashimport.ShapeConvertor", methodName : "parseEdges"});
		return { strokeEdges : strokeEdges, fillEdges : fillEdges};
	}
	,findFillContours: function(fillEdges) {
		var r = [];
		while(fillEdges.length > 0) {
			var base = fillEdges.shift();
			var edges = [base.edge];
			var i = 0;
			while(i < fillEdges.length) if(fillEdges[i].fill == base.fill) {
				edges.push(fillEdges[i].edge);
				fillEdges.splice(i,1);
			} else {
				++i;
			}
			var contours = nanofl.engine.geom.Contours.fromVectors(edges);
			var _g = 0;
			while(_g < contours.length) {
				var contour = [contours[_g]];
				++_g;
				var c = Lambda.find(r,(function(contour) {
					return function(c) {
						return c.contour.equ(contour[0]);
					};
				})(contour));
				if(c == null) {
					r.push({ fill : base.fill, contour : contour[0]});
				} else if(c.fill == null) {
					c.fill = base.fill;
				}
			}
		}
		return r;
	}
	,polygonsFromFillContours: function(fillContours) {
		this.assertFillContoursCorrect(fillContours);
		var _g = 0;
		while(_g < fillContours.length) {
			var fc = fillContours[_g];
			++_g;
			if(fc.contour.getClockwiseProduct() < 0) {
				fc.contour.reverse();
			}
		}
		this.assertFillContoursCorrect(fillContours);
		var r = [];
		var _g = 0;
		while(_g < fillContours.length) {
			var outer = fillContours[_g];
			++_g;
			if(outer.fill == null) {
				continue;
			}
			var inners = [];
			var _g1 = 0;
			while(_g1 < fillContours.length) {
				var inner = fillContours[_g1];
				++_g1;
				if(inner != outer && inner.contour.isNestedTo(outer.contour)) {
					stdlib_Debug.assert(inner.contour != outer.contour,null,{ fileName : "src/flashimport/ShapeConvertor.hx", lineNumber : 154, className : "flashimport.ShapeConvertor", methodName : "polygonsFromFillContours"});
					stdlib_Debug.assert(!inner.contour.equ(outer.contour),null,{ fileName : "src/flashimport/ShapeConvertor.hx", lineNumber : 155, className : "flashimport.ShapeConvertor", methodName : "polygonsFromFillContours"});
					inners.push(inner.contour.clone().reverse());
				}
			}
			nanofl.engine.geom.Contours.removeNested(inners);
			nanofl.engine.geom.Contours.mergeByCommonEdges(inners,true);
			var polygon = new nanofl.engine.geom.Polygon(outer.fill,[outer.contour].concat(inners));
			polygon.assertCorrect();
			r.push(polygon);
		}
		return r;
	}
	,assertFillContoursCorrect: function(fillContours) {
		var _g = 0;
		while(_g < fillContours.length) {
			var fc = fillContours[_g];
			++_g;
			fc.contour.assertCorrect();
		}
		var i = 0;
		while(i < fillContours.length) {
			var j = i + 1;
			while(j < fillContours.length) {
				if(fillContours[i].contour.equ(fillContours[j].contour)) {
					haxe_Log.trace("Equ contours:\n\tfill[i] = " + Std.string(fillContours[i].fill) + "\n\tfill[j] = " + Std.string(fillContours[j].fill) + "\n\tcontour = " + Std.string(fillContours[i].contour),{ fileName : "src/flashimport/ShapeConvertor.hx", lineNumber : 180, className : "flashimport.ShapeConvertor", methodName : "assertFillContoursCorrect"});
				}
				++j;
			}
			++i;
		}
	}
	,__class__: flashimport_ShapeConvertor
};
var flashimport_SymbolLoader = function(fileSystem,fonts,doc,srcLibDir,library) {
	this.generatedAutoIDs = [];
	this.morphingNotSupported = [];
	this.fontMap = new haxe_ds_StringMap();
	this.fileSystem = fileSystem;
	this.doc = doc;
	this.srcLibDir = srcLibDir;
	this.library = library;
	this.fontConvertor = new flashimport_FontConvertor(fonts.getFontNames());
};
flashimport_SymbolLoader.__name__ = "flashimport.SymbolLoader";
flashimport_SymbolLoader.log = function(s,infos) {
};
flashimport_SymbolLoader.prototype = {
	loadFromFile: function(href) {
		var namePath = flashimport_PathTools.unescape(haxe_io_Path.withoutExtension(href));
		if(!this.library.hasItem(namePath)) {
			flashimport_SymbolLoader.log("Load item \"" + namePath + "\"",{ fileName : "src/flashimport/SymbolLoader.hx", lineNumber : 78, className : "flashimport.SymbolLoader", methodName : "loadFromFile"});
			if(this.fileSystem.exists(this.srcLibDir + "/" + href)) {
				this.loadFromXml(namePath,new htmlparser_XmlDocument(this.fileSystem.getContent(this.srcLibDir + "/" + href)));
			}
		}
	}
	,loadFromXml: function(namePath,src) {
		if(this.library.hasItem(namePath)) {
			return js_Boot.__cast(this.library.getItem(namePath) , nanofl.ide.libraryitems.MovieClipItem);
		}
		var symbolItemXml = htmlparser_HtmlParserTools.findOne(src,">DOMSymbolItem");
		if(symbolItemXml == null) {
			symbolItemXml = htmlparser_HtmlParserTools.findOne(src,">DOMDocument");
		}
		var r = new nanofl.ide.libraryitems.MovieClipItem(namePath);
		r.likeButton = htmlparser_HtmlParserTools.getAttr(symbolItemXml,"symbolType") == "button";
		this.loadLinkage(r,symbolItemXml);
		var _g = 0;
		var _g1 = symbolItemXml.find(">timeline>DOMTimeline>layers>DOMLayer").concat(symbolItemXml.find(">timelines>DOMTimeline>layers>DOMLayer"));
		while(_g < _g1.length) {
			var layer = _g1[_g];
			++_g;
			r.addLayer(this.loadLayer(namePath,layer));
		}
		this.library.addItem(r);
		return r;
	}
	,loadLayer: function(namePath,layer) {
		var r = new nanofl.engine.movieclip.Layer(htmlparser_HtmlParserTools.getAttr(layer,"name"),htmlparser_HtmlParserTools.getAttr(layer,"layerType","normal"),htmlparser_HtmlParserTools.getAttr(layer,"visible",true),htmlparser_HtmlParserTools.getAttr(layer,"locked",false),htmlparser_HtmlParserTools.getAttrInt(layer,"parentLayerIndex"));
		var _g = 0;
		var _g1 = layer.find(">frames>DOMFrame");
		while(_g < _g1.length) {
			var frame = _g1[_g];
			++_g;
			r.addKeyFrame(this.loadFrame(namePath,frame));
		}
		return r;
	}
	,loadFrame: function(namePath,frame) {
		return new nanofl.engine.movieclip.KeyFrame(htmlparser_HtmlParserTools.getAttr(frame,"name",""),htmlparser_HtmlParserTools.getAttr(frame,"duration",1) | 0,this.loadMotionTween(namePath,frame),this.loadElements(namePath,frame.find(">elements>*"),new nanofl.engine.geom.Matrix()));
	}
	,loadMotionTween: function(namePath,frame) {
		var type = htmlparser_HtmlParserTools.getAttr(frame,"tweenType","none");
		switch(type) {
		case "motion":
			return new nanofl.engine.movieclip.MotionTween(-htmlparser_HtmlParserTools.getAttrInt(frame,"acceleration",0),htmlparser_HtmlParserTools.getAttr(frame,"motionTweenOrientToPath",false),this.parseMotionTweenRotate(htmlparser_HtmlParserTools.getAttr(frame,"motionTweenRotate"),htmlparser_HtmlParserTools.getAttr(frame,"motionTweenRotateTimes",1)),0,0,0,0);
		case "none":
			return null;
		case "shape":
			if(!Lambda.has(this.morphingNotSupported,namePath)) {
				this.morphingNotSupported.push(namePath);
				nanofl.engine.Debug.console.warn("Shape morphing tween is not supported (symbol '" + namePath + "').");
			}
			return null;
		default:
			nanofl.engine.Debug.console.warn("Unknow tween type '" + type + "' (symbol '" + namePath + "').");
			return null;
		}
	}
	,loadElements: function(namePath,elements,parentMatrix) {
		var _gthis = this;
		var r = [];
		var _g = 0;
		while(_g < elements.length) {
			var element = [elements[_g]];
			++_g;
			switch(element[0].name) {
			case "DOMBitmapInstance":case "DOMSymbolInstance":
				var instance = flashimport_PathTools.unescape(htmlparser_HtmlParserTools.getAttr(element[0],"libraryItemName"));
				var instance1 = htmlparser_HtmlParserTools.getAttr(element[0],"name","");
				var instance2 = this.loadColorEffect(htmlparser_HtmlParserTools.findOne(element[0],">color>Color"));
				var _this = element[0].find(">filters>*");
				var result = new Array(_this.length);
				var _g1 = 0;
				var _g2 = _this.length;
				while(_g1 < _g2) {
					var i = _g1++;
					result[i] = _gthis.loadFilter(_this[i]);
				}
				var instance3 = new nanofl.engine.elements.Instance(instance,instance1,instance2,result,htmlparser_HtmlParserTools.getAttr(element[0],"blendMode","normal"));
				instance3.matrix = flashimport_MatrixParser.load(htmlparser_HtmlParserTools.findOne(element[0],">matrix>Matrix")).prependMatrix(parentMatrix);
				this.loadRegPoint(instance3,htmlparser_HtmlParserTools.findOne(element[0],">transformationPoint>Point"));
				r.push(instance3);
				break;
			case "DOMGroup":
				var elements1 = element[0].find(">members>*");
				if(elements1.length > 0) {
					var m = flashimport_MatrixParser.load(htmlparser_HtmlParserTools.findOne(element[0],">matrix>Matrix"));
					var group = new nanofl.engine.elements.GroupElement(this.loadElements(namePath,elements1,m.clone().invert().prependMatrix(parentMatrix)));
					group.matrix = m;
					r.push(group);
				}
				break;
			case "DOMDynamicText":case "DOMInputText":case "DOMStaticText":
				r.push(this.loadText(element[0],parentMatrix));
				break;
			case "DOMOvalObject":
				r.push(new nanofl.engine.elements.GroupElement(this.loadDrawing(namePath,element[0],parentMatrix,(function(element) {
					return function(strokes,fills) {
						return nanofl.engine.elements.ShapeElement.createOval(htmlparser_HtmlParserTools.getAttrFloat(element[0],"x") + htmlparser_HtmlParserTools.getAttrFloat(element[0],"objectWidth") / 2,htmlparser_HtmlParserTools.getAttrFloat(element[0],"y") + htmlparser_HtmlParserTools.getAttrFloat(element[0],"objectHeight") / 2,htmlparser_HtmlParserTools.getAttrFloat(element[0],"objectWidth") / 2,htmlparser_HtmlParserTools.getAttrFloat(element[0],"objectHeight") / 2,htmlparser_HtmlParserTools.getAttrFloat(element[0],"startAngle",0.0),htmlparser_HtmlParserTools.getAttrFloat(element[0],"endAngle",360.0),htmlparser_HtmlParserTools.getAttrFloat(element[0],"innerRadius",0.0),htmlparser_HtmlParserTools.getAttrBool(element[0],"closePath",true),strokes.length > 0 ? strokes[0] : null,fills.length > 0 ? fills[0] : null);
					};
				})(element))));
				break;
			case "DOMRectangleObject":
				r.push(new nanofl.engine.elements.GroupElement(this.loadDrawing(namePath,element[0],parentMatrix,(function(element) {
					return function(strokes,fills) {
						return nanofl.engine.elements.ShapeElement.createRectangle(htmlparser_HtmlParserTools.getAttrFloat(element[0],"x"),htmlparser_HtmlParserTools.getAttrFloat(element[0],"y"),htmlparser_HtmlParserTools.getAttrFloat(element[0],"objectWidth"),htmlparser_HtmlParserTools.getAttrFloat(element[0],"objectHeight"),htmlparser_HtmlParserTools.getAttrFloat(element[0],"topLeftRadius",0.0),htmlparser_HtmlParserTools.getAttrFloat(element[0],"topRightRadius",0.0),htmlparser_HtmlParserTools.getAttrFloat(element[0],"bottomRightRadius",0.0),htmlparser_HtmlParserTools.getAttrFloat(element[0],"bottomLeftRadius",0.0),strokes.length > 0 ? strokes[0] : null,fills.length > 0 ? fills[0] : null);
					};
				})(element))));
				break;
			case "DOMShape":
				if(!htmlparser_HtmlParserTools.getAttr(element[0],"isDrawingObject",false)) {
					r = r.concat(this.loadShape(namePath,element[0],parentMatrix));
				} else {
					r.push(new nanofl.engine.elements.GroupElement(this.loadShape(namePath,element[0],parentMatrix)));
				}
				break;
			case "DOMTLFText":
				nanofl.engine.Debug.console.warn("DOMTLFText is not supported. Please, resave original document in Flash Pro CC.");
				break;
			default:
				nanofl.engine.Debug.console.warn("Unknow element node: '" + element[0].name + "'.");
			}
		}
		return r;
	}
	,loadShape: function(namePath,element,parentMatrix) {
		var _gthis = this;
		return this.loadDrawing(namePath,element,parentMatrix,function(strokes,fills) {
			return new flashimport_ShapeConvertor(strokes,fills,_gthis.loadEdgeDatas(element)).convert();
		});
	}
	,loadDrawing: function(namePath,element,parentMatrix,parseDrawData) {
		var _this = element.find(">strokes>StrokeStyle>*, >stroke>*");
		var f = $bind(this,this.loadShapeStroke);
		var result = new Array(_this.length);
		var _g = 0;
		var _g1 = _this.length;
		while(_g < _g1) {
			var i = _g++;
			result[i] = f(_this[i]);
		}
		var transformedStrokes = result;
		var _this = element.find(">fills>FillStyle>*, >fill>*");
		var f = $bind(this,this.loadShapeFill);
		var result = new Array(_this.length);
		var _g = 0;
		var _g1 = _this.length;
		while(_g < _g1) {
			var i = _g++;
			result[i] = f(_this[i]);
		}
		var transformedFills = result;
		var matrixBy = new haxe_ds_ObjectMap();
		var byMatrix = new flashimport_MatrixMap();
		var _g = 0;
		while(_g < transformedStrokes.length) {
			var z = transformedStrokes[_g];
			++_g;
			matrixBy.set(z.stroke,z.matrix);
			if(!byMatrix.exists(z.matrix)) {
				byMatrix.set(z.matrix,[]);
			}
			byMatrix.get(z.matrix).push(z.stroke);
		}
		var _g = 0;
		while(_g < transformedFills.length) {
			var z = transformedFills[_g];
			++_g;
			matrixBy.set(z.fill,z.matrix);
			if(!byMatrix.exists(z.matrix)) {
				byMatrix.set(z.matrix,[]);
			}
			byMatrix.get(z.matrix).push(z.fill);
		}
		var result = new Array(transformedStrokes.length);
		var _g = 0;
		var _g1 = transformedStrokes.length;
		while(_g < _g1) {
			var i = _g++;
			result[i] = transformedStrokes[i].stroke;
		}
		var shapeData = result;
		var result = new Array(transformedFills.length);
		var _g = 0;
		var _g1 = transformedFills.length;
		while(_g < _g1) {
			var i = _g++;
			result[i] = transformedFills[i].fill;
		}
		var shapeData1 = parseDrawData(shapeData,result);
		var objectMatrix = flashimport_MatrixParser.load(htmlparser_HtmlParserTools.findOne(element,">matrix>Matrix")).prependMatrix(parentMatrix);
		var r = [];
		var edges = stdlib_LambdaArray.extract(shapeData1.edges,function(edge) {
			return matrixBy.h[edge.stroke.__id__].isIdentity();
		});
		var polygons = stdlib_LambdaArray.extract(shapeData1.polygons,function(polygon) {
			return matrixBy.h[polygon.fill.__id__].isIdentity();
		});
		if(edges.length > 0 || polygons.length > 0) {
			var shape = new nanofl.engine.elements.ShapeElement(edges,polygons);
			this.loadRegPoint(shape,htmlparser_HtmlParserTools.findOne(element,">transformationPoint>Point"));
			shape.transform(objectMatrix,true);
			r.push(shape);
		}
		var matrix = byMatrix.keys();
		while(matrix.hasNext()) {
			var matrix1 = [matrix.next()];
			if(matrix1[0].isIdentity()) {
				continue;
			}
			var shape = new nanofl.engine.elements.ShapeElement(stdlib_LambdaArray.extract(shapeData1.edges,(function(matrix) {
				return function(edge) {
					return matrixBy.h[edge.stroke.__id__].equ(matrix[0]);
				};
			})(matrix1)),stdlib_LambdaArray.extract(shapeData1.polygons,(function(matrix) {
				return function(polygon) {
					return matrixBy.h[polygon.fill.__id__].equ(matrix[0]);
				};
			})(matrix1)));
			shape.transform(matrix1[0].clone().invert(),false);
			r.push(this.wrapElements(namePath,[shape],objectMatrix.clone().appendMatrix(matrix1[0])));
		}
		return r;
	}
	,wrapElements: function(autoPrefixID,elements,matrix) {
		var mcItem = new nanofl.ide.libraryitems.MovieClipItem(this.generateNewID(autoPrefixID));
		this.library.addItem(mcItem);
		mcItem.addLayer(new nanofl.engine.movieclip.Layer("auto"));
		mcItem.get_layers()[0].addKeyFrame(new nanofl.engine.movieclip.KeyFrame(null,null,null,elements));
		var r = mcItem.newInstance();
		if(matrix != null) {
			r.matrix = matrix;
		}
		return r;
	}
	,loadEdgeDatas: function(element) {
		var r = [];
		var _g = 0;
		var _g1 = element.find(">edges>Edge");
		while(_g < _g1.length) {
			var edge = _g1[_g];
			++_g;
			var edgeData = new flashimport_EdgeData(edge);
			if((edgeData.fillStyle0 != null || edgeData.fillStyle1 != null || edgeData.strokeStyle != null) && edgeData.drawOps.length > 0) {
				r.push(edgeData);
			}
		}
		return r;
	}
	,loadShapeFill: function(fill) {
		switch(fill.name) {
		case "BitmapFill":
			return { fill : new nanofl.engine.fills.BitmapFill(htmlparser_HtmlParserTools.getAttr(fill,"bitmapPath"),htmlparser_HtmlParserTools.getAttr(fill,"bitmapIsClipped",true) ? "no-repeat" : "repeat",flashimport_MatrixParser.load(htmlparser_HtmlParserTools.findOne(fill,">matrix>Matrix"),20)), matrix : new nanofl.engine.geom.Matrix()};
		case "LinearGradient":
			var gradients = fill.find(">GradientEntry");
			var m = flashimport_MatrixParser.load(htmlparser_HtmlParserTools.findOne(fill,">matrix>Matrix"),0.001220703125);
			var p0 = m.transformPoint(-1,0);
			var p1 = m.transformPoint(1,0);
			var result = new Array(gradients.length);
			var _g = 0;
			var _g1 = gradients.length;
			while(_g < _g1) {
				var i = _g++;
				var g = gradients[i];
				result[i] = nanofl.engine.ColorTools.joinStringAndAlpha(htmlparser_HtmlParserTools.getAttr(g,"color","#000000"),htmlparser_HtmlParserTools.getAttr(g,"alpha",1.0));
			}
			var tmp = result;
			var result = new Array(gradients.length);
			var _g = 0;
			var _g1 = gradients.length;
			while(_g < _g1) {
				var i = _g++;
				result[i] = htmlparser_HtmlParserTools.getAttr(gradients[i],"ratio");
			}
			return { fill : new nanofl.engine.fills.LinearFill(tmp,result,p0.x,p0.y,p1.x,p1.y), matrix : new nanofl.engine.geom.Matrix()};
		case "RadialGradient":
			var focalPointRatio = htmlparser_HtmlParserTools.getAttr(fill,"focalPointRatio",0.0);
			var gradients = fill.find(">GradientEntry");
			var m = flashimport_MatrixParser.load(htmlparser_HtmlParserTools.findOne(fill,">matrix>Matrix"),0.001220703125);
			var p0 = m.transformPoint(0,0);
			var p1 = m.transformPoint(1,0);
			var p2 = m.transformPoint(0,1);
			var k = Math.abs(nanofl.engine.geom.PointTools.getDist(p0.x,p0.y,p2.x,p2.y) - nanofl.engine.geom.PointTools.getDist(p0.x,p0.y,p1.x,p1.y));
			if(k < flashimport_SymbolLoader.EPS) {
				var result = new Array(gradients.length);
				var _g = 0;
				var _g1 = gradients.length;
				while(_g < _g1) {
					var i = _g++;
					var g = gradients[i];
					result[i] = nanofl.engine.ColorTools.joinStringAndAlpha(htmlparser_HtmlParserTools.getAttr(g,"color","#000000"),htmlparser_HtmlParserTools.getAttr(g,"alpha",1.0));
				}
				var tmp = result;
				var result = new Array(gradients.length);
				var _g = 0;
				var _g1 = gradients.length;
				while(_g < _g1) {
					var i = _g++;
					result[i] = htmlparser_HtmlParserTools.getAttr(gradients[i],"ratio");
				}
				return { fill : new nanofl.engine.fills.RadialFill(tmp,result,p0.x,p0.y,nanofl.engine.geom.PointTools.getDist(p0.x,p0.y,p1.x,p1.y),p0.x + (p1.x - p0.x) * focalPointRatio,p0.y + (p1.y - p0.y) * focalPointRatio), matrix : new nanofl.engine.geom.Matrix()};
			} else {
				var result = new Array(gradients.length);
				var _g = 0;
				var _g1 = gradients.length;
				while(_g < _g1) {
					var i = _g++;
					var g = gradients[i];
					result[i] = nanofl.engine.ColorTools.joinStringAndAlpha(htmlparser_HtmlParserTools.getAttr(g,"color","#000000"),htmlparser_HtmlParserTools.getAttr(g,"alpha",1.0));
				}
				var tmp = result;
				var result = new Array(gradients.length);
				var _g = 0;
				var _g1 = gradients.length;
				while(_g < _g1) {
					var i = _g++;
					result[i] = htmlparser_HtmlParserTools.getAttr(gradients[i],"ratio");
				}
				return { fill : new nanofl.engine.fills.RadialFill(tmp,result,0,0,1,focalPointRatio,0), matrix : m};
			}
			break;
		case "SolidColor":
			return { fill : new nanofl.engine.fills.SolidFill(nanofl.engine.ColorTools.joinStringAndAlpha(htmlparser_HtmlParserTools.getAttr(fill,"color","#000000"),htmlparser_HtmlParserTools.getAttr(fill,"alpha",1.0))), matrix : new nanofl.engine.geom.Matrix()};
		default:
			nanofl.engine.Debug.console.warn("Unknow fill type '" + fill.name + "'.");
			return { fill : new nanofl.engine.fills.SolidFill("#FFFFFF"), matrix : new nanofl.engine.geom.Matrix()};
		}
	}
	,loadShapeStroke: function(stroke) {
		var isHairline = htmlparser_HtmlParserTools.getAttr(stroke,"solidStyle") == "hairline";
		var colorElem = htmlparser_HtmlParserTools.findOne(stroke,">fill>SolidColor");
		if(stroke.name == "SolidStroke") {
			return { stroke : new nanofl.engine.strokes.SolidStroke(nanofl.engine.ColorTools.joinStringAndAlpha(htmlparser_HtmlParserTools.getAttr(colorElem,"color","#000000"),htmlparser_HtmlParserTools.getAttr(colorElem,"alpha",1.0)),!isHairline ? htmlparser_HtmlParserTools.getAttr(stroke,"weight",1.0) : 1.0,htmlparser_HtmlParserTools.getAttr(stroke,"caps","round"),htmlparser_HtmlParserTools.getAttr(stroke,"joins","round"),htmlparser_HtmlParserTools.getAttr(stroke,"miterLimit",3.0),isHairline), matrix : new nanofl.engine.geom.Matrix()};
		} else {
			nanofl.engine.Debug.console.warn("Unknow stroke type '" + stroke.name + "'.");
			return { stroke : new nanofl.engine.strokes.SolidStroke("#000000"), matrix : new nanofl.engine.geom.Matrix()};
		}
	}
	,loadRegPoint: function(dest,point) {
		if(point != null) {
			dest.regX = htmlparser_HtmlParserTools.getAttr(point,"x",0);
			dest.regY = htmlparser_HtmlParserTools.getAttr(point,"y",0);
		}
	}
	,loadText: function(text,parentMatrix) {
		var _gthis = this;
		var r = htmlparser_HtmlParserTools.getAttr(text,"name","");
		var r1 = htmlparser_HtmlParserTools.getAttr(text,"width",0.0) + 4.0;
		var r2 = htmlparser_HtmlParserTools.getAttr(text,"height",0.0) + 4.0;
		var r3 = htmlparser_HtmlParserTools.getAttr(text,"isSelectable",true);
		var _this = text.find(">textRuns>DOMTextRun");
		var result = new Array(_this.length);
		var _g = 0;
		var _g1 = _this.length;
		while(_g < _g1) {
			var i = _g++;
			result[i] = _gthis.loadTextRun(_this[i]);
		}
		var r4 = new nanofl.engine.elements.TextElement(r,r1,r2,r3,false,nanofl.TextRun.optimize(result));
		r4.matrix = flashimport_MatrixParser.load(htmlparser_HtmlParserTools.findOne(text,">matrix>Matrix"),1.0,-2 + htmlparser_HtmlParserTools.getAttr(text,"left",0.0),-2).prependMatrix(parentMatrix);
		this.loadRegPoint(r4,htmlparser_HtmlParserTools.findOne(text,">transformationPoint>Point"));
		return r4;
	}
	,loadTextRun: function(textRun) {
		var textAttrs = htmlparser_HtmlParserTools.findOne(textRun,">textAttrs>DOMTextAttrs");
		var face = htmlparser_HtmlParserTools.getAttr(textAttrs,"face");
		if(!Object.prototype.hasOwnProperty.call(this.fontMap.h,face)) {
			var font = this.fontConvertor.convert(face);
			this.fontMap.h[face] = font;
			nanofl.engine.Debug.console.log("FONT MAP: " + face + " -> " + font.face + " / " + (font.style != "" ? font.style : "regular"));
		}
		var font = this.fontMap.h[face];
		return nanofl.TextRun.create(StringTools.replace(stdlib_Utf8.htmlUnescape(htmlparser_HtmlParserTools.findOne(textRun,">characters").get_innerHTML()),"\r","\n"),htmlparser_HtmlParserTools.getAttr(textAttrs,"fillColor","#000000"),font.face,font.style,htmlparser_HtmlParserTools.getAttrFloat(textAttrs,"size",12.0),htmlparser_HtmlParserTools.getAttr(textAttrs,"alignment","left"),0,"#000000",htmlparser_HtmlParserTools.getAttrBool(textAttrs,"autoKern",false),htmlparser_HtmlParserTools.getAttrFloat(textAttrs,"letterSpacing",0),htmlparser_HtmlParserTools.getAttrFloat(textAttrs,"lineSpacing",2));
	}
	,loadColorEffect: function(color) {
		if(color == null) {
			return null;
		}
		if(color.hasAttribute("brightness")) {
			return new nanofl.engine.coloreffects.ColorEffectBrightness(htmlparser_HtmlParserTools.getAttr(color,"brightness",1.0));
		}
		if(color.hasAttribute("tintMultiplier")) {
			return new nanofl.engine.coloreffects.ColorEffectTint(htmlparser_HtmlParserTools.getAttr(color,"tintColor"),htmlparser_HtmlParserTools.getAttr(color,"tintMultiplier",1.0));
		}
		var props = ["alphaMultiplier","redMultiplier","greenMultiplier","blueMultiplier","alphaOffset","redOffset","greenOffset","blueOffset"];
		var propCount = stdlib_LambdaIterator.count(new haxe_ds__$StringMap_StringMapKeyIterator(color.getAttributesAssoc().h),function(s) {
			return Lambda.has(props,s);
		});
		if(color.hasAttribute("alphaMultiplier") && propCount == 1) {
			return new nanofl.engine.coloreffects.ColorEffectAlpha(htmlparser_HtmlParserTools.getAttr(color,"alphaMultiplier",1.0));
		} else if(propCount > 0) {
			return new nanofl.engine.coloreffects.ColorEffectAdvanced(htmlparser_HtmlParserTools.getAttr(color,"alphaMultiplier",1.0),htmlparser_HtmlParserTools.getAttr(color,"redMultiplier",1.0),htmlparser_HtmlParserTools.getAttr(color,"greenMultiplier",1.0),htmlparser_HtmlParserTools.getAttr(color,"blueMultiplier",1.0),htmlparser_HtmlParserTools.getAttr(color,"alphaOffset",0.0),htmlparser_HtmlParserTools.getAttr(color,"redOffset",0.0),htmlparser_HtmlParserTools.getAttr(color,"greenOffset",0.0),htmlparser_HtmlParserTools.getAttr(color,"blueOffset",0.0));
		}
		return null;
	}
	,loadFilter: function(filter) {
		if(filter == null) {
			return null;
		}
		var params = filter.getAttributesObject();
		this.fixFilterParamFloat(params,"strength",100,function(k) {
			return Math.round(k * 100);
		});
		this.fixFilterParamFloat(params,"blurX",10,function(k) {
			return k * 2;
		});
		this.fixFilterParamFloat(params,"blurY",10,function(k) {
			return k * 2;
		});
		filter.name = filter.name == "BlurFilter" ? "BoxBlurFilter" : filter.name;
		return new nanofl.engine.FilterDef(filter.name,params);
	}
	,parseMotionTweenRotate: function(motionTweenRotate,motionTweenRotateTimes) {
		switch(motionTweenRotate) {
		case "clockwise":
			return motionTweenRotateTimes;
		case "counter-clockwise":
			return -motionTweenRotateTimes;
		default:
			return 0;
		}
	}
	,loadLinkage: function(item,node) {
		if(htmlparser_HtmlParserTools.getAttr(node,"linkageExportForAS",false)) {
			item.linkedClass = htmlparser_HtmlParserTools.getAttr(node,"linkageClassName","");
			var linkageIdentifier = htmlparser_HtmlParserTools.getAttr(node,"linkageIdentifier","");
			if(linkageIdentifier != "") {
				nanofl.engine.Debug.console.warn("Linkage identifier is not supported (symbol '" + item.namePath + "')");
				if(item.linkedClass == "") {
					item.linkedClass = linkageIdentifier;
				}
			}
		}
	}
	,fixFilterParamFloat: function(params,name,defValue,f) {
		params[name] = Object.prototype.hasOwnProperty.call(params,name) ? f(stdlib_Std.parseFloat(Reflect.field(params,name))) : defValue;
	}
	,generateNewID: function(autoPrefixID) {
		if(autoPrefixID == null) {
			autoPrefixID = "auto";
		}
		var i = 1;
		while(true) {
			var r = autoPrefixID + "_" + i;
			if(!this.library.hasItem(r) && this.generatedAutoIDs.indexOf(r) < 0) {
				this.generatedAutoIDs.push(r);
				return r;
			}
			++i;
		}
	}
	,__class__: flashimport_SymbolLoader
};
var haxe_StackItem = $hxEnums["haxe.StackItem"] = { __ename__:"haxe.StackItem",__constructs__:null
	,CFunction: {_hx_name:"CFunction",_hx_index:0,__enum__:"haxe.StackItem",toString:$estr}
	,Module: ($_=function(m) { return {_hx_index:1,m:m,__enum__:"haxe.StackItem",toString:$estr}; },$_._hx_name="Module",$_.__params__ = ["m"],$_)
	,FilePos: ($_=function(s,file,line,column) { return {_hx_index:2,s:s,file:file,line:line,column:column,__enum__:"haxe.StackItem",toString:$estr}; },$_._hx_name="FilePos",$_.__params__ = ["s","file","line","column"],$_)
	,Method: ($_=function(classname,method) { return {_hx_index:3,classname:classname,method:method,__enum__:"haxe.StackItem",toString:$estr}; },$_._hx_name="Method",$_.__params__ = ["classname","method"],$_)
	,LocalFunction: ($_=function(v) { return {_hx_index:4,v:v,__enum__:"haxe.StackItem",toString:$estr}; },$_._hx_name="LocalFunction",$_.__params__ = ["v"],$_)
};
haxe_StackItem.__constructs__ = [haxe_StackItem.CFunction,haxe_StackItem.Module,haxe_StackItem.FilePos,haxe_StackItem.Method,haxe_StackItem.LocalFunction];
var haxe_CallStack = {};
haxe_CallStack.callStack = function() {
	return haxe_NativeStackTrace.toHaxe(haxe_NativeStackTrace.callStack());
};
haxe_CallStack.toString = function(stack) {
	var b = new StringBuf();
	var _g = 0;
	var _g1 = stack;
	while(_g < _g1.length) {
		var s = _g1[_g];
		++_g;
		b.b += "\nCalled from ";
		haxe_CallStack.itemToString(b,s);
	}
	return b.b;
};
haxe_CallStack.itemToString = function(b,s) {
	switch(s._hx_index) {
	case 0:
		b.b += "a C function";
		break;
	case 1:
		var m = s.m;
		b.b += "module ";
		b.b += m == null ? "null" : "" + m;
		break;
	case 2:
		var s1 = s.s;
		var file = s.file;
		var line = s.line;
		var col = s.column;
		if(s1 != null) {
			haxe_CallStack.itemToString(b,s1);
			b.b += " (";
		}
		b.b += file == null ? "null" : "" + file;
		b.b += " line ";
		b.b += line == null ? "null" : "" + line;
		if(col != null) {
			b.b += " column ";
			b.b += col == null ? "null" : "" + col;
		}
		if(s1 != null) {
			b.b += ")";
		}
		break;
	case 3:
		var cname = s.classname;
		var meth = s.method;
		b.b += Std.string(cname == null ? "<unknown>" : cname);
		b.b += ".";
		b.b += meth == null ? "null" : "" + meth;
		break;
	case 4:
		var n = s.v;
		b.b += "local function #";
		b.b += n == null ? "null" : "" + n;
		break;
	}
};
var haxe_IMap = function() { };
haxe_IMap.__name__ = "haxe.IMap";
haxe_IMap.__isInterface__ = true;
var haxe_Exception = function(message,previous,native) {
	Error.call(this,message);
	this.message = message;
	this.__previousException = previous;
	this.__nativeException = native != null ? native : this;
};
haxe_Exception.__name__ = "haxe.Exception";
haxe_Exception.thrown = function(value) {
	if(((value) instanceof haxe_Exception)) {
		return value.get_native();
	} else if(((value) instanceof Error)) {
		return value;
	} else {
		var e = new haxe_ValueException(value);
		return e;
	}
};
haxe_Exception.__super__ = Error;
haxe_Exception.prototype = $extend(Error.prototype,{
	toString: function() {
		return this.get_message();
	}
	,get_message: function() {
		return this.message;
	}
	,get_native: function() {
		return this.__nativeException;
	}
	,__class__: haxe_Exception
});
var haxe_Log = function() { };
haxe_Log.__name__ = "haxe.Log";
haxe_Log.formatOutput = function(v,infos) {
	var str = Std.string(v);
	if(infos == null) {
		return str;
	}
	var pstr = infos.fileName + ":" + infos.lineNumber;
	if(infos.customParams != null) {
		var _g = 0;
		var _g1 = infos.customParams;
		while(_g < _g1.length) {
			var v = _g1[_g];
			++_g;
			str += ", " + Std.string(v);
		}
	}
	return pstr + ": " + str;
};
haxe_Log.trace = function(v,infos) {
	var str = haxe_Log.formatOutput(v,infos);
	if(typeof(console) != "undefined" && console.log != null) {
		console.log(str);
	}
};
var haxe_NativeStackTrace = function() { };
haxe_NativeStackTrace.__name__ = "haxe.NativeStackTrace";
haxe_NativeStackTrace.callStack = function() {
	var e = new Error("");
	var stack = haxe_NativeStackTrace.tryHaxeStack(e);
	if(typeof(stack) == "undefined") {
		try {
			throw e;
		} catch( _g ) {
		}
		stack = e.stack;
	}
	return haxe_NativeStackTrace.normalize(stack,2);
};
haxe_NativeStackTrace.toHaxe = function(s,skip) {
	if(skip == null) {
		skip = 0;
	}
	if(s == null) {
		return [];
	} else if(typeof(s) == "string") {
		var stack = s.split("\n");
		if(stack[0] == "Error") {
			stack.shift();
		}
		var m = [];
		var _g = 0;
		var _g1 = stack.length;
		while(_g < _g1) {
			var i = _g++;
			if(skip > i) {
				continue;
			}
			var line = stack[i];
			var matched = line.match(/^    at ([$A-Za-z0-9_. ]+) \(([^)]+):([0-9]+):([0-9]+)\)$/);
			if(matched != null) {
				var path = matched[1].split(".");
				if(path[0] == "$hxClasses") {
					path.shift();
				}
				var meth = path.pop();
				var file = matched[2];
				var line1 = Std.parseInt(matched[3]);
				var column = Std.parseInt(matched[4]);
				m.push(haxe_StackItem.FilePos(meth == "Anonymous function" ? haxe_StackItem.LocalFunction() : meth == "Global code" ? null : haxe_StackItem.Method(path.join("."),meth),file,line1,column));
			} else {
				m.push(haxe_StackItem.Module(StringTools.trim(line)));
			}
		}
		return m;
	} else if(skip > 0 && Array.isArray(s)) {
		return s.slice(skip);
	} else {
		return s;
	}
};
haxe_NativeStackTrace.tryHaxeStack = function(e) {
	if(e == null) {
		return [];
	}
	var oldValue = Error.prepareStackTrace;
	Error.prepareStackTrace = haxe_NativeStackTrace.prepareHxStackTrace;
	var stack = e.stack;
	Error.prepareStackTrace = oldValue;
	return stack;
};
haxe_NativeStackTrace.prepareHxStackTrace = function(e,callsites) {
	var stack = [];
	var _g = 0;
	while(_g < callsites.length) {
		var site = callsites[_g];
		++_g;
		if(haxe_NativeStackTrace.wrapCallSite != null) {
			site = haxe_NativeStackTrace.wrapCallSite(site);
		}
		var method = null;
		var fullName = site.getFunctionName();
		if(fullName != null) {
			var idx = fullName.lastIndexOf(".");
			if(idx >= 0) {
				var className = fullName.substring(0,idx);
				var methodName = fullName.substring(idx + 1);
				method = haxe_StackItem.Method(className,methodName);
			} else {
				method = haxe_StackItem.Method(null,fullName);
			}
		}
		var fileName = site.getFileName();
		var fileAddr = fileName == null ? -1 : fileName.indexOf("file:");
		if(haxe_NativeStackTrace.wrapCallSite != null && fileAddr > 0) {
			fileName = fileName.substring(fileAddr + 6);
		}
		stack.push(haxe_StackItem.FilePos(method,fileName,site.getLineNumber(),site.getColumnNumber()));
	}
	return stack;
};
haxe_NativeStackTrace.normalize = function(stack,skipItems) {
	if(skipItems == null) {
		skipItems = 0;
	}
	if(Array.isArray(stack) && skipItems > 0) {
		return stack.slice(skipItems);
	} else if(typeof(stack) == "string") {
		switch(stack.substring(0,6)) {
		case "Error\n":case "Error:":
			++skipItems;
			break;
		default:
		}
		return haxe_NativeStackTrace.skipLines(stack,skipItems);
	} else {
		return stack;
	}
};
haxe_NativeStackTrace.skipLines = function(stack,skip,pos) {
	if(pos == null) {
		pos = 0;
	}
	if(skip > 0) {
		pos = stack.indexOf("\n",pos);
		if(pos < 0) {
			return "";
		} else {
			return haxe_NativeStackTrace.skipLines(stack,--skip,pos + 1);
		}
	} else {
		return stack.substring(pos);
	}
};
var haxe_Timer = function(time_ms) {
	var me = this;
	this.id = setInterval(function() {
		me.run();
	},time_ms);
};
haxe_Timer.__name__ = "haxe.Timer";
haxe_Timer.delay = function(f,time_ms) {
	var t = new haxe_Timer(time_ms);
	t.run = function() {
		t.stop();
		f();
	};
	return t;
};
haxe_Timer.prototype = {
	stop: function() {
		if(this.id == null) {
			return;
		}
		clearInterval(this.id);
		this.id = null;
	}
	,run: function() {
	}
	,__class__: haxe_Timer
};
var haxe_Utf8 = function(size) {
	this.__b = "";
};
haxe_Utf8.__name__ = "haxe.Utf8";
haxe_Utf8.iter = function(s,chars) {
	var _g = 0;
	var _g1 = s.length;
	while(_g < _g1) {
		var i = _g++;
		chars(HxOverrides.cca(s,i));
	}
};
haxe_Utf8.encode = function(s) {
	throw new haxe_exceptions_NotImplementedException(null,null,{ fileName : "haxe/Utf8.hx", lineNumber : 66, className : "haxe.Utf8", methodName : "encode"});
};
haxe_Utf8.decode = function(s) {
	throw new haxe_exceptions_NotImplementedException(null,null,{ fileName : "haxe/Utf8.hx", lineNumber : 74, className : "haxe.Utf8", methodName : "decode"});
};
haxe_Utf8.compare = function(a,b) {
	if(a > b) {
		return 1;
	} else if(a == b) {
		return 0;
	} else {
		return -1;
	}
};
haxe_Utf8.prototype = {
	__class__: haxe_Utf8
};
var haxe_ValueException = function(value,previous,native) {
	haxe_Exception.call(this,String(value),previous,native);
	this.value = value;
};
haxe_ValueException.__name__ = "haxe.ValueException";
haxe_ValueException.__super__ = haxe_Exception;
haxe_ValueException.prototype = $extend(haxe_Exception.prototype,{
	__class__: haxe_ValueException
});
var haxe_ds_IntMap = function() {
	this.h = { };
};
haxe_ds_IntMap.__name__ = "haxe.ds.IntMap";
haxe_ds_IntMap.__interfaces__ = [haxe_IMap];
haxe_ds_IntMap.prototype = {
	__class__: haxe_ds_IntMap
};
var haxe_ds_List = function() {
	this.length = 0;
};
haxe_ds_List.__name__ = "haxe.ds.List";
haxe_ds_List.prototype = {
	__class__: haxe_ds_List
};
var haxe_ds__$List_ListNode = function(item,next) {
	this.item = item;
	this.next = next;
};
haxe_ds__$List_ListNode.__name__ = "haxe.ds._List.ListNode";
haxe_ds__$List_ListNode.prototype = {
	__class__: haxe_ds__$List_ListNode
};
var haxe_ds_ObjectMap = function() {
	this.h = { __keys__ : { }};
};
haxe_ds_ObjectMap.__name__ = "haxe.ds.ObjectMap";
haxe_ds_ObjectMap.__interfaces__ = [haxe_IMap];
haxe_ds_ObjectMap.prototype = {
	set: function(key,value) {
		var id = key.__id__;
		if(id == null) {
			id = (key.__id__ = $global.$haxeUID++);
		}
		this.h[id] = value;
		this.h.__keys__[id] = key;
	}
	,__class__: haxe_ds_ObjectMap
};
var haxe_ds_StringMap = function() {
	this.h = Object.create(null);
};
haxe_ds_StringMap.__name__ = "haxe.ds.StringMap";
haxe_ds_StringMap.__interfaces__ = [haxe_IMap];
haxe_ds_StringMap.prototype = {
	__class__: haxe_ds_StringMap
};
var haxe_ds__$StringMap_StringMapKeyIterator = function(h) {
	this.h = h;
	this.keys = Object.keys(h);
	this.length = this.keys.length;
	this.current = 0;
};
haxe_ds__$StringMap_StringMapKeyIterator.__name__ = "haxe.ds._StringMap.StringMapKeyIterator";
haxe_ds__$StringMap_StringMapKeyIterator.prototype = {
	hasNext: function() {
		return this.current < this.length;
	}
	,next: function() {
		return this.keys[this.current++];
	}
	,__class__: haxe_ds__$StringMap_StringMapKeyIterator
};
var haxe_exceptions_PosException = function(message,previous,pos) {
	haxe_Exception.call(this,message,previous);
	if(pos == null) {
		this.posInfos = { fileName : "(unknown)", lineNumber : 0, className : "(unknown)", methodName : "(unknown)"};
	} else {
		this.posInfos = pos;
	}
};
haxe_exceptions_PosException.__name__ = "haxe.exceptions.PosException";
haxe_exceptions_PosException.__super__ = haxe_Exception;
haxe_exceptions_PosException.prototype = $extend(haxe_Exception.prototype,{
	toString: function() {
		return "" + haxe_Exception.prototype.toString.call(this) + " in " + this.posInfos.className + "." + this.posInfos.methodName + " at " + this.posInfos.fileName + ":" + this.posInfos.lineNumber;
	}
	,__class__: haxe_exceptions_PosException
});
var haxe_exceptions_NotImplementedException = function(message,previous,pos) {
	if(message == null) {
		message = "Not implemented";
	}
	haxe_exceptions_PosException.call(this,message,previous,pos);
};
haxe_exceptions_NotImplementedException.__name__ = "haxe.exceptions.NotImplementedException";
haxe_exceptions_NotImplementedException.__super__ = haxe_exceptions_PosException;
haxe_exceptions_NotImplementedException.prototype = $extend(haxe_exceptions_PosException.prototype,{
	__class__: haxe_exceptions_NotImplementedException
});
var haxe_io_Bytes = function() { };
haxe_io_Bytes.__name__ = "haxe.io.Bytes";
var haxe_io_Path = function(path) {
	switch(path) {
	case ".":case "..":
		this.dir = path;
		this.file = "";
		return;
	}
	var c1 = path.lastIndexOf("/");
	var c2 = path.lastIndexOf("\\");
	if(c1 < c2) {
		this.dir = HxOverrides.substr(path,0,c2);
		path = HxOverrides.substr(path,c2 + 1,null);
		this.backslash = true;
	} else if(c2 < c1) {
		this.dir = HxOverrides.substr(path,0,c1);
		path = HxOverrides.substr(path,c1 + 1,null);
	} else {
		this.dir = null;
	}
	var cp = path.lastIndexOf(".");
	if(cp != -1) {
		this.ext = HxOverrides.substr(path,cp + 1,null);
		this.file = HxOverrides.substr(path,0,cp);
	} else {
		this.ext = null;
		this.file = path;
	}
};
haxe_io_Path.__name__ = "haxe.io.Path";
haxe_io_Path.withoutExtension = function(path) {
	var s = new haxe_io_Path(path);
	s.ext = null;
	return s.toString();
};
haxe_io_Path.withoutDirectory = function(path) {
	var s = new haxe_io_Path(path);
	s.dir = null;
	return s.toString();
};
haxe_io_Path.directory = function(path) {
	var s = new haxe_io_Path(path);
	if(s.dir == null) {
		return "";
	}
	return s.dir;
};
haxe_io_Path.extension = function(path) {
	var s = new haxe_io_Path(path);
	if(s.ext == null) {
		return "";
	}
	return s.ext;
};
haxe_io_Path.join = function(paths) {
	var _g = [];
	var _g1 = 0;
	var _g2 = paths;
	while(_g1 < _g2.length) {
		var v = _g2[_g1];
		++_g1;
		if(v != null && v != "") {
			_g.push(v);
		}
	}
	var paths = _g;
	if(paths.length == 0) {
		return "";
	}
	var path = paths[0];
	var _g = 1;
	var _g1 = paths.length;
	while(_g < _g1) {
		var i = _g++;
		path = haxe_io_Path.addTrailingSlash(path);
		path += paths[i];
	}
	return haxe_io_Path.normalize(path);
};
haxe_io_Path.normalize = function(path) {
	var slash = "/";
	path = path.split("\\").join(slash);
	if(path == slash) {
		return slash;
	}
	var target = [];
	var _g = 0;
	var _g1 = path.split(slash);
	while(_g < _g1.length) {
		var token = _g1[_g];
		++_g;
		if(token == ".." && target.length > 0 && target[target.length - 1] != "..") {
			target.pop();
		} else if(token == "") {
			if(target.length > 0 || HxOverrides.cca(path,0) == 47) {
				target.push(token);
			}
		} else if(token != ".") {
			target.push(token);
		}
	}
	var tmp = target.join(slash);
	var acc_b = "";
	var colon = false;
	var slashes = false;
	var _g_offset = 0;
	var _g_s = tmp;
	while(_g_offset < _g_s.length) {
		var s = _g_s;
		var index = _g_offset++;
		var c = s.charCodeAt(index);
		if(c >= 55296 && c <= 56319) {
			c = c - 55232 << 10 | s.charCodeAt(index + 1) & 1023;
		}
		var c1 = c;
		if(c1 >= 65536) {
			++_g_offset;
		}
		var c2 = c1;
		switch(c2) {
		case 47:
			if(!colon) {
				slashes = true;
			} else {
				var i = c2;
				colon = false;
				if(slashes) {
					acc_b += "/";
					slashes = false;
				}
				acc_b += String.fromCodePoint(i);
			}
			break;
		case 58:
			acc_b += ":";
			colon = true;
			break;
		default:
			var i1 = c2;
			colon = false;
			if(slashes) {
				acc_b += "/";
				slashes = false;
			}
			acc_b += String.fromCodePoint(i1);
		}
	}
	return acc_b;
};
haxe_io_Path.addTrailingSlash = function(path) {
	if(path.length == 0) {
		return "/";
	}
	var c1 = path.lastIndexOf("/");
	var c2 = path.lastIndexOf("\\");
	if(c1 < c2) {
		if(c2 != path.length - 1) {
			return path + "\\";
		} else {
			return path;
		}
	} else if(c1 != path.length - 1) {
		return path + "/";
	} else {
		return path;
	}
};
haxe_io_Path.prototype = {
	toString: function() {
		return (this.dir == null ? "" : this.dir + (this.backslash ? "\\" : "/")) + this.file + (this.ext == null ? "" : "." + this.ext);
	}
	,__class__: haxe_io_Path
};
var haxe_iterators_ArrayIterator = function(array) {
	this.current = 0;
	this.array = array;
};
haxe_iterators_ArrayIterator.__name__ = "haxe.iterators.ArrayIterator";
haxe_iterators_ArrayIterator.prototype = {
	hasNext: function() {
		return this.current < this.array.length;
	}
	,next: function() {
		return this.array[this.current++];
	}
	,__class__: haxe_iterators_ArrayIterator
};
var haxe_iterators_StringIterator = function(s) {
	this.s = s;
};
haxe_iterators_StringIterator.__name__ = "haxe.iterators.StringIterator";
haxe_iterators_StringIterator.prototype = {
	__class__: haxe_iterators_StringIterator
};
var haxe_iterators_StringKeyValueIterator = function(s) {
	this.s = s;
};
haxe_iterators_StringKeyValueIterator.__name__ = "haxe.iterators.StringKeyValueIterator";
haxe_iterators_StringKeyValueIterator.prototype = {
	__class__: haxe_iterators_StringKeyValueIterator
};
var htmlparser_CssSelector = function(type) {
	this.classes = [];
	this.type = type;
};
htmlparser_CssSelector.__name__ = "htmlparser.CssSelector";
htmlparser_CssSelector.parse = function(selector) {
	var r = [];
	var selectors = new EReg("\\s*,\\s*","g").split(selector);
	var _g = 0;
	while(_g < selectors.length) {
		var s = selectors[_g];
		++_g;
		if(s != "") {
			r.push(htmlparser_CssSelector.parseInner(s));
		}
	}
	return r;
};
htmlparser_CssSelector.parseInner = function(selector) {
	var rr = [];
	selector = " " + selector;
	var r = null;
	var re = new EReg(htmlparser_CssSelector.reSelector,"gi");
	var pos = 0;
	while(re.matchSub(selector,pos)) {
		var type1;
		try {
			type1 = re.matched(1);
		} catch( _g ) {
			type1 = null;
		}
		if(type1 == null) {
			type1 = "";
		}
		var type2;
		try {
			type2 = re.matched(2);
		} catch( _g1 ) {
			type2 = null;
		}
		if(type2 == null) {
			type2 = "";
		}
		if(type1.length > 0 || type2.length > 0) {
			if(r != null) {
				rr.push(r);
			}
			r = new htmlparser_CssSelector(type2.length > 0 ? ">" : " ");
		}
		var name = re.matched(4);
		if(name != "*") {
			var s = re.matched(3);
			if(s == "#") {
				r.id = name;
			} else if(s == ".") {
				r.classes.push(name);
			} else {
				r.tagNameLC = name.toLowerCase();
			}
			var sIndex;
			try {
				sIndex = re.matched(5);
			} catch( _g2 ) {
				sIndex = null;
			}
			if(sIndex != null && sIndex != "") {
				r.index = Std.parseInt(sIndex.substring(1,sIndex.length - 1));
				var f = r.index;
				if(isNaN(f)) {
					r.index = null;
				}
			}
		}
		var p = re.matchedPos();
		pos = p.pos + p.len;
	}
	if(r != null) {
		rr.push(r);
	}
	return rr;
};
htmlparser_CssSelector.getMatched = function(re,n) {
	try {
		return re.matched(n);
	} catch( _g ) {
		return null;
	}
};
htmlparser_CssSelector.prototype = {
	__class__: htmlparser_CssSelector
};
var htmlparser_HtmlAttribute = function(name,value,quote) {
	this.name = name;
	this.value = value;
	this.quote = quote;
};
htmlparser_HtmlAttribute.__name__ = "htmlparser.HtmlAttribute";
htmlparser_HtmlAttribute.prototype = {
	toString: function() {
		if(this.value != null && this.quote != null) {
			return this.name + "=" + this.quote + htmlparser_HtmlTools.escape(this.value,"\r\n" + (this.quote == "'" ? "\"" : "'")) + this.quote;
		} else {
			return this.name;
		}
	}
	,__class__: htmlparser_HtmlAttribute
};
var htmlparser_HtmlNode = function() { };
htmlparser_HtmlNode.__name__ = "htmlparser.HtmlNode";
htmlparser_HtmlNode.prototype = {
	remove: function() {
		if(this.parent != null) {
			this.parent.removeChild(this);
		}
	}
	,getPrevSiblingNode: function() {
		if(this.parent == null) {
			return null;
		}
		var siblings = this.parent.nodes;
		var n = Lambda.indexOf(siblings,this);
		if(n <= 0) {
			return null;
		}
		if(n > 0) {
			return siblings[n - 1];
		}
		return null;
	}
	,getNextSiblingNode: function() {
		if(this.parent == null) {
			return null;
		}
		var siblings = this.parent.nodes;
		var n = Lambda.indexOf(siblings,this);
		if(n < 0) {
			return null;
		}
		if(n + 1 < siblings.length) {
			return siblings[n + 1];
		}
		return null;
	}
	,toString: function() {
		return "";
	}
	,toText: function() {
		return "";
	}
	,hxSerialize: function(s) {
	}
	,hxUnserialize: function(s) {
	}
	,__class__: htmlparser_HtmlNode
};
var htmlparser_HtmlNodeElement = function(name,attributes) {
	this.name = name;
	this.attributes = attributes;
	this.nodes = [];
	this.children = [];
};
htmlparser_HtmlNodeElement.__name__ = "htmlparser.HtmlNodeElement";
htmlparser_HtmlNodeElement.__super__ = htmlparser_HtmlNode;
htmlparser_HtmlNodeElement.prototype = $extend(htmlparser_HtmlNode.prototype,{
	getPrevSiblingElement: function() {
		if(this.parent == null) {
			return null;
		}
		var n = this.parent.children.indexOf(this);
		if(n < 0) {
			return null;
		}
		if(n > 0) {
			return this.parent.children[n - 1];
		}
		return null;
	}
	,getNextSiblingElement: function() {
		if(this.parent == null) {
			return null;
		}
		var n = this.parent.children.indexOf(this);
		if(n < 0) {
			return null;
		}
		if(n + 1 < this.parent.children.length) {
			return this.parent.children[n + 1];
		}
		return null;
	}
	,addChild: function(node,beforeNode) {
		if(beforeNode == null) {
			this.nodes.push(node);
			node.parent = this;
			if(((node) instanceof htmlparser_HtmlNodeElement)) {
				this.children.push(node);
			}
		} else {
			var n = this.nodes.indexOf(beforeNode);
			if(n < 0) {
				throw new haxe_Exception("`beforeNode` is not found.");
			}
			this.nodes.splice(n,0,node);
			node.parent = this;
			var _g = [];
			var _g1 = 0;
			var _g2 = this.nodes;
			while(_g1 < _g2.length) {
				var v = _g2[_g1];
				++_g1;
				if(((v) instanceof htmlparser_HtmlNodeElement)) {
					_g.push(v);
				}
			}
			this.children = _g;
		}
	}
	,addChildren: function(nodesToAdd,beforeNode) {
		var n = beforeNode != null ? this.nodes.indexOf(beforeNode) : 0;
		if(n < 0) {
			throw new haxe_Exception("`beforeNode` is not found.");
		}
		this.nodes = (n > 0 ? this.nodes.slice(0,n) : []).concat(nodesToAdd).concat(this.nodes.slice(n));
		var _g = 0;
		while(_g < nodesToAdd.length) {
			var node = nodesToAdd[_g];
			++_g;
			node.parent = this;
		}
		var _g = [];
		var _g1 = 0;
		var _g2 = this.nodes;
		while(_g1 < _g2.length) {
			var v = _g2[_g1];
			++_g1;
			if(((v) instanceof htmlparser_HtmlNodeElement)) {
				_g.push(v);
			}
		}
		this.children = _g;
	}
	,toString: function() {
		var sAttrs_b = "";
		var _g = 0;
		var _g1 = this.attributes;
		while(_g < _g1.length) {
			var a = _g1[_g];
			++_g;
			sAttrs_b += " ";
			sAttrs_b += Std.string(a.toString());
		}
		var innerBuf_b = "";
		var _g = 0;
		var _g1 = this.nodes;
		while(_g < _g1.length) {
			var node = _g1[_g];
			++_g;
			innerBuf_b += Std.string(node.toString());
		}
		var inner = innerBuf_b;
		if(inner == "" && this.isSelfClosing()) {
			return "<" + this.name + sAttrs_b + " />";
		}
		if(this.name != null && this.name != "") {
			return "<" + this.name + sAttrs_b + ">" + inner + "</" + this.name + ">";
		} else {
			return inner;
		}
	}
	,getAttribute: function(name) {
		var nameLC = name.toLowerCase();
		var _g = 0;
		var _g1 = this.attributes;
		while(_g < _g1.length) {
			var a = _g1[_g];
			++_g;
			if(a.name.toLowerCase() == nameLC) {
				return a.value;
			}
		}
		return null;
	}
	,setAttribute: function(name,value) {
		var nameLC = name.toLowerCase();
		var _g = 0;
		var _g1 = this.attributes;
		while(_g < _g1.length) {
			var a = _g1[_g];
			++_g;
			if(a.name.toLowerCase() == nameLC) {
				a.value = value;
				return;
			}
		}
		this.attributes.push(new htmlparser_HtmlAttribute(name,value,"\""));
	}
	,removeAttribute: function(name) {
		var nameLC = name.toLowerCase();
		var _g = 0;
		var _g1 = this.attributes.length;
		while(_g < _g1) {
			var i = _g++;
			var a = this.attributes[i];
			if(a.name.toLowerCase() == nameLC) {
				this.attributes.splice(i,1);
				return;
			}
		}
	}
	,hasAttribute: function(name) {
		var nameLC = name.toLowerCase();
		var _g = 0;
		var _g1 = this.attributes;
		while(_g < _g1.length) {
			var a = _g1[_g];
			++_g;
			if(a.name.toLowerCase() == nameLC) {
				return true;
			}
		}
		return false;
	}
	,get_innerHTML: function() {
		var r_b = "";
		var _g = 0;
		var _g1 = this.nodes;
		while(_g < _g1.length) {
			var node = _g1[_g];
			++_g;
			r_b += Std.string(node.toString());
		}
		return r_b;
	}
	,set_innerHTML: function(value) {
		var newNodes = htmlparser_HtmlParser.run(value);
		this.nodes = [];
		this.children = [];
		var _g = 0;
		while(_g < newNodes.length) {
			var node = newNodes[_g];
			++_g;
			this.addChild(node);
		}
		return value;
	}
	,get_innerText: function() {
		return this.toText();
	}
	,set_innerText: function(text) {
		this.fastSetInnerHTML(htmlparser_HtmlTools.escape(text));
		return text;
	}
	,fastSetInnerHTML: function(html) {
		this.nodes = [];
		this.children = [];
		this.addChild(new htmlparser_HtmlNodeText(html));
	}
	,toText: function() {
		var r_b = "";
		var _g = 0;
		var _g1 = this.nodes;
		while(_g < _g1.length) {
			var node = _g1[_g];
			++_g;
			r_b += Std.string(node.toText());
		}
		return r_b;
	}
	,find: function(selector) {
		var parsedSelectors = htmlparser_CssSelector.parse(selector);
		var resNodes = [];
		var _g = 0;
		while(_g < parsedSelectors.length) {
			var s = parsedSelectors[_g];
			++_g;
			var _g1 = 0;
			var _g2 = this.children;
			while(_g1 < _g2.length) {
				var node = _g2[_g1];
				++_g1;
				var nodesToAdd = node.findInner(s);
				var _g3 = 0;
				while(_g3 < nodesToAdd.length) {
					var nodeToAdd = nodesToAdd[_g3];
					++_g3;
					if(resNodes.indexOf(nodeToAdd) < 0) {
						resNodes.push(nodeToAdd);
					}
				}
			}
		}
		return resNodes;
	}
	,findInner: function(selectors) {
		if(selectors.length == 0) {
			return [];
		}
		var nodes = [];
		if(selectors[0].type == " ") {
			var _g = 0;
			var _g1 = this.children;
			while(_g < _g1.length) {
				var child = _g1[_g];
				++_g;
				nodes = nodes.concat(child.findInner(selectors));
			}
		}
		if(this.isSelectorTrue(selectors[0])) {
			if(selectors.length > 1) {
				var subSelectors = selectors.slice(1);
				var _g = 0;
				var _g1 = this.children;
				while(_g < _g1.length) {
					var child = _g1[_g];
					++_g;
					nodes = nodes.concat(child.findInner(subSelectors));
				}
			} else if(selectors.length == 1) {
				if(this.parent != null) {
					nodes.push(this);
				}
			}
		}
		return nodes;
	}
	,isSelectorTrue: function(selector) {
		if(selector.tagNameLC != null && this.name.toLowerCase() != selector.tagNameLC) {
			return false;
		}
		if(selector.id != null && this.getAttribute("id") != selector.id) {
			return false;
		}
		var _g = 0;
		var _g1 = selector.classes;
		while(_g < _g1.length) {
			var clas = _g1[_g];
			++_g;
			var reg = new EReg("(?:^|\\s)" + clas + "(?:$|\\s)","");
			var classAttr = this.getAttribute("class");
			if(classAttr == null || !reg.match(classAttr)) {
				return false;
			}
		}
		if(selector.index != null && (this.parent == null || this.parent.children.indexOf(this) + 1 != selector.index)) {
			return false;
		}
		return true;
	}
	,replaceChild: function(node,newNode) {
		if(((newNode) instanceof Array)) {
			this.replaceChildByMany(node,newNode);
		} else {
			this.replaceChildByOne(node,newNode);
		}
	}
	,replaceChildByOne: function(node,newNode) {
		var n = this.nodes.indexOf(node);
		if(n < 0) {
			throw new haxe_Exception("Node to replace is not found.");
		}
		this.nodes[n].parent = null;
		this.nodes[n] = newNode;
		newNode.parent = this;
		var _g = [];
		var _g1 = 0;
		var _g2 = this.nodes;
		while(_g1 < _g2.length) {
			var v = _g2[_g1];
			++_g1;
			if(((v) instanceof htmlparser_HtmlNodeElement)) {
				_g.push(v);
			}
		}
		this.children = _g;
	}
	,replaceChildByMany: function(node,newNodes) {
		var n = this.nodes.indexOf(node);
		if(n < 0) {
			throw new haxe_Exception("Node to replace is not found.");
		}
		this.nodes[n].parent = null;
		var lastNodes = this.nodes.slice(n + 1,this.nodes.length);
		this.nodes = (n > 0 ? this.nodes.slice(0,n) : []).concat(newNodes).concat(lastNodes);
		var _g = 0;
		while(_g < newNodes.length) {
			var n = newNodes[_g];
			++_g;
			n.parent = this;
		}
		var _g = [];
		var _g1 = 0;
		var _g2 = this.nodes;
		while(_g1 < _g2.length) {
			var v = _g2[_g1];
			++_g1;
			if(((v) instanceof htmlparser_HtmlNodeElement)) {
				_g.push(v);
			}
		}
		this.children = _g;
	}
	,removeChild: function(node) {
		var n = this.nodes.indexOf(node);
		if(n < 0) {
			throw new haxe_Exception("Node to remove is not found.");
		}
		this.nodes.splice(n,1);
		node.parent = null;
		if(((node) instanceof htmlparser_HtmlNodeElement)) {
			n = this.children.indexOf(node);
			if(n >= 0) {
				this.children.splice(n,1);
			}
		}
	}
	,getAttributesAssoc: function() {
		var attrs = new haxe_ds_StringMap();
		var _g = 0;
		var _g1 = this.attributes;
		while(_g < _g1.length) {
			var attr = _g1[_g];
			++_g;
			attrs.h[attr.name] = attr.value;
		}
		return attrs;
	}
	,getAttributesObject: function() {
		var attrs = { };
		var _g = 0;
		var _g1 = this.attributes;
		while(_g < _g1.length) {
			var attr = _g1[_g];
			++_g;
			attrs[attr.name] = attr.value;
		}
		return attrs;
	}
	,isSelfClosing: function() {
		if(!Object.prototype.hasOwnProperty.call(htmlparser_HtmlParser.SELF_CLOSING_TAGS_HTML,this.name)) {
			return this.name.indexOf(":") >= 0;
		} else {
			return true;
		}
	}
	,hxSerialize: function(s) {
		s.serialize(this.name);
		s.serialize(this.attributes);
		s.serialize(this.nodes);
	}
	,hxUnserialize: function(s) {
		this.name = s.unserialize();
		this.attributes = s.unserialize();
		this.nodes = [];
		this.children = [];
		var ns = s.unserialize();
		var _g = 0;
		while(_g < ns.length) {
			var n = ns[_g];
			++_g;
			this.addChild(n);
		}
	}
	,__class__: htmlparser_HtmlNodeElement
});
var htmlparser_HtmlNodeText = function(text) {
	this.text = text;
};
htmlparser_HtmlNodeText.__name__ = "htmlparser.HtmlNodeText";
htmlparser_HtmlNodeText.__super__ = htmlparser_HtmlNode;
htmlparser_HtmlNodeText.prototype = $extend(htmlparser_HtmlNode.prototype,{
	toString: function() {
		return this.text;
	}
	,toText: function() {
		return htmlparser_HtmlTools.unescape(this.text);
	}
	,hxSerialize: function(s) {
		s.serialize(this.text);
	}
	,hxUnserialize: function(s) {
		this.text = s.unserialize();
	}
	,__class__: htmlparser_HtmlNodeText
});
var htmlparser_HtmlParser = function() {
};
htmlparser_HtmlParser.__name__ = "htmlparser.HtmlParser";
htmlparser_HtmlParser.run = function(str,tolerant) {
	if(tolerant == null) {
		tolerant = false;
	}
	return new htmlparser_HtmlParser().parse(str,tolerant);
};
htmlparser_HtmlParser.parseAttrs = function(str) {
	var attributes = [];
	var pos = 0;
	while(pos < str.length && htmlparser_HtmlParser.reParseAttrs.matchSub(str,pos)) {
		var name = htmlparser_HtmlParser.reParseAttrs.matched(1);
		var value = htmlparser_HtmlParser.reParseAttrs.matched(2);
		var quote = null;
		var unescaped = null;
		if(value != null) {
			quote = HxOverrides.substr(value,0,1);
			if(quote == "\"" || quote == "'") {
				value = HxOverrides.substr(value,1,value.length - 2);
			} else {
				quote = "";
			}
			unescaped = htmlparser_HtmlTools.unescape(value);
		}
		attributes.push(new htmlparser_HtmlAttribute(name,unescaped,quote));
		var p = htmlparser_HtmlParser.reParseAttrs.matchedPos();
		pos = p.pos + p.len;
	}
	return attributes;
};
htmlparser_HtmlParser.getMatched = function(re,n) {
	try {
		return re.matched(n);
	} catch( _g ) {
		return null;
	}
};
htmlparser_HtmlParser.prototype = {
	parse: function(str,tolerant) {
		if(tolerant == null) {
			tolerant = false;
		}
		this.tolerant = tolerant;
		this.matches = [];
		var pos = 0;
		while(pos < str.length && htmlparser_HtmlParser.reMain.matchSub(str,pos)) {
			var p = htmlparser_HtmlParser.reMain.matchedPos();
			var re = htmlparser_HtmlParser.reMain;
			var cdata;
			try {
				cdata = re.matched(1);
			} catch( _g ) {
				cdata = null;
			}
			if(cdata == null || cdata == "") {
				var r = htmlparser_HtmlParser.reMain.matched(0);
				var p1 = p.pos;
				var re1 = htmlparser_HtmlParser.reMain;
				var r1;
				try {
					r1 = re1.matched(2);
				} catch( _g1 ) {
					r1 = null;
				}
				var re2 = htmlparser_HtmlParser.reMain;
				var r2;
				try {
					r2 = re2.matched(3);
				} catch( _g2 ) {
					r2 = null;
				}
				var re3 = htmlparser_HtmlParser.reMain;
				var r3;
				try {
					r3 = re3.matched(4);
				} catch( _g3 ) {
					r3 = null;
				}
				var re4 = htmlparser_HtmlParser.reMain;
				var r4;
				try {
					r4 = re4.matched(5);
				} catch( _g4 ) {
					r4 = null;
				}
				var re5 = htmlparser_HtmlParser.reMain;
				var r5;
				try {
					r5 = re5.matched(6);
				} catch( _g5 ) {
					r5 = null;
				}
				var re6 = htmlparser_HtmlParser.reMain;
				var r6;
				try {
					r6 = re6.matched(7);
				} catch( _g6 ) {
					r6 = null;
				}
				var re7 = htmlparser_HtmlParser.reMain;
				var r7;
				try {
					r7 = re7.matched(8);
				} catch( _g7 ) {
					r7 = null;
				}
				var re8 = htmlparser_HtmlParser.reMain;
				var r8;
				try {
					r8 = re8.matched(9);
				} catch( _g8 ) {
					r8 = null;
				}
				var re9 = htmlparser_HtmlParser.reMain;
				var r9;
				try {
					r9 = re9.matched(10);
				} catch( _g9 ) {
					r9 = null;
				}
				var re10 = htmlparser_HtmlParser.reMain;
				var r10;
				try {
					r10 = re10.matched(11);
				} catch( _g10 ) {
					r10 = null;
				}
				var re11 = htmlparser_HtmlParser.reMain;
				var r11;
				try {
					r11 = re11.matched(12);
				} catch( _g11 ) {
					r11 = null;
				}
				var re12 = htmlparser_HtmlParser.reMain;
				var r12;
				try {
					r12 = re12.matched(13);
				} catch( _g12 ) {
					r12 = null;
				}
				var re13 = htmlparser_HtmlParser.reMain;
				var r13;
				try {
					r13 = re13.matched(14);
				} catch( _g13 ) {
					r13 = null;
				}
				var r14 = { all : r, allPos : p1, script : r1, scriptAttrs : r2, scriptText : r3, style : r4, styleAttrs : r5, styleText : r6, elem : r7, tagOpen : r8, attrs : r9, tagEnd : r10, close : r11, tagClose : r12, comment : r13, tagOpenLC : null, tagCloseLC : null};
				if(r14.tagOpen != null) {
					r14.tagOpenLC = r14.tagOpen.toLowerCase();
				}
				if(r14.tagClose != null) {
					r14.tagCloseLC = r14.tagClose.toLowerCase();
				}
				this.matches.push(r14);
			}
			pos = p.pos + p.len;
		}
		if(this.matches.length > 0) {
			this.str = str;
			this.i = 0;
			var nodes = this.processMatches([]).nodes;
			if(this.i < this.matches.length) {
				throw haxe_Exception.thrown(new htmlparser_HtmlParserException("Not all nodes processed.",this.getPosition(this.i)));
			}
			return nodes;
		}
		if(str.length > 0) {
			return [new htmlparser_HtmlNodeText(str)];
		} else {
			return [];
		}
	}
	,processMatches: function(openedTagsLC) {
		var nodes = [];
		var prevEnd = this.i > 0 ? this.matches[this.i - 1].allPos + this.matches[this.i - 1].all.length : 0;
		var curStart = this.matches[this.i].allPos;
		if(prevEnd < curStart) {
			nodes.push(new htmlparser_HtmlNodeText(HxOverrides.substr(this.str,prevEnd,curStart - prevEnd)));
		}
		while(this.i < this.matches.length) {
			var m = this.matches[this.i];
			if(m.elem != null && m.elem != "") {
				var ee = this.parseElement(openedTagsLC);
				nodes.push(ee.element);
				if(ee.closeTagLC != "") {
					return { nodes : nodes, closeTagLC : ee.closeTagLC};
				}
			} else if(m.script != null && m.script != "") {
				var scriptNode = this.newElement("script",htmlparser_HtmlParser.parseAttrs(m.scriptAttrs));
				scriptNode.addChild(new htmlparser_HtmlNodeText(m.scriptText));
				nodes.push(scriptNode);
			} else if(m.style != null && m.style != "") {
				var styleNode = this.newElement("style",htmlparser_HtmlParser.parseAttrs(m.styleAttrs));
				styleNode.addChild(new htmlparser_HtmlNodeText(m.styleText));
				nodes.push(styleNode);
			} else if(m.close != null && m.close != "") {
				if(m.tagCloseLC == openedTagsLC[openedTagsLC.length - 1]) {
					break;
				}
				if(this.tolerant) {
					if(openedTagsLC.lastIndexOf(m.tagCloseLC) >= 0) {
						break;
					}
				} else {
					throw haxe_Exception.thrown(new htmlparser_HtmlParserException("Closed tag <" + m.tagClose + "> don't match to open tag <" + openedTagsLC[openedTagsLC.length - 1] + ">.",this.getPosition(this.i)));
				}
			} else if(m.comment != null && m.comment != "") {
				nodes.push(new htmlparser_HtmlNodeText(m.comment));
			} else {
				throw haxe_Exception.thrown(new htmlparser_HtmlParserException("Unexpected XML node.",this.getPosition(this.i)));
			}
			if(this.tolerant && this.i >= this.matches.length) {
				break;
			}
			var curEnd = this.matches[this.i].allPos + this.matches[this.i].all.length;
			var nextStart = this.i + 1 < this.matches.length ? this.matches[this.i + 1].allPos : this.str.length;
			if(curEnd < nextStart) {
				nodes.push(new htmlparser_HtmlNodeText(HxOverrides.substr(this.str,curEnd,nextStart - curEnd)));
			}
			this.i++;
		}
		return { nodes : nodes, closeTagLC : ""};
	}
	,parseElement: function(openedTagsLC) {
		var tag = this.matches[this.i].tagOpen;
		var tagLC = this.matches[this.i].tagOpenLC;
		var attrs = this.matches[this.i].attrs;
		var isWithClose = this.matches[this.i].tagEnd != null && this.matches[this.i].tagEnd != "" || this.isSelfClosingTag(tagLC);
		var elem = this.newElement(tag,htmlparser_HtmlParser.parseAttrs(attrs));
		var closeTagLC = "";
		if(!isWithClose) {
			this.i++;
			openedTagsLC.push(tagLC);
			var m = this.processMatches(openedTagsLC);
			var _g = 0;
			var _g1 = m.nodes;
			while(_g < _g1.length) {
				var node = _g1[_g];
				++_g;
				elem.addChild(node);
			}
			openedTagsLC.pop();
			closeTagLC = m.closeTagLC != tagLC ? m.closeTagLC : "";
			if(this.i < this.matches.length || !this.tolerant) {
				if(this.matches[this.i].close == null || this.matches[this.i].close == "" || this.matches[this.i].tagCloseLC != tagLC) {
					if(!this.tolerant) {
						throw haxe_Exception.thrown(new htmlparser_HtmlParserException("Tag <" + tag + "> not closed.",this.getPosition(this.i)));
					} else {
						closeTagLC = this.matches[this.i].tagCloseLC;
					}
				}
			}
		}
		return { element : elem, closeTagLC : closeTagLC};
	}
	,isSelfClosingTag: function(tag) {
		return Object.prototype.hasOwnProperty.call(htmlparser_HtmlParser.SELF_CLOSING_TAGS_HTML,tag);
	}
	,newElement: function(name,attributes) {
		return new htmlparser_HtmlNodeElement(name,attributes);
	}
	,getPosition: function(matchIndex) {
		var m = this.matches[matchIndex];
		var line = 1;
		var lastNewLinePos = -1;
		var i = 0;
		while(i < m.allPos) {
			var chars = i + 1 < this.str.length ? this.str.substring(i,i + 2) : this.str.charAt(i);
			if(chars == "\r\n") {
				i += 2;
				lastNewLinePos = i;
				++line;
			} else if(chars.charAt(0) == "\n" || chars.charAt(0) == "\r") {
				++i;
				lastNewLinePos = i;
				++line;
			} else {
				++i;
			}
		}
		return { line : line, column : m.allPos - lastNewLinePos, length : m.all.length};
	}
	,__class__: htmlparser_HtmlParser
};
var htmlparser_HtmlParserException = function(message,pos) {
	this.message = message;
	this.line = pos.line;
	this.column = pos.column;
	this.length = pos.length;
};
htmlparser_HtmlParserException.__name__ = "htmlparser.HtmlParserException";
htmlparser_HtmlParserException.prototype = {
	toString: function() {
		return "Parse error at " + this.line + ":" + this.column + ". " + this.message;
	}
	,__class__: htmlparser_HtmlParserException
};
var htmlparser_HtmlParserTools = function() { };
htmlparser_HtmlParserTools.__name__ = "htmlparser.HtmlParserTools";
htmlparser_HtmlParserTools.getAttr = function(node,attrName,defaultValue) {
	if(node == null || !node.hasAttribute(attrName)) {
		if(((defaultValue) instanceof Array)) {
			return null;
		} else {
			return defaultValue;
		}
	}
	return htmlparser_HtmlParserTools.parseValue(node.getAttribute(attrName),defaultValue);
};
htmlparser_HtmlParserTools.getAttrString = function(node,attrName,defaultValue) {
	var r = node.getAttribute(attrName);
	if(r == null) {
		return defaultValue;
	} else {
		return r;
	}
};
htmlparser_HtmlParserTools.getAttrInt = function(node,attrName,defaultValue) {
	var r = Std.parseInt(node.getAttribute(attrName));
	if(r == null || isNaN(r)) {
		return defaultValue;
	} else {
		return r;
	}
};
htmlparser_HtmlParserTools.getAttrFloat = function(node,attrName,defaultValue) {
	var r = parseFloat(node.getAttribute(attrName));
	if(r == null || isNaN(r)) {
		return defaultValue;
	} else {
		return r;
	}
};
htmlparser_HtmlParserTools.getAttrBool = function(node,attrName,defaultValue) {
	var r = node.getAttribute(attrName);
	if(r == null || r == "") {
		return defaultValue;
	} else if(r != "0" && r.toLowerCase() != "false") {
		return r.toLowerCase() != "no";
	} else {
		return false;
	}
};
htmlparser_HtmlParserTools.findOne = function(node,selector) {
	var nodes = node.find(selector);
	if(nodes.length > 0) {
		return nodes[0];
	} else {
		return null;
	}
};
htmlparser_HtmlParserTools.parseValue = function(value,defaultValue) {
	if(typeof(defaultValue) == "number") {
		return parseFloat(value);
	}
	if(typeof(defaultValue) == "boolean") {
		if(value != null && value != "" && value != "0") {
			return ["false","no"].indexOf(value.toLowerCase()) < 0;
		} else {
			return false;
		}
	}
	if(((defaultValue) instanceof Array)) {
		var elems = [];
		var parCounter = 0;
		var lastCommaIndex = -1;
		var _g = 0;
		var _g1 = value.length;
		while(_g < _g1) {
			var i = _g++;
			var c = value.charAt(i);
			if(c == "(" || c == "[" || c == "{") {
				++parCounter;
			} else if(c == ")" || c == "]" || c == "}") {
				--parCounter;
			} else if(c == "," && parCounter == 0) {
				elems.push(value.substring(lastCommaIndex + 1,i));
				lastCommaIndex = i;
			}
		}
		elems.push(value.substring(lastCommaIndex + 1,value.length));
		if(defaultValue.length > 0) {
			var result = new Array(elems.length);
			var _g = 0;
			var _g1 = elems.length;
			while(_g < _g1) {
				var i = _g++;
				result[i] = htmlparser_HtmlParserTools.parseValue(elems[i],defaultValue[0]);
			}
			return result;
		} else {
			return elems;
		}
	}
	return value;
};
var htmlparser_HtmlTools = function() { };
htmlparser_HtmlTools.__name__ = "htmlparser.HtmlTools";
htmlparser_HtmlTools.get_htmlUnescapeMap = function() {
	if(htmlparser_HtmlTools.htmlUnescapeMap == null) {
		var _g = new haxe_ds_StringMap();
		_g.h["nbsp"] = " ";
		_g.h["amp"] = "&";
		_g.h["lt"] = "<";
		_g.h["gt"] = ">";
		_g.h["quot"] = "\"";
		_g.h["apos"] = "'";
		_g.h["euro"] = "";
		_g.h["iexcl"] = "";
		_g.h["cent"] = "";
		_g.h["pound"] = "";
		_g.h["curren"] = "";
		_g.h["yen"] = "";
		_g.h["brvbar"] = "";
		_g.h["sect"] = "";
		_g.h["uml"] = "";
		_g.h["copy"] = "";
		_g.h["ordf"] = "";
		_g.h["not"] = "";
		_g.h["shy"] = "";
		_g.h["reg"] = "";
		_g.h["macr"] = "";
		_g.h["deg"] = "";
		_g.h["plusmn"] = "";
		_g.h["sup2"] = "";
		_g.h["sup3"] = "";
		_g.h["acute"] = "";
		_g.h["micro"] = "";
		_g.h["para"] = "";
		_g.h["middot"] = "";
		_g.h["cedil"] = "";
		_g.h["sup1"] = "";
		_g.h["ordm"] = "";
		_g.h["raquo"] = "";
		_g.h["frac14"] = "";
		_g.h["frac12"] = "";
		_g.h["frac34"] = "";
		_g.h["iquest"] = "";
		_g.h["Agrave"] = "";
		_g.h["Aacute"] = "";
		_g.h["Acirc"] = "";
		_g.h["Atilde"] = "";
		_g.h["Auml"] = "";
		_g.h["Aring"] = "";
		_g.h["AElig"] = "";
		_g.h["Ccedil"] = "";
		_g.h["Egrave"] = "";
		_g.h["Eacute"] = "";
		_g.h["Ecirc"] = "";
		_g.h["Euml"] = "";
		_g.h["Igrave"] = "";
		_g.h["Iacute"] = "";
		_g.h["Icirc"] = "";
		_g.h["Iuml"] = "";
		_g.h["ETH"] = "";
		_g.h["Ntilde"] = "";
		_g.h["Ograve"] = "";
		_g.h["Oacute"] = "";
		_g.h["Ocirc"] = "";
		_g.h["Otilde"] = "";
		_g.h["Ouml"] = "";
		_g.h["times"] = "";
		_g.h["Oslash"] = "";
		_g.h["Ugrave"] = "";
		_g.h["Uacute"] = "";
		_g.h["Ucirc"] = "";
		_g.h["Uuml"] = "";
		_g.h["Yacute"] = "";
		_g.h["THORN"] = "";
		_g.h["szlig"] = "";
		_g.h["agrave"] = "";
		_g.h["aacute"] = "";
		_g.h["acirc"] = "";
		_g.h["atilde"] = "";
		_g.h["auml"] = "";
		_g.h["aring"] = "";
		_g.h["aelig"] = "";
		_g.h["ccedil"] = "";
		_g.h["egrave"] = "";
		_g.h["eacute"] = "";
		_g.h["ecirc"] = "";
		_g.h["euml"] = "";
		_g.h["igrave"] = "";
		_g.h["iacute"] = "";
		_g.h["icirc"] = "";
		_g.h["iuml"] = "";
		_g.h["eth"] = "";
		_g.h["ntilde"] = "";
		_g.h["ograve"] = "";
		_g.h["oacute"] = "";
		_g.h["ocirc"] = "";
		_g.h["otilde"] = "";
		_g.h["ouml"] = "";
		_g.h["divide"] = "";
		_g.h["oslash"] = "";
		_g.h["ugrave"] = "";
		_g.h["uacute"] = "";
		_g.h["ucirc"] = "";
		_g.h["uuml"] = "";
		_g.h["yacute"] = "";
		_g.h["thorn"] = "";
		htmlparser_HtmlTools.htmlUnescapeMap = _g;
	}
	return htmlparser_HtmlTools.htmlUnescapeMap;
};
htmlparser_HtmlTools.escape = function(text,chars) {
	if(chars == null) {
		chars = "";
	}
	var r = text.split("&").join("&amp;");
	r = r.split("<").join("&lt;");
	r = r.split(">").join("&gt;");
	if(chars.indexOf("\"") >= 0) {
		r = r.split("\"").join("&quot;");
	}
	if(chars.indexOf("'") >= 0) {
		r = r.split("'").join("&apos;");
	}
	if(chars.indexOf(" ") >= 0) {
		r = r.split(" ").join("&nbsp;");
	}
	if(chars.indexOf("\n") >= 0) {
		r = r.split("\n").join("&#xA;");
	}
	if(chars.indexOf("\r") >= 0) {
		r = r.split("\r").join("&#xD;");
	}
	return r;
};
htmlparser_HtmlTools.unescape = function(text) {
	return new EReg("[<]!\\[CDATA\\[((?:.|[\r\n])*?)\\]\\][>]|&[^;]+;","g").map(text,function(re) {
		var s = re.matched(0);
		if(s.charAt(0) == "&") {
			if(s.charAt(1) == "#") {
				var numbers = s.substring(2,s.length - 1);
				if(numbers.charAt(0) == "x") {
					numbers = "0" + numbers;
				}
				var code = Std.parseInt(numbers);
				if(code != null && code != 0) {
					return String.fromCodePoint(code);
				} else {
					return s;
				}
			} else {
				var r = htmlparser_HtmlTools.get_htmlUnescapeMap().h[s.substring(1,s.length - 1)];
				if(r != null) {
					return r;
				} else {
					return s;
				}
			}
		}
		return re.matched(1);
	});
};
var htmlparser_XmlBuilder = function(indent,newLine) {
	if(newLine == null) {
		newLine = "\n";
	}
	if(indent == null) {
		indent = "\t";
	}
	this.level = 0;
	this.indent = indent;
	this.newLine = newLine;
	this.cur = this.xml = new htmlparser_XmlDocument();
};
htmlparser_XmlBuilder.__name__ = "htmlparser.XmlBuilder";
htmlparser_XmlBuilder.prototype = {
	begin: function(tag,attrs) {
		if(this.indent != null) {
			if(this.level > 0 || this.cur.nodes.length > 0) {
				this.cur.addChild(new htmlparser_HtmlNodeText(this.newLine + StringTools.rpad("",this.indent,this.level * this.indent.length)));
			}
			this.level++;
		}
		var node;
		if(attrs != null) {
			var result = new Array(attrs.length);
			var _g = 0;
			var _g1 = attrs.length;
			while(_g < _g1) {
				var i = _g++;
				var a = attrs[i];
				result[i] = new htmlparser_HtmlAttribute(a.name,a.value,"\"");
			}
			node = result;
		} else {
			node = [];
		}
		var node1 = new htmlparser_XmlNodeElement(tag,node);
		this.cur.addChild(node1);
		this.cur = node1;
		return this;
	}
	,end: function() {
		if(this.indent != null) {
			this.level--;
			if(Lambda.exists(this.cur.nodes,function(e) {
				return !((e) instanceof htmlparser_HtmlNodeText);
			})) {
				this.cur.addChild(new htmlparser_HtmlNodeText(this.newLine + StringTools.rpad("",this.indent,this.level * this.indent.length)));
			}
		}
		this.cur = this.cur.parent;
		return this;
	}
	,attr: function(name,value,defValue) {
		if(value != null && (typeof(value) != "number" || !isNaN(value)) && value != defValue) {
			if(((value) instanceof Array)) {
				value = value.join(",");
			}
			this.cur.setAttribute(name,Std.string(value));
		}
		return this;
	}
	,content: function(s) {
		this.cur.addChild(new htmlparser_HtmlNodeText(s));
		return this;
	}
	,toString: function() {
		return this.xml.toString();
	}
	,__class__: htmlparser_XmlBuilder
};
var htmlparser_XmlNodeElement = function(name,attributes) {
	htmlparser_HtmlNodeElement.call(this,name,attributes);
};
htmlparser_XmlNodeElement.__name__ = "htmlparser.XmlNodeElement";
htmlparser_XmlNodeElement.__super__ = htmlparser_HtmlNodeElement;
htmlparser_XmlNodeElement.prototype = $extend(htmlparser_HtmlNodeElement.prototype,{
	isSelfClosing: function() {
		return true;
	}
	,set_innerHTML: function(value) {
		var newNodes = htmlparser_XmlParser.run(value);
		this.nodes = [];
		this.children = [];
		var _g = 0;
		while(_g < newNodes.length) {
			var node = newNodes[_g];
			++_g;
			this.addChild(node);
		}
		return value;
	}
	,__class__: htmlparser_XmlNodeElement
});
var htmlparser_XmlDocument = function(str) {
	if(str == null) {
		str = "";
	}
	htmlparser_XmlNodeElement.call(this,"",[]);
	var nodes = htmlparser_XmlParser.run(str);
	var _g = 0;
	while(_g < nodes.length) {
		var node = nodes[_g];
		++_g;
		this.addChild(node);
	}
};
htmlparser_XmlDocument.__name__ = "htmlparser.XmlDocument";
htmlparser_XmlDocument.__super__ = htmlparser_XmlNodeElement;
htmlparser_XmlDocument.prototype = $extend(htmlparser_XmlNodeElement.prototype,{
	__class__: htmlparser_XmlDocument
});
var htmlparser_XmlParser = function() {
	htmlparser_HtmlParser.call(this);
};
htmlparser_XmlParser.__name__ = "htmlparser.XmlParser";
htmlparser_XmlParser.run = function(str) {
	return new htmlparser_XmlParser().parse(str);
};
htmlparser_XmlParser.__super__ = htmlparser_HtmlParser;
htmlparser_XmlParser.prototype = $extend(htmlparser_HtmlParser.prototype,{
	isSelfClosingTag: function(tag) {
		return false;
	}
	,newElement: function(name,attributes) {
		return new htmlparser_XmlNodeElement(name,attributes);
	}
	,__class__: htmlparser_XmlParser
});
var js_Boot = function() { };
js_Boot.__name__ = "js.Boot";
js_Boot.getClass = function(o) {
	if(o == null) {
		return null;
	} else if(((o) instanceof Array)) {
		return Array;
	} else {
		var cl = o.__class__;
		if(cl != null) {
			return cl;
		}
		var name = js_Boot.__nativeClassName(o);
		if(name != null) {
			return js_Boot.__resolveNativeClass(name);
		}
		return null;
	}
};
js_Boot.__string_rec = function(o,s) {
	if(o == null) {
		return "null";
	}
	if(s.length >= 5) {
		return "<...>";
	}
	var t = typeof(o);
	if(t == "function" && (o.__name__ || o.__ename__)) {
		t = "object";
	}
	switch(t) {
	case "function":
		return "<function>";
	case "object":
		if(o.__enum__) {
			var e = $hxEnums[o.__enum__];
			var con = e.__constructs__[o._hx_index];
			var n = con._hx_name;
			if(con.__params__) {
				s = s + "\t";
				return n + "(" + ((function($this) {
					var $r;
					var _g = [];
					{
						var _g1 = 0;
						var _g2 = con.__params__;
						while(true) {
							if(!(_g1 < _g2.length)) {
								break;
							}
							var p = _g2[_g1];
							_g1 = _g1 + 1;
							_g.push(js_Boot.__string_rec(o[p],s));
						}
					}
					$r = _g;
					return $r;
				}(this))).join(",") + ")";
			} else {
				return n;
			}
		}
		if(((o) instanceof Array)) {
			var str = "[";
			s += "\t";
			var _g = 0;
			var _g1 = o.length;
			while(_g < _g1) {
				var i = _g++;
				str += (i > 0 ? "," : "") + js_Boot.__string_rec(o[i],s);
			}
			str += "]";
			return str;
		}
		var tostr;
		try {
			tostr = o.toString;
		} catch( _g ) {
			return "???";
		}
		if(tostr != null && tostr != Object.toString && typeof(tostr) == "function") {
			var s2 = o.toString();
			if(s2 != "[object Object]") {
				return s2;
			}
		}
		var str = "{\n";
		s += "\t";
		var hasp = o.hasOwnProperty != null;
		var k = null;
		for( k in o ) {
		if(hasp && !o.hasOwnProperty(k)) {
			continue;
		}
		if(k == "prototype" || k == "__class__" || k == "__super__" || k == "__interfaces__" || k == "__properties__") {
			continue;
		}
		if(str.length != 2) {
			str += ", \n";
		}
		str += s + k + " : " + js_Boot.__string_rec(o[k],s);
		}
		s = s.substring(1);
		str += "\n" + s + "}";
		return str;
	case "string":
		return o;
	default:
		return String(o);
	}
};
js_Boot.__interfLoop = function(cc,cl) {
	if(cc == null) {
		return false;
	}
	if(cc == cl) {
		return true;
	}
	var intf = cc.__interfaces__;
	if(intf != null) {
		var _g = 0;
		var _g1 = intf.length;
		while(_g < _g1) {
			var i = _g++;
			var i1 = intf[i];
			if(i1 == cl || js_Boot.__interfLoop(i1,cl)) {
				return true;
			}
		}
	}
	return js_Boot.__interfLoop(cc.__super__,cl);
};
js_Boot.__instanceof = function(o,cl) {
	if(cl == null) {
		return false;
	}
	switch(cl) {
	case Array:
		return ((o) instanceof Array);
	case Bool:
		return typeof(o) == "boolean";
	case Dynamic:
		return o != null;
	case Float:
		return typeof(o) == "number";
	case Int:
		if(typeof(o) == "number") {
			return ((o | 0) === o);
		} else {
			return false;
		}
		break;
	case String:
		return typeof(o) == "string";
	default:
		if(o != null) {
			if(typeof(cl) == "function") {
				if(js_Boot.__downcastCheck(o,cl)) {
					return true;
				}
			} else if(typeof(cl) == "object" && js_Boot.__isNativeObj(cl)) {
				if(((o) instanceof cl)) {
					return true;
				}
			}
		} else {
			return false;
		}
		if(cl == Class ? o.__name__ != null : false) {
			return true;
		}
		if(cl == Enum ? o.__ename__ != null : false) {
			return true;
		}
		return o.__enum__ != null ? $hxEnums[o.__enum__] == cl : false;
	}
};
js_Boot.__downcastCheck = function(o,cl) {
	if(!((o) instanceof cl)) {
		if(cl.__isInterface__) {
			return js_Boot.__interfLoop(js_Boot.getClass(o),cl);
		} else {
			return false;
		}
	} else {
		return true;
	}
};
js_Boot.__cast = function(o,t) {
	if(o == null || js_Boot.__instanceof(o,t)) {
		return o;
	} else {
		throw haxe_Exception.thrown("Cannot cast " + Std.string(o) + " to " + Std.string(t));
	}
};
js_Boot.__nativeClassName = function(o) {
	var name = js_Boot.__toStr.call(o).slice(8,-1);
	if(name == "Object" || name == "Function" || name == "Math" || name == "JSON") {
		return null;
	}
	return name;
};
js_Boot.__isNativeObj = function(o) {
	return js_Boot.__nativeClassName(o) != null;
};
js_Boot.__resolveNativeClass = function(name) {
	return $global[name];
};
var js_html_VideoFrameBufferInit = function() { };
js_html_VideoFrameBufferInit.__name__ = "js.html.VideoFrameBufferInit";
js_html_VideoFrameBufferInit.__isInterface__ = true;
js_html_VideoFrameBufferInit.prototype = {
	__class__: js_html_VideoFrameBufferInit
};
var js_html_VideoColorSpaceInit = function() { };
js_html_VideoColorSpaceInit.__name__ = "js.html.VideoColorSpaceInit";
js_html_VideoColorSpaceInit.__isInterface__ = true;
js_html_VideoColorSpaceInit.prototype = {
	__class__: js_html_VideoColorSpaceInit
};
var js_html_PlaneLayout = function() { };
js_html_PlaneLayout.__name__ = "js.html.PlaneLayout";
js_html_PlaneLayout.__isInterface__ = true;
js_html_PlaneLayout.prototype = {
	__class__: js_html_PlaneLayout
};
var js_html_DOMRectInit = function() { };
js_html_DOMRectInit.__name__ = "js.html.DOMRectInit";
js_html_DOMRectInit.__isInterface__ = true;
js_html_DOMRectInit.prototype = {
	__class__: js_html_DOMRectInit
};
var js_html_VideoFrameInit = function() { };
js_html_VideoFrameInit.__name__ = "js.html.VideoFrameInit";
js_html_VideoFrameInit.__isInterface__ = true;
js_html_VideoFrameInit.prototype = {
	__class__: js_html_VideoFrameInit
};
var js_injecting_InjectorRO = function() { };
js_injecting_InjectorRO.__name__ = "js.injecting.InjectorRO";
js_injecting_InjectorRO.__isInterface__ = true;
js_injecting_InjectorRO.prototype = {
	__class__: js_injecting_InjectorRO
};
var nanofl_IInstance = function() { };
nanofl_IInstance.__name__ = "nanofl.IInstance";
nanofl_IInstance.__isInterface__ = true;
nanofl_IInstance.prototype = {
	__class__: nanofl_IInstance
};
var nanofl_engine_IElementsContainer = function() { };
nanofl_engine_IElementsContainer.__name__ = "nanofl.engine.IElementsContainer";
nanofl_engine_IElementsContainer.__isInterface__ = true;
nanofl_engine_IElementsContainer.prototype = {
	__class__: nanofl_engine_IElementsContainer
};
var nanofl_engine_IFramedItem = function() { };
nanofl_engine_IFramedItem.__name__ = "nanofl.engine.IFramedItem";
nanofl_engine_IFramedItem.__isInterface__ = true;
nanofl_engine_IFramedItem.prototype = {
	__class__: nanofl_engine_IFramedItem
};
var nanofl_engine_IInstance = function() { };
nanofl_engine_IInstance.__name__ = "nanofl.engine.IInstance";
nanofl_engine_IInstance.__isInterface__ = true;
nanofl_engine_IInstance.prototype = {
	__class__: nanofl_engine_IInstance
};
var nanofl_engine_ILayersContainer = function() { };
nanofl_engine_ILayersContainer.__name__ = "nanofl.engine.ILayersContainer";
nanofl_engine_ILayersContainer.__isInterface__ = true;
nanofl_engine_ILayersContainer.prototype = {
	__class__: nanofl_engine_ILayersContainer
};
var nanofl_engine_ILibraryItem = function() { };
nanofl_engine_ILibraryItem.__name__ = "nanofl.engine.ILibraryItem";
nanofl_engine_ILibraryItem.__isInterface__ = true;
nanofl_engine_ILibraryItem.prototype = {
	__class__: nanofl_engine_ILibraryItem
};
var nanofl_engine_IMotionTween = function() { };
nanofl_engine_IMotionTween.__name__ = "nanofl.engine.IMotionTween";
nanofl_engine_IMotionTween.__isInterface__ = true;
nanofl_engine_IMotionTween.prototype = {
	__class__: nanofl_engine_IMotionTween
};
var nanofl_engine_IPathElement = function() { };
nanofl_engine_IPathElement.__name__ = "nanofl.engine.IPathElement";
nanofl_engine_IPathElement.__isInterface__ = true;
nanofl_engine_IPathElement.__interfaces__ = [nanofl_engine_ILayersContainer];
nanofl_engine_IPathElement.prototype = {
	__class__: nanofl_engine_IPathElement
};
var nanofl_engine_ISelectable = function() { };
nanofl_engine_ISelectable.__name__ = "nanofl.engine.ISelectable";
nanofl_engine_ISelectable.__isInterface__ = true;
nanofl_engine_ISelectable.prototype = {
	__class__: nanofl_engine_ISelectable
};
var nanofl_engine_ISpriteSheetableItem = function() { };
nanofl_engine_ISpriteSheetableItem.__name__ = "nanofl.engine.ISpriteSheetableItem";
nanofl_engine_ISpriteSheetableItem.__isInterface__ = true;
nanofl_engine_ISpriteSheetableItem.prototype = {
	__class__: nanofl_engine_ISpriteSheetableItem
};
var nanofl_engine_ITextureItem = function() { };
nanofl_engine_ITextureItem.__name__ = "nanofl.engine.ITextureItem";
nanofl_engine_ITextureItem.__isInterface__ = true;
nanofl_engine_ITextureItem.prototype = {
	__class__: nanofl_engine_ITextureItem
};
var nanofl_engine_ITimeline = function() { };
nanofl_engine_ITimeline.__name__ = "nanofl.engine.ITimeline";
nanofl_engine_ITimeline.__isInterface__ = true;
nanofl_engine_ITimeline.prototype = {
	__class__: nanofl_engine_ITimeline
};
var nanofl_engine_fills_IFill = function() { };
nanofl_engine_fills_IFill.__name__ = "nanofl.engine.fills.IFill";
nanofl_engine_fills_IFill.__isInterface__ = true;
nanofl_engine_fills_IFill.prototype = {
	__class__: nanofl_engine_fills_IFill
};
var nanofl_engine_strokes_IStroke = function() { };
nanofl_engine_strokes_IStroke.__name__ = "nanofl.engine.strokes.IStroke";
nanofl_engine_strokes_IStroke.__isInterface__ = true;
nanofl_engine_strokes_IStroke.prototype = {
	__class__: nanofl_engine_strokes_IStroke
};
var nanofl_ide_ISymbol = function() { };
nanofl_ide_ISymbol.__name__ = "nanofl.ide.ISymbol";
nanofl_ide_ISymbol.__isInterface__ = true;
nanofl_ide_ISymbol.prototype = {
	__class__: nanofl_ide_ISymbol
};
var nanofl_ide_ITimeline = function() { };
nanofl_ide_ITimeline.__name__ = "nanofl.ide.ITimeline";
nanofl_ide_ITimeline.__isInterface__ = true;
nanofl_ide_ITimeline.__interfaces__ = [nanofl_engine_ITimeline];
nanofl_ide_ITimeline.prototype = {
	__class__: nanofl_ide_ITimeline
};
var nanofl_ide_libraryitems_IIdeLibraryItem = function() { };
nanofl_ide_libraryitems_IIdeLibraryItem.__name__ = "nanofl.ide.libraryitems.IIdeLibraryItem";
nanofl_ide_libraryitems_IIdeLibraryItem.__isInterface__ = true;
nanofl_ide_libraryitems_IIdeLibraryItem.__interfaces__ = [nanofl_engine_ILibraryItem];
nanofl_ide_libraryitems_IIdeLibraryItem.prototype = {
	__class__: nanofl_ide_libraryitems_IIdeLibraryItem
};
var nanofl_ide_libraryitems_IIdeInstancableItem = function() { };
nanofl_ide_libraryitems_IIdeInstancableItem.__name__ = "nanofl.ide.libraryitems.IIdeInstancableItem";
nanofl_ide_libraryitems_IIdeInstancableItem.__isInterface__ = true;
nanofl_ide_libraryitems_IIdeInstancableItem.__interfaces__ = [nanofl_ide_libraryitems_IIdeLibraryItem,nanofl_ide_ISymbol];
nanofl_ide_libraryitems_IIdeInstancableItem.prototype = {
	__class__: nanofl_ide_libraryitems_IIdeInstancableItem
};
var nanofl_ide_sys_Environment = function() { };
nanofl_ide_sys_Environment.__name__ = "nanofl.ide.sys.Environment";
nanofl_ide_sys_Environment.__isInterface__ = true;
nanofl_ide_sys_Environment.prototype = {
	__class__: nanofl_ide_sys_Environment
};
var nanofl_ide_sys_FileSystem = function() { };
nanofl_ide_sys_FileSystem.__name__ = "nanofl.ide.sys.FileSystem";
nanofl_ide_sys_FileSystem.__isInterface__ = true;
nanofl_ide_sys_FileSystem.prototype = {
	__class__: nanofl_ide_sys_FileSystem
};
var nanofl_ide_sys_Folders = function() { };
nanofl_ide_sys_Folders.__name__ = "nanofl.ide.sys.Folders";
nanofl_ide_sys_Folders.__isInterface__ = true;
nanofl_ide_sys_Folders.prototype = {
	__class__: nanofl_ide_sys_Folders
};
var nanofl_ide_sys_Fonts = function() { };
nanofl_ide_sys_Fonts.__name__ = "nanofl.ide.sys.Fonts";
nanofl_ide_sys_Fonts.__isInterface__ = true;
nanofl_ide_sys_Fonts.prototype = {
	__class__: nanofl_ide_sys_Fonts
};
var nanofl_ide_sys_ProcessManager = function() { };
nanofl_ide_sys_ProcessManager.__name__ = "nanofl.ide.sys.ProcessManager";
nanofl_ide_sys_ProcessManager.__isInterface__ = true;
nanofl_ide_sys_ProcessManager.prototype = {
	__class__: nanofl_ide_sys_ProcessManager
};
var nanofl_ide_sys_Zip = function() { };
nanofl_ide_sys_Zip.__name__ = "nanofl.ide.sys.Zip";
nanofl_ide_sys_Zip.__isInterface__ = true;
nanofl_ide_sys_Zip.prototype = {
	__class__: nanofl_ide_sys_Zip
};
var stdlib_Debug = function() { };
stdlib_Debug.__name__ = "stdlib.Debug";
stdlib_Debug.getDump = function(v,limit,level,prefix) {
	if(prefix == null) {
		prefix = "";
	}
	if(level == null) {
		level = 0;
	}
	if(limit == null) {
		limit = 10;
	}
	if(level >= limit) {
		return "...\n";
	}
	prefix += "\t";
	var s = "?\n";
	var _g = Type.typeof(v);
	switch(_g._hx_index) {
	case 0:
		s = "NULL\n";
		break;
	case 1:
		s = "INT(" + Std.string(v) + ")\n";
		break;
	case 2:
		s = "FLOAT(" + Std.string(v) + ")\n";
		break;
	case 3:
		s = "BOOL(" + (v ? "true" : "false") + ")\n";
		break;
	case 4:
		s = "OBJECT" + "\n" + stdlib_Debug.getObjectDump(v,limit,level + 1,prefix);
		break;
	case 5:
		s = "FUNCTION\n";
		break;
	case 6:
		var c = _g.c;
		if(c == String) {
			s = "STRING(" + Std.string(v) + ")\n";
		} else if(c == Array) {
			s = "ARRAY(" + Std.string(v.length) + ")\n";
			var _g1 = 0;
			var _g2 = js_Boot.__cast(v , Array);
			while(_g1 < _g2.length) {
				var item = _g2[_g1];
				++_g1;
				s += prefix + stdlib_Debug.getDump(item,limit,level + 1,prefix);
			}
		} else if(c == haxe_ds_List) {
			s = "LIST(" + Lambda.count(v) + ")\n";
			var _g_head = (js_Boot.__cast(v , haxe_ds_List)).h;
			while(_g_head != null) {
				var val = _g_head.item;
				_g_head = _g_head.next;
				var item = val;
				s += prefix + stdlib_Debug.getDump(item,limit,level + 1,prefix);
			}
		} else if(c == haxe_ds_StringMap) {
			s = "StringMap\n";
			var map = js_Boot.__cast(v , haxe_ds_StringMap);
			var h = map.h;
			var _g_h = h;
			var _g_keys = Object.keys(h);
			var _g_length = _g_keys.length;
			var _g_current = 0;
			while(_g_current < _g_length) {
				var key = _g_keys[_g_current++];
				s += prefix + key + " => " + stdlib_Debug.getDump(map.h[key],limit,level + 1,prefix);
			}
		} else {
			s = "CLASS(" + c.__name__ + ")\n" + stdlib_Debug.getObjectDump(v,limit,level + 1,prefix);
		}
		break;
	case 7:
		var e = _g.e;
		var e1 = v;
		s = "ENUM(" + e.__ename__ + ") = " + $hxEnums[e1.__enum__].__constructs__[e1._hx_index]._hx_name + "\n";
		break;
	case 8:
		s = "UNKNOW\n";
		break;
	}
	return s;
};
stdlib_Debug.getObjectDump = function(obj,limit,level,prefix) {
	var s = "";
	var _g = 0;
	var _g1 = Reflect.fields(obj);
	while(_g < _g1.length) {
		var fieldName = _g1[_g];
		++_g;
		s += prefix + fieldName + " : " + stdlib_Debug.getDump(Reflect.field(obj,fieldName),limit,level,prefix);
	}
	return s;
};
stdlib_Debug.assert = function(e,message,pos) {
	if(!e) {
		if(message == null) {
			message = "error";
		} else if(Reflect.isFunction(message)) {
			message = message();
		}
		var s = "ASSERT " + Std.string(message) + " in " + pos.fileName + " at line " + pos.lineNumber;
		throw new Error(s);
	}
};
stdlib_Debug.traceStack = function(v,pos) {
	var stack = stdlib_StringTools.trim(StringTools.replace(haxe_CallStack.toString(haxe_CallStack.callStack()),"prototype<.",""));
	var _g = [];
	var _g1 = 0;
	var _g2 = stack.split("\n");
	while(_g1 < _g2.length) {
		var v1 = _g2[_g1];
		++_g1;
		if(v1 != "Called from module") {
			_g.push(v1);
		}
	}
	var _this = _g;
	var result = new Array(_this.length);
	var _g = 0;
	var _g1 = _this.length;
	while(_g < _g1) {
		var i = _g++;
		var _this1 = _this[i].split("@");
		var result1 = new Array(_this1.length);
		var _g2 = 0;
		var _g3 = _this1.length;
		while(_g2 < _g3) {
			var i1 = _g2++;
			result1[i1] = stdlib_StringTools.rtrim(_this1[i1],"</");
		}
		result[i] = result1.join("@");
	}
	var lines = result;
	var len = 0;
	var _g = 0;
	while(_g < lines.length) {
		var line = lines[_g];
		++_g;
		var b = line.indexOf("@");
		if(len <= b) {
			len = b;
		}
	}
	var result = new Array(lines.length);
	var _g = 0;
	var _g1 = lines.length;
	while(_g < _g1) {
		var i = _g++;
		var ss = lines[i].split("@");
		result[i] = ss[0] + StringTools.rpad(""," ",len - ss[0].length + 1) + ss[1];
	}
	lines = result;
	stack = lines.slice(1).join("\n");
	haxe_Log.trace("TRACE " + (typeof(v) == "string" ? v : stdlib_StringTools.trim(stdlib_Debug.getDump(v))) + "\nStack trace:\n" + stack,{ fileName : "stdlib/Debug.hx", lineNumber : 189, className : "stdlib.Debug", methodName : "traceStack", customParams : [pos]});
};
stdlib_Debug.methodNotSupported = function(_this,pos) {
	var c = js_Boot.getClass(_this);
	throw new haxe_Exception("Method " + pos.methodName + "() is not supported by class " + c.__name__ + ".");
};
var stdlib_Event = function(target) {
	this.target = target;
	this.handlers = [];
};
stdlib_Event.__name__ = "stdlib.Event";
stdlib_Event.prototype = {
	bind: function(handler) {
		this.handlers.push(handler);
	}
	,unbind: function(handler) {
		while(HxOverrides.remove(this.handlers,handler)) {
		}
	}
	,unbindAll: function() {
		this.handlers = [];
	}
	,call: function(args) {
		var _g = 0;
		var _g1 = this.handlers;
		while(_g < _g1.length) {
			var handler = _g1[_g];
			++_g;
			handler.apply(null,[this.target,args]);
		}
	}
	,__class__: stdlib_Event
};
var stdlib_LambdaArray = function() { };
stdlib_LambdaArray.__name__ = "stdlib.LambdaArray";
stdlib_LambdaArray.addRange = function(arr,range) {
	var _g = 0;
	while(_g < range.length) {
		var e = range[_g];
		++_g;
		arr.push(e);
	}
};
stdlib_LambdaArray.insertRange = function(arr,pos,range) {
	var _g = 0;
	while(_g < range.length) {
		var e = range[_g];
		++_g;
		arr.splice(pos++,0,e);
	}
};
stdlib_LambdaArray.extract = function(arr,f) {
	var r = [];
	var i = 0;
	while(i < arr.length) if(f(arr[i])) {
		r.push(arr[i]);
		arr.splice(i,1);
	} else {
		++i;
	}
	return r;
};
stdlib_LambdaArray.spliceEx = function(arr,pos,len,replacement) {
	var r = arr.splice(pos,len != null ? len : arr.length - pos);
	if(replacement != null) {
		stdlib_LambdaArray.insertRange(arr,pos,replacement);
	}
	return r;
};
stdlib_LambdaArray.filterByType = function(arr,klass) {
	var _g = [];
	var _g1 = 0;
	var _g2 = arr;
	while(_g1 < _g2.length) {
		var v = _g2[_g1];
		++_g1;
		if(js_Boot.__instanceof(v,klass)) {
			_g.push(v);
		}
	}
	return _g;
};
stdlib_LambdaArray.distinct = function(arr,equFunc) {
	var r = [];
	if(equFunc == null) {
		var _g = 0;
		while(_g < arr.length) {
			var x = arr[_g];
			++_g;
			if(r.indexOf(x) == -1) {
				r.push(x);
			}
		}
	} else {
		var _g = 0;
		while(_g < arr.length) {
			var x = [arr[_g]];
			++_g;
			if(!Lambda.exists(r,(function(x) {
				return function(y) {
					return equFunc(x[0],y);
				};
			})(x))) {
				r.push(x[0]);
			}
		}
	}
	return r;
};
var stdlib_LambdaIterable = function() { };
stdlib_LambdaIterable.__name__ = "stdlib.LambdaIterable";
stdlib_LambdaIterable.findIndex = function(it,f) {
	var n = 0;
	var x = $getIterator(it);
	while(x.hasNext()) {
		var x1 = x.next();
		if(f(x1)) {
			return n;
		}
		++n;
	}
	return -1;
};
stdlib_LambdaIterable.findLastIndex = function(it,f) {
	var r = -1;
	var n = 0;
	var x = $getIterator(it);
	while(x.hasNext()) {
		var x1 = x.next();
		if(f(x1)) {
			r = n;
		}
		++n;
	}
	return r;
};
stdlib_LambdaIterable.sorted = function(it,cmp) {
	var r = Lambda.array(it);
	r.sort(cmp != null ? cmp : Reflect.compare);
	return r;
};
stdlib_LambdaIterable.filterByType = function(it,klass) {
	var r = [];
	var x = $getIterator(it);
	while(x.hasNext()) {
		var x1 = x.next();
		if(js_Boot.__instanceof(x1,klass)) {
			r.push(x1);
		}
	}
	return r;
};
var stdlib_LambdaIterator = function() { };
stdlib_LambdaIterator.__name__ = "stdlib.LambdaIterator";
stdlib_LambdaIterator.array = function(it) {
	var r = [];
	var e = it;
	while(e.hasNext()) {
		var e1 = e.next();
		r.push(e1);
	}
	return r;
};
stdlib_LambdaIterator.indexOf = function(it,elem) {
	var r = 0;
	while(it.hasNext()) {
		if(it.next() == elem) {
			return r;
		}
		++r;
	}
	return -1;
};
stdlib_LambdaIterator.map = function(it,conv) {
	var r = [];
	var e = it;
	while(e.hasNext()) {
		var e1 = e.next();
		r.push(conv(e1));
	}
	return r;
};
stdlib_LambdaIterator.filter = function(it,pred) {
	var r = [];
	var e = it;
	while(e.hasNext()) {
		var e1 = e.next();
		if(pred(e1)) {
			r.push(e1);
		}
	}
	return r;
};
stdlib_LambdaIterator.exists = function(it,pred) {
	var e = it;
	while(e.hasNext()) {
		var e1 = e.next();
		if(pred(e1)) {
			return true;
		}
	}
	return false;
};
stdlib_LambdaIterator.count = function(it,pred) {
	var n = 0;
	if(pred == null) {
		var _ = it;
		while(_.hasNext()) {
			var _1 = _.next();
			++n;
		}
	} else {
		var x = it;
		while(x.hasNext()) {
			var x1 = x.next();
			if(pred(x1)) {
				++n;
			}
		}
	}
	return n;
};
stdlib_LambdaIterator.findIndex = function(it,f) {
	var n = 0;
	var x = it;
	while(x.hasNext()) {
		var x1 = x.next();
		if(f(x1)) {
			return n;
		}
		++n;
	}
	return -1;
};
stdlib_LambdaIterator.findLastIndex = function(it,f) {
	var r = -1;
	var n = 0;
	var x = it;
	while(x.hasNext()) {
		var x1 = x.next();
		if(f(x1)) {
			r = n;
		}
		++n;
	}
	return r;
};
stdlib_LambdaIterator.sorted = function(it,cmp) {
	var r = stdlib_LambdaIterator.array(it);
	r.sort(cmp != null ? cmp : Reflect.compare);
	return r;
};
stdlib_LambdaIterator.join = function(it,sep) {
	var r_b = "";
	var isFirst = true;
	var x = it;
	while(x.hasNext()) {
		var x1 = x.next();
		if(!isFirst) {
			r_b += sep == null ? "null" : "" + sep;
		} else {
			isFirst = false;
		}
		r_b += Std.string(Std.string(x1));
	}
	return r_b;
};
var stdlib_Std = function() { };
stdlib_Std.__name__ = "stdlib.Std";
stdlib_Std.isOfType = function(v,t) {
	return js_Boot.__instanceof(v,t);
};
stdlib_Std.string = function(s) {
	return Std.string(s);
};
stdlib_Std.int = function(x) {
	return x | 0;
};
stdlib_Std.random = function(x) {
	return Std.random(x);
};
stdlib_Std.parseInt = function(x,defaultValue) {
	if(x != null) {
		if(new EReg("^\\s*[+-]?\\s*((?:0x[0-9a-fA-F]{1,7})|(?:\\d{1,9}))\\s*$","").match(x)) {
			return Std.parseInt(x);
		} else {
			return defaultValue;
		}
	} else {
		return defaultValue;
	}
};
stdlib_Std.parseFloat = function(x,defaultValue) {
	if(x == null) {
		return defaultValue;
	}
	if(new EReg("^\\s*[+-]?\\s*\\d{1,20}(?:[.]\\d+)?(?:e[+-]?\\d{1,20})?\\s*$","").match(x)) {
		var r = parseFloat(x);
		if(!isNaN(r)) {
			return r;
		} else {
			return defaultValue;
		}
	}
	return defaultValue;
};
stdlib_Std.downcast = function(obj,_) {
	return obj;
};
stdlib_Std.bool = function(v) {
	if(v != false && v != null && v != 0 && v != "" && v != "0") {
		if(typeof(v) == "string") {
			if((js_Boot.__cast(v , String)).toLowerCase() != "false" && (js_Boot.__cast(v , String)).toLowerCase() != "off") {
				return (js_Boot.__cast(v , String)).toLowerCase() != "null";
			} else {
				return false;
			}
		} else {
			return true;
		}
	} else {
		return false;
	}
};
stdlib_Std.parseValue = function(x) {
	var value = x;
	var valueLC = value != null ? value.toLowerCase() : null;
	var parsedValue;
	if(valueLC == "true") {
		value = true;
	} else if(valueLC == "false") {
		value = false;
	} else if(valueLC == "null") {
		value = null;
	} else {
		parsedValue = stdlib_Std.parseInt(value);
		if(parsedValue != null) {
			value = parsedValue;
		} else {
			parsedValue = stdlib_Std.parseFloat(value);
			if(parsedValue != null) {
				value = parsedValue;
			}
		}
	}
	return value;
};
stdlib_Std.hash = function(obj) {
	var r = new haxe_ds_StringMap();
	var _g = 0;
	var _g1 = Reflect.fields(obj);
	while(_g < _g1.length) {
		var key = _g1[_g];
		++_g;
		r.h[key] = Reflect.field(obj,key);
	}
	return r;
};
stdlib_Std.min = function(a,b) {
	if(a < b) {
		return a;
	} else {
		return b;
	}
};
stdlib_Std.max = function(a,b) {
	if(a > b) {
		return a;
	} else {
		return b;
	}
};
stdlib_Std.abs = function(x) {
	if(x >= 0) {
		return x;
	} else {
		return -x;
	}
};
stdlib_Std.sign = function(n) {
	if(n > 0) {
		return 1;
	} else if(n < 0) {
		return -1;
	} else {
		return 0;
	}
};
var stdlib_StringTools = function() { };
stdlib_StringTools.__name__ = "stdlib.StringTools";
stdlib_StringTools.ltrim = function(s,chars) {
	if(chars == null) {
		return StringTools.ltrim(s);
	}
	while(s.length > 0 && chars.indexOf(HxOverrides.substr(s,0,1)) >= 0) s = HxOverrides.substr(s,1,null);
	return s;
};
stdlib_StringTools.rtrim = function(s,chars) {
	if(chars == null) {
		return StringTools.rtrim(s);
	}
	while(s.length > 0 && chars.indexOf(HxOverrides.substr(s,s.length - 1,1)) >= 0) s = HxOverrides.substr(s,0,s.length - 1);
	return s;
};
stdlib_StringTools.trim = function(s,chars) {
	if(chars == null) {
		return StringTools.trim(s);
	}
	return stdlib_StringTools.rtrim(stdlib_StringTools.ltrim(s,chars),chars);
};
stdlib_StringTools.hexdec = function(s) {
	return stdlib_Std.parseInt("0x" + s);
};
stdlib_StringTools.addcslashes = function(s) {
	return new EReg("['\"\t\r\n\\\\]","g").map(s,function(re) {
		return "\\" + re.matched(0);
	});
};
stdlib_StringTools.stripTags = function(str,allowedTags) {
	if(allowedTags == null) {
		allowedTags = "";
	}
	var allowedTagsArray = [];
	if(allowedTags != "") {
		var re = new EReg("[a-zA-Z0-9]+","i");
		var pos = 0;
		while(re.matchSub(allowedTags,pos)) {
			allowedTagsArray.push(re.matched(0));
			pos = re.matchedPos().pos + re.matchedPos().len;
		}
	}
	var re = new EReg("</?[\\S][^>]*>","g");
	str = re.map(str,function(_) {
		var html = re.matched(0);
		var allowed = false;
		if(allowedTagsArray.length > 0) {
			var htmlLC = html.toLowerCase();
			var _g = 0;
			while(_g < allowedTagsArray.length) {
				var allowedTag = allowedTagsArray[_g];
				++_g;
				if(StringTools.startsWith(htmlLC,"<" + allowedTag + ">") || StringTools.startsWith(htmlLC,"<" + allowedTag + " ") || StringTools.startsWith(htmlLC,"</" + allowedTag)) {
					allowed = true;
					break;
				}
			}
		}
		if(allowed) {
			return html;
		} else {
			return "";
		}
	});
	return str;
};
stdlib_StringTools.regexEscape = function(s) {
	var _this_r = new RegExp("([\\-\\[\\]/\\{\\}\\(\\)\\*\\+\\?\\.\\\\\\^\\$\\|])","g".split("u").join(""));
	return s.replace(_this_r,"\\$1");
};
stdlib_StringTools.jsonEscape = function(s) {
	if(s == null) {
		return "null";
	}
	var r = "\"";
	var _g_offset = 0;
	var _g_s = s;
	while(_g_offset < _g_s.length) {
		var s = _g_s;
		var index = _g_offset++;
		var c = s.charCodeAt(index);
		if(c >= 55296 && c <= 56319) {
			c = c - 55232 << 10 | s.charCodeAt(index + 1) & 1023;
		}
		var c1 = c;
		if(c1 >= 65536) {
			++_g_offset;
		}
		var c2 = c1;
		switch(c2) {
		case 9:
			r += "\\t";
			break;
		case 10:
			r += "\\n";
			break;
		case 13:
			r += "\\r";
			break;
		case 34:
			r += "\\\"";
			break;
		case 92:
			r += "\\\\";
			break;
		default:
			if(c2 < 32) {
				r += "\\u" + StringTools.hex(c2,4);
			} else {
				r += String.fromCodePoint(c2);
			}
		}
	}
	r += "\"";
	return r;
};
stdlib_StringTools.isNullOrEmpty = function(s) {
	if(s != null) {
		return s == "";
	} else {
		return true;
	}
};
stdlib_StringTools.capitalize = function(s) {
	if(s == "") {
		return s;
	} else {
		return HxOverrides.substr(s,0,1).toUpperCase() + HxOverrides.substr(s,1,null);
	}
};
stdlib_StringTools.urlEncode = function(s) {
	return encodeURIComponent(s);
};
stdlib_StringTools.urlDecode = function(s) {
	return decodeURIComponent(s.split("+").join(" "));
};
stdlib_StringTools.htmlEscape = function(s,quotes) {
	return StringTools.htmlEscape(s,quotes);
};
stdlib_StringTools.htmlUnescape = function(s) {
	return StringTools.htmlUnescape(s);
};
stdlib_StringTools.contains = function(s,value) {
	return s.indexOf(value) != -1;
};
stdlib_StringTools.startsWith = function(s,start) {
	return StringTools.startsWith(s,start);
};
stdlib_StringTools.endsWith = function(s,end) {
	return StringTools.endsWith(s,end);
};
stdlib_StringTools.isSpace = function(s,pos) {
	return StringTools.isSpace(s,pos);
};
stdlib_StringTools.lpad = function(s,c,l) {
	return StringTools.lpad(s,c,l);
};
stdlib_StringTools.rpad = function(s,c,l) {
	return StringTools.rpad(s,c,l);
};
stdlib_StringTools.replace = function(s,sub,by) {
	return StringTools.replace(s,sub,by);
};
stdlib_StringTools.hex = function(n,digits) {
	return StringTools.hex(n,digits);
};
stdlib_StringTools.fastCodeAt = function(s,index) {
	return s.charCodeAt(index);
};
stdlib_StringTools.unsafeCodeAt = function(s,index) {
	return s.charCodeAt(index);
};
stdlib_StringTools.iterator = function(s) {
	return new haxe_iterators_StringIterator(s);
};
stdlib_StringTools.keyValueIterator = function(s) {
	return new haxe_iterators_StringKeyValueIterator(s);
};
stdlib_StringTools.isEof = function(c) {
	return c != c;
};
stdlib_StringTools.quoteUnixArg = function(argument) {
	return StringTools.quoteUnixArg(argument);
};
stdlib_StringTools.quoteWinArg = function(argument,escapeMetaCharacters) {
	return StringTools.quoteWinArg(argument,escapeMetaCharacters);
};
var stdlib_Utf8 = function(size) {
	haxe_Utf8.call(this,size);
};
stdlib_Utf8.__name__ = "stdlib.Utf8";
stdlib_Utf8.replace = function(s,from,to) {
	var codes = [];
	haxe_Utf8.iter(s,function(c) {
		codes.push(c);
	});
	var r = new stdlib_Utf8();
	var len = from.length;
	if(codes.length < len) {
		return s;
	}
	var _g = 0;
	var _g1 = codes.length - len + 1;
	while(_g < _g1) {
		var i = [_g++];
		var found = [true];
		var j = [0];
		haxe_Utf8.iter(from,(function(j,found,i) {
			return function(cc) {
				if(found[0]) {
					if(codes[i[0] + j[0]] != cc) {
						found[0] = false;
					}
					j[0]++;
				}
			};
		})(j,found,i));
		if(found[0]) {
			r.addString(to);
		} else {
			r.__b += String.fromCodePoint(codes[i[0]]);
		}
	}
	var _g = codes.length - len + 1;
	var _g1 = codes.length;
	while(_g < _g1) {
		var i1 = _g++;
		r.__b += String.fromCodePoint(codes[i1]);
	}
	return r.__b;
};
stdlib_Utf8.compactSpaces = function(s) {
	var r = new stdlib_Utf8();
	var prevSpace = false;
	haxe_Utf8.iter(s,function(c) {
		if(c == 32 || c == 13 || c == 10 || c == 9) {
			if(!prevSpace) {
				r.__b += String.fromCodePoint(32);
				prevSpace = true;
			}
		} else {
			r.__b += String.fromCodePoint(c);
			prevSpace = false;
		}
	});
	return r.__b;
};
stdlib_Utf8.htmlUnescape = function(s) {
	var r = new stdlib_Utf8();
	var $escape = null;
	haxe_Utf8.iter(s,function(c) {
		if($escape != null) {
			if(c == 59) {
				var chr = stdlib_Utf8.htmlUnescapeChar($escape);
				if(chr != null) {
					r.__b += String.fromCodePoint(chr);
				}
				$escape = null;
			} else {
				$escape += String.fromCodePoint(c);
			}
		} else if(c == 38) {
			$escape = "";
		} else {
			r.__b += String.fromCodePoint(c);
		}
	});
	return r.__b;
};
stdlib_Utf8.htmlEscape = function(utf8Str,chars) {
	if(chars == null) {
		chars = "";
	}
	chars = "&<>" + chars;
	var r = new stdlib_Utf8();
	haxe_Utf8.iter(utf8Str,function(c) {
		var s = stdlib_Utf8.get_htmlEscapeMap().h[c];
		if(s != null && c >= 0 && c <= 255 && chars.indexOf(String.fromCodePoint(c)) >= 0) {
			r.addString(s);
		} else {
			r.__b += String.fromCodePoint(c);
		}
	});
	return r.__b;
};
stdlib_Utf8.htmlUnescapeChar = function($escape) {
	if(StringTools.startsWith($escape,"#x")) {
		return stdlib_Std.parseInt("0x" + HxOverrides.substr($escape,2,null));
	} else if(StringTools.startsWith($escape,"#")) {
		return stdlib_Std.parseInt(HxOverrides.substr($escape,1,null));
	} else {
		var r = stdlib_Utf8.get_htmlUnescapeMap().h[$escape];
		if(r != null) {
			return r;
		}
	}
	haxe_Log.trace("Unknow escape sequence: " + $escape,{ fileName : "stdlib/Utf8.hx", lineNumber : 131, className : "stdlib.Utf8", methodName : "htmlUnescapeChar"});
	return null;
};
stdlib_Utf8.get_htmlEscapeMap = function() {
	if(stdlib_Utf8.htmlEscapeMap == null) {
		var _g = new haxe_ds_IntMap();
		_g.h[32] = "&nbsp;";
		_g.h[38] = "&amp;";
		_g.h[60] = "&lt;";
		_g.h[62] = "&gt;";
		_g.h[34] = "&quot;";
		_g.h[39] = "&apos;";
		_g.h[13] = "&#xD;";
		_g.h[10] = "&#xA;";
		stdlib_Utf8.htmlEscapeMap = _g;
	}
	return stdlib_Utf8.htmlEscapeMap;
};
stdlib_Utf8.get_htmlUnescapeMap = function() {
	if(stdlib_Utf8.htmlUnescapeMap == null) {
		var _g = new haxe_ds_StringMap();
		_g.h["nbsp"] = 32;
		_g.h["amp"] = 38;
		_g.h["lt"] = 60;
		_g.h["gt"] = 62;
		_g.h["quot"] = 34;
		_g.h["apos"] = 39;
		_g.h["euro"] = 8364;
		_g.h["iexcl"] = 161;
		_g.h["cent"] = 162;
		_g.h["pound"] = 163;
		_g.h["curren"] = 164;
		_g.h["yen"] = 165;
		_g.h["brvbar"] = 166;
		_g.h["sect"] = 167;
		_g.h["uml"] = 168;
		_g.h["copy"] = 169;
		_g.h["ordf"] = 170;
		_g.h["not"] = 172;
		_g.h["shy"] = 173;
		_g.h["reg"] = 174;
		_g.h["macr"] = 175;
		_g.h["deg"] = 176;
		_g.h["plusmn"] = 177;
		_g.h["sup2"] = 178;
		_g.h["sup3"] = 179;
		_g.h["acute"] = 180;
		_g.h["micro"] = 181;
		_g.h["para"] = 182;
		_g.h["middot"] = 183;
		_g.h["cedil"] = 184;
		_g.h["sup1"] = 185;
		_g.h["ordm"] = 186;
		_g.h["raquo"] = 187;
		_g.h["frac14"] = 188;
		_g.h["frac12"] = 189;
		_g.h["frac34"] = 190;
		_g.h["iquest"] = 191;
		_g.h["Agrave"] = 192;
		_g.h["Aacute"] = 193;
		_g.h["Acirc"] = 194;
		_g.h["Atilde"] = 195;
		_g.h["Auml"] = 196;
		_g.h["Aring"] = 197;
		_g.h["AElig"] = 198;
		_g.h["Ccedil"] = 199;
		_g.h["Egrave"] = 200;
		_g.h["Eacute"] = 201;
		_g.h["Ecirc"] = 202;
		_g.h["Euml"] = 203;
		_g.h["Igrave"] = 204;
		_g.h["Iacute"] = 205;
		_g.h["Icirc"] = 206;
		_g.h["Iuml"] = 207;
		_g.h["ETH"] = 208;
		_g.h["Ntilde"] = 209;
		_g.h["Ograve"] = 210;
		_g.h["Oacute"] = 211;
		_g.h["Ocirc"] = 212;
		_g.h["Otilde"] = 213;
		_g.h["Ouml"] = 214;
		_g.h["times"] = 215;
		_g.h["Oslash"] = 216;
		_g.h["Ugrave"] = 217;
		_g.h["Uacute"] = 218;
		_g.h["Ucirc"] = 219;
		_g.h["Uuml"] = 220;
		_g.h["Yacute"] = 221;
		_g.h["THORN"] = 222;
		_g.h["szlig"] = 223;
		_g.h["agrave"] = 224;
		_g.h["aacute"] = 225;
		_g.h["acirc"] = 226;
		_g.h["atilde"] = 227;
		_g.h["auml"] = 228;
		_g.h["aring"] = 229;
		_g.h["aelig"] = 230;
		_g.h["ccedil"] = 231;
		_g.h["egrave"] = 232;
		_g.h["eacute"] = 233;
		_g.h["ecirc"] = 234;
		_g.h["euml"] = 235;
		_g.h["igrave"] = 236;
		_g.h["iacute"] = 237;
		_g.h["icirc"] = 238;
		_g.h["iuml"] = 239;
		_g.h["eth"] = 240;
		_g.h["ntilde"] = 241;
		_g.h["ograve"] = 242;
		_g.h["oacute"] = 243;
		_g.h["ocirc"] = 244;
		_g.h["otilde"] = 245;
		_g.h["ouml"] = 246;
		_g.h["divide"] = 247;
		_g.h["oslash"] = 248;
		_g.h["ugrave"] = 249;
		_g.h["uacute"] = 250;
		_g.h["ucirc"] = 251;
		_g.h["uuml"] = 252;
		_g.h["yacute"] = 253;
		_g.h["thorn"] = 254;
		stdlib_Utf8.htmlUnescapeMap = _g;
	}
	return stdlib_Utf8.htmlUnescapeMap;
};
stdlib_Utf8.iter = function(s,chars) {
	haxe_Utf8.iter(s,chars);
};
stdlib_Utf8.encode = function(s) {
	return haxe_Utf8.encode(s);
};
stdlib_Utf8.decode = function(s) {
	return haxe_Utf8.decode(s);
};
stdlib_Utf8.charCodeAt = function(s,index) {
	return HxOverrides.cca(s,index);
};
stdlib_Utf8.validate = function(s) {
	return true;
};
stdlib_Utf8.$length = function(s) {
	return s.length;
};
stdlib_Utf8.compare = function(a,b) {
	return haxe_Utf8.compare(a,b);
};
stdlib_Utf8.sub = function(s,pos,len) {
	return HxOverrides.substr(s,pos,len);
};
stdlib_Utf8.__super__ = haxe_Utf8;
stdlib_Utf8.prototype = $extend(haxe_Utf8.prototype,{
	addString: function(s) {
		var _gthis = this;
		haxe_Utf8.iter(s,function(c) {
			_gthis.__b += String.fromCodePoint(c);
		});
	}
	,__class__: stdlib_Utf8
});
var stdlib_Uuid = function() { };
stdlib_Uuid.__name__ = "stdlib.Uuid";
stdlib_Uuid.newUuid = function() {
	var timeF = new Date().getTime();
	var time = timeF - 268435455. * (timeF / 268435455 | 0) | 0;
	var uuid = StringTools.hex(stdlib_Uuid.counter++,8) + "-" + StringTools.hex(timeF / 65536 | 0,8) + "-" + StringTools.hex(time % 65536,8) + "-" + StringTools.hex(Std.random(65536),4) + "-" + StringTools.hex(Std.random(65536),4);
	return uuid;
};
function $getIterator(o) { if( o instanceof Array ) return new haxe_iterators_ArrayIterator(o); else return o.iterator(); }
function $bind(o,m) { if( m == null ) return null; if( m.__id__ == null ) m.__id__ = $global.$haxeUID++; var f; if( o.hx__closures__ == null ) o.hx__closures__ = {}; else f = o.hx__closures__[m.__id__]; if( f == null ) { f = m.bind(o); o.hx__closures__[m.__id__] = f; } return f; }
$global.$haxeUID |= 0;
if(typeof(performance) != "undefined" ? typeof(performance.now) == "function" : false) {
	HxOverrides.now = performance.now.bind(performance);
}
if( String.fromCodePoint == null ) String.fromCodePoint = function(c) { return c < 0x10000 ? String.fromCharCode(c) : String.fromCharCode((c>>10)+0xD7C0)+String.fromCharCode((c&0x3FF)+0xDC00); }
Object.defineProperty(String.prototype,"__class__",{ value : String, enumerable : false, writable : true});
String.__name__ = "String";
Array.__name__ = "Array";
Date.prototype.__class__ = Date;
Date.__name__ = "Date";
var Int = { };
var Dynamic = { };
var Float = Number;
var Bool = Boolean;
var Class = { };
var Enum = { };
js_Boot.__toStr = ({ }).toString;
FlashImporterPlugin.IMPORT_MEDIA_SCRIPT_TEMPLATE = "// Generated by Haxe 4.3.3\n(function ($global) { \"use strict\";\nvar FlashMediaImporter = function() { };\nFlashMediaImporter.__name__ = true;\nFlashMediaImporter.main = function() {\n\tvar srcFilePath = \"file:///\" + StringTools.replace(FlashMediaImporter.SRC_FILE,\"\\\\\",\"/\");\n\tvar destLibraryDir = \"file:///\" + haxe_io_Path.addTrailingSlash(StringTools.replace(FlashMediaImporter.DEST_DIR,\"\\\\\",\"/\")) + \"library\";\n\tFlashMediaImporter.log(\"Import media from '\" + srcFilePath + \"' to '\" + destLibraryDir + \"' directory:\");\n\tvar doc = fl.openDocument(srcFilePath);\n\tFLfile.createFolder(destLibraryDir);\n\tvar _g = 0;\n\tvar _g1 = doc.library.items.length;\n\twhile(_g < _g1) {\n\t\tvar i = _g++;\n\t\tvar item = doc.library.items[i];\n\t\tif(item != null) {\n\t\t\tswitch(item.itemType) {\n\t\t\tcase \"bitmap\":\n\t\t\t\tFlashMediaImporter.log(\"  Import: \" + item.name + \" / \" + item.itemType + \" / \" + item.originalCompressionType);\n\t\t\t\tFlashMediaImporter.importBitmap(destLibraryDir,item);\n\t\t\t\tbreak;\n\t\t\tcase \"button\":case \"folder\":case \"graphic\":case \"movie clip\":\n\t\t\t\tbreak;\n\t\t\tcase \"sound\":\n\t\t\t\tFlashMediaImporter.log(\"  Import: \" + item.name + \" / \" + item.itemType + \" / \" + item.originalCompressionType);\n\t\t\t\tFlashMediaImporter.importSound(destLibraryDir,item);\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\tFlashMediaImporter.log(\"    Skip: \" + item.name + \" / \" + item.itemType);\n\t\t\t}\n\t\t}\n\t}\n\tdoc.close(false);\n\tFlashMediaImporter.log(\"Done.\");\n\tFLfile.write(\"file:///\" + StringTools.replace(FlashMediaImporter.DEST_DIR,\"\\\\\",\"/\") + \"/.done-import-media\",\"\");\n};\nFlashMediaImporter.importBitmap = function(destLibraryDir,item) {\n\tvar savePath = destLibraryDir + \"/\" + item.name + \".png\";\n\tif(!FLfile.exists(savePath)) {\n\t\tFLfile.createFolder(haxe_io_Path.directory(savePath));\n\t\tvar temp = fl.createDocument();\n\t\ttemp.addItem({ x : 0, y : 0},item);\n\t\tvar image = temp.getTimeline().layers[0].frames[0].elements[0];\n\t\ttemp.width = image.getBits().width;\n\t\ttemp.height = image.getBits().height;\n\t\timage.x = 0;\n\t\timage.y = 0;\n\t\timage.setTransformationPoint({ x : 0, y : 0});\n\t\timage.width = temp.width;\n\t\timage.height = temp.height;\n\t\ttemp.exportPNG(savePath,false,true);\n\t\ttemp.close(false);\n\t}\n\treturn true;\n};\nFlashMediaImporter.importSound = function(destLibraryDir,item) {\n\tvar savePath = destLibraryDir + \"/\" + haxe_io_Path.withoutExtension(item.name) + (item.originalCompressionType == \"RAW\" ? \".wav\" : \".mp3\");\n\tif(!FLfile.exists(savePath)) {\n\t\tFLfile.createFolder(haxe_io_Path.directory(savePath));\n\t\titem.exportToFile(savePath);\n\t}\n\treturn true;\n};\nFlashMediaImporter.log = function(s) {\n\tfl.trace(s);\n};\nvar HxOverrides = function() { };\nHxOverrides.__name__ = true;\nHxOverrides.substr = function(s,pos,len) {\n\tif(len == null) {\n\t\tlen = s.length;\n\t} else if(len < 0) {\n\t\tif(pos == 0) {\n\t\t\tlen = s.length + len;\n\t\t} else {\n\t\t\treturn \"\";\n\t\t}\n\t}\n\treturn s.substr(pos,len);\n};\nHxOverrides.now = function() {\n\treturn Date.now();\n};\nMath.__name__ = true;\nvar Std = function() { };\nStd.__name__ = true;\nStd.string = function(s) {\n\treturn js_Boot.__string_rec(s,\"\");\n};\nvar StringTools = function() { };\nStringTools.__name__ = true;\nStringTools.replace = function(s,sub,by) {\n\treturn s.split(sub).join(by);\n};\nvar haxe_Log = function() { };\nhaxe_Log.__name__ = true;\nhaxe_Log.formatOutput = function(v,infos) {\n\tvar str = Std.string(v);\n\tif(infos == null) {\n\t\treturn str;\n\t}\n\tvar pstr = infos.fileName + \":\" + infos.lineNumber;\n\tif(infos.customParams != null) {\n\t\tvar _g = 0;\n\t\tvar _g1 = infos.customParams;\n\t\twhile(_g < _g1.length) {\n\t\t\tvar v = _g1[_g];\n\t\t\t++_g;\n\t\t\tstr += \", \" + Std.string(v);\n\t\t}\n\t}\n\treturn pstr + \": \" + str;\n};\nhaxe_Log.trace = function(v,infos) {\n\tvar str = haxe_Log.formatOutput(v,infos);\n\tif(typeof(console) != \"undefined\" && console.log != null) {\n\t\tconsole.log(str);\n\t}\n};\nvar haxe_io_Path = function(path) {\n\tswitch(path) {\n\tcase \".\":case \"..\":\n\t\tthis.dir = path;\n\t\tthis.file = \"\";\n\t\treturn;\n\t}\n\tvar c1 = path.lastIndexOf(\"/\");\n\tvar c2 = path.lastIndexOf(\"\\\\\");\n\tif(c1 < c2) {\n\t\tthis.dir = HxOverrides.substr(path,0,c2);\n\t\tpath = HxOverrides.substr(path,c2 + 1,null);\n\t\tthis.backslash = true;\n\t} else if(c2 < c1) {\n\t\tthis.dir = HxOverrides.substr(path,0,c1);\n\t\tpath = HxOverrides.substr(path,c1 + 1,null);\n\t} else {\n\t\tthis.dir = null;\n\t}\n\tvar cp = path.lastIndexOf(\".\");\n\tif(cp != -1) {\n\t\tthis.ext = HxOverrides.substr(path,cp + 1,null);\n\t\tthis.file = HxOverrides.substr(path,0,cp);\n\t} else {\n\t\tthis.ext = null;\n\t\tthis.file = path;\n\t}\n};\nhaxe_io_Path.__name__ = true;\nhaxe_io_Path.withoutExtension = function(path) {\n\tvar s = new haxe_io_Path(path);\n\ts.ext = null;\n\treturn s.toString();\n};\nhaxe_io_Path.directory = function(path) {\n\tvar s = new haxe_io_Path(path);\n\tif(s.dir == null) {\n\t\treturn \"\";\n\t}\n\treturn s.dir;\n};\nhaxe_io_Path.addTrailingSlash = function(path) {\n\tif(path.length == 0) {\n\t\treturn \"/\";\n\t}\n\tvar c1 = path.lastIndexOf(\"/\");\n\tvar c2 = path.lastIndexOf(\"\\\\\");\n\tif(c1 < c2) {\n\t\tif(c2 != path.length - 1) {\n\t\t\treturn path + \"\\\\\";\n\t\t} else {\n\t\t\treturn path;\n\t\t}\n\t} else if(c1 != path.length - 1) {\n\t\treturn path + \"/\";\n\t} else {\n\t\treturn path;\n\t}\n};\nhaxe_io_Path.prototype = {\n\ttoString: function() {\n\t\treturn (this.dir == null ? \"\" : this.dir + (this.backslash ? \"\\\\\" : \"/\")) + this.file + (this.ext == null ? \"\" : \".\" + this.ext);\n\t}\n};\nvar haxe_iterators_ArrayIterator = function(array) {\n\tthis.current = 0;\n\tthis.array = array;\n};\nhaxe_iterators_ArrayIterator.__name__ = true;\nhaxe_iterators_ArrayIterator.prototype = {\n\thasNext: function() {\n\t\treturn this.current < this.array.length;\n\t}\n\t,next: function() {\n\t\treturn this.array[this.current++];\n\t}\n};\nvar js_Boot = function() { };\njs_Boot.__name__ = true;\njs_Boot.__string_rec = function(o,s) {\n\tif(o == null) {\n\t\treturn \"null\";\n\t}\n\tif(s.length >= 5) {\n\t\treturn \"<...>\";\n\t}\n\tvar t = typeof(o);\n\tif(t == \"function\" && (o.__name__ || o.__ename__)) {\n\t\tt = \"object\";\n\t}\n\tswitch(t) {\n\tcase \"function\":\n\t\treturn \"<function>\";\n\tcase \"object\":\n\t\tif(((o) instanceof Array)) {\n\t\t\tvar str = \"[\";\n\t\t\ts += \"\\t\";\n\t\t\tvar _g = 0;\n\t\t\tvar _g1 = o.length;\n\t\t\twhile(_g < _g1) {\n\t\t\t\tvar i = _g++;\n\t\t\t\tstr += (i > 0 ? \",\" : \"\") + js_Boot.__string_rec(o[i],s);\n\t\t\t}\n\t\t\tstr += \"]\";\n\t\t\treturn str;\n\t\t}\n\t\tvar tostr;\n\t\ttry {\n\t\t\ttostr = o.toString;\n\t\t} catch( _g ) {\n\t\t\treturn \"???\";\n\t\t}\n\t\tif(tostr != null && tostr != Object.toString && typeof(tostr) == \"function\") {\n\t\t\tvar s2 = o.toString();\n\t\t\tif(s2 != \"[object Object]\") {\n\t\t\t\treturn s2;\n\t\t\t}\n\t\t}\n\t\tvar str = \"{\\n\";\n\t\ts += \"\\t\";\n\t\tvar hasp = o.hasOwnProperty != null;\n\t\tvar k = null;\n\t\tfor( k in o ) {\n\t\tif(hasp && !o.hasOwnProperty(k)) {\n\t\t\tcontinue;\n\t\t}\n\t\tif(k == \"prototype\" || k == \"__class__\" || k == \"__super__\" || k == \"__interfaces__\" || k == \"__properties__\") {\n\t\t\tcontinue;\n\t\t}\n\t\tif(str.length != 2) {\n\t\t\tstr += \", \\n\";\n\t\t}\n\t\tstr += s + k + \" : \" + js_Boot.__string_rec(o[k],s);\n\t\t}\n\t\ts = s.substring(1);\n\t\tstr += \"\\n\" + s + \"}\";\n\t\treturn str;\n\tcase \"string\":\n\t\treturn o;\n\tdefault:\n\t\treturn String(o);\n\t}\n};\nif(typeof(performance) != \"undefined\" ? typeof(performance.now) == \"function\" : false) {\n\tHxOverrides.now = performance.now.bind(performance);\n}\nString.__name__ = true;\nArray.__name__ = true;\njs_Boot.__toStr = ({ }).toString;\nhaxe_Log.trace = function(v,infos) {\n\tfl.trace(v);\n};\nFlashMediaImporter.SRC_FILE = \"{SRC_FILE}\";\nFlashMediaImporter.DEST_DIR = \"{DEST_DIR}\";\nFlashMediaImporter.TEMP_MC_NAME = \"__temp_fme\";\nFlashMediaImporter.main();\n})({});\n";
haxe_SysTools.winMetaCharacters = [32,40,41,37,33,94,34,60,62,38,124,10,13,44,59];
flashimport_SymbolLoader.EPS = 1e-10;
htmlparser_CssSelector.reID = "[a-z](?:-?[_a-z0-9])*";
htmlparser_CssSelector.reNamespacedID = htmlparser_CssSelector.reID + "(?::" + htmlparser_CssSelector.reID + ")?";
htmlparser_CssSelector.reSelector = "(\\s*)((?:[>]\\s*)?)([.#]?)(" + htmlparser_CssSelector.reNamespacedID + "|[*])((?:\\[\\d+\\])?)";
htmlparser_HtmlParser.SELF_CLOSING_TAGS_HTML = { img : 1, br : 1, input : 1, meta : 1, link : 1, hr : 1, base : 1, embed : 1, spacer : 1, source : 1, param : 1};
htmlparser_HtmlParser.reID = "[a-z](?:-?[_a-z0-9])*";
htmlparser_HtmlParser.reNamespacedID = htmlparser_HtmlParser.reID + "(?::" + htmlparser_HtmlParser.reID + ")?";
htmlparser_HtmlParser.reCDATA = "[<]!\\[CDATA\\[[\\s\\S]*?\\]\\][>]";
htmlparser_HtmlParser.reScript = "[<]\\s*script\\s*([^>]*)>([\\s\\S]*?)<\\s*/\\s*script\\s*>";
htmlparser_HtmlParser.reStyle = "<\\s*style\\s*([^>]*)>([\\s\\S]*?)<\\s*/\\s*style\\s*>";
htmlparser_HtmlParser.reElementOpen = "<\\s*(" + htmlparser_HtmlParser.reNamespacedID + ")";
htmlparser_HtmlParser.reAttr = htmlparser_HtmlParser.reNamespacedID + "(?:\\s*=\\s*(?:'[^']*?'|\"[^\"]*?\"|[-_a-z0-9]+))?";
htmlparser_HtmlParser.reElementEnd = "(/)?\\s*>";
htmlparser_HtmlParser.reElementClose = "<\\s*/\\s*(" + htmlparser_HtmlParser.reNamespacedID + ")\\s*>";
htmlparser_HtmlParser.reComment = "<!--[\\s\\S]*?-->";
htmlparser_HtmlParser.reMain = new EReg("(" + htmlparser_HtmlParser.reCDATA + ")|(" + htmlparser_HtmlParser.reScript + ")|(" + htmlparser_HtmlParser.reStyle + ")|(" + htmlparser_HtmlParser.reElementOpen + "((?:\\s+" + htmlparser_HtmlParser.reAttr + ")*)\\s*" + htmlparser_HtmlParser.reElementEnd + ")|(" + htmlparser_HtmlParser.reElementClose + ")|(" + htmlparser_HtmlParser.reComment + ")","ig");
htmlparser_HtmlParser.reParseAttrs = new EReg("(" + htmlparser_HtmlParser.reNamespacedID + ")(?:\\s*=\\s*('[^']*'|\"[^\"]*\"|[-_a-z0-9]+))?","ig");
stdlib_Uuid.counter = 0;
FlashImporterPlugin.main();
})(typeof window != "undefined" ? window : typeof global != "undefined" ? global : typeof self != "undefined" ? self : this);
